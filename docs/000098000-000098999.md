# StackOverflow 问答 000098000-000098999

# security - 如何在我的安全站点上获得那个巨大的安全图标？

> ID：98026
> 
> 赞同：2
> 
> 时间：2008-09-18T23:33:15.397
> 
> 标签：security

如果我访问 www.paypal.com，Firefox 会在地址栏中显示一个巨大的图标。是否可以在不向 Verisign 支付 2700 美元的情况下让我的网站执行此操作？哪里是购买 SSL 证书且不会破产的最佳地点？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-18T23:37:18.460

您说的是 EV（扩展验证）SSL。[Digicert](http://www.digicert.com/ev-ssl-certification.htm)在这方面非常有竞争力（每年 488 美元）以及标准 SSL 证书。不过，无论您选择谁，请确保您检查他们所拥有的浏览器兼容性，因为一些更便宜的浏览器没有像更昂贵的浏览器那样广泛的支持，这意味着您有点得到您所支付的费用。

**编辑：**此外，EV 仅在较新的浏览器上受支持（例如，不支持 IE6）。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-18T23:34:47.343

我在[GeoTrust](http://www.geotrust.com)上很幸运。我所知道的任何选择都不是我所说的“便宜”，但您可以做得比 Verisign 定价更好，而 GeoTrust 就是其中之一。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-18T23:37:17.273

你说的是EV证书。EV 代表扩展验证。基本上，更大的代价是让某人真正了解您的业务并验证您是您所说的那个人。我已将 Verisign 用于我的网站。

这是Firefox 中包含[的证书列表。](http://www.mozilla.org/projects/security/certs/included/)

这些通常非常昂贵，而且有充分的理由。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-18T23:38:01.873

您看到的图标来自扩展验证证书（EV 证书）。众所周知，它们的价格较高，但威瑞信并不是唯一出售它们的证书颁发机构。你也可以在 500 美元左右找到它们。[Microsoft 维护着与 IE7 一起使用的 CA 列表。](http://support.microsoft.com/kb/931125)我随机选择了两三个，发现一个能以不到 500 美元的价格卖给我 EV 证书。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-18T23:39:18.580

要获得绿条，您的 CA 需要通过审核。确保您购买的是扩展验证证书并使用 https。

# .net - 在 IEqualityComparer 中包装委托

> ID：98033
> 
> 赞同：128
> 
> 时间：2008-09-18T23:34:18.310
> 
> 标签：.net, linq, delegates

几个 Linq.Enumerable 函数采用`IEqualityComparer<T>`. 是否有一个方便的包装类适应 a`delegate(T,T)=>bool`来实现`IEqualityComparer<T>`？编写一个很容易（如果您忽略了定义正确哈希码的问题），但我想知道是否有开箱即用的解决方案。

具体来说，我想对`Dictionary`s 进行设置操作，仅使用键来定义成员资格（同时根据不同的规则保留值）。

* * *

## 回答 #1

> 赞同：174
> 
> 时间：2010-09-15T16:39:50.217

# 关于重要性`GetHashCode`

其他人已经评论了任何自定义`IEqualityComparer<T>`实现**都应该真正包含`GetHashCode`方法**的事实。但没有人愿意详细解释*原因*。

这就是为什么。您的问题特别提到了 LINQ 扩展方法；几乎*所有*这些都依赖哈希码才能正常工作，因为它们在内部使用哈希表来提高效率。

以[`Distinct`](http://msdn.microsoft.com/en-us/library/bb338049.aspx)为例。如果它使用的只是一种方法，请考虑此扩展方法的含义`Equals`。如果您只有 ，您如何确定一个项目是否已经按顺序扫描`Equals`？您枚举您已经查看过的整个值集合并检查匹配项。这将导致`Distinct`使用最坏情况的 O(N ² ) 算法而不是 O(N) 算法！

幸运的是，情况并非如此。`Distinct`不*只是*使用`Equals`; 它也使用`GetHashCode`。事实上，*如果**没有**`IEqualityComparer<T>`提供适当的`GetHashCode`*. 下面是一个人为的例子来说明这一点。

假设我有以下类型：

```
class Value
{
    public string Name { get; private set; }
    public int Number { get; private set; }

    public Value(string name, int number)
    {
        Name = name;
        Number = number;
    }

    public override string ToString()
    {
        return string.Format("{0}: {1}", Name, Number);
    }
} 
```

现在说我有一个`List<Value>`并且我想找到所有具有不同名称的元素。这是`Distinct`使用自定义相等比较器的完美用例。因此，让我们使用[Aku 答案](https://stackoverflow.com/questions/98033/wrap-a-delegate-in-an-iequalitycomparer/98119#98119)`Comparer<T>`中的类：

```
var comparer = new Comparer<Value>((x, y) => x.Name == y.Name); 
```

现在，如果我们有一堆`Value`具有相同`Name`属性的元素，它们应该都折叠成一个返回的值`Distinct`，对吧？让我们来看看...

```
var values = new List<Value>();

var random = new Random();
for (int i = 0; i < 10; ++i)
{
    values.Add("x", random.Next());
}

var distinct = values.Distinct(comparer);

foreach (Value x in distinct)
{
    Console.WriteLine(x);
} 
```

输出：

```
x: 1346013431
x: 1388845717
x: 1576754134
x: 1104067189
x: 1144789201
x: 1862076501
x: 1573781440
x: 646797592
x: 655632802
x: 1206819377

```

嗯，这没有用，是吗？

怎么样[`GroupBy`](http://msdn.microsoft.com/en-us/library/bb534334.aspx)？让我们试试：

```
var grouped = values.GroupBy(x => x, comparer);

foreach (IGrouping<Value> g in grouped)
{
    Console.WriteLine("[KEY: '{0}']", g);
    foreach (Value x in g)
    {
        Console.WriteLine(x);
    }
} 
```

输出：

```
[键='x：1346013431']
x: 1346013431
[键='x：1388845717']
x: 1388845717
[键='x：1576754134']
x: 1576754134
[键='x：1104067189']
x: 1104067189
[键='x：1144789201']
x: 1144789201
[键='x：1862076501']
x: 1862076501
[键='x：1573781440']
x: 1573781440
[键='x：646797592']
x: 646797592
[键='x：655632802']
x: 655632802
[键='x：1206819377']
x: 1206819377

```

再次：没有工作。

`Distinct`如果您考虑一下，在内部使用 a `HashSet<T>`（或等效的）以及在内部`GroupBy`使用类似 a 的东西是有意义的`Dictionary<TKey, List<T>>`。这可以解释为什么这些方法不起作用吗？让我们试试这个：

```
var uniqueValues = new HashSet<Value>(values, comparer);

foreach (Value x in uniqueValues)
{
    Console.WriteLine(x);
} 
```

输出：

```
x: 1346013431
x: 1388845717
x: 1576754134
x: 1104067189
x: 1144789201
x: 1862076501
x: 1573781440
x: 646797592
x: 655632802
x: 1206819377

```

是的……开始有意义了？

`GetHashCode`希望从这些示例中可以清楚地说明为什么在任何实现中包含适当的`IEqualityComparer<T>`内容是如此重要。

* * *

# 原始答案

扩展[orip 的答案](https://stackoverflow.com/questions/98033/wrap-a-delegate-in-an-iequalitycomparer/1239337#1239337)：

这里可以进行一些改进。

1.  首先，我会用 a`Func<T, TKey>`而不是`Func<T, object>`; `keyExtractor`这将防止在实际本身中对值类型键进行装箱。
2.  其次，我实际上会添加一个`where TKey : IEquatable<TKey>`约束；这将防止在`Equals`调用中装箱（`object.Equals`需要一个`object`参数；您需要一个`IEquatable<TKey>`实现来获取一个`TKey`参数而不装箱）。显然，这可能会造成过于严格的限制，因此您可以创建一个没有约束的基类和一个带有它的派生类。

生成的代码可能如下所示：

```
public class KeyEqualityComparer<T, TKey> : IEqualityComparer<T>
{
    protected readonly Func<T, TKey> keyExtractor;

    public KeyEqualityComparer(Func<T, TKey> keyExtractor)
    {
        this.keyExtractor = keyExtractor;
    }

    public virtual bool Equals(T x, T y)
    {
        return this.keyExtractor(x).Equals(this.keyExtractor(y));
    }

    public int GetHashCode(T obj)
    {
        return this.keyExtractor(obj).GetHashCode();
    }
}

public class StrictKeyEqualityComparer<T, TKey> : KeyEqualityComparer<T, TKey>
    where TKey : IEquatable<TKey>
{
    public StrictKeyEqualityComparer(Func<T, TKey> keyExtractor)
        : base(keyExtractor)
    { }

    public override bool Equals(T x, T y)
    {
        // This will use the overload that accepts a TKey parameter
        // instead of an object parameter.
        return this.keyExtractor(x).Equals(this.keyExtractor(y));
    }
} 
```

* * *

## 回答 #2

> 赞同：119
> 
> 时间：2009-08-06T14:41:23.787

当您想要自定义相等检查时，99% 的时间您都对定义要比较的键感兴趣，而不是比较本身。

这可能是一个优雅的解决方案（来自 Python 的[列表排序方法](http://wiki.python.org/moin/HowTo/Sorting#Sortingbykeys)的概念）。

用法：

```
var foo = new List<string> { "abc", "de", "DE" };

// case-insensitive distinct
var distinct = foo.Distinct(new KeyEqualityComparer<string>( x => x.ToLower() ) ); 
```

`KeyEqualityComparer`班级：

```
public class KeyEqualityComparer<T> : IEqualityComparer<T>
{
    private readonly Func<T, object> keyExtractor;

    public KeyEqualityComparer(Func<T,object> keyExtractor)
    {
        this.keyExtractor = keyExtractor;
    }

    public bool Equals(T x, T y)
    {
        return this.keyExtractor(x).Equals(this.keyExtractor(y));
    }

    public int GetHashCode(T obj)
    {
        return this.keyExtractor(obj).GetHashCode();
    }
} 
```

* * *

## 回答 #3

> 赞同：47
> 
> 时间：2008-09-18T23:52:01.247

恐怕没有这种开箱即用的包装器。但是创建一个并不难：

```
class Comparer<T>: IEqualityComparer<T>
{
    private readonly Func<T, T, bool> _comparer;

    public Comparer(Func<T, T, bool> comparer)
    {
        if (comparer == null)
            throw new ArgumentNullException("comparer");

        _comparer = comparer;
    }

    public bool Equals(T x, T y)
    {
        return _comparer(x, y);
    }

    public int GetHashCode(T obj)
    {
        return obj.ToString().ToLower().GetHashCode();
    }
}

...

Func<int, int, bool> f = (x, y) => x == y;
var comparer = new Comparer<int>(f);
Console.WriteLine(comparer.Equals(1, 1));
Console.WriteLine(comparer.Equals(1, 2)); 
```

* * *

## 回答 #4

> 赞同：46
> 
> 时间：2010-09-15T16:13:49.633

通常，我会通过在答案上评论 @Sam 来解决这个问题（我已经对原始帖子进行了一些编辑，以便在不改变行为的情况下对其进行一些清理。）

以下是我对@Sam[的回答的](https://stackoverflow.com/questions/98033/wrap-a-delegate-in-an-iequalitycomparer/270203#270203)即兴演奏，对默认散列策略进行了 [IMNSHO] 关键修复：-

```
class FuncEqualityComparer<T> : IEqualityComparer<T>
{
    readonly Func<T, T, bool> _comparer;
    readonly Func<T, int> _hash;

    public FuncEqualityComparer( Func<T, T, bool> comparer )
        : this( comparer, t => 0 ) // NB Cannot assume anything about how e.g., t.GetHashCode() interacts with the comparer's behavior
    {
    }

    public FuncEqualityComparer( Func<T, T, bool> comparer, Func<T, int> hash )
    {
        _comparer = comparer;
        _hash = hash;
    }

    public bool Equals( T x, T y )
    {
        return _comparer( x, y );
    }

    public int GetHashCode( T obj )
    {
        return _hash( obj );
    }
} 
```

* * *

## 回答 #5

> 赞同：24
> 
> 时间：2011-08-02T14:25:17.287

与丹涛的回答相同，但有一些改进：

1.  依赖`EqualityComparer<>.Default`于进行实际比较，以避免对`struct`已实现的值类型进行装箱`IEquatable<>`。

2.  自从`EqualityComparer<>.Default`使用它就不会爆炸`null.Equals(something)`。

3.  提供了静态包装器`IEqualityComparer<>`，它将有一个静态方法来创建比较器的实例 - 简化了调用。比较

    ```
    Equality<Person>.CreateComparer(p => p.ID); 
    ```

    和

    ```
    new EqualityComparer<Person, int>(p => p.ID); 
    ```

4.  添加了一个重载来指定`IEqualityComparer<>`键。

**班上：**

```
public static class Equality<T>
{
    public static IEqualityComparer<T> CreateComparer<V>(Func<T, V> keySelector)
    {
        return CreateComparer(keySelector, null);
    }

    public static IEqualityComparer<T> CreateComparer<V>(Func<T, V> keySelector, 
                                                         IEqualityComparer<V> comparer)
    {
        return new KeyEqualityComparer<V>(keySelector, comparer);
    }

    class KeyEqualityComparer<V> : IEqualityComparer<T>
    {
        readonly Func<T, V> keySelector;
        readonly IEqualityComparer<V> comparer;

        public KeyEqualityComparer(Func<T, V> keySelector, 
                                   IEqualityComparer<V> comparer)
        {
            if (keySelector == null)
                throw new ArgumentNullException("keySelector");

            this.keySelector = keySelector;
            this.comparer = comparer ?? EqualityComparer<V>.Default;
        }

        public bool Equals(T x, T y)
        {
            return comparer.Equals(keySelector(x), keySelector(y));
        }

        public int GetHashCode(T obj)
        {
            return comparer.GetHashCode(keySelector(obj));
        }
    }
} 
```

你可以这样使用它：

```
var comparer1 = Equality<Person>.CreateComparer(p => p.ID);
var comparer2 = Equality<Person>.CreateComparer(p => p.Name);
var comparer3 = Equality<Person>.CreateComparer(p => p.Birthday.Year);
var comparer4 = Equality<Person>.CreateComparer(p => p.Name, StringComparer.CurrentCultureIgnoreCase); 
```

Person 是一个简单的类：

```
class Person
{
    public int ID { get; set; }
    public string Name { get; set; }
    public DateTime Birthday { get; set; }
} 
```

* * *

## 回答 #6

> 赞同：11
> 
> 时间：2008-11-06T20:44:50.210

```
public class FuncEqualityComparer<T> : IEqualityComparer<T>
{
    readonly Func<T, T, bool> _comparer;
    readonly Func<T, int> _hash;

    public FuncEqualityComparer( Func<T, T, bool> comparer )
        : this( comparer, t => t.GetHashCode())
    {
    }

    public FuncEqualityComparer( Func<T, T, bool> comparer, Func<T, int> hash )
    {
        _comparer = comparer;
        _hash = hash;
    }

    public bool Equals( T x, T y )
    {
        return _comparer( x, y );
    }

    public int GetHashCode( T obj )
    {
        return _hash( obj );
    }
} 
```

带有扩展名：-

```
public static class SequenceExtensions
{
    public static bool SequenceEqual<T>( this IEnumerable<T> first, IEnumerable<T> second, Func<T, T, bool> comparer )
    {
        return first.SequenceEqual( second, new FuncEqualityComparer<T>( comparer ) );
    }

    public static bool SequenceEqual<T>( this IEnumerable<T> first, IEnumerable<T> second, Func<T, T, bool> comparer, Func<T, int> hash )
    {
        return first.SequenceEqual( second, new FuncEqualityComparer<T>( comparer, hash ) );
    }
} 
```

* * *

## 回答 #7

> 赞同：6
> 
> 时间：2011-05-27T09:44:57.567

orip 的回答很棒。

这里有一个小扩展方法，使它更容易：

```
public static IEnumerable<T> Distinct<T>(this IEnumerable<T> list, Func<T, object>    keyExtractor)
{
    return list.Distinct(new KeyEqualityComparer<T>(keyExtractor));
}
var distinct = foo.Distinct(x => x.ToLower()) 
```

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-19T00:09:28.773

我要回答我自己的问题。要将字典视为集合，最简单的方法似乎是将集合操作应用于 dict.Keys，然后使用 Enumerable.ToDictionary(...) 转换回字典。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2013-06-29T11:26:55.483

（德语文本）[使用 lambda 表达式实现 IEqualityCompare 的实现](http://flurfunk.sdx-ag.de/2013/06/linq-iequalitycomparer-durch-lambda.html) 关心空值并使用扩展方法生成 IEqualityComparer。

要在 Linq 联合中创建 IEqualityComparer，您只需编写

```
persons1.Union(persons2, person => person.LastName) 
```

比较器：

```
public class LambdaEqualityComparer<TSource, TComparable> : IEqualityComparer<TSource>
{
  Func<TSource, TComparable> _keyGetter;

  public LambdaEqualityComparer(Func<TSource, TComparable> keyGetter)
  {
    _keyGetter = keyGetter;
  }

  public bool Equals(TSource x, TSource y)
  {
    if (x == null || y == null) return (x == null && y == null);
    return object.Equals(_keyGetter(x), _keyGetter(y));
  }

  public int GetHashCode(TSource obj)
  {
    if (obj == null) return int.MinValue;
    var k = _keyGetter(obj);
    if (k == null) return int.MaxValue;
    return k.GetHashCode();
  }
} 
```

您还需要添加扩展方法以支持类型推断

```
public static class LambdaEqualityComparer
{
       // source1.Union(source2, lambda)
        public static IEnumerable<TSource> Union<TSource, TComparable>(
           this IEnumerable<TSource> source1, 
           IEnumerable<TSource> source2, 
            Func<TSource, TComparable> keySelector)
        {
            return source1.Union(source2, 
               new LambdaEqualityComparer<TSource, TComparable>(keySelector));
       }
   } 
```

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2010-06-29T15:17:21.183

只有一个优化：我们可以使用开箱即用的 EqualityComparer 进行价值比较，而不是委托它。

这也将使实现更清晰，因为实际的比较逻辑现在保留在您可能已经重载的 GetHashCode() 和 Equals() 中。

这是代码：

```
public class MyComparer<T> : IEqualityComparer<T> 
{ 
  public bool Equals(T x, T y) 
  { 
    return EqualityComparer<T>.Default.Equals(x, y); 
  } 

  public int GetHashCode(T obj) 
  { 
    return obj.GetHashCode(); 
  } 
} 
```

不要忘记在对象上重载 GetHashCode() 和 Equals() 方法。

这篇文章帮助了我：[c#比较两个通用值](https://stackoverflow.com/questions/488250/c-compare-two-generic-values)

寿司

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2012-04-06T06:52:59.073

[orip 的回答](https://stackoverflow.com/a/1239337/1295274)很棒。扩展 orip 的答案：

我认为解决方案的关键是使用“扩展方法”来转移“匿名类型”。

```
 public static class Comparer 
    {
      public static IEqualityComparer<T> CreateComparerForElements<T>(this IEnumerable<T> enumerable, Func<T, object> keyExtractor)
      {
        return new KeyEqualityComparer<T>(keyExtractor);
      }
    } 
```

用法：

```
var n = ItemList.Select(s => new { s.Vchr, s.Id, s.Ctr, s.Vendor, s.Description, s.Invoice }).ToList();
n.AddRange(OtherList.Select(s => new { s.Vchr, s.Id, s.Ctr, s.Vendor, s.Description, s.Invoice }).ToList(););
n = n.Distinct(x=>new{Vchr=x.Vchr,Id=x.Id}).ToList(); 
```

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2011-05-30T13:10:48.653

```
public static Dictionary<TKey, TValue> Distinct<TKey, TValue>(this IEnumerable<TValue> items, Func<TValue, TKey> selector)
  {
     Dictionary<TKey, TValue> result = null;
     ICollection collection = items as ICollection;
     if (collection != null)
        result = new Dictionary<TKey, TValue>(collection.Count);
     else
        result = new Dictionary<TKey, TValue>();
     foreach (TValue item in items)
        result[selector(item)] = item;
     return result;
  } 
```

这使得使用 lambda 选择一个属性成为可能，如下所示：`.Select(y => y.Article).Distinct(x => x.ArticleID);`

* * *

## 回答 #13

> 赞同：-2
> 
> 时间：2008-09-18T23:55:44.873

我不知道现有的课程，但类似：

```
public class MyComparer<T> : IEqualityComparer<T>
{
  private Func<T, T, bool> _compare;
  MyComparer(Func<T, T, bool> compare)
  {
    _compare = compare;
  }

  public bool Equals(T x, Ty)
  {
    return _compare(x, y);
  }

  public int GetHashCode(T obj)
  {
    return obj.GetHashCode();
  }
} 
```

注意：我还没有真正编译和运行它，所以可能有错字或其他错误。

# sap - 在 SAP OMS 和 Websphere Commerce 之间进行交互的最简单方法是什么？

> ID：98044
> 
> 赞同：3
> 
> 时间：2008-09-18T23:35:26.827
> 
> 标签：sap, webmethods, wcs, websphere-commerce, adaptor

是否会为 SAP 或 webmethods 使用 Websphere Adapter 或其他什么？选择其中之一时是否需要考虑其他因素？？？最终系统需要在 SAP 和 WCS 前端之间同步。没有问题..没有延迟....

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-23T09:29:50.333

我建议结合使用 SAP Business Connector ( [http://service.sap.com/sbc-download](http://service.sap.com/sbc-download) )，它提供了一个简单的接口，用于从 SAP 端接收/发送 RFC 调用，以及 IBM WebSphere Java 库，这允许与 WebSphere 轻松交互。（“webshphere.jar”，可能可以在[http://www.ibm.com/developerworks/websphere](http://www.ibm.com/developerworks/websphere)的某个地方找到。）

然后，您可以在 Business Connector 中编写“Java 服务”，它充当来自 SAP 的 RFC 数据和 WebSphere 数据之间的桥梁。应该只是几天的开发工作。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2012-10-16T00:57:38.920

嗯... IBM 网站上有一份白皮书显示了您执行此操作的最佳方式。根据您的 IT 战略选择您的集成模式和集成技术。

# java - 我应该使用哪个 EJB 3 持久提供程序？

> ID：98045
> 
> 赞同：3
> 
> 时间：2008-09-18T23:35:40.397
> 
> 标签：java, orm, jpa, jakarta-ee

我在一个相当大的 J2EE 项目上使用 EJB 3，默认情况下，Netbeans 将实体 bean 的持久提供程序设置为 TopLink。可以选择将提供程序更改为以下之一，甚至添加新的持久性库：

*   休眠
*   古多
*   OpenJPA

您更喜欢使用哪个持久性提供程序？使用其他提供商有什么好处？

虽然 TopLink 似乎很好，但我找不到太多关于如何控制缓存等的好文档。任何帮助将不胜感激。

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-19T00:34:53.843

我只考虑使用两个 JPA 提供程序：

如果您想坚持使用标准 JPA，我会使用 EclipseLink。虽然 Toplink Essentials 是 JPA 1.0 的参考实现，但 EclipseLink 基本上继承了 TopLink Essentials 代码，并将成为 JPA 2.0 的参考实现（并在发布时与 Glassfish V3 捆绑在一起；预计在 2009 年 5 月围绕 JavaOne）。TopLink Essentials 是 Oracle 的商业 TopLink 产品的一个有点残缺的版本，但 EclipseLink 基本上具有 TopLink 的所有功能。

另一个选择显然是 Hibernate。它被广泛使用和成熟，但并不是我所看到的问题。例如，上次我查看了 Hibernate 与具有多个一对多渴望关系的实体存在问题。我不知道 Hibernate 是否具有与 EclipseLink 的批处理查询提示等效的功能，但它是处理此类问题的一个非常有用的功能。

Hibernate 当然也支持标准的 JPA。Hibernate 的最大优势在于，如果您对它的工作原理有疑问，谷歌搜索很可能会为您找到答案。

老实说，除了上述两个提供商之外，我不会考虑其他任何东西。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T00:00:33.537

我强烈推荐 Hibernate，原因如下：

*   Java 世界中使用最广泛和最受尊敬的开源持久层；庞大的活跃社区，并在大量关键任务应用程序中大量使用。
*   如果您希望与应用程序的其余部分（例如 Spring 等）走不同的路线，那么您根本不需要将自己与 J2EE 或特定供应商联系起来，因为 Hibernate 仍然可以很好地发挥作用。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T00:01:32.817

我发现 Hibernate 有很好的文档记录，并且得到了各种缓存技术的良好支持。在非 JPA 上下文中，我也比其他人更多地使用它，所以也许我因此对它有点偏见。

我使用 TopLink Essentials 尝试过的几个小玩具项目也运行良好，但我从未涉足缓存或任何需要提供者特定文档的事情。总的来说，我认为社区对此的支持较少，这也是我最终使用 Hibernate 的部分原因。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T00:02:34.997

我使用休眠。它非常成熟，效果很好。我个人没有使用过其他任何一种，但我知道 Hibernate 是目前功能最齐全的 JPA 提供程序之一。也因为有这么多人在使用它，几乎我遇到的每一个问题，我都可以通过谷歌搜索快速找到解决方案。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T21:15:54.553

我最近研究了一个使用 Kodo JPA 框架构建的大型企业应用程序。Kodo 生成的 SQL 通常在处理大量数据时不太具有可扩展性。在我看来，它产生了太多带有外部连接的查询。考虑到在尝试扩展 kodo 时我们必须更改多少映射，我不建议将它用于大型企业应用程序。甚至与我们交谈过的 Oracle 代表也在试图让客户从 kodo 转向 TopLink。甲骨文可能会在未来逐步淘汰 kodo。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2009-03-21T14:27:23.597

DataNucleus [http://www.datanucleus.org](http://www.datanucleus.org)也是一个完全兼容的 JPA 提供程序，具有 JPA1 和一些预览 JPA2 功能

# python - 你最喜欢的 Python 模拟库是什么？

> ID：98053
> 
> 赞同：93
> 
> 时间：2008-09-18T23:37:47.147
> 
> 标签：python, mocking

你最喜欢的 Python 模拟库是什么？

* * *

## 回答 #1

> 赞同：43
> 
> 时间：2008-09-18T23:41:03.380

我只用过一个，但我在 Michael Foord 的 Mock 上取得了很好的效果：[http](http://www.voidspace.org.uk/python/mock/) ://www.voidspace.org.uk/python/mock/ 。

迈克尔的介绍说得比我好：

> 已经有几个 Python 模拟库可用，为什么还要另一个呢？
> 
> 大多数模拟库都遵循“记录->重播”的模拟模式。我更喜欢 'action -> assertion' 模式，尤其是在使用 Python unittest 模块时，这种模式更具可读性和直观性。
> 
> ...
> 
> 它还提供实用功能/对象来协助测试，尤其是猴子补丁。

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2008-09-18T23:45:41.217

[Mox](http://code.google.com/p/pymox/), from Google

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-09-19T11:36:55.890

[来自古斯塔沃](http://labix.org/mocker)·尼迈耶的嘲弄者。

它并不完美，但它非常强大和灵活。

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2009-06-23T21:22:22.923

[丁格斯](http://pypi.python.org/pypi/dingus/)，加里·伯恩哈特着。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2012-02-20T10:05:59.627

我是mocktest的作者。我认为它功能齐全且易于使用，但我可能有偏见：

[http://gfxmonk.net/dist/doc/mocktest/doc/](http://gfxmonk.net/dist/doc/mocktest/doc/)

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2011-07-05T21:25:57.750

[pyDoubles](http://www.pydoubles.org)用于 Python 的测试替身框架，由 iExpertos.com 提供。它支持模拟、存根、间谍和匹配器，包括 Hamcrest 匹配器

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-18T23:44:46.740

I've used [pMock](http://pmock.sourceforge.net/) in the past, and didn't mind it, it had pretty decent docs too. However, Foord's Mock as mentioned above is also nice.

# c# - 为什么此 X.509 证书被视为无效？

> ID：98074
> 
> 赞同：9
> 
> 时间：2008-09-18T23:42:11.723
> 
> 标签：c#, ssl, certificate, x509

我的服务器上安装了给定的证书。该证书具有有效日期，并且在 Windows 证书 MMC 管理单元中似乎完全有效。

但是，当我尝试读取证书时，为了在 HttpRequest 中使用它，我找不到它。这是使用的代码：

```
 X509Store store = new X509Store(StoreName.Root, StoreLocation.LocalMachine);
    store.Open(OpenFlags.ReadOnly); X509Certificate2Collection col =
    store.Certificates.Find(X509FindType.FindBySerialNumber, "xxx", true); 
```

`xxx`是序列号；该参数的`true`意思是“只有有效的证书”。返回的集合为空。

奇怪的是，如果我通过了`false`，表明可以接受无效证书，则该集合包含一个元素——具有指定序列号的证书。

结论：证书看似有效，但该`Find`方法将其视为无效！为什么？

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-09-19T00:45:01.980

尝试使用[X509Chain](http://msdn.microsoft.com/en-us/library/system.security.cryptography.x509certificates.x509chain.aspx)类验证证书链。这可以准确地告诉您为什么证书不被认为是有效的。

As erickson suggested, your X509Store may not have the trusted certificate from the CA in the chain. If you used OpenSSL or another tool to generate your own self-signed CA, you need to add the public certificate for that CA to the X509Store.

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-09-19T00:16:09.707

X509Store 中是否存在颁发者的证书？证书只有在您信任的人签名时才有效。

这是来自真实 CA 的证书，还是您自己签署的证书？开发人员经常使用的证书签名工具，如 OpenSSL，默认不添加一些重要的扩展。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-19T00:05:08.830

我相信 x509 证书与特定用户相关联。它可能是无效的，因为在代码中您以与创建它的用户不同的用户身份访问它吗？

# java - eclipse可以将类文件中的第二个类提取到自己的文件中吗

> ID：98079
> 
> 赞同：37
> 
> 时间：2008-09-18T23:43:53.497
> 
> 标签：java, eclipse, refactoring

我经常首先通过在我正在处理的类中创建一个内部类来重构代码——当我完成后，我将整个东西移动到一个新的类文件中。这使得将代码重构到新类中非常容易，因为 A）我只处理一个文件，并且 B）我不会创建新文件，直到我对名称/名称有一个很好的了解（有时它会结束作为一个以上的类）。

Eclipse 有什么办法可以帮助我完成最后一步吗？我应该能够告诉它我想要类在哪个包中，它可以从类名中找出文件名，从包中找出目录。

这似乎是一个微不足道的重构并且非常明显，但我无法弄清楚击键/手势/任何让它发生的东西。我尝试过拖动、菜单、上下文菜单和浏览键盘快捷键。

有人知道这个吗？

[编辑] 这些已经是这个文件中的“顶级”类，而不是内部类，并且“移动”似乎不想为我创建一个新类。这是我通常做的艰难的方式——包括走出去，创建一个空班，回来和搬家。我想一步完成整个事情。

* * *

## 回答 #1

> 赞同：45
> 
> 时间：2008-09-18T23:49:38.103

很抱歉我之前给出了错误的答案。我重新检查了，它并没有完全想要你想要的。不过，在 3.4 中，我确实为您找到了解决方案。

突出显示该类，复制 CTRL-C 或剪切 CTRL-X，单击您希望该类进入的包，然后粘贴 CTRL-V。Eclipse 将自动为您生成类。

将成员类型转换为顶级并不完全有效。这样做将创建外部类的一个字段并生成一个将外部类作为参数的构造函数。

* * *

## 回答 #2

> 赞同：37
> 
> 时间：2011-04-01T00:34:17.880

在 Eclipse 3.6 中，您可以执行以下操作：重构 -> 将类型移动到新文件

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-18T23:55:09.353

右键单击类名（在源代码中）并选择 Refactor -> Convert Member Type to Top Level。但是，它不允许您选择包。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2015-05-10T13:09:04.543

对于 IntelliJ IDEA / Android Studio：重构 -> 移动 -> 将内部类 MyInnerClass 移动到上层

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-18T23:55:07.450

可以在 2 次重构中完成：

> 1.  将成员类型转换为顶级
>     
>     
> 2.  移动

# java - 如何在 Java 中解析 PHP 序列化数据结构？

> ID：98090
> 
> 赞同：5
> 
> 时间：2008-09-18T23:46:20.137
> 
> 标签：java, php, serialization

我有一个结合了 Java 和 PHP 最好和最差的系统。我正在尝试将曾经用 PHP 编写的组件迁移到 Java One。

有没有人有一些关于如何在 Java 中解析 PHP 序列化数据结构的提示？序列化是指 php 的序列化函数的输出。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-18T23:51:12.153

PHP 序列化为简单的基于文本的格式。[PHPSerialize](http://hurring.com/scott/code/java/serialize/v0.1/PHPSerialize.java)看起来像一个用 Java 编写的解析器。您还可以将[Python 实现](http://pypi.python.org/pypi/phpserialize/1.1)移植到 Java——我怀疑它非常复杂。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2010-12-21T11:15:00.337

我遇到了同样的问题并找到了这个库： [http ://code.google.com/p/serialized-php-parser/](http://code.google.com/p/serialized-php-parser/)

它完全符合您的需要

# sql - SQL Server：选择文字值是否比选择字段更快？

> ID：98096
> 
> 赞同：1
> 
> 时间：2008-09-18T23:47:12.570
> 
> 标签：sql, sql-server

我见过一些人使用`EXISTS (SELECT 1 FROM ...)`而不是`EXISTS (SELECT id FROM ...)`作为优化——而不是查找并返回一个值，SQL Server 可以简单地返回它给出的文字。

总是`SELECT(1)`更快？从表中选择一个值是否需要选择文字可以避免的工作？

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-09-19T03:36:23.737

在 SQL Server 中，使用`SELECT 1`或`SELECT *`在`EXISTS`. 您实际上并没有返回行的内容，而是由`WHERE`子句确定的集合不是空的。尝试并排运行查询`SET STATISTICS IO ON`，您可以证明这些方法是等效的。我个人更喜欢`SELECT *`.`EXISTS`

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2009-10-21T18:33:08.680

为了谷歌的缘故，我将用与这个问题相同的答案来更新这个问题（[使用 Exists 1 或 Exists * 的子查询](https://stackoverflow.com/questions/1597442/subquery-using-exists-1-or-exists/)），因为（当前）一个不正确的答案被标记为已接受。请注意，SQL 标准实际上说 EXISTS via * 与常量相同。

不，这已经被报道了无数次。SQL Server 很聪明，知道它正被用于 EXISTS，并向系统返回 NO DATA。

微软： [http ://technet.microsoft.com/en-us/library/ms189259.aspx?ppud=4](http://technet.microsoft.com/en-us/library/ms189259.aspx?ppud=4)

> EXISTS 引入的子查询的选择列表几乎总是由星号 (*) 组成。没有理由列出列名，因为您只是在测试满足子查询中指定条件的行是否存在。

还有，不信？尝试运行以下命令：

```
SELECT whatever
  FROM yourtable
 WHERE EXISTS( SELECT 1/0
                 FROM someothertable 
                WHERE a_valid_clause ) 
```

如果它实际上是在对 SELECT 列表做某事，它会抛出一个 div by zero 错误。它没有。

编辑：注意，SQL 标准实际上谈到了这一点。

ANSI SQL 1992 标准，第 191 页[http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt](http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt)

> ```
>  3) Case:
> 
>         a) If the <select list> "*" is simply contained in a <subquery> that is immediately contained in an <exists predicate>, then the <select list> is equivalent to a <value expression> that is an arbitrary <literal>. 
> ```

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-19T00:02:10.320

当您使用 SELECT 1 时，您清楚地显示（向稍后阅读您的代码的人）您正在**测试**记录是否存在。即使没有性能提升（有待讨论），代码可读性和可维护性也会有所提升。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-18T23:48:57.917

是的，因为当您选择文字时，它不需要从磁盘（甚至从缓存）中读取。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-19T00:00:18.887

在存在子句中选择什么并不重要。大多数人都会选择 *，然后 sql server 会自动选择最佳索引

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-22T16:24:01.687

正如有人指出的那样，sql server 忽略了 EXISTS 中的列选择列表，所以没关系。我个人倾向于使用“ `SELECT null ...`”来表示该值根本没有被使用。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2010-12-03T17:21:57.077

如果您查看执行计划

```
select COUNT(1) from master..spt_values 
```

并查看流聚合，您会看到它计算

```
Scalar Operator(Count(*)) 
```

所以`1`实际上被转换为`*`

但是，我在“Inside SQL Server”系列书籍中的某处读过，这些书籍`*`可能会在检查列权限时产生非常小的开销。不幸的是，这本书没有比我记得的更详细。

* * *

## 回答 #8

> 赞同：-1
> 
> 时间：2008-09-19T00:04:36.147

选择 1 应该更好地用于您的示例。Select * 在运行前获取与对象相关的所有元数据，这会在查询编译期间增加开销。尽管在执行计划中运行这两种类型的查询时您可能看不到差异。

# memory - VS2005：限制堆大小

> ID：98098
> 
> 赞同：1
> 
> 时间：2008-09-18T23:47:20.557
> 
> 标签：memory, visual-c++, heap-memory

VS2005 C++ 编译器标志是否像 Xmx???M java 标志这样我可以限制在 Windows 上运行的应用程序的堆大小。

我需要限制堆大小，以便填充内存以找出当前的空闲内存。（代码也在嵌入式系统上运行，这是获取内存使用情况的最佳方法）

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2009-03-13T09:03:23.060

您可以通过在以下位置设置大小来设置程序的堆大小：

`Linker -> System -> Heap Reserve Size`

也可以在编译器命令行使用`/HEAP:reserve`

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T00:06:31.290

您可能想查看 gflags 实用程序（在 Windows 调试工具中）是否可以执行此操作。它可以用大量的原生应用程序做很多其他有趣的事情。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T00:08:56.167

堆大小取决于使用的分配器。可能还有一些 Windows API 调用限制了进程可以分配的内存量，但我不知道有一个，我现在不想寻找它，抱歉。但总的来说，如果您编写自己的分配器（可能只是环绕编译器提供的`malloc()`或`new`运算符），您可以通过这种方式人为地限制堆大小。

或者，如果您有自己的分配器，即使只是一个包装器，您也可以跟踪总共分配了多少内存。如果你知道可用的数量，你可以做一些减法并得到总数。然后，您可能还可以获得碎片统计信息，例如最大的空闲块。

# apache - 自动 Apache 服务器维护页面

> ID：98106
> 
> 赞同：4
> 
> 时间：2008-09-18T23:49:27.057
> 
> 标签：apache, maintenance

我有一个在 Linux/Apache/Tomcat 堆栈上运行的网站，需要每隔几个月自动离线以进行服务器维护，这将持续任意时间。有哪些选项可以让 Apache 建立和关闭“服务器维护”页面？

我需要能够通过 shell 脚本来控制它。（Google 提供的答案围绕手动编辑服务器配置展开，我不想凌晨 3 点在办公室！）我想我可以将脚本放入 .htaccess 文件中，并在完成后将其删除，但这似乎不够优雅。

* * *

回复评论：

[Mike 的答案](https://stackoverflow.com/a/98174/9304)看起来像是最佳实践的答案，尽管我要做的可能更像[Dan 的答案](https://stackoverflow.com/a/98126/9304)，因为第三方托管服务提供商控制着负载均衡器，我不想处理这种混乱。谢谢！

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-19T00:00:35.017

我们有一个可以做到这一点的设置，但它不仅包括 apache。它后面有一个负载均衡器和两台服务器。两个 Web 服务器都使用 Apache 为网站提供服务，其中一个有一个额外的虚拟主机，用于提供简单的 HTML 维护页面。负载均衡器有一个虚拟 HTTP 服务，可以将请求重定向到真实服务器。此虚拟服务具有三个真实服务器：两个是实际服务器，第三个是第二个服务器上指向维护页面的虚拟 IP。真实服务器使用权重最小的第三个进行加权，负载均衡器使用固定加权算法。因此，当真实网站因任何原因下线时，所有请求都会转到维护主机，用户会看到带有电话号码的漂亮错误页面。事实上，我使用一个小脚本来检查真实服务器的健康状况，

PS。我使用 Load Master 1500 作为负载均衡器。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-18T23:54:19.713

使用自定义配置文件启动 Apache 非常容易。在我的系统上：

```
httpd -f <config> 
```

我经常将它与 shell 脚本结合使用，这是一个非常简单的配置作为维护占位符。该脚本只是停止我的常规 Apache，然后启动它。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-18T23:51:54.010

制作2个配置文件并来回交换它们

如果文件只有一点点改变，将它们与预处理器合并，从一个源生成标准和“离线”版本，并在它们之间进行交换。

IIRC apache 配置文件是使用 CPP 构建的

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-18T23:52:46.237

我们做过类似的事情。我们有一个 index.html 重定向到我们的主站点页面。当我们进行维护时，我们会运行一个脚本来更改 html 文件中的重定向。然后我们通过脚本在cron和viola自动维护窗口。

希望有帮助！

# sql-server-2005 - SQL Server Reporting Services shows DTD prohibited in XML document error

> ID：98122
> 
> 赞同：1
> 
> 时间：2008-09-18T23:52:58.233
> 
> 标签：sql-server-2005, reporting, service

I am getting the following error when running a reporting services report.

```
Process name: w3wp.exe
Account name: NT AUTHORITY\NETWORK SERVICE 
Exception information: 
    Exception type: XmlException 
    Exception message: For security reasons DTD is prohibited in this XML document.  To enable DTD processing set the ProhibitDtd property on XmlReaderSettings to false and pass the settings into XmlReader.Create method. 
```

I select a report, enter the parameters(the parameters look messed up) and then press view report. Then at the bottom the message "For security reasons DTD is prohibited in this XML document. To enable DTD processing set the ProhibitDtd property on XmlReaderSettings ..." shows up.

How do I fix this?

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T01:11:43.380

检查您的报告服务器网站是否具有正确的本地路径文件夹。如果不正确，您可能需要执行 iisreset。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2018-08-30T13:20:52.507

在我的情况下，下载 xml 文件的 URL 实际上是强制执行表单身份验证，因此报告服务不是获取 XML，而是获取 ASP.NET / HTML 登录表单。

为了避免半天的研究，你应该首先在一个新的隐身浏览器中测试你的 url，以确保它可以正常工作并且你得到了预期的纯 xml。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2010-10-13T13:21:41.007

我在使用 SSRS 2005 并运行包含 XML 数据的大型报告时注意到了这一点。

在运行月度报告时它会起作用，但是当我运行季度报告时给我这个错误。

升级到 SQL/SSRS 2008 为我解决了这个问题！

# javascript - 为什么 Javascript getYear() 返回 108？

> ID：98124
> 
> 赞同：97
> 
> 时间：2008-09-18T23:53:48.340
> 
> 标签：javascript, date

为什么这个 javascript 返回 108 而不是 2008？它得到正确的日期和月份，但不是年份？

```
myDate = new Date();
year = myDate.getYear(); 
```

年 = 108？

* * *

## 回答 #1

> 赞同：130
> 
> 时间：2008-09-18T23:58:40.890

这是[千年虫](http://en.wikipedia.org/wiki/Y2K)问题，只计算自 1900 年以来的年份。

现在有潜在的兼容性问题`getYear()`已被弃用，取而代之的是`getFullYear()`- from [quirksmode](http://www.quirksmode.org/js/introdate.html)：

> 更复杂的是，date.getYear() 现在已被弃用，您应该使用 date.getFullYear()，而旧版浏览器不支持它。但是，如果它有效，它应该总是给出全年，即。2000 而不是 100。
> 
> 您的浏览器使用这两种方法提供以下年份：

```
* The year according to getYear(): 108
* The year according to getFullYear(): 2008 
```

Internet Explorer 和 Firefox 之间也存在实现差异，因为 IE 的实现`getYear()`已更改为`getFullYear()`来自[IBM](http://www-128.ibm.com/developerworks/web/library/wa-ie2mozgd/)的行为：

> 根据 ECMAScript 规范，getYear 返回减去 1900 的年份，最初的意思是返回 1998 年的“98”。getYear 在 ECMAScript 版本 3 中已被弃用，取而代之的是 getFullYear()。
> 
> Internet Explorer 将 getYear() 更改为像 getFullYear() 一样工作，并使其符合 Y2k 标准，而 Mozilla 保留了标准行为。

* * *

## 回答 #2

> 赞同：25
> 
> 时间：2008-09-19T00:12:49.107

由于 getFullYear 在较旧的浏览器中不起作用，因此您可以使用以下内容：

```
Date.prototype.getRealYear = function() 
{ 
    if(this.getFullYear)
        return this.getFullYear();
    else
        return this.getYear() + 1900; 
}; 
```

Javascript 原型可用于扩展现有对象，很像 C# 扩展方法。现在，我们可以这样做；

```
var myDate = new Date();
myDate.getRealYear();
// Outputs 2008 
```

* * *

## 回答 #3

> 赞同：13
> 
> 时间：2008-09-19T00:42:44.700

检查文档。这不是千年虫问题——而是缺少千年虫问题！这个决定最初是用 C 语言做出的，后来被复制到 Perl、显然是 JavaScript 和可能的其他几种语言中。很久以前，使用两位数的年份显然仍然是可取的，但值得注意的是，设计该界面的人有足够的远见，意识到他们需要考虑在 2000 年及以后会发生什么，所以不要只提供最后两个数字，他们提供了自 1900 年以来的年数。如果您赶时间或想冒险，可以使用这两位数字。或者，如果您希望您的程序继续工作，您可以将结果加上 100 并使用成熟的四位数年份。

我记得我第一次在 Perl 中进行日期操作。奇怪的是，我**阅读了文档**。显然，这不是一件常见的事情。一两年后，我在 1999 年 12 月 31 日被叫到办公室修复一个在最后一刻发现的一些合同 Perl 代码中的错误，这是我从未有过的事情。正是这个问题：标准日期调用返回自 1900 年以来的年份，程序员将其视为两位数年份。（他们认为他们在 2000 年会得到“00”。）作为一个没有经验的年轻程序员，让我大吃一惊的是，我们为一份“专业”工作付出了如此多的额外费用，而那些人甚至懒得去阅读文档。这是多年幻灭的开始。现在我老了，愤世嫉俗。:)

在 2000 年，一年一度的 YAPC Perl 会议被称为“YAPC 19100”，以纪念这个经常被报告的非 bug。

如今，至少在 Perl 世界中，使用标准模块进行日期处理更有意义，它使用真正的四位数年份。不确定 JavaScript 有什么可用的。

* * *

## 回答 #4

> 赞同：6
> 
> 时间：2008-09-18T23:55:00.023

它必须返回自 1900 年以来的年数。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2008-09-18T23:55:21.600

使用`date.getFullYear()`.

这是（正如在别处正确指出的那样）是千年虫的事情。Netscape（写于 2000 年之前）最初返回，例如`98`从`getYear()`. 它没有返回`00`，而是返回`100`2000 年。然后其他浏览器出现并以不同的方式出现，并且由于不兼容而导致每个人都不高兴。

后来的浏览器支持`getFullYear`作为返回完整年份的标准方法。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-09-19T00:22:16.027

这个问题太老了，让我怀念网络时代的泪水！

没错，Date.getYear() 返回自 1900 年以来的年数，就像 Perl 的 localtime() 一样。有人想知道为什么在 1990 年代设计的语言不能解释世纪营业额，但我能说什么呢？你必须在那里。这在当时有点道理（就像 pets.com 所做的那样）。

在 2000 年之前，人们可能想通过在 getYear() 的结果中附加“19”来修复这个错误，从而导致[“19100 年错误”](http://www.theregister.co.uk/2000/01/04/transmeta_screws_up_on_y2k/)。其他人已经充分回答了这个问题（将 1900 添加到 getDate() 的结果中）。

也许您正在阅读的关于 JavaScript 的书有点旧？

感谢过去的爆炸！

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-19T09:46:31.083

正如所指出的，您应该永远不要使用`getYear()`，而是使用`getFullYear()`.

然而，这个故事并不像“ IE实现`GetYear()`为`getFullYear()`.`getYear()``getYear()``getFullYear()`

这在所有浏览器中输出 99：

```
javascript:alert(new Date(917823600000).getYear()); 
```

这在 FF/WebKit 中输出 108，在 Opera/IE 中输出 2008：

```
javascript:alert(new Date().getYear()); 
```

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-18T23:58:13.683

这是愚蠢的。它[可以追溯到 Y2K 之前的天数](http://www.irt.org/articles/js199/index.htm)，现在由于遗留原因只返回自 1900 年以来的年数。使用 getFullYear() 获取实际年份。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2010-08-10T09:26:02.403

我正在使用`date.getUTCFullYear()`；工作没有问题。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-18T23:55:06.683

你得到的数字是自 1900 年以来的年数。不要问我为什么..

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-18T23:58:30.797

正如其他人所说，它返回自 1900 年以来的年数。这样做的原因*是*，当 JavaScript 在 90 年代中期发明时，这种行为既方便又与其他语言中的日期时间 API 一致。特别是 C。当然，一旦 API 建立起来，出于向后兼容性的原因，他们就无法更改它。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-09-19T00:03:46.757

顺便说一句，不同的浏览器可能会返回不同的结果，所以最好完全跳过这个函数并始终使用 getFullYear() 。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-11-25T07:03:58.840

var date_object=新日期（）；var year = date_object.getYear(); 如果（年 < 2000）{ 年 = 年 + 1900；} //你会得到一整年....

* * *

## 回答 #14

> 赞同：-1
> 
> 时间：2008-09-18T23:55:46.043

它正在返回 4 位数的年份 - 1900，这在 9 多年前可能很酷，但现在已经很迟钝了。Java 的 java.util.Date 也可以做到这一点。

# internet-explorer - 在 Internet Explorer 上的 iFrame 中访问域 Cookie

> ID：98127
> 
> 赞同：25
> 
> 时间：2008-09-18T23:54:43.037
> 
> 标签：internet-explorer, iframe, cookies

我的域（我们称之为 www.example.com）创建了一个 cookie。在另一个站点（比方说，www.myspace.com）上，我的域加载在 iFrame 中。

在除 Internet Explorer 之外的所有浏览器（Firefox、Opera、Camino、Safari 等）上，我都可以访问自己的 cookie。在 IE 中，它不允许我从 iFrame 中访问 c​​ookie。

有没有办法解决这个问题？

真的，这没有任何意义，因为试图访问 cookie 的站点是 www.example.com，而 cookie 归 www.example.com 所有。但出于某种原因，IE 认为 iFrame 使它们无关。

* * *

## 回答 #1

> 赞同：35
> 
> 时间：2008-09-18T23:56:01.627

Internet Explorer 的默认隐私设置意味着第 3 方 cookie（例如 iframe 中的那些）与第 1 方 cookie 的处理方式不同。（默认情况下，第 3 方 cookie 会被静默拒绝）。

要让 IE6 接受 iframe 中的 cookie，您需要确保您的网站提供 P3P 紧凑标头。

有关更多信息，请参阅[http://msdn.microsoft.com/en-us/library/ms537343.aspx](http://msdn.microsoft.com/en-us/library/ms537343.aspx)。

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2009-05-12T11:01:46.550

在 PHP 中：标头 ("p3p:CP=\"IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT\"");

* * *

## 回答 #3

> 赞同：-1
> 
> 时间：2008-09-19T00:02:07.010

对我来说，这听起来像是一个隐私设置问题。要么增加 IE 中的安全设置（您无法说服用户这样做），要么采取其他方法。

# windows - 如何使 Windows 软件在脚本中以不同用户身份运行？

> ID：98134
> 
> 赞同：4
> 
> 时间：2008-09-18T23:55:12.440
> 
> 标签：windows, build-process, scripting, wise

我正在使用一个调用 Wise 的构建脚本来创建一些安装文件。问题是 Wise 许可证只允许它在一个特定的用户帐户下运行，这与我的构建脚本将运行的帐户不同。我知道 Windows 有**runas**命令，但这不适用于自动脚本，因为无法通过命令行输入密码。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-18T23:58:12.747

这可能会有所帮助：[为什么 RunAs 程序不接受命令行上的密码？](http://blogs.msdn.com/oldnewthing/archive/2004/11/29/271551.aspx)

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T00:25:58.357

我建议看看[CPAU](http://www.joeware.net/freetools/tools/cpau/index.htm)。

> 用于在备用安全上下文中启动进程的命令行工具。基本上这是一个 runas 替代品。还允许您创建作业文件并将 id、密码和命令行编码到文件中，以便普通用户可以使用。

您可以像这样使用它（[示例](http://www.joeware.net/freetools/tools/cpau/usage.htm)）：

```
CPAU -u user [-p password] -ex "WhatToRun" [switches] 
```

或者您可以创建一个“.job”文件，其中包含用户和密码编码。这样您就可以避免将用户密码放在构建脚本中。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T00:03:01.207

这是一个变通的解决方案，但您可以创建一个以您的用户帐户运行的计划任务，并让它定期运行，可能每分钟运行一次。是的，您必须等待它运行。

然后，此任务可以查找一些要处理的数据文件，并且只有在它们存在时才进行真正的工作。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T00:31:59.297

这可能会有所帮助，这是我在另一个项目中使用的让人们创建自己的帐户的类；每个人都必须有权访问该程序，但不能允许同一帐户访问 LDAP 内容，因此该程序使用此类以不同用户身份运行它。

[http://www.codeproject.com/KB/dotnet/UserImpersonationInNET.aspx](http://www.codeproject.com/KB/dotnet/UserImpersonationInNET.aspx)

# python - 如何在没有 Django 其余部分的情况下使用 Django 模板？

> ID：98135
> 
> 赞同：105
> 
> 时间：2008-09-18T23:55:21.147
> 
> 标签：python, django, templates, django-templates, template-engine

我想在我的（Python）代码中使用 Django 模板引擎，但我没有构建基于 Django 的网站。如何在没有 settings.py 文件（和其他文件）且必须设置 DJANGO_SETTINGS_MODULE 环境变量的情况下使用它？

如果我运行以下代码：

```
>>> import django.template
>>> from django.template import Template, Context
>>> t = Template('My name is {{ my_name }}.') 
```

我得到：

```
ImportError: Settings cannot be imported, because environment variable DJANGO_SETTINGS_MODULE is undefined. 
```

* * *

## 回答 #1

> 赞同：134
> 
> 时间：2008-09-19T00:01:39.993

解决方案很简单。它实际上[有据可查](http://docs.djangoproject.com/en/dev/ref/templates/api/#configuring-the-template-system-in-standalone-mode)，但不太容易找到。（我不得不四处寻找——当我尝试了几个不同的谷歌搜索时，它没有出现。）

以下代码有效：

```
>>> from django.template import Template, Context
>>> from django.conf import settings
>>> settings.configure()
>>> t = Template('My name is {{ my_name }}.')
>>> c = Context({'my_name': 'Daryl Spitzer'})
>>> t.render(c)
u'My name is Daryl Spitzer.' 
```

有关您可能想要定义的一些设置的描述（作为配置的关键字参数），请参阅 Django 文档（上面链接）。

* * *

## 回答 #2

> 赞同：46
> 
> 时间：2008-09-19T00:08:41.783

[Jinja2的语法与 Django 的](http://jinja.pocoo.org/2/ "Jinja2 网站") [语法](http://jinja.pocoo.org/2/documentation/templates "模板语法参考")几乎相同，只有很少的差异，而且您获得了一个更强大的模板引擎，它还可以将您的模板编译为字节码（FAST！）。

我将它用于模板，包括在 Django 本身中，它非常好。如果缺少某些您想要的功能，您也可以轻松编写扩展。

以下是代码生成的一些演示：

```
>>> import jinja2
>>> print jinja2.Environment().compile('{% for row in data %}{{ row.name | upper }}{% endfor %}', raw=True) 
from __future__ import division
from jinja2.runtime import LoopContext, Context, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join
name = None

def root(context, environment=environment):
    l_data = context.resolve('data')
    t_1 = environment.filters['upper']
    if 0: yield None
    for l_row in l_data:
        if 0: yield None
        yield unicode(t_1(environment.getattr(l_row, 'name')))

blocks = {}
debug_info = '1=9' 
```

* * *

## 回答 #3

> 赞同：9
> 
> 时间：2008-09-18T23:56:36.370

你想使用 Django 的模板有什么特别的原因吗？在我看来，[Jinja](http://jinja.pocoo.org/)和[Genshi](http://genshi.edgewall.org/)都比较优秀。

* * *

如果您真的想要，请参阅[Django 文档`settings.py`](http://docs.djangoproject.com/en/dev/topics/settings/#topics-settings)。特别是“使用设置而不设置`DJANGO_SETTINGS_MODULE`”部分。使用这样的东西：

```
from django.conf import settings
settings.configure (FOO='bar') # Your settings go here 
```

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2008-09-20T21:02:58.693

我也会推荐jinja2。有一篇关于vs.的[好文章](https://web.archive.org/web/20090421084229/http://lucumr.pocoo.org/2008/9/16/why-jinja-is-not-django-and-why-django-should-have-a-look-at-it)提供了一些详细信息，说明为什么你应该更喜欢后者。`django``jinja2`

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2015-12-28T14:00:18.747

根据 Jinja 文档，[Python 3 支持仍处于试验阶段](http://jinja.pocoo.org/docs/dev/intro/#experimental-python-3-support)。因此，如果您使用的是 Python 3 并且性能不是问题，您可以使用 django 的内置模板引擎。

Django 1.8 引入了对[多个模板引擎](https://docs.djangoproject.com/en/1.9/releases/1.8/#multiple-template-engines)的支持，这需要更改模板的初始化方式。您必须明确配置`settings.DEBUG`django 提供的默认模板引擎使用哪个。这是在不使用 django 其余部分的情况下使用模板的代码。

```
from django.template import Template, Context
from django.template.engine import Engine

from django.conf import settings
settings.configure(DEBUG=False)

template_string = "Hello {{ name }}"
template = Template(template_string, engine=Engine())
context = Context({"name": "world"})
output = template.render(context) #"hello world" 
```

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2017-11-24T02:00:02.307

除了其他人写的，如果你想在 Django > 1.7 上使用 Django 模板，你必须给你的 settings.configure(...) 调用 TEMPLATES 变量并像这样调用 django.setup() ：

```
from django.conf import settings

settings.configure(TEMPLATES=[
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['.'], # if you want the templates from a file
        'APP_DIRS': False, # we have no apps
    },
])

import django
django.setup() 
```

然后你可以像往常一样从一个字符串加载你的模板：

```
from django import template   
t = template.Template('My name is {{ name }}.')   
c = template.Context({'name': 'Rob'})   
t.render(c) 
```

如果您在 .configure 中写入 DIRS 变量，则从磁盘：

```
from django.template.loader import get_template
t = get_template('a.html')
t.render({'name': 5}) 
```

[Django 错误：没有配置 DjangoTemplates 后端](https://stackoverflow.com/questions/43834226/django-error-no-djangotemplates-backend-is-configured#43834287)

[http://django.readthedocs.io/en/latest/releases/1.7.html#standalone-scripts](http://django.readthedocs.io/en/latest/releases/1.7.html#standalone-scripts)

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2013-12-09T20:37:34.113

感谢各位的帮助。这里还有一个补充。需要使用自定义模板标签的情况。

假设您在模块 read.py 中有这个重要的模板标签

```
from django import template

register = template.Library()

@register.filter(name='bracewrap')
def bracewrap(value):
    return "{" + value + "}" 
```

这是 html 模板文件“temp.html”：

```
{{var|bracewrap}} 
```

最后，这是一个 Python 脚本，它将把所有的东西联系在一起

```
import django
from django.conf import settings
from django.template import Template, Context
import os

#load your tags
from django.template.loader import get_template
django.template.base.add_to_builtins("read")

# You need to configure Django a bit
settings.configure(
    TEMPLATE_DIRS=(os.path.dirname(os.path.realpath(__file__)), ),
)

#or it could be in python
#t = Template('My name is {{ my_name }}.')
c = Context({'var': 'stackoverflow.com rox'})

template = get_template("temp.html")
# Prepare context ....
print template.render(c) 
```

输出将是

```
{stackoverflow.com rox} 
```

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-12-05T22:15:35.720

我也会说[Jinja](http://jinja.pocoo.org/)。它绝对比 Django 模板引擎**更强大，而且它是****独立的**。

如果这是现有 Django 应用程序的外部插件，您可以创建[自定义命令](http://docs.djangoproject.com/en/dev/howto/custom-management-commands/#howto-custom-management-commands)并在项目环境中使用模板引擎。像这样;

```
manage.py generatereports --format=html 
```

但我认为只使用 Django 模板引擎而不是 Jinja 是不值得的。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-18T23:58:12.467

发现这个：

[http://snippets.dzone.com/posts/show/3339](http://snippets.dzone.com/posts/show/3339)

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-11-20T02:43:43.517

不。改用[StringTemplate](http://www.stringtemplate.org/) ——一旦你知道它，就没有理由考虑任何其他模板引擎。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-18T23:57:12.203

Google`AppEngine`使用了 Django 模板引擎，你看过他们是怎么做的吗？你可能只是使用它。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-09-19T00:18:31.120

我附和上述说法。Jinja 2 是一个非常好的通用 Django 模板超集。我认为他们正在努力使 Django 模板与 settings.py 的耦合度降低一些，但 Jinja 应该适合你。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2012-07-17T08:50:43.473

运行`manage.py`外壳时：

```
>>> from django import template   
>>> t = template.Template('My name is {{ me }}.')   
>>> c = template.Context({'me': 'ShuJi'})   
>>> t.render(c) 
```

# c++ - What's the best hashing algorithm to use on a stl string when using hash_map?

> ID：98153
> 
> 赞同：48
> 
> 时间：2008-09-18T23:58:05.820
> 
> 标签：c++, windows, performance, stl, hash

I've found the standard hashing function on VS2005 is painfully slow when trying to achieve high performance look ups. What are some good examples of fast and efficient hashing algorithms that should void most collisions?

* * *

## 回答 #1

> 赞同：64
> 
> 时间：2008-09-20T08:46:37.293

I worked with [Paul Larson](http://research.microsoft.com/~PALARSON/) of Microsoft Research on some hashtable implementations. He investigated a number of string hashing functions on a variety of datasets and found that a simple multiply by 101 and add loop worked surprisingly well.

```
unsigned int
hash(
    const char* s,
    unsigned int seed = 0)
{
    unsigned int hash = seed;
    while (*s)
    {
        hash = hash * 101  +  *s++;
    }
    return hash;
} 
```

* * *

## 回答 #2

> 赞同：19
> 
> 时间：2008-09-19T00:01:51.257

From some old code of mine:

```
/* magic numbers from http://www.isthe.com/chongo/tech/comp/fnv/ */
static const size_t InitialFNV = 2166136261U;
static const size_t FNVMultiple = 16777619;

/* Fowler / Noll / Vo (FNV) Hash */
size_t myhash(const string &s)
{
    size_t hash = InitialFNV;
    for(size_t i = 0; i < s.length(); i++)
    {
        hash = hash ^ (s[i]);       /* xor  the low 8 bits */
        hash = hash * FNVMultiple;  /* multiply by the magic number */
    }
    return hash;
} 
```

Its fast. Really freaking fast.

* * *

## 回答 #3

> 赞同：8
> 
> 时间：2008-09-19T00:01:31.757

Boost has an [boost::hash](http://www.boost.org/doc/libs/1_36_0/doc/html/hash.html) library which can provides some basic hash functions for most common types.

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2008-09-18T23:59:19.903

That always depends on your data-set.

I for one had surprisingly good results by using the CRC32 of the string. Works very good with a wide range of different input sets.

Lots of good CRC32 implementations are easy to find on the net.

**Edit:** Almost forgot: This page has a nice hash-function shootout with performance numbers and test-data:

[http://smallcode.weblogs.us/](http://smallcode.weblogs.us/) <-- further down the page.

* * *

## 回答 #5

> 赞同：6
> 
> 时间：2008-09-19T03:13:05.617

如果您要散列一组固定的单词，最好的散列函数通常是[完美的散列函数](http://en.wikipedia.org/wiki/Perfect_hash)。但是，它们通常要求您尝试散列的单词集在编译时是已知的。[在词法分析器](http://en.wikipedia.org/wiki/Lexical_analysis)中检测关键字（并将关键字转换为标记）是使用[gperf](http://www.gnu.org/software/gperf/)等工具生成的完美哈希函数的常见用法。完美的哈希还可以让您`hash_map`用简单的数组或`vector`.

如果您没有散列一组固定的单词，那么显然这不适用。

* * *

## 回答 #6

> 赞同：6
> 
> 时间：2008-09-19T00:24:04.167

我已经使用 Jenkins 哈希编写了一个 Bloom 过滤器库，它具有出色的性能。

详细信息和代码可在此处获得：http: [//burtleburtle.net/bob/c/lookup3.c](http://burtleburtle.net/bob/c/lookup3.c)

这就是 Perl 用于其散列操作的方法，fwiw。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-19T00:18:57.487

字符串哈希的一个经典建议是逐个遍历字母，将它们的 ascii/unicode 值添加到累加器，每次将累加器乘以素数。（允许散列值溢出）

```
 template <> struct myhash{};

  template <> struct myhash<string>
    {
    size_t operator()(string &to_hash) const
      {
      const char * in = to_hash.c_str();
      size_t out=0;
      while(NULL != *in)
        {
        out*= 53; //just a prime number
        out+= *in;
        ++in;
        }
      return out;
      }
    };

  hash_map<string, int, myhash<string> > my_hash_map; 
```

如果不丢弃数据，很难比这更快。如果您知道您的字符串只能通过几个字符而不是它们的全部内容来区分，那么您可以做得更快。

如果值被计算得太频繁，您可以尝试通过创建一个新的 basic_string 子类来更好地缓存哈希值，该子类记住其哈希值。不过，hash_map 应该在内部执行此操作。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2012-02-20T02:41:45.030

我做了一些搜索，有趣的是，Paul Larson 的小算法出现在这里 [http://www.strchr.com/hash_functions](http://www.strchr.com/hash_functions) 在许多条件下测试的碰撞最少，而且它的速度非常快展开或表驱动。

拉森是简单的乘以 101 并在上面添加循环。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2014-03-19T18:29:30.190

Python 3.4 包含一个基于[SipHash](https://131002.net/siphash/)的新哈希算法。[PEP 456](http://legacy.python.org/dev/peps/pep-0456/)信息量很大。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2016-12-24T15:08:00.470

从[哈希函数一直向下](http://aras-p.info/blog/2016/08/02/Hash-Functions-all-the-way-down/)：

> [MurmurHash](https://github.com/aappleby/smhasher "MurmurHash 父项目")作为一种“通用哈希函数”非常流行，至少在游戏开发者圈子里是这样。
> 
> 这是一个不错的选择，但是让我们稍后看看我们是否可以做得更好。另一个不错的选择，特别是如果您对数据的了解比“它将是未知的字节数”更多，是滚动您自己的（例如，参见 Won Chun 的回复，或 Rune 的修改后的 xxHash/Murmur，它们专门用于 4 字节密钥ETC。）。如果您知道您的数据，请始终尝试查看该知识是否可以用于良好的效果！

如果没有更多信息，我会推荐[MurmurHash](https://github.com/aappleby/smhasher "MurmurHash 父项目")作为通用[非加密哈希函数](https://en.wikipedia.org/wiki/List_of_hash_functions#Non-cryptographic_hash_functions)。对于小字符串（程序中的平均标识符大小），非常简单且著名的[djb2](http://www.cse.yorku.ca/~oz/hash.html "djb2")和[FNV](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function "福勒-诺尔-沃")非常好。

> 在这里（数据大小 < 10 字节）我们可以看到其他算法的 ILP 智能并没有表​​现出来，而 FNV 或 djb2 的超级简单性在性能上获胜。

## [djb2](http://www.cse.yorku.ca/~oz/hash.html "djb2")

```
unsigned long
hash(unsigned char *str)
{
    unsigned long hash = 5381;
    int c;

    while (c = *str++)
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    return hash;
} 
```

## [FNV-1](http://www.isthe.com/chongo/tech/comp/fnv/index.html)

```
hash = FNV_offset_basis
for each byte_of_data to be hashed
     hash = hash × FNV_prime
     hash = hash XOR byte_of_data
return hash 
```

## [FNV-1A](http://www.isthe.com/chongo/tech/comp/fnv/index.html)

```
hash = FNV_offset_basis
for each byte_of_data to be hashed
     hash = hash XOR byte_of_data
     hash = hash × FNV_prime
return hash 
```

## 关于安全性和可用性的说明

哈希函数会使您的代码容易受到拒绝服务攻击。如果攻击者能够强制您的服务器处理太多冲突，您的服务器可能无法处理请求。

一些哈希函数（如[MurmurHash）](https://github.com/aappleby/smhasher "MurmurHash 父项目")接受一个种子，您可以提供该种子以大大降低攻击者预测您的服务器软件正在生成的哈希值的能力。记在脑子里。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-19T11:14:21.263

如果您的字符串平均比单个缓存行长，但它们的长度+前缀相当独特，请考虑仅使用长度+前 8/16 个字符。（长度包含在 std::string 对象本身中，因此读起来很便宜）

# windows-services - 如何让 runonce 运行，而无需管理员登录

> ID：98163
> 
> 赞同：0
> 
> 时间：2008-09-18T23:59:01.870
> 
> 标签：windows-services, installation, registry, runonce

如果后台有以管理员身份运行的服务，是否有任何方法可以强制使用 RunOnce 更新软件，而无需管理员登录？

**编辑**：我想要做的主要事情是在 RunOnce 运行时运行，在资源管理器启动之前运行 IE。我需要能够安装东西，而无需启动管理员帐户。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T00:13:17.623

我不确定我是否理解这个问题。让我尝试：

你提到的服务，是你的吗？如果是这样，您可以向其中添加代码以模仿 Windows：从您的服务中检查 RunOnce 值并启动它指定的可执行文件。您可以使用 CreateProcessAsUser() API 在任意用户的上下文中启动它。启动进程后，删除 RunOnce 条目。

还是我误解了你的问题？

编辑：服务不依赖于任何登录的用户。您可以在服务本身启动后立即从服务启动更新过程，它会在任何真实用户登录计算机之前发生。

# aggregate - NDepend CQL 计数查询

> ID：98186
> 
> 赞同：3
> 
> 时间：2008-09-19T00:02:49.880
> 
> 标签：aggregate, cql, ndepend

我想查询特定类的公共方法表以及 NDepend CQL 中每个方法的使用计数。当前查询如下所示：

```
SELECT METHODS 
FROM TYPES "AE.DataAccess.DBHelper" 
WHERE IsPublic 
```

是否可以在 CQL 中聚合查询？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T16:15:45.413

看起来下面的查询将生成一个漂亮的表，其中包含我正在寻找的可以导出到 Excel 的值。多么棒的工具。

> 从类型“AE.DataAccess.DBHelper”中选择方法，其中 IsPublic ORDER BY MethodCa DESC

# c# - 从单元测试触发 UI 控件事件

> ID：98196
> 
> 赞同：3
> 
> 时间：2008-09-19T00:04:10.797
> 
> 标签：c#, winforms, unit-testing

作为 TDD 的初学者，我正在尝试编写一个测试，假设属性在 PropertyGrid（C#、WinForms、.NET 3.5）上的值已更改。

更改属性网格中对象的属性不会触发事件（很公平，因为它是 UI 引发的事件，所以我可以看到为什么更改拥有的对象可能对它不可见）。

在更改 SelectedNode 属性时，我也遇到了相同的问题，即在 TreeView 上触发 AfterSelect。

我可以有一个我的单元测试可以调用的函数来模拟 UI 事件将触发的代码，但这会使我的代码混乱，除非我将其公开，否则我将不得不在同一个项目中编写所有测试，甚至是我正在测试的对象的类（再次，我认为这是混乱的）。这对我来说似乎很难看，并且会遇到可维护性问题。

是否有惯例进行这种基于 UI 的单元测试

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-19T00:42:34.573

要对代码进行单元测试，您需要模拟 UI 界面元素的对象。您可以使用许多工具来执行此操作，我不能推荐其中一个。[在 Phil Haack 的博客](http://haacked.com/archive/2008/03/23/comparing-moq-to-rhino-mocks.aspx)中， MoQ 和 Rhino Mocks 进行了很好的比较，我发现它很有用，并且可能对你有用。

如果您使用 TDD，需要考虑的另一件事是为您的视图创建一个接口，这将有助于 TDD 过程。为此有一个设计模型（可能不止一个，但这是我使用的一个），称为模型视图演示器（现在分为被动视图和主管控制器）。遵循其中之一将使您的代码在未来更具可测试性。

另外，请记住，无法通过单元测试来测试 UI 本身。另一个答案中已经建议的测试自动化工具将适用于此，但不适用于对代码进行单元测试。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T00:16:27.007

Microsoft 在 .Net Framework 中内置了 UI 自动化。您可以使用它来模拟用户以正常方式使用您的软件。

有一篇 MSDN 文章“[使用 UI 自动化进行自动化测试](http://msdn.microsoft.com/en-us/library/aa348551.aspx "MSDN - 使用 UI 自动化进行自动化测试")，这是一个很好的起点。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T00:15:03.003

由于其简单性，我推荐的一种选择是让您的 UI 在触发事件时调用一个辅助类或方法并对其进行单元测试。确保它（您在 UI 中的事件处理程序）具有尽可能少的逻辑，然后我相信您会知道该做什么。

在你的单元测试中达到 100% 的覆盖率是相当困难的。我所说的困难当然是指效率低下。即使你擅长这样的事情，在我看来，它可能会给你的代码库增加比你的单元测试更复杂的复杂性。如果您不确定如何将您的逻辑分割成一个单独的类或方法，那是我很乐意帮助解决的另一个问题。

我很想看看人们在处理这类问题时还需要哪些其他技术。

# javascript - What cross-browser JavaScript libraries exist?

> ID：98205
> 
> 赞同：13
> 
> 时间：2008-09-19T00:06:11.243
> 
> 标签：javascript, ajax, dom, cross-browser

I'm gearing up to do some Ajax style client-side JavaScript code in the near future, and I've heard rave reviews of jQuery when it comes to this realm. What I'm wondering is:

*   **What are all the cross-browser JavaScript libraries out there?**

What is the experience using them?

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-09-19T00:14:59.337

An excellent resource is [Jeff Atwood's post on JavaScript libraries](https://blog.codinghorror.com/secrets-of-the-javascript-ninjas/).

He lists:

1.  [Prototype](https://en.wikipedia.org/wiki/Prototype_JavaScript_Framework) and [Script.aculo.us](https://en.wikipedia.org/wiki/Script.aculo.us)
2.  [jQuery](https://en.wikipedia.org/wiki/JQuery)
3.  [Yahoo UI Library](https://en.wikipedia.org/wiki/Yahoo!_UI_Library)
4.  [Ext JS](https://en.wikipedia.org/wiki/Ext_JS)
5.  [Dojo](http://dojotoolkit.org/)
6.  [MooTools](https://en.wikipedia.org/wiki/MooTools)

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-19T00:20:27.077

*所有*的跨浏览器 JavaScript 库都在那里？您确实意识到那里有 [100 多个库](http://ntt.cc/2008/02/13/the-most-complete-ajax-framework-and-javascript-libraries-list.html)，所以您应该缩小范围，IMO。

一个很好的起点是 Wikipedia 的*[JavaScript 框架比较](http://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks)*，其中包括 Dojo、[Ext JS](http://en.wikipedia.org/wiki/Ext_JS)、[jQuery](http://en.wikipedia.org/wiki/JQuery)、midori、[MochiKit](http://mochikit.com/)、[MooTools](http://en.wikipedia.org/wiki/MooTools)、[Prototype](http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework) & script.aculo.us、qooxdoo、[YUI](http://en.wikipedia.org/wiki/Yahoo!_UI_Library)和 SweetDEV RIA。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2011-11-26T23:18:32.880

我想报告这个几乎不为人知的图书馆，题为：“ [BBC Glow](http://www.bbc.co.uk/glow/) ”。

其他库因花里胡哨而受到称赞，但 Glow 是关于跨浏览器支持的。该项目对其目标有明确的说明，并且还有一个浏览器[支持表](http://www.bbc.co.uk/guidelines/futuremedia/technical/browser_support.shtml)。

这是一个坚实的起点。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-19T00:08:11.100

[Prototype](http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework) [FTW](http://en.wiktionary.org/wiki/FTW).

I do like [jQuery](http://en.wikipedia.org/wiki/JQuery), but Prototype serves my needs most of the time. It may just be because I'm more familiar with it, but I seem to get stuff done faster in Prototype than in jQuery.

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2012-06-19T23:03:41.387

大多数现有的答案要么是通往黏糊糊的营销渠道，要么是图书馆早已过期。

所传达的“跨浏览器”通常是“多浏览器”，即浏览器的一小部分。诸如[Dojo Toolkit](http://en.wikipedia.org/wiki/Dojo_Toolkit)和[Ext JS](http://en.wikipedia.org/wiki/Ext_JS)之类的库（实际上是 Sencha 的任何东西）都犯了这种行为。jQuery 在一些对健全代码的大声呼吁出现之前曾经表现得类似（该项目仍然有一座巨大的山需要攀登）。“跨浏览器”通常指的是 DOM 和其他一些 API 的抽象。

我最近完成了一个 HTML DOM 库，它涵盖了非常广泛的浏览器，我认为这里的社区可能会对它感兴趣。目前的名单是：

*   互联网浏览器 5-9；
*   火狐1-13；
*   [歌剧](http://en.wikipedia.org/wiki/Opera_%28web_browser%29)5-12；
*   Safari 3.1-5；
*   Chrome 1-4（假定适用于所有 Chrome 版本，但 Chrome 版本仍然难以独立测试）；这是我遇到的第二广泛的覆盖范围，仅次于另一个，我将在下一段中提到。我创建的库名为：“Matt's DOM Utils”（Utils），可以通过 GitHub[[0]] 或我自己的站点[ [1](http://en.wikipedia.org/wiki/Dojo_Toolkit) ] 访问。它是完全模块化的，特别关注 DOM 遍历，同时提供其他实用程序，例如`Element::classList`模块。

但是，互联网上最全面的 DOM 库是 David Mark 的“我的库”。该库包含大量实用程序，几乎涵盖了[Netscape](http://en.wikipedia.org/wiki/Netscape_Navigator) 4 以外的所有浏览器。它具有伪模块化构建阶段，如果需要，可以非常少。可以通过 GitHub[ [2](http://en.wikipedia.org/wiki/Ext_JS) ] 或 David 的网站[ [3](http://en.wikipedia.org/wiki/Opera_%28web_browser%29) ] 访问它。我建议任何阅读此线程的人彻底了解该 API。我从作者和代码本身都学到了很多东西。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-19T00:07:38.603

jQuery.

(Added so as to have an entry for voting.)

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-19T00:11:18.970

Loads!

jQuery, [Prototype](http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework), [Ext JS](http://en.wikipedia.org/wiki/Ext_JS), Dojo, [MooTools](http://en.wikipedia.org/wiki/MooTools), [YUI](http://en.wikipedia.org/wiki/Yahoo!_UI_Library), [Mochikit](http://mochikit.com/), the list goes on!

jQuery is very popular, and an excellent choice. However, some frameworks are better for some things, and others better for others. If you could give us a better idea of what you want to do, or how you will be using it (or even which other languages you use) we'd be able to give you a nudge towards one or the other.

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-19T01:14:04.123

如果你想跟上其他人的潮流，那么 jQuery 就是你的终极目标。不用多想，只听别人的。:P

就个人而言，我使用并喜欢[**MochiKit**](http://MochiKit.com)。它似乎可以完成 jQuery 所做的所有事情，但理念有点不同，而且社区规模要小得多。没有很多额外的插件，但有一些。它的设计采用了很多 Python 风格和函数式编程结构，所以如果你觉得这听起来很有趣，你可能想看看。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-19T01:53:56.057

Dori 发布的列表非常全面，我认为不可能列出所有库，因为即使在我打字的时候也可能有一个正在编写（这似乎是某些人的热情）。

我觉得使用[jQuery](http://en.wikipedia.org/wiki/JQuery)和/或[Prototype](http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework)可能会让你快速起步并快速构建整洁的东西，而且你很有可能会像我们许多人一样爱上它们。

Gucci 让 Thomas Fuchs（[script.aculo.us](http://en.wikipedia.org/wiki/Script.aculo.us)的创建者）在不使用 Flash 的情况下创建[了他们的网站](http://www.gucci.com) ，但是看看它，它看起来很神奇，因为它只是 JavaScript / CSS。

一个关于它的帖子是*[Gucci Relaunches on Script.aculo.us](http://ajaxian.com/archives/gucci-relaunches-on-scriptaculous)*。

这些库功能强大且用途广泛（带有一些不错的插件），以至于您不会“碰壁”并很快开始寻找其他库。

我也看到人们用[Dojo](http://en.wikipedia.org/wiki/Dojo_Toolkit)和[Ext JS](http://en.wikipedia.org/wiki/Ext_JS)做了一些很好的事情，但我自己从来没有和他们一起工作过。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-11-20T08:57:51.997

流行的有 jQuery、[Dojo Toolkit](http://en.wikipedia.org/wiki/Dojo_Toolkit)、[Prototype](http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework)（带有[Script.aculo.us](http://en.wikipedia.org/wiki/Script.aculo.us)）和[MooTools](http://en.wikipedia.org/wiki/MooTools)。我鼓励您测试 MooTools *，除非*您使用的是 ASP.NET，在这种情况下，我鼓励您查看我正在开发的项目 ( [Ra-Ajax](http://ra-ajax.org) )，它是一个完全服务器端绑定的 Ajax 框架ASP.NET...

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-19T04:47:03.037

我喜欢 jQuery。原型非常相似。还有其他几个，但我强烈建议您自己评估它们。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-09-19T04:57:55.973

我更喜欢 Mootools，因为它是轻量级的并且基于 Prototype，但就像 Jay 所说的你应该自己检查一下。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-19T00:07:20.400

Do have a closer look at [MooTools](http://en.wikipedia.org/wiki/MooTools).

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-09-19T03:51:26.897

jQuery 是一个不错的选择。它倾向于“瘦而快速”的一面，并允许一些奇妙的 DOM 操作。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-09-19T01:37:03.710

我想不出不使用[jQuery](http://en.wikipedia.org/wiki/JQuery)来进行任何 JavaScript 开发（还要深入了解[jQuery UI](http://en.wikipedia.org/wiki/JQuery_UI)）。

# asp.net-mvc - 您如何验证 ASP.NET MVC 中的复选框？

> ID：98212
> 
> 赞同：1
> 
> 时间：2008-09-19T00:08:08.197
> 
> 标签：asp.net-mvc, validation, checkbox

我想知道人们使用什么方法来验证 ASP.NET MVC（客户端和服务器端）中的复选框。

我目前正在使用 JQuery 进行客户端验证，但我很好奇人们正在使用什么方法，最好是最少的大惊小怪（我正在寻找一个新的解决方案）。

我应该提一下，我目前正在使用 MVC Preview 4，虽然如果 MVC Preview 4 中没有优雅的解决方案，我可以升级到 MVC Preview 5，但我不希望在这个阶段仅仅出于与其他开发人员和现有解决方案的兼容性目的.

注意，我看过这些相关的帖子：

*   [在 ASP.NET MVC 框架中验证已发布的表单数据](https://stackoverflow.com/questions/10300/validating-posted-form-data-in-the-aspnet-mvc-framework)
*   [使用 ASP.NET MVC 实现字段验证的最佳方法是什么？](https://stackoverflow.com/questions/16747/whats-the-best-way-to-implement-field-validation-using-aspnet-mvc)
*   [MVC.net JQuery 验证](https://stackoverflow.com/questions/61456/mvcnet-jquery-validation)

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-12-03T18:08:37.140

如果您继续访问验证网站并下载包含演示文件的整个包，您可以找到带有验证复选框和单选按钮示例的包。链接在这里：http: [//jquery.bassistance.de/validate/jquery.validate.zip](http://jquery.bassistance.de/validate/jquery.validate.zip)

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T00:10:43.637

我假设您只需检查复选框的名称是否已发布到服务器。我自己不是 ASP 编码员，我帮不上忙，尽管这是在 PHP 中完成的方式（当然，取决于您映射验证的方式）。

```
<?php echo isset($_POST['checkbox_name']) ? 'checked' : 'not checked'; ?> 
```

# mysql-management - How to know about memory consumption in mysql?

> ID：98223
> 
> 赞同：8
> 
> 时间：2008-09-19T00:09:43.763
> 
> 标签：mysql-management

how can one know that each process or a thread is consuming how much memory in MYSQL?

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-09-19T00:30:56.910

假设您只需要 mysql 服务器程序的内存使用情况。

在 Windows 上，您可以使用[Process Explorer](http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx)

在 linux 上，您可以使用 top 命令。

1.  使用“ps -e”查找mysql进程的pid
2.  然后使用 "top -p {pid}" 其中 {pid} 是 mysql 进程的 pid。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T00:38:18.780

在 linux 上，您还可以使用 top|grep mysql 获取 mysql 进程统计信息的运行报告，每个最高刷新周期 1 行。

# ftp - 如何递归列出远程FTP的目录内容

> ID：98224
> 
> 赞同：23
> 
> 时间：2008-09-19T00:09:50.847
> 
> 标签：ftp

从远程 UNIX FTP 服务器下载文件后，您需要验证是否已正确下载所有文件。最少您会在 Windows 命令提示符中获得类似于“dir /s”命令的信息。FTP 客户端在 Windows 上运行。

* * *

## 回答 #1

> 赞同：23
> 
> 时间：2008-09-19T00:12:10.903

遗憾的是，这是为 Unix/Linux 用户编写的：/

就个人而言，我会安装 CYGWIN 只是为了让 LFTP/RSYNC 的 Linux 二进制文件在 Windows 上工作，因为似乎没有任何东西可以与之竞争。

正如@zadok.myopenid.com 提到的rsync，这似乎是使用CYGWIN 为它构建的windows （如果你最终能够通过ssh 访问该框）

[http://www.aboutmyip.com/AboutMyXApp/DeltaCopy.jsp](http://www.aboutmyip.com/AboutMyXApp/DeltaCopy.jsp)

Rsync 很方便，因为它将所有内容与校验和进行比较，并以最佳方式传输部分更改块。

* * *

如果您获得 CYGWIN/Linux：

[http://lftp.yar.ru/](http://lftp.yar.ru/) 是我最喜欢的探索工具。

它几乎可以做 bash 可以做的所有事情，尽管是远程的。

例子：

```
$ lftp mirror.3fl.net.au
lftp mirror.3fl.net.au:~> ls                          
drwxr-xr-x 14 root root 4096 Nov 27 2007 游戏
drwx------ 2 root root 16384 2006 年 4 月 13 日 lost+found
drwxr-xr-x 15 镜子 镜子 4096 Jul 15 05:20 pub
lftp mirror.3fl.net.au:/> cd 游戏/杂项
lftp mirror.3fl.net.au:/games/misc>find
./
./dreamchess/
./dreamchess/full_game/                                                      
./dreamchess/full_game/dreamchess-0.2.0-win32.exe                                      
./frets_on_fire/
./frets_on_fire/full_game/                                                      
./frets_on_fire/full_game/FretsOnFire-1.2.451-macosx.zip                                  
./frets_on_fire/full_game/FretsOnFire-1.2.512-win32.zip
./frets_on_fire/full_game/FretsOnFire_ghc_mod.zip
./gametap_setup.exe
……
lftp mirror.3fl.net.au:/games/misc> du gametap_setup.exe
32442 gametap_setup.exe
lftp mirror.3fl.net.au:/games/misc> du -sh gametap_setup.exe
32M gametap_setup.exe
lftp mirror.3fl.net.au:/games/misc>

```

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2010-12-11T00:30:26.390

做这个 ：

```
ls -lR 
```

.....................

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-19T00:13:38.887

如果您有 ssh 访问权限，请改用 rsync。这是一个更好的数据传输应用程序。

为您的操作系统获取保险丝并加载 ftpfs。这将允许您在本地挂载远程 ftp 目录，您可以使用 dir /s 或您想要的任何其他应用程序。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2015-06-15T18:40:34.877

假设您通过命令行使用简单的 ftp，请使用带有 -Rl 选项的 dir 命令递归搜索并将其复制到文件中，然后使用 grep、find 或操作系统支持的任何方式搜索文件。

ftp> dir -Rl education.txt 输出到本地文件：education.txt？y 227 进入被动模式 (9,62,119,15,138,239) 150 打开文件列表的 ASCII 模式数据连接 226 传输完成

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2013-04-10T10:30:52.040

您可以使用apache-commons-net 中的**ftp.listFiles("directory")**并且可以编写自己的 BFS 或 DFS 以递归方式获取所有文件。

# vim - 在 Emacs 中使用 viper + vimpulse 时，Vim 宏不起作用

> ID：98225
> 
> 赞同：4
> 
> 时间：2008-09-19T00:09:56.510
> 
> 标签：vim, emacs, viper-mode, vimpulse

任何其他使 emacs 尽可能类似于 vim 的调整也将不胜感激。

附录：我不只是使用 vim 的主要原因是我喜欢 emacs 如何让您在两个不同的框架中打开文件[添加：抱歉，这令人困惑：我的意思是单独的*windows*，emacs 称之为“框架”]。这就像进行垂直分割，但我不必有一个巨大的窗口。

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2009-01-27T16:38:56.577

[您可以在客户端服务器模式下](http://www.vim.org/htmldoc/remote.html#clientserver)运行 VIM ，然后您可以有两个窗口连接到一个实例，因此不再需要 Emacs。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2009-01-27T10:13:36.327

我不知道如何使 Vim 宏工作，但是由于您要求进行调整以使 emacs 尽可能像 vim，所以这里有一些我每天使用的 vimpulse 的补充：

```
(define-key viper-vi-global-user-map [(delete)] 'delete-char)
(define-key viper-vi-global-user-map "/" 'isearch-forward-regexp)
(define-key viper-vi-global-user-map "?" 'isearch-backward-regexp)
(define-key viper-vi-global-user-map "\C-wh" 'windmove-left)
(define-key viper-vi-global-user-map "\C-wj" 'windmove-down)
(define-key viper-vi-global-user-map "\C-wk" 'windmove-up)
(define-key viper-vi-global-user-map "\C-wl" 'windmove-right)
(define-key viper-vi-global-user-map "\C-wv" '(lambda () (interactive)
                                                (split-window-horizontally)
                                                (other-window 1)
                                                (switch-to-buffer (other-buffer))))

(define-key viper-visual-mode-map "F" 'viper-find-char-backward)
(define-key viper-visual-mode-map "t" 'viper-goto-char-forward)
(define-key viper-visual-mode-map "T" 'viper-goto-char-backward)
(define-key viper-visual-mode-map "e" '(lambda ()
                                         (interactive)
                                         (viper-end-of-word 1)
                                         (viper-forward-char 1)))

(push '("only" (delete-other-windows)) ex-token-alist)
(push '("close" (delete-window)) ex-token-alist) 
```

当然，学习 Emacs 也很重要，但是 Emacs 依赖于自定义来使其行为完全符合您的要求。而且默认的 Vim 键绑定非常舒适，使用 Viper 仅仅意味着 Viper 为您做了一些 Emacs 定制。

至于使用 Vim 而不是 Emacs，我喜欢 Vim，但我喜欢 Emacs 的 Lisp 系统的交互性。*没有什么比在*编辑器中的任何位置键入一行代码并通过一次击键立即评估它，在*运行时*`C-M-x`通过一次击键（

 ** * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T05:14:26.230

我没有给你任何 viper 或 vimpulse 的调整，但我建议你尝试跟随模式。

当然，我也建议你也开始学习 Emacs。我的意思是，如果你已经到了这一步，你不妨阅读本教程，也许看看 emacswiki。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2009-01-27T16:44:31.607

我使用的 VIM 版本支持（Window 版本）支持使用“Ctrl+W s”将文件分成 2 个不同的帧...

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2009-01-28T15:32:21.703

Vim 很容易让你在两个不同的框架中打开一个文件：

`:split`水平分割

`:vsplit`垂直分割

您可以在同一个文件、不同文件或两者之间多次拆分屏幕。

`CTRL-w-w`切换帧。

`:resize +n`或`:resize -n`调整当前帧的大小。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2011-05-21T02:55:07.537

Emacs+vimpulse 很棒，但我认为它正确的工作流程是自由地将 emacs 命令与 vim 快捷方式结合使用。例如，emacs 的宏快捷键 F3 和 F4 比 vim 的 qq 和 @q 更容易。也可以通过 Alt+x 访问 emacs 命令，而不是 : 命令。尽管 vimpulse 支持一些重要的 vim 命令，但它们只是为了兼容性。

以下是我的 vimpulse 特定自定义。

.emacs

```
 ; I use C-d to quit emacs and vim
   (vimpulse-global-set-key 'vi-state (kbd "C-d") 'save-buffers-kill-terminal)
   ; use ; instead of :
   (vimpulse-global-set-key 'vi-state (kbd ";") 'viper-ex)
   ; use C-e instead of $. This works for all motion command too! (e.g. d C-e is easier to type than d$)
   (vimpulse-global-set-key 'vi-state (kbd "C-e") 'viper-goto-eol)
   (defun t_save() (interactive)(save-buffer)(viper-change-state-to-vi)) 
   (global-set-key (kbd "\C-s") 't_save) ; save using C-s instead of :w<CR> or C-x-s

    (defun command-line-diff (switch)
          (let ((file1 (pop command-line-args-left))
                (file2 (pop command-line-args-left)))
            (ediff file1 file2)))

    ;; Usage: emacs -diff file1 file2 (much better then vimdiff)
    (add-to-list 'command-switch-alist '("-diff" . command-line-diff)) 
```

如果你喜欢终端，你可以使用 emacs -nw。在这种情况下，这个剪贴板插件很有用。[http://www.lingotrek.com/2010/12/integrating-emacs-with-x11-clipboard-in.html](http://www.lingotrek.com/2010/12/integrating-emacs-with-x11-clipboard-in.html)

。毒蛇

```
 (setq viper-inhibit-startup-message 't)
    (setq viper-expert-level '3)
    (setq viper-ESC-key "\C-c") ; use C-c instead of ESC. unlike vim, C-c works perfectly with vimpulse. 
```

vim 所做的几乎所有事情都可以在 emacs+vimpulse 中轻松完成（如果不是同样的方式），但反之则绝对不行！

ps 上面的大部分建议都得到了最近 vimpulse BY DEFAULT 的支持。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T00:12:03.727

您总是可以在 shell 缓冲区中启动 vim 并调整它的大小以填充整个帧？

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-19T00:13:57.530

如果你想要 VIM 功能，安装 VIM 更有意义！

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2009-01-27T09:05:30.440

我不确定我是否回答了您的问题，因为尚不完全清楚您在问什么（为什么宏不起作用，或者哪些调整可用于在 emacs 中模拟 vim）
所以，这是您的问题吗？：

> *   一位使用古老 emacs-snapshot（从 2005 年开始）的用户提到
>     ，这种模式会导致他键盘上的所有键停止工作，除非他从宏 my-get-emulation- 中删除读取“viper--key-maps”的行此文件中的键盘映射

如果是，您可以尝试规定的解决方案。

我从[emacs wiki](http://www.emacswiki.org/emacs/vimpulse.el)获得了这些信息，这是一个已知的错误。

# pointers - MIPS 汇编指针指向指针？

> ID：98236
> 
> 赞同：5
> 
> 时间：2008-09-19T00:12:40.247
> 
> 标签：pointers, assembly, mips

我想我知道如何处理这个案子，但我只是想确保我做对了。假设您有以下 C 代码：

```
int myInt = 3;
int* myPointer = &myInt;
int** mySecondPointer = &myPointer; 
```

P 包含一个地址，该地址指向内存中具有另一个地址的位置。我想修改第二个地址。所以MIPS代码：

```
la $t0, my_new_address
lw $t1, ($a0) # address that points to the address we want to modify
sw $t0, ($t1) # load address into memory pointed to by $t1 
```

你会这样做吗？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-19T00:21:17.543

是的，据我所知，这是正确的。如果您使用相同的变量名称（例如，符号而不是硬寄存器名称）会更容易。

您为什么不简单地编译 c 代码并查看列表文件或程序集输出？当我有疑问时，我总是这样做。

# c++ - 后增量运算符行为

> ID：98242
> 
> 赞同：15
> 
> 时间：2008-09-19T00:13:26.093
> 
> 标签：c++, c, post-increment

> **可能重复：**
> [C、C++、Java 和 C# 中的前后递增运算符行为](https://stackoverflow.com/questions/6457130/pre-post-increment-operator-behavior-in-c-c-java-c-sharp)

这是一个测试用例：

```
 void foo(int i, int j)
{
   printf("%d %d", i, j);
}
...
test = 0;
foo(test++, test); 
```

我希望得到“0 1”输出，但我得到“0 0”是什么给出的？

* * *

## 回答 #1

> 赞同：47
> 
> 时间：2008-09-19T00:15:17.930

这是未指定行为的示例。该标准**没有**说明应该以什么顺序评估参数。这是编译器实现的决定。编译器可以自由地以任何顺序评估函数的参数。

在这种情况下，看起来实际上是从右到左处理参数，而不是预期的从左到右。

一般来说，在参数中做副作用是不好的编程习惯。

而不是**foo(test++, test);** 你应该写**foo(test, test+1); 测试++；**

它在语义上等同于您要完成的任务。

编辑：正如安东尼正确指出的那样，在没有中间序列点的情况下读取和修改单个变量是未定义的。所以在这种情况下，行为确实是**undefined**。所以编译器可以自由地生成它想要的任何代码。

* * *

## 回答 #2

> 赞同：29
> 
> 时间：2008-09-19T09:06:19.963

这不仅仅是*未指定*的行为，它实际上是**未定义的行为**。

是的，参数评估的顺序是*未指定*的，但是在没有中间序列点的情况下读取和修改单个变量是*未定义的，除非读取只是为了计算新值。*函数参数的评估之间没有序列点，因此`f(test,test++)`未定义的**行为**：`test`正在为一个参数读取并为另一个参数进行修改。如果您将修改移动到一个函数中，那么您就可以了：

```
int preincrement(int* p)
{
    return ++(*p);
}

int test;
printf("%d %d\n",preincrement(&test),test); 
```

这是因为在 entry 和 exit to 上有一个序列点`preincrement`，因此必须在简单读取之前或之后评估调用。现在订单只是*未指定*。

另请注意，逗号*运算符*提供了一个序列点，因此

```
int dummy;
dummy=test++,test; 
```

很好 --- 增量发生在读取之前，因此`dummy`设置为新值。

* * *

## 回答 #3

> 赞同：14
> 
> 时间：2008-09-19T00:16:10.067

原来我说的都是错的！计算副作用的时间点**是**未指定的。如果 test 是一个局部变量，Visual C++ 将在调用 foo() 之后执行递增，但如果 test 声明为静态或全局，它将在调用 foo() 之前递增并产生不同的结果，尽管最终值为测试将是正确的。

增量应该在调用 foo() 之后在单独的语句中完成。即使在 C/C++ 标准中指定了该行为，它也会令人困惑。您会认为 C++ 编译器会将其标记为潜在错误。

[这](https://www.securecoding.cert.org/confluence/display/cplusplus/EXP34-C.+Do+not+depend+on+order+of+evaluation+between+sequence+points)是对序列点和未指定行为的一个很好的描述。

<----开始错错错---->

“test++”的“++”位在调用 foo 之后被执行。所以你将 (0,0) 传递给 foo，而不是 (1,0)

下面是 Visual Studio 2002 的汇编器输出：

```
mov ecx, DWORD PTR _i$[ebp]
push    ecx
mov edx, DWORD PTR tv66[ebp]
push    edx
call    _foo
add esp, 8
mov eax, DWORD PTR _i$[ebp]
add eax, 1
mov DWORD PTR _i$[ebp], eax 
```

增量是在调用 foo() 之后完成的。虽然这种行为是设计使然，但它肯定会让不经意的读者感到困惑，应该避免。增量应该在调用 foo() 之后在单独的语句中完成

<----END OF Wrong Wrong Wrong ---->

* * *

## 回答 #4

> 赞同：6
> 
> 时间：2008-09-19T03:41:46.827

这是“未指定的行为”，但在实践中，通过指定 C 调用堆栈的方式，它几乎总是保证您将看到它为 0, 0 而绝不是 1, 0。

正如有人指出的那样，VC 的汇编器输出首先将最右边的参数压入堆栈。这就是在汇编器中实现 C 函数调用的方式。这是为了适应 C 的“无限参数列表”特性。通过以从右到左的顺序推送参数，第一个参数保证是堆栈的顶部项目。

取 printf 的签名：

```
int printf(const char *format, ...); 
```

这些椭圆表示未知数量的参数。如果参数从左到右推送，则格式将位于我们不知道大小的堆栈的底部。

知道在 C（和 C++）中参数是从左到右处理的，我们可以确定解析和解释函数调用的最简单方法。到达参数列表的末尾，开始推送，随时评估任何复杂的语句。

然而，即使这样也不能拯救你，因为大多数 C 编译器都有解析函数“Pascal 风格”的选项。这意味着函数参数以从左到右的方式压入堆栈。例如，如果 printf 是用 Pascal 选项编译的，那么输出很可能是 1, 0 （但是，由于 printf 使用椭圆，我不认为它可以编译成 Pascal 风格）。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-19T00:18:39.700

C 不保证函数调用中参数的评估顺序，因此您可能会得到结果“0 1”或“0 0”。编译器之间的顺序可以改变，同一个编译器可以根据优化参数选择不同的顺序。

写 foo(test, test + 1) 然后在下一行做 ++test 会更安全。无论如何，编译器应该尽可能优化它。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-19T00:16:39.440

函数参数的求值顺序是未定义的。在这种情况下，它似乎是从右到左进行的。

（修改序列点之间的变量基本上允许编译器做它想做的任何事情。）

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-19T14:23:06.730

嗯，既然已经编辑了 OP 以保持一致性，它与答案不同步。关于评估顺序的基本答案是正确的。但是 foo(++test, test); 的具体可能值是不同的。案子。

++test*将*在通过之前递增，因此第一个参数将始终为 1。第二个参数将为 0 或 1，具体取决于评估顺序。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-20T01:13:43.827

根据 C 标准，在单个序列点中有多个对变量的引用是未定义的行为（在这里您可以将其视为语句或函数的参数），其中多个引用中的一个包括前/后修改。所以： foo(f++,f) <--未定义 f 何时增加。同样（我一直在用户代码中看到这一点）： *p = p++ + p;

通常，编译器不会更改其对此类事物的行为（主要修订除外）。

通过打开警告并注意它们来避免它。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-10-03T14:45:03.487

重复其他人所说的话，这不是未指定的行为，而是未定义的行为。该程序可以合法地输出任何内容或不输出任何内容，将 n 保留为任何值，或向您的老板发送侮辱性电子邮件。

作为实践，编译器编写者通常只会做他们最容易编写的事情，这通常意味着程序将获取 n 一次或两次，调用函数，并在某个时间递增。这就像任何其他可以想象的行为一样，根据标准是很好的。没有理由期望编译器或版本之间或具有不同编译器选项的行为相同。没有理由为什么必须一致地编译同一程序中的两个不同但外观相似的示例，尽管我敢打赌。

简而言之，不要这样做。如果你很好奇，可以在不同的情况下进行测试，但不要假装只有一个正确甚至可以预测的结果。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-19T00:15:37.570

编译器可能不会按照您期望的顺序评估参数。

# terminology - “脚本”和“应用程序”有什么区别？

> ID：98268
> 
> 赞同：35
> 
> 时间：2008-09-19T00:16:56.617
> 
> 标签：terminology

我指的是[这个答案](https://stackoverflow.com/questions/17231/why-shouldnt-i-bet-the-future-of-the-company-on-shell-scripts#92305)中的区别：

> ...bash 不是用来编写应用程序的，它是用来编写脚本的。所以可以肯定的是，您的应用程序可能有一些管理脚本，但不要编写`critical-business-logic.sh`，因为另一种语言可能更适合这样的东西。

作为从事过多种语言的程序员，这似乎是对 C、Java 和其他编译语言的势利。我不是在寻找强化我的观点或挥手回答的问题。相反，我真的想知道所指的技术差异。

（而且我在日常工作中使用 C，所以我不仅仅是防御性的。）

* * *

## 回答 #1

> 赞同：51
> 
> 时间：2008-09-19T00:20:19.433

传统上，一个程序被编译并一个脚本被解释，但这已经不再重要了。如果您真的愿意，您可以生成大多数脚本的编译版本，而其他“编译”语言（如 Java）实际上是解释的（在字节码级别）。

更现代的定义可能是程序旨在供客户使用（可能是内部程序），因此应包括文档和支持，而脚本主要供作者使用。

网络是一个有趣的反例。我们都喜欢使用 Google 搜索引擎查找内容。用于创建它引用的“数据库”的大部分代码仅供其作者和维护者使用。这是否使它成为一个脚本？

* * *

## 回答 #2

> 赞同：44
> 
> 时间：2008-09-19T00:18:54.960

我会说应用程序倾向于以交互方式使用，脚本将在其中运行，适合批处理工作。我不认为这是一个具体的区别。

* * *

## 回答 #3

> 赞同：32
> 
> 时间：2008-09-19T00:24:31.777

通常，它是“脚本”与“程序”。

我和你一样，这种区别主要是“编译语言势利”，或者引用拉里沃尔的话说，“演员有剧本，观众有节目”。

* * *

## 回答 #4

> 赞同：8
> 
> 时间：2008-09-19T01:04:03.850

这是一个有趣的话题，我认为区分“脚本”和“应用程序”没有很好的指导方针。

让我们看一些 Wikipedia 文章来感受一下区别。

[脚本](http://en.wikipedia.org/wiki/Scripting_language "脚本语言")（维基百科 -> 脚本语言）：

> 脚本语言、脚本语言或扩展语言，是一种控制软件应用程序的编程语言。“脚本”通常被视为与“程序”不同，后者独立于任何其他应用程序执行。同时，它们与应用程序的核心代码不同，后者通常用不同的语言编写，并且通过最终用户可以访问，它们使应用程序的行为能够适应用户的需求。

[应用程序](http://en.wikipedia.org/wiki/Application_software#Terminology "应用")（维基百科 -> 应用程序软件 -> 术语）

> 在计算机科学中，应用程序是旨在帮助人们执行某种类型工作的计算机程序。因此，应用程序不同于操作系统（运行计算机）、实用程序（执行维护或通用任务）和编程语言（用于创建计算机程序）。根据设计的工作，应用程序可以操作文本、数字、图形或这些元素的组合。

阅读上述条目似乎表明区别在于脚本由另一个软件“托管”，而应用程序不是。我想这是可以争论的，例如控制 shell 行为的 shell 脚本，以及控制解释器行为以执行所需操作的 perl 脚本。（我觉得这可能有点牵强，所以我可能不完全同意。）

归根结底，我认为可以根据程序的**规模**来区分口语。与应用程序相比，脚本的规模通常较小。

此外，就目的而言，脚本通常*执行*需要处理的任务，例如，构建为某个软件生成多个发布版本的脚本。另一方面，应用程序旨在*提供*更精细且面向最终用户的功能。例如，记事本或 Firefox。

* * *

## 回答 #5

> 赞同：8
> 
> 时间：2009-01-16T00:39:04.093

John Ousterhout（TCL 的发明者）在[http://www.tcl.tk/doc/scripting.html](http://www.tcl.tk/doc/scripting.html)有一篇很好的文章，他在其中提出了系统编程语言之间的区别（用于实现构建块，强调正确性，类型安全）与脚本语言相比（用于组合构建块，强调对不断变化的环境和要求的响应能力，轻松转换进出文本表示）。如果您使用该分类系统，那么 99% 的程序员所做的工作更适合脚本语言而不是系统编程语言。

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2008-09-19T00:19:15.363

脚本往往是一系列启动、运行和终止的命令。它通常不需要/很少的人机交互。应用程序是一个“程序”......它通常需要人工交互，它往往更大。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-19T00:21:00.070

对我来说，脚本意味着对代码的逐行解释。您可以打开一个脚本并查看其程序员可读的内容。应用程序意味着一个独立的编译可执行文件。

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2008-09-19T00:31:02.603

它通常只是一个语义论点，甚至是贬低某些编程语言的一种方式。就我而言，“脚本”是一种程序，确切的定义有些模糊，并因上下文而异。

我可能会使用术语“脚本”来表示主要以线性方式执行的程序，而不是具有大量顺序逻辑或子例程的程序，就像好莱坞的“脚本”是演员执行的线性指令序列一样。我可能会用它来表示以嵌入在更大程序中的语言编写的程序，以驱动该程序。例如，在旧的 Mac OS 下使用 AppleScript 自动执行任务，或者使用嵌入式 TCL 接口驱动以某种方式暴露自身的程序。

但在所有这些情况下，脚本都是一种程序。

“脚本语言”一词已用于动态解释（有时是编译）语言，通常这些语言具有许多共同特征，例如非常高级的指令、内置散列和任意长度的列表以及其他高级数据结构等。但是这些语言能够编写非常大、复杂、模块化、设计良好的程序，所以如果你认为“脚本”不是程序，那么这个术语可能会让你感到困惑。

另请参阅[它是 Perl 程序还是 Perl 脚本？](http://search.cpan.org/~rgarcia/perl-5.10.0/pod/perlfaq1.pod#Is_it_a_Perl_program_or_a_Perl_script?)在 perlfaq1 中。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-09-19T00:22:41.440

脚本通常作为脚本引擎内较大应用程序的一部分运行，例如。JavaScript -> 浏览器 这与传统的静态类型编译语言和动态语言形成对比，其中代码旨在构成应用程序的主要部分。

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-09-19T00:49:37.287

应用程序是针对一组常见问题的脚本集合。

脚本是用于执行一项相当具体的任务的一段代码。

IMO，差异与使用的语言无关。可以使用 bash 编写复杂的应用程序，也可以使用 C++ 编写简单的脚本。

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2010-07-22T11:29:41.027

首先，我想明确一点，**脚本就是程序**。换句话说，脚本是一组指令。

**程序：**

将要编译的一组指令称为程序。

**脚本：**

一组将被解释的指令称为脚本。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2008-09-19T00:20:58.200

以 perl 为例，您可以编写 perl 脚本或 perl 应用程序。

脚本将暗示单个文件或单个命名空间。（例如 updateFile.pl）。

应用程序将由文件或名称空间/类的集合组成（例如，带有许多 .pm 模块文件的 OO 设计的 perl 应用程序）。

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2008-09-19T00:49:46.680

就个人而言，我认为分离是从实际实施退一步。

据我估计，已经计划了一个*应用程序。*它有多个目标，有多个可交付成果。在应用程序必须满足的编码之前，在设计时预留了一些任务。

然而，一个脚本只是作为套装组合在一起，几乎没有涉及任何计划。

然而，缺乏适当的计划并不会将您降级为脚本。可能，它使您的应用程序成为组织不良的脚本集合。

此外，应用程序可以包含聚合构成整体的脚本。但是一个脚本只能引用一个应用程序。

* * *

## 回答 #14

> 赞同：1
> 
> 时间：2009-01-16T01:29:57.920

一个应用程序很大，将被人们一遍又一遍地使用，并可能出售给客户。

脚本一开始很小，如果幸运的话，它会保持很小，很少出售给客户，并且可能会自动运行或被废弃。

* * *

## 回答 #15

> 赞同：1
> 
> 时间：2012-03-01T06:49:10.433

关于什么：

**脚本：**

> **脚本**是用一种语言编写的编程语句的文本文件（或文本文件的集合），它允许在其中编写的各个语句在每个语句执行**之前直接****解释为机器可执行**代码***，并且意图发生这种情况***。

 *****应用：**

> 应用**程序**是任何计算机程序，其主要功能涉及向人类 Actor 提供服务。

因此，理论上，用脚本语言编写的基于脚本的程序可以在执行脚本时更改其文本语句（当然，风险很大）。编译程序的类似情况是翻转内存中的位。

有接盘侠吗？:)

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2015-02-24T08:15:23.903

@Jeff 的回答很好。我最喜欢的解释是

> 许多（大多数？）脚本语言是解释性的，很少有编译语言被认为是脚本语言，但是编译与解释的问题只是松散地与“脚本”与“严肃”语言的问题相关联。
> 
> 这里的很多问题是“脚本”是一个非常模糊的名称——它意味着一种便于编写脚本的语言，而不是编写“成熟的程序”（或应用程序）。但是如何区分一个复杂的脚本和一个简单的应用程序呢？这是一个本质上无法回答的问题。通常，脚本是应用于某些数据集的一系列命令，可能以用户定义的顺序......但是，可以将该描述扩展到适用于 Photoshop，这显然是一个主要应用程序。脚本通常比应用程序小，做一些定义明确的事情并且使用起来“更简单”，并且通常可以分解成一系列清晰的子操作，但所有这些事情都是主观的。

[从这里](https://mail.python.org/pipermail/tutor/2003-June/022867.html)引用。

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2016-10-27T05:38:59.983

我认为代码是编译还是解释都没有关系。

真正的区别在于代码的核心逻辑：

*   如果代码产生了系统中其他程序未实现的新功能 - 它就是一个程序。它甚至可以通过脚本进行操作。

*   如果代码主要通过其他程序的操作进行操作，并且总结果主要是被操作程序的工作结果 - 它是一个脚本。从字面上看，一些程序的动作脚本。

* * *

## 回答 #18

> 赞同：-1
> 
> 时间：2008-09-19T00:25:03.337

实际上脚本（或脚本语言）和应用程序之间的区别在于脚本不需要将其编译为机器语言。您使用解释器运行脚本的源代码。应用程序将源代码编译成机器代码，以便您可以将其作为独立应用程序运行。

* * *

## 回答 #19

> 赞同：-1
> 
> 时间：2008-09-19T00:53:08.793

我会说脚本通常是一**组以纯文本编写的命令或指令**，**由托管应用程序**（浏览器、命令解释器或 shell，...）执行。

这并不意味着它在实际执行时不强大或没有以某种方式编译。但是脚本本身不能做任何事情，它只是纯文本。
本质上它只能是一个片段，需要组合起来构建一个程序或应用程序，但扩展和完全开发的脚本或脚本集在主机执行时可以视为程序或应用程序，就像一堆源文件编译后可以成为应用程序。

* * *

## 回答 #20

> 赞同：-2
> 
> 时间：2008-09-19T00:19:51.913

脚本语言没有标准库或平台（或者没有多少）。它小巧轻便，旨在嵌入到更大的应用程序中。Bash 和 Javascript 是脚本语言的绝佳示例，因为它们的功能完全依赖于其他程序。

使用此定义，脚本是为驱动更大的应用程序（套件）而设计的代码。Javascript 可能会调用 Firefox 来打开窗口或操作 DOM。Bash 脚本执行现有程序或其他脚本，并通过管道将它们连接在一起。

* * *

您还问为什么不使用脚本语言，所以：

是否有任何脚本语言的单元测试工具？对于完全缺失的“真实”应用程序来说，这似乎是一个非常重要的工具。而且很少有任何真正的脚本语言库绑定。

大多数时候，无论如何，脚本都可以替换为真正的轻量级语言，例如 Python 或 Ruby。

# reporting - 是否可以将 SSRS 报告与网络表单集成

> ID：98274
> 
> 赞同：3
> 
> 时间：2008-09-19T00:18:07.830
> 
> 标签：reporting

是否可以将 SSRS 报告集成到网络表单中。一个示例足以让我继续前进。

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-19T00:30:32.090

绝对是。

您正在寻找的是 ReportViewer 控件，它位于 Microsoft.Reporting.WebForms 程序集中。它将允许您在 Web 表单上放置一个控件，该控件将为人们提供一个用于设置报告参数和获取报告的界面。

或者，您可以自己设置所有参数并以您需要的任何格式输出报告。我们在应用程序中使用它来输出 PDF。

例如 - 这就是我们如何为我们的一份报告设置一个 reportviewer 对象并获取 PDF，然后将其发送回用户。特定的代码块是一个 Web 处理程序。

```
public void ProcessRequest(HttpContext context)
{
    string report = null;
    int managerId = -1;
    int planId = -1;
    GetParametersFromSession(context.Session, out report, out managerId, out planId);
    if (report == null || managerId == -1 || planId == -1)
    {
        return;
    }

    CultureInfo currentCulture = Thread.CurrentThread.CurrentCulture;

    List<ReportParameter> parameters = new List<ReportParameter>();
    parameters.Add(new ReportParameter("Prefix", report));
    parameters.Add(new ReportParameter("ManagerId", managerId.ToString()));
    parameters.Add(new ReportParameter("ActionPlanId", planId.ToString()));
    string language = Thread.CurrentThread.CurrentCulture.Name;
    language = String.Format("{0}_{1}", language.Substring(0, 2), language.Substring(3, 2).ToLower());
    parameters.Add(new ReportParameter("Lang", language));

    ReportViewer rv = new ReportViewer();
    rv.ProcessingMode = ProcessingMode.Remote;
    rv.ServerReport.ReportServerUrl = new Uri(ConfigurationManager.AppSettings["ReportServer"]);
    if (ConfigurationManager.AppSettings["DbYear"] == "2007")
    {
        rv.ServerReport.ReportPath = "/ActionPlanning/Plan";
    }
    else
    {
        rv.ServerReport.ReportPath = String.Format("/ActionPlanning{0}/Plan", ConfigurationManager.AppSettings["DbYear"]);
    }
    rv.ServerReport.SetParameters(parameters);

    string mimeType = null;
    string encoding = null;
    string extension = null;
    string[] streamIds = null;
    Warning[] warnings = null;
    byte[] output = rv.ServerReport.Render("pdf", null, out mimeType, out encoding, out extension, out streamIds, out warnings);

    context.Response.ContentType = mimeType;
    context.Response.BinaryWrite(output);
} 
```

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T00:24:35.133

这是一篇知识库文章，描述了如何以特定文件格式将报表输出呈现到 aspx 页面。

[http://support.microsoft.com/kb/875447/en-us](http://support.microsoft.com/kb/875447/en-us)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T00:42:44.777

请注意，当您不使用 URL 访问方法时，您将失去一些功能，例如参数选择的东西。

> 报表服务器 URL 访问支持 HTML 查看器和报表工具栏的扩展功能。SOAP API 不支持这种类型的呈现报告。如果使用 SOAP 呈现报表，则需要设计和开发自己的报表工具栏。

[http://msdn.microsoft.com/en-us/library/ms155089.aspx](http://msdn.microsoft.com/en-us/library/ms155089.aspx)

# mysql - MySQL触发器+多个数据库的复制

> ID：98275
> 
> 赞同：4
> 
> 时间：2008-09-19T00:18:20.170
> 
> 标签：mysql, triggers, replication

我在 MySQL 5.0.45 上运行了几个数据库，并试图让我的旧数据库与修改后的模式同步，这样我就可以同时运行这两个数据库。我通过向新数据库添加触发器来做到这一点，但我遇到了复制问题。我的设置如下。

服务器“主”

*   数据库“legacydb”，复制到服务器“slave”。
*   数据库“newdb”，具有更新“legacydb”且没有复制的触发器。

服务器“奴隶”

*   数据库“legacydb”

我对“newdb”的更新运行良好，并触发了我的触发器。他们在“主”服务器上更新“legacydb”。但是，这些更改不会复制到从属服务器。MySQL 文档说，为简单起见，复制在`"SELECT DATABASE();"`决定复制哪些查询时会查看当前数据库上下文（例如），而不是查看查询的产品。我的触发器是从数据库“newdb”的上下文中运行的，因此复制会忽略更新。

我尝试将更新语句移动到“legacydb”中的存储过程。当我连接到“master”并手动运行时，这工作正常（即数据复制到从属）`"USE newdb; CALL legacydb.do_update('Foobar', 1, 2, 3, 4);"`。但是，当从触发器调用此过程时，它不会复制。

到目前为止，我对如何解决此问题的想法是以下之一。

*   强制触发器设置一个新的当前数据库。这将是最简单的，但我认为这是不可能的。这是我希望通过存储过程实现的。

*   复制两个数据库，并在主从中都有触发器。这是可能的，但设置起来很痛苦。

*   无论当前数据库上下文如何，强制复制获取对“legacydb”的所有更改。

*   如果复制运行的级别太高，它甚至不会看到我的触发器运行的任何更新，在这种情况下，再多的黑客攻击也无法实现我想要的。

任何有关如何实现这一目标的帮助将不胜感激。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-19T03:34:40.463

这可能与它有关：

存储函数在执行前获取表锁，以避免由于语句执行顺序和出现在日志中的时间不匹配而导致二进制日志不一致。记录调用函数的语句，而不是函数内执行的语句。因此，更新相同基础表的存储函数不会并行执行。

相反，存储过程不获取表级锁。在存储过程中执行的所有语句都写入二进制日志。

此外，还有一个完整的触发器问题列表：http: [//dev.mysql.com/doc/refman/5.0/en/routine-restrictions.html](http://dev.mysql.com/doc/refman/5.0/en/routine-restrictions.html)

# macos - Mac OS X 上的焦点跟随鼠标（加上自动抬起）

> ID：98310
> 
> 赞同：211
> 
> 时间：2008-09-19T00:24:30.890
> 
> 标签：macos, focus, mouse

（我不想听到我想要那个有多疯狂！:)

焦点跟随鼠标也称为点对焦点、指针焦点和（在某些实现中）马虎焦点。[添加其他术语，使其更易于搜索！] X-mouse

* * *

## 回答 #1

> 赞同：85
> 
> 时间：2008-09-19T00:27:28.683

您可以通过在命令行发出以下命令来为 Terminal.app 执行此操作：

```
defaults write com.apple.Terminal FocusFollowsMouse -bool true 
```

对于 X11 应用程序，您可以这样做：

```
defaults write com.apple.x11 wm_ffm -bool true 
```

在 Snow Leopard 中，改用这个：

```
defaults write org.x.X11 wm_ffm -bool true 
```

显然有一个名为 CodeTek Virtual Desktop 的程序可以在系统范围内模拟它，但它的成本是 $$（而且他们从来没有为 OSX Leopard 提供过版本）。

* * *

## 回答 #2

> 赞同：59
> 
> 时间：2008-09-19T00:26:59.480

[Steve Yegge 不久前](http://steve-yegge.blogspot.com/2008/04/settling-osx-focus-follows-mouse-debate.html)写了一篇关于此的文章，他尝试并未能写出合适的扩展。从那以后，我试图找到适用于 OS X 的焦点跟随鼠标应用程序，但也失败了。

* * *

## 回答 #3

> 赞同：58
> 
> 时间：2016-03-05T21:34:24.147

尽管这远不是一个完整的解决方案，但 OSX (10.11) 中内置的两个方便的操作是：

**⌃⌥-click** (control-option-click) - 在不提升窗口的情况下切换焦点

**⌘-click** (command-click) - 在窗口中单击而不切换焦点

不确定何时引入这些快捷方式，因为我无法在任何地方找到它们。

* * *

## 回答 #4

> 赞同：50
> 
> 时间：2010-10-15T13:09:39.663

焦点跟随鼠标不是特别适合 OS X 的输入法，因为它的菜单栏被设计为位于屏幕顶部。当您将鼠标移出应用程序窗口以进入菜单时，如果它在途中穿过任何其他应用程序的窗口，则菜单会更改。

所以是的，在回复 dreeves 评论时，它对终端（或桌面上的任何其他单个应用程序）非常有效，因为它会影响的唯一其他窗口是终端窗口，所以当你切换窗口时菜单永远不会改变。它适用于 X11，因为 X11 应用程序的菜单栏通常嵌入在窗口中，因此您不必离开窗口即可访问它们。

当然，您可以通过在焦点更改和/或菜单切换之前引入人为延迟来解决菜单更改问题，但它永远不会像在其他桌面上那样工作。

* * *

## 回答 #5

> 赞同：36
> 
> 时间：2020-10-08T21:33:00.740

我已经定期回到这个问题大约 10 年了，我终于找到了一个简单的解决方案：AutoRaise [https://github.com/sbmpost/AutoRaise](https://github.com/sbmpost/AutoRaise)

默认情况下，它启用焦点跟随鼠标和自动提升。您可以使用配置选项延迟自动升起。

它还具有他们所谓的“扭曲”功能，当您使用 Command-Tab 键进入窗口时，该功能可将鼠标指针居中。在我尝试之前我从不知道我需要这个，但是一旦我尝试过，我就不能没有它！

* * *

## 回答 #6

> 赞同：23
> 
> 时间：2016-01-28T22:34:59.547

所以我决定再次改进我在 MouseFocus.app 上所做的工作，但仍然存在一些缺陷。这些现在都修好了。我将整个内容重命名为“AutoRaise”以更好地反映此工具的作用：当您将窗口悬停时，它将被提升到前面（您选择的延迟）并获得焦点。该工具可以在[这里](https://github.com/sbmpost/AutoRaise/raw/master/AutoRaise)下载。要使用它，请将其复制到您的 /Applications/ 文件夹，确保它是可执行的（chmod 700 AutoRaise）。然后在 Finder 中双击它。要快速打开/关闭它，您可以使用下面的小程序并将其粘贴到自动化*服务*工作流程中。然后通过 System Preferences|Keyboard|Shortcuts 将创建的服务绑定到键盘快捷键。

*更新 (29-03-2017)：AutoRaise 二进制文件已更新。如果在命令行上没有指定延迟，它现在也会在~~相同的~~主文件夹。这在使用下面的 applescript 时特别有用，因为“启动应用程序”不支持命令行参数。延迟应以单位指定~~50毫秒~~20 毫秒。例如，要指定 20 毫秒的延迟，在终端中运行一次此命令：'echo 1 > ~/AutoRaise.delay'*

```
on run {input, parameters}
    tell application "Finder"
        if exists of application process "AutoRaise" then
            quit application "/Applications/AutoRaise"
            display notification "AutoRaise Stopped"
        else
            launch application "/Applications/AutoRaise"
            display notification "AutoRaise Started"
        end if
    end tell
    return input
end run 
```

*更新（18-04-2019）：来源[https://github.com/sbmpost/AutoRaise](https://github.com/sbmpost/AutoRaise)*

*更新 (05-06-2020)：默认延迟已设置为 2 并且轮询时间减少。这些设置可防止在快速移动鼠标（例如到达顶部菜单）时意外弹出窗口。还添加了变形鼠标功能并修复了内存泄漏。有关更多详细信息，请查看[自述文件](https://github.com/sbmpost/AutoRaise)*

* * *

## 回答 #7

> 赞同：21
> 
> 时间：2013-03-05T15:37:04.860

菜单问题是传统焦点跟随鼠标不起作用的唯一原因。

这是另一种选择：在按下键盘上的键之前不要改变焦点。这将涵盖 95% 的焦点跟随鼠标用例，并且会让这个老脾气的 X 用户非常高兴。我不知道我会在 Chrome 中滚动浏览网页多少次，然后按 Command-T 打开一个新选项卡，然后在终端中找到打开的选项卡。如果我的大脑在使用 Mac 的 8 个月内没有意识到这一点，那么它永远不会。

* * *

## 回答 #8

> 赞同：17
> 
> 时间：2015-03-20T04:10:59.427

[Amethyst](https://github.com/ianyh/Amethyst)支持此功能。它可以很容易地安装`brew install amethyst`。

这是我使用的配置文件。它会关闭除焦点跟随鼠标之外的所有功能。将其保存到`~/.amethyst`.

```
{
    "LAYOUTS": "----------------------",
    "layouts": [
    ],

    "MODIFIERS": "----------------------",
    "Valid modifiers are": [
        "option",
        "shift",
        "control",
        "command"
    ],

    "mod1": [
    ],
    "mod2": [
    ],

    "COMMANDS": "----------------------",
    "Commands are": {
        "cycle-layout": "Cycle layout to the next layout",
        "cycle-layout-backward": "Cycle layout to the previous layout",
        "focus-screen-1": "Focus the main window on the first screen",
        "focus-screen-2": "Focus the main window on the second screen",
        "focus-screen-3": "Focus the main window on the third screen",
        "focus-screen-2": "Focus the main window on the second screen",
        "focus-screen-3": "Focus the main window on the third screen",
        "focus-screen-4": "Focus the main window on the fourth screen",
        "throw-screen-1": "Throw the focused window to the first screen",
        "throw-screen-2": "Throw the focused window to the second screen",
        "throw-screen-3": "Throw the focused window to the third screen",
        "throw-screen-4": "Throw the focused window to the fourth screen",
        "shrink-main": "Shrink the main pane of the current layout",
        "expand-main": "Expand the main pane of the current layout",
        "increase-main": "Increase the number of windows in the main pane",
        "decrease-main": "Decrease the number of windows in the main pane",
        "focus-ccw": "Move window focus counter-clockwise on the current screen",
        "focus-cw": "Move window focus clockwise on the current screen",
        "swap-ccw": "Swap focused window with the next window going counter-clockwi$
        "swap-cw": "Swap focused window with the next window going clockwise",
        "swap-main": "Swap focused window with the main window of its screen",
        "throw-space-1": "Throw the focused window to the first space",
        "throw-space-2": "Throw the focused window to the second space",
        "throw-space-3": "Throw the focused window to the third space",
        "throw-space-4": "Throw the focused window to the fourth space",
        "throw-space-5": "Throw the focused window to the fifth space",
        "throw-space-6": "Throw the focused window to the sixth space",
        "throw-space-7": "Throw the focused window to the seventh space",
        "throw-space-8": "Throw the focused window to the eighth space",
        "throw-space-9": "Throw the focused window to the ninth space",
        "throw-space-8": "Throw the focused window to the eighth space",
        "throw-space-9": "Throw the focused window to the ninth space",
        "toggle-float": "Toggle the focused window between being floating and tiled"
    },

    "screens": "3",

    "cycle-layout": {
        "mod": "mod1",
    },
    "cycle-layout-backward": {
        "mod": "mod2",
    },
    "select-tall-layout": {
        "mod": "mod1"
    },
    "select-wide-layout": {
        "mod": "mod1"
    },
    "select-fullscreen-layout": {
        "mod": "mod1"
    },
    "select-column-layout": {
        "mod": "mod1"
    },
        "mod": "mod1"
    },
    "focus-screen-1": {
        "mod": "mod1"
    },
    "focus-screen-2": {
        "mod": "mod1"
    },
    "focus-screen-3": {
        "mod": "mod1"
    },
    "focus-screen-4": {
        "mod": "mod1"
    },
    "throw-screen-1": {
        "mod": "mod2"
    },
    "throw-screen-2": {
        "mod": "mod2"
    },
    "throw-screen-3": {
        "mod": "mod2"
    },
    "throw-screen-4": {
        "mod": "mod2"
    "throw-screen-4": {
        "mod": "mod2"
    },
    "shrink-main": {
        "mod": "mod1"
    },
    "expand-main": {
        "mod": "mod1"
    },
    "increase-main": {
        "mod": "mod1"
    },
    "decrease-main": {
        "mod": "mod1"
    },
    "focus-ccw": {
        "mod": "mod1"
    },
    "focus-cw": {
        "mod": "mod1"
    },
    "swap-screen-ccw": {
        "mod": "mod2"
    },
    "swap-screen-cw": {
    },
    "swap-screen-cw": {
        "mod": "mod2"
    },
    "swap-ccw": {
        "mod": "mod2"
    },
    "swap-cw": {
        "mod": "mod2"
    },
    "swap-main": {
        "mod": "mod1"
    },
    "throw-space-1": {
        "mod": "mod2"
    },
    "throw-space-2": {
        "mod": "mod2"
    },
    "throw-space-3": {
        "mod": "mod2"
    },
    "throw-space-4": {
        "mod": "mod2"
    },

        "mod": "mod2"
    },
    "throw-space-5": {
        "mod": "mod2"
    },
    "throw-space-6": {
        "mod": "mod2"
    },
    "throw-space-7": {
        "mod": "mod2"
    },
    "throw-space-8": {
        "mod": "mod2"
    },
    "throw-space-9": {
        "mod": "mod2"
    },
    "toggle-float": {
        "mod": "mod1"
    },
    "toggle-tiling": {
        "mod": "mod2"
    },
    "display-current-layout": {
        "mod": "mod1"
    "display-current-layout": {
        "mod": "mod1"
    },

    "MISC": "----------------------",
    "floating": [],
    "float-small-windows": false,
    "mouse-follows-focus": false,
    "focus-follows-mouse": true,
    "enables-layout-hud": false,
    "enables-layout-hud-on-space-change": false
} 
```

* * *

## 回答 #9

> 赞同：11
> 
> 时间：2019-05-03T13:28:59.693

焦点跟随鼠标现在可以在 macOS 中使用，在我的例子中是 Mojave，使用[chunkwm](https://koekeishiya.github.io/chunkwm/docs/source.html)。有关“无自动提升”解决方案，请参阅[此](https://stackoverflow.com/a/55936326/4637974)Stack Overflow 响应。离开会激活自动加注

```
chunkc set ffm_disable_autoraise         0 
```

在`~/.chunkwmrc`.

**编辑**2019-09-12：

chunkwm 已被[yabai](https://github.com/koekeishiya/yabai)取代。安装：

```
brew tap koekeishiya/formulae
brew install yabai
mkdir -p ~/.config/yabai/
printf 'yabai -m config focus_follows_mouse autoraise' >> ~/.config/yabai/yabairc
brew services start yabai 
```

* * *

## 回答 #10

> 赞同：8
> 
> 时间：2008-09-19T00:33:19.777

Codetek 有一个产品可以做到这一点，但他们从未发布过 Leopard 或更高版本的版本。

MondoMouse 可以做焦点跟随鼠标，但不能自动提升。不过，即使是焦点跟随鼠标也坏了。例如，它不能很好地与 command-tab 配合使用（如果您使用 command-tab 到一个新应用程序并且不触摸鼠标，那么它不应该*将*焦点切换回鼠标指针碰巧所在的位置——我很确定我见过的 Linux 中的每个实现都正确，但 MondoMouse 没有）。

您可以仅为终端窗口启用焦点跟随鼠标（无自动提升）（只需在终端中执行以下命令）：

```
defaults write com.apple.Terminal FocusFollowsMouse -string YES 
```

同样对于 X11 窗口：

```
defaults write org.x.X11 wm_ffm -bool true 
```

（对于 10.5.5 之前的 mac 版本，这是：

```
defaults write com.apple.x11 wm_ffm true 
```

)

我不知道任何其他支持它的应用程序。

* * *

## 回答 #11

> 赞同：8
> 
> 时间：2008-09-19T03:07:04.260

我目前使用 MondoMouse，即使有它的怪癖，没有它我也无法使用我的 mac。他们有免费试用，我会推荐给大家。

[MondoMouse](http://www.atomicbird.com/mondomouse)

* * *

## 回答 #12

> 赞同：6
> 
> 时间：2017-11-08T03:20:59.293

chunkwm 也支持这个（默认情况下我相信）： [chunkwm](https://github.com/koekeishiya/chunkwm)

* * *

## 回答 #13

> 赞同：5
> 
> 时间：2009-07-16T20:14:42.190

有趣的是，Leopard 默认启用了一种焦点跟随鼠标（无自动提升）。滚轮在不聚焦的窗口中工作。

* * *

## 回答 #14

> 赞同：4
> 
> 时间：2011-06-22T17:02:42.873

不幸的是，CodeTek Virtual Desktop Pro 不再开发，几年前该公司似乎已经倒闭了。

历史参考： http: [//www.codetek.com/ctvd/](http://www.codetek.com/ctvd/) （不适用于新的 OS X 版本！）

历史回顾：[http ://www.osnews.com/story/6144](http://www.osnews.com/story/6144)

使用 CodeTek Virtual Desktop Pro，您可以获得 Focus-Follow-Mouse 并禁用 Auto-Raise，它还有一个用于虚拟桌面的 Pager——类似于 Fvwm 在 Linux 上的工作方式。它真的很完美——我买过的最好的软件。它与所有应用程序一致地工作，切换应用程序、将窗口移动到不同的工作区以及导航工作区比在最新的 OS X 版本 [10.6、10.7、10.8] 中实现的方式要容易得多

不幸的是，Mac OS X 10.5 VirtualDesktop Pro 停止工作，看起来苹果积极确保 CodeTek 不会继续工作。

令人遗憾的是，Apple 粉碎了 CodeTek 及其产品 - Virtual Desktop Pro 确实优于目前 OS X 工作区的实现方式。它基本上像 LINUX 上的 Fvwm 一样工作 - 超快速导航 - 没有不必要的点击或鼠标手势......

看到 Apple 规定了窗口管理器 (Finder) 的行为并且似乎不再允许第三方替换 Finder 让我感到难过。

* * *

## 回答 #15

> 赞同：3
> 
> 时间：2011-12-02T16:24:38.870

还有点击时引发的相关问题。在 OSX 下，每次单击一个窗口时，它也会被提升，因此可能会隐藏其他窗口。当从两个窗口中复制/粘贴时，其中一个窗口覆盖了大部分屏幕，这是有问题的。我喜欢保留一个全局（在所有工作区中都处于活动状态）记事本，我可以从中复制/粘贴内容（可以是命令、文本、待办事项等任何内容）。这在 OSX 下是具有挑战性的。最好有一个选项来禁用点击时加注。

* * *

## 回答 #16

> 赞同：3
> 
> 时间：2013-07-31T04:40:46.213

[试试](http://pilotmoon.com/dwellclick/)DwellClick 。虽然它不是出于预期目的，但自动点击行为具有类似于自动抬起或焦点跟随鼠标的副作用。

就个人而言，我只在光标移动停止后使用左键单击功能，但也有使用修饰符单击和窗口拖动辅助，非常方便。

浏览网页时也有点令人沮丧，因为您要么想要禁用应用程序，要么更加注意光标所在的位置（例如，不在您不打算激活的任何链接或按钮上）。

* * *

## 回答 #17

> 赞同：3
> 
> 时间：2019-11-21T11:32:41.307

在 mac 中使用**Dwell功能。**转到辅助功能 -> 键盘 -> 辅助功能键盘（我在 Catalina 上）

[点击这里获取更多信息](http://xahlee.info/kbd/macos_hover_switch_window.html)

* * *

[![在此处输入图像描述](https://i.stack.imgur.com/JwGyf.png)](https://i.stack.imgur.com/JwGyf.png)

[![在此处输入图像描述](https://i.stack.imgur.com/9dsxX.jpg)](https://i.stack.imgur.com/9dsxX.jpg)

* * *

## 回答 #18

> 赞同：1
> 
> 时间：2011-08-22T19:52:00.433

尝试使用这些选项后，我的 Command-Tab 开始出现异常。这是它如何再次关注应用程序的解决方案：

似乎以前的功能，即终端的窗口焦点随着鼠标移动而改变的能力，在 10.6 中被破坏，导致 Command-Tab 不能正确转移窗口焦点。要解决此问题，只需将以下命令粘贴到终端中：

默认写入 com.apple.Terminal FocusFollowsMo​​use -string NO

然后重启终端。

* * *

## 回答 #19

> 赞同：1
> 
> 时间：2016-10-14T17:58:48.760

解决方案：因为我习惯于在 Windows 中自动加注，所以我在 Mac 上非常想念它。我为 Mac 找到的解决方案是 Zooom（是的，三个 o's）。它具有自动升起功能。您甚至可以设置毫秒在自动提升之前等待。没有它就活不下去。Autoraise 是首选项中的一个选项，您可以在屏幕截图中看到[https://www.macupdate.com/app/mac/23203/zooom](https://www.macupdate.com/app/mac/23203/zooom) [http://coderage-software.com/zooom/index.html](http://coderage-software.com/zooom/index.html)

* * *

## 回答 #20

> 赞同：1
> 
> 时间：2021-06-15T14:37:42.340

一些对双屏“专注于悬停”部分可能有用的建议。当另一个屏幕已经具有输入框焦点时，它不能解决某些问题，例如在输入框中输入内容。但它可能会对“专注于悬停”的各个方面来这里的人有所帮助。

如果没有这个修复，我总是必须在监视器中“聚焦点击”，然后才能根据上下文点击任何内容。

您可以通过以下方式获得“专注于悬停”的某些方面：

1.  进入“系统偏好设置”
2.  选择选项“任务控制”
3.  在那里你应该看到'显示器有单独的空间'，取消它

然后至少选择 Monitor1，现在您可以立即单击 Monitor2 中的某些内容，例如电子邮件或选项卡，而无需第一次“焦点单击”。

与往常一样，这可能不适用于每个人，具体取决于操作系统版本和其他可能。

* * *

## 回答 #21

> 赞同：0
> 
> 时间：2018-12-03T11:05:45.173

在 MacOS Mojave 上测试 MondoMouse ( [https://www.atomicbird.com/about/mac-apps )。](https://www.atomicbird.com/about/mac-apps)似乎对我来说工作得很好！

要安装 prefpane，将会有一个通知“*启用辅助设备访问*”，它不再驻留在**系统偏好设置 > 辅助功能**中。您必须在**安全和隐私 > 辅助功能 > 隐私中进行设置**

在您打开的每个应用程序中都会有几个关于允许 MondoMouse 的警告，但一旦设置它就可以正常工作！终于解脱了 ：）

* * *

## 回答 #22

> 赞同：0
> 
> 时间：2021-01-21T08:12:59.230

如果有人感兴趣，这里有一个用于多显示器自动对焦的玩具级实现：[https ://bitbucket.org/sivann/mac-screenfocus/src/master/](https://bitbucket.org/sivann/mac-screenfocus/src/master/)

它主要工作，但不处理不同监视器中同一应用程序的多个窗口。如果您将鼠标移动到另一台显示器，则将焦点放在最后一个拥有它的应用程序上。

* * *

## 回答 #23

> 赞同：-18
> 
> 时间：2008-09-19T06:59:59.910

你真的不能很好地做到这一点，因为 Mac 界面在设计时根本没有考虑到焦点跟随鼠标（有或没有自动提升）。我怀疑这种情况很快就会改变，除非它改变，否则每个试图实现焦点跟随鼠标的人都会遇到同样的障碍并最终得到一个不令人满意的结果（对于那些想要这样的人来说）。

所以，是的，你*为*想要这个而疯狂——但出于技术原因。习惯于按照自己的方式使用 Mac，我敢肯定，当你找到新的高效工作方式时，你强迫它表现得像你过去使用的任何 X11 东西一样的愿望会有所减弱。

# java - 在 Spring Bean 上下文中有许多未使用的 bean 会浪费大量资源吗？

> ID：98320
> 
> 赞同：8
> 
> 时间：2008-09-19T00:25:25.987
> 
> 标签：java, spring

我的模型层被少数不同的项目使用，我想为模型使用单个 XML Spring 配置文件，无论哪个项目正在使用它。

我的问题是：由于并非所有项目都使用了所有 bean，如果没有实例化，我是否会浪费大量资源？我不太确定 Spring 加载它们有多懒惰，因为直到现在它才成为问题。

有任何想法吗？

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-09-19T01:08:13.717

取自[Spring 参考手册](http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-lazy-init)：

> ApplicationContext 实现的默认行为是在启动时急切地预实例化所有单例 bean。预实例化意味着 ApplicationContext 将急切地创建和配置其所有单例 bean，作为其初始化过程的一部分。通常这是一件好事，因为这意味着配置或周围环境中的任何错误都会立即被发现（而不是可能的数小时甚至数天）。
> 
> 但是，有时这种行为不是我们想要的。如果您不希望在使用 ApplicationContext 时预先实例化单例 bean，则可以通过将 bean 定义标记为延迟初始化来选择性地控制它。延迟初始化的 bean 向 IoC 容器指示是否应在启动时或首次请求时创建 bean 实例。
> 
> 通过 XML 配置 bean 时，这种延迟加载由 [bean 元素] 上的 'lazy-init' 属性控制；例如：

```
<bean id="lazy" class="com.foo.ExpensiveToCreateBean" lazy-init="true"/> 
```

但是，除非您的 bean 正在使用文件锁或数据库连接之类的资源，否则如果您更容易为多个（但不同的）配置文件进行这种配置，我不会太担心简单的内存开销。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-09-29T19:18:22.480

In addition to the other comments: it's also possible to specify a whole configuration file to be lazily initialized, by using the 'default-lazy-init' attribute on the `<beans/>` element; for example:

```
<beans default-lazy-init="true">
    <!-- no beans will be pre-instantiated... -->
</beans> 
```

This is much easier than adding the `lazy-init` attribute to every bean, if you have a lot of them.

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T00:51:39.933

默认情况下，Spring bean 是单例的，并且在创建应用程序上下文时（在启动时）被实例化。因此，假设您没有覆盖默认行为，那么将创建每个 bean 的单个实例。

* * *

## 回答 #4

> 赞同：-1
> 
> 时间：2008-09-19T00:58:31.417

取决于对象。

但是，未使用的代码是“粗糙的”，会增加维护成本。

最好删除 refs 和 classes。如果以后需要，您始终可以从版本控制中恢复。

# c - 您遇到的 C 的常见未定义/未指定行为是什么？

> ID：98340
> 
> 赞同：72
> 
> 时间：2008-09-19T00:30:10.313
> 
> 标签：c, language-lawyer, undefined-behavior, unspecified-behavior

C 语言中未指定行为的一个示例是函数参数的求值顺序。它可能是从左到右或从右到左，你只是不知道。这将影响评估方式`foo(c++, c)`或`foo(++c, c)`评估方式。

还有哪些其他未指明的行为会让不知情的程序员感到惊讶？

* * *

## 回答 #1

> 赞同：85
> 
> 时间：2008-09-19T00:33:12.910

语言律师问题。嗯。

我的个人top3：

1.  违反严格的别名规则

2.  违反严格的别名规则

3.  违反严格的别名规则

    :-)

**编辑**这里有一个小例子，它做错了两次：

（假设 32 位整数和小端）

```
float funky_float_abs (float a)
{
  unsigned int temp = *(unsigned int *)&a;
  temp &= 0x7fffffff;
  return *(float *)&temp;
} 
```

该代码试图通过直接在浮点表示中对符号位进行位旋转来获得浮点的绝对值。

但是，通过从一种类型转换为另一种类型来创建指向对象的指针的结果是无效的 C。编译器可能会假设指向不同类型的指针不指向同一块内存。这适用于除 void* 和 char* 之外的所有类型的指针（符号无关紧要）。

在上述情况下，我这样做了两次。一次获取浮点 a 的 int-alias，一次将值转换回浮点数。

有三种有效的方法可以做到这一点。

在强制转换期间使用 char 或 void 指针。这些总是别名为任何东西，所以它们是安全的。

```
float funky_float_abs (float a)
{
  float temp_float = a;
  // valid, because it's a char pointer. These are special.
  unsigned char * temp = (unsigned char *)&temp_float;
  temp[3] &= 0x7f;
  return temp_float;
} 
```

使用内存复制。Memcpy 采用 void 指针，因此它也会强制使用别名。

```
float funky_float_abs (float a)
{
  int i;
  float result;
  memcpy (&i, &a, sizeof (int));
  i &= 0x7fffffff;
  memcpy (&result, &i, sizeof (int));
  return result;
} 
```

第三种有效方式：使用联合。自 C99 以来，这显然**不是未定义的：**

```
float funky_float_abs (float a)
{
  union 
  {
     unsigned int i;
     float f;
  } cast_helper;

  cast_helper.f = a;
  cast_helper.i &= 0x7fffffff;
  return cast_helper.f;
} 
```

* * *

## 回答 #2

> 赞同：32
> 
> 时间：2008-09-19T01:18:39.307

我个人最喜欢的未定义行为是，如果非空源文件未以换行符结尾，则行为未定义。

我怀疑这是真的，尽管我见过的任何编译器都没有根据它是否以换行符终止来区别对待源文件，而不是发出警告。所以这并不是真正让不知情的程序员感到惊讶的事情，除了他们可能会对警告感到惊讶。

因此，对于真正的可移植性问题（主要是依赖于实现而不是未指定或未定义，但我认为这符合问题的精神）：

*   char 不一定是（未）签名的。
*   int 可以是 16 位以上的任何大小。
*   浮点数不一定是 IEEE 格式的或符合标准的。
*   整数类型不一定是二进制补码，整数算术溢出会导致未定义的行为（现代硬件不会崩溃，但某些编译器优化会导致与环绕不同的行为，即使这是硬件所做的。例如，`if (x+1 < x)`可能会优化为始终为假何时`x`签署类型：参见`-fstrict-overflow`GCC 中的选项）。
*   “/”、“.” #include 中的“..”和“..”没有明确的含义，并且可以被不同的编译器区别对待（这实际上是不同的，如果出错，它会毁了你的一天）。

即使在您开发的平台上，真正严重的问题也会令人惊讶，因为行为只是部分未定义/未指定：

*   POSIX 线程和 ANSI 内存模型。对内存的并发访问并没有新手想象的那么好。volatile 不符合新手的想法。内存访问的顺序并不像新手想象的那么好。访问*可以*在某些方向上跨内存屏障移动。不需要内存缓存一致性。

*   分析代码并不像您想象的那么容易。如果您的测试循环无效，编译器可以删除部分或全部。inline 没有定义的效果。

而且，正如我认为 Nils 顺便提到的：

*   违反严格的别名规则。

* * *

## 回答 #3

> 赞同：21
> 
> 时间：2008-09-19T00:33:22.240

我最喜欢的是这个：

```
// what does this do?
x = x++; 
```

要回答一些评论，根据标准，这是未定义的行为。看到这一点，编译器可以做任何事情，包括格式化你的硬盘。例如，请参见[此处的评论](http://www.digitalmars.com/pnews/read.php?server=news.digitalmars.com&group=digitalmars.D&artnum=47343)。关键不是您可以看到某些行为可能存在合理的期望。由于 C++ 标准和序列点的定义方式，这行代码实际上是未定义的行为。

例如，如果我们`x = 1`在上面的行之前有，那么之后的有效结果是什么？有人评论说应该

> x 增加 1

所以我们应该看到 x == 2 之后。然而这实际上不是真的，你会发现一些编译器之后有 x == 1，甚至可能有 x == 3。你必须仔细查看生成的程序集，看看为什么会这样，但差异是由于到根本问题。本质上，我认为这是因为允许编译器以它喜欢的任何顺序评估两个赋值语句，因此它可以执行第`x++`一个或第`x =`一个。

* * *

## 回答 #4

> 赞同：21
> 
> 时间：2008-09-19T00:44:25.240

用指向某物的指针来划分某物。只是由于某种原因无法编译... :-)

```
result = x/*y; 
```

* * *

## 回答 #5

> 赞同：11
> 
> 时间：2008-09-19T07:58:06.523

我遇到的另一个问题（已定义，但绝对出乎意料）。

char是邪恶的。

*   有符号或无符号取决于编译器的感觉
*   **不**强制为 8 位

* * *

## 回答 #6

> 赞同：9
> 
> 时间：2013-08-15T19:31:17.837

我无法计算我已更正 printf 格式说明符以匹配其参数的次数。**任何不匹配都是未定义的行为**。

*   不，您不能将`int`（或`long`）传递给`%x`-`unsigned int`是必需的
*   不，您不得传递`unsigned int`to `%d`- an`int`是必需的
*   不，您不能将 a 传递`size_t`给`%u`或`%d`- 使用`%zu`
*   不，您不能使用`%d`or打印指针`%x`- 使用`%p`并强制转换为`void *`

* * *

## 回答 #7

> 赞同：8
> 
> 时间：2008-09-19T02:40:37.893

如果函数原型不可用，编译器不必告诉您正在调用具有错误参数数量/错误参数类型的函数。

* * *

## 回答 #8

> 赞同：8
> 
> 时间：2013-08-15T20:19:06.437

我见过很多相对缺乏经验的程序员被多字符常量所困扰。

这：

```
"x" 
```

是一个字符串文字（在大多数情况下它是类型`char[2]`并衰减为）。`char*`

这：

```
'x' 
```

是一个普通的字符常量（由于历史原因，它的类型是`int`）。

这：

```
'xy' 
```

也是一个完全合法的字符常量，但它的值（仍然是 type `int`）是实现定义的。这是一个几乎无用的语言功能，主要用于引起混淆。

* * *

## 回答 #9

> 赞同：5
> 
> 时间：2012-02-01T22:18:51.200

不久前，clang 开发人员在每个 C 程序员都应该阅读的帖子中发布了一些[很好的示例。](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html)一些之前没有提到的有趣的：

*   有符号整数溢出 - 不，将有符号变量包装超过其最大值是不行的。
*   取消引用 NULL 指针 - 是的，这是未定义的，可能会被忽略，请参阅链接的第 2 部分。

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-09-19T02:44:23.097

EE 刚刚发现 a>>-2 有点令人担忧。

我点点头，告诉他们这不自然。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-09-19T00:32:23.570

请务必在使用变量之前始终初始化它们！当我刚开始使用 C 语言时，这让我很头疼。

# java - 最快的高斯模糊实现

> ID：98359
> 
> 赞同：39
> 
> 时间：2008-09-19T00:33:36.857
> 
> 标签：java, image-processing, filtering, gaussian

你如何实现最快的[高斯模糊](http://en.wikipedia.org/wiki/Gaussian_blur)算法？

我打算用 Java 实现它，所以排除了[GPU解决方案。](http://en.wikipedia.org/wiki/Graphics_processing_unit)我的应用程序[planetGenesis](http://planetGenesis.sourceforge.net)是跨平台的，所以我不想要[JNI](http://en.wikipedia.org/wiki/Java_Native_Interface)。

* * *

## 回答 #1

> 赞同：33
> 
> 时间：2008-09-19T14:31:31.763

您应该使用高斯核是可分离的这一事实，即您可以将 2D 卷积表示为两个 1D 卷积的组合。

如果滤波器很大，使用空间域中的卷积等价于频域（傅立叶）域中的乘法这一事实也可能有意义。这意味着您可以对图像和滤波器进行傅里叶变换，将（复数）结果相乘，然后进行傅里叶逆变换。FFT（快速傅里叶变换）的复杂度为 O(n log n)，而卷积的复杂度为 O(n^2)。此外，如果您需要使用相同的过滤器模糊许多图像，您只需对过滤器进行一次 FFT。

如果您决定使用 FFT，[FFTW 库](http://www.fftw.org)是一个不错的选择。

* * *

## 回答 #2

> 赞同：28
> 
> 时间：2008-09-19T01:58:05.297

数学运动员可能知道这一点，但对其他人来说......

由于高斯具有良好的数学特性，您可以通过首先对图像的每一行运行 1D 高斯模糊，然后对每列运行 1D 模糊来快速模糊 2D 图像。

* * *

## 回答 #3

> 赞同：23
> 
> 时间：2013-08-22T08:40:47.530

**终极解决方案**

如此多的信息和实现让我非常困惑，我不知道我应该相信哪一个。想通之后，我决定写自己的文章。我希望它能为您节省数小时的时间。

[最快的高斯模糊（线性时间）](http://blog.ivank.net/fastest-gaussian-blur.html)

它包含源代码，（我希望）它简短、干净且易于重写为任何其他语言。请投票给它，以便其他人可以看到它。

* * *

## 回答 #4

> 赞同：17
> 
> 时间：2008-09-19T21:18:09.633

1.  我找到了*[Quasimondo：孵化器：处理：快速高斯模糊](http://incubator.quasimondo.com/processing/gaussian_blur_1.php)*。此方法包含许多近似值，例如使用整数和查找表而不是浮点数和浮点除法。我不知道现代 Java 代码有多少加速。

2.  *[Fast Shadows on Rectangles](http://www.stereopsis.com/shadowrect/)*[有一个使用B-splines](http://en.wikipedia.org/wiki/B-spline)的近似算法。

3.  *[C# 中的快速高斯模糊算法](http://www.cnblogs.com/Dah/archive/2007/03/30/694527.html)*声称有一些很酷的优化。

4.  此外，David Everly 的*[Fast Gaussian Blur (PDF) 提供了一种用于高斯模糊处理的快速方法。](http://www.geometrictools.com/Documentation/FastGaussianBlur.pdf)*

我会尝试各种方法，对它们进行基准测试并在此处发布结果。

出于我的目的，我从 Internet复制并实现了基本（独立处理 XY 轴）方法和 David Everly 的*快速高斯模糊方法。*它们的参数不同，所以我无法直接比较它们。然而，对于大的模糊半径，后者经历的迭代次数要少得多。此外，后者是一种近似算法。

* * *

## 回答 #5

> 赞同：8
> 
> 时间：2008-09-19T00:38:21.043

您可能希望框模糊，这要快得多。请参阅[此链接](http://www.gamasutra.com/features/20010209/evans_01.htm)以获取出色的教程和一些[复制和粘贴 C 代码](http://www.gamasutra.com/features/20010209/Listing2.cpp)。

* * *

## 回答 #6

> 赞同：7
> 
> 时间：2009-02-11T22:22:40.290

For larger blur radiuses, try applying a [box blur](http://en.wikipedia.org/wiki/Box_blur) three times. This will approximate a Gaussian blur very well, and be much faster than a true Gaussian blur.

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2016-07-09T18:47:59.753

我已经将 Ivan Kuckir 的快速高斯模糊实现转换为 Java，该实现使用三个通道和线性框模糊。正如他[在自己的博客](http://blog.ivank.net/fastest-gaussian-blur.html)中所说，由此产​​生的过程是 O(n) 。如果您想了解更多关于为什么 3 时间框模糊近似于高斯模糊（3%）我的朋友，您可以查看[框模糊](https://en.wikipedia.org/wiki/Box_blur)和[高斯模糊](https://en.wikipedia.org/wiki/Gaussian_blur)。

这是java实现。

```
@Override
public BufferedImage ProcessImage(BufferedImage image) {
    int width = image.getWidth();
    int height = image.getHeight();

    int[] pixels = image.getRGB(0, 0, width, height, null, 0, width);
    int[] changedPixels = new int[pixels.length];

    FastGaussianBlur(pixels, changedPixels, width, height, 12);

    BufferedImage newImage = new BufferedImage(width, height, image.getType());
    newImage.setRGB(0, 0, width, height, changedPixels, 0, width);

    return newImage;
}

private void FastGaussianBlur(int[] source, int[] output, int width, int height, int radius) {
    ArrayList<Integer> gaussianBoxes = CreateGausianBoxes(radius, 3);
    BoxBlur(source, output, width, height, (gaussianBoxes.get(0) - 1) / 2);
    BoxBlur(output, source, width, height, (gaussianBoxes.get(1) - 1) / 2);
    BoxBlur(source, output, width, height, (gaussianBoxes.get(2) - 1) / 2);
}

private ArrayList<Integer> CreateGausianBoxes(double sigma, int n) {
    double idealFilterWidth = Math.sqrt((12 * sigma * sigma / n) + 1);

    int filterWidth = (int) Math.floor(idealFilterWidth);

    if (filterWidth % 2 == 0) {
        filterWidth--;
    }

    int filterWidthU = filterWidth + 2;

    double mIdeal = (12 * sigma * sigma - n * filterWidth * filterWidth - 4 * n * filterWidth - 3 * n) / (-4 * filterWidth - 4);
    double m = Math.round(mIdeal);

    ArrayList<Integer> result = new ArrayList<>();

    for (int i = 0; i < n; i++) {
        result.add(i < m ? filterWidth : filterWidthU);
    }

    return result;
}

private void BoxBlur(int[] source, int[] output, int width, int height, int radius) {
    System.arraycopy(source, 0, output, 0, source.length);
    BoxBlurHorizantal(output, source, width, height, radius);
    BoxBlurVertical(source, output, width, height, radius);
}

private void BoxBlurHorizontal(int[] sourcePixels, int[] outputPixels, int width, int height, int radius) {
    int resultingColorPixel;
    float iarr = 1f / (radius + radius);
    for (int i = 0; i < height; i++) {
        int outputIndex = i * width;
        int li = outputIndex;
        int sourceIndex = outputIndex + radius;

        int fv = Byte.toUnsignedInt((byte) sourcePixels[outputIndex]);
        int lv = Byte.toUnsignedInt((byte) sourcePixels[outputIndex + width - 1]);
        float val = (radius) * fv;

        for (int j = 0; j < radius; j++) {
            val += Byte.toUnsignedInt((byte) (sourcePixels[outputIndex + j]));
        }

        for (int j = 0; j < radius; j++) {
            val += Byte.toUnsignedInt((byte) sourcePixels[sourceIndex++]) - fv;
            resultingColorPixel = Byte.toUnsignedInt(((Integer) Math.round(val * iarr)).byteValue());
            outputPixels[outputIndex++] = (0xFF << 24) | (resultingColorPixel << 16) | (resultingColorPixel << 8) | (resultingColorPixel);
        }

        for (int j = (radius + 1); j < (width - radius); j++) {
            val += Byte.toUnsignedInt((byte) sourcePixels[sourceIndex++]) - Byte.toUnsignedInt((byte) sourcePixels[li++]);
            resultingColorPixel = Byte.toUnsignedInt(((Integer) Math.round(val * iarr)).byteValue());
            outputPixels[outputIndex++] = (0xFF << 24) | (resultingColorPixel << 16) | (resultingColorPixel << 8) | (resultingColorPixel);
        }

        for (int j = (width - radius); j < width; j++) {
            val += lv - Byte.toUnsignedInt((byte) sourcePixels[li++]);
            resultingColorPixel = Byte.toUnsignedInt(((Integer) Math.round(val * iarr)).byteValue());
            outputPixels[outputIndex++] = (0xFF << 24) | (resultingColorPixel << 16) | (resultingColorPixel << 8) | (resultingColorPixel);
        }
    }
}

private void BoxBlurVertical(int[] sourcePixels, int[] outputPixels, int width, int height, int radius) {
    int resultingColorPixel;
    float iarr = 1f / (radius + radius + 1);
    for (int i = 0; i < width; i++) {
        int outputIndex = i;
        int li = outputIndex;
        int sourceIndex = outputIndex + radius * width;

        int fv = Byte.toUnsignedInt((byte) sourcePixels[outputIndex]);
        int lv = Byte.toUnsignedInt((byte) sourcePixels[outputIndex + width * (height - 1)]);
        float val = (radius + 1) * fv;

        for (int j = 0; j < radius; j++) {
            val += Byte.toUnsignedInt((byte) sourcePixels[outputIndex + j * width]);
        }
        for (int j = 0; j <= radius; j++) {
            val += Byte.toUnsignedInt((byte) sourcePixels[sourceIndex]) - fv;
            resultingColorPixel = Byte.toUnsignedInt(((Integer) Math.round(val * iarr)).byteValue());
            outputPixels[outputIndex] = (0xFF << 24) | (resultingColorPixel << 16) | (resultingColorPixel << 8) | (resultingColorPixel);
            sourceIndex += width;
            outputIndex += width;
        }
        for (int j = radius + 1; j < (height - radius); j++) {
            val += Byte.toUnsignedInt((byte) sourcePixels[sourceIndex]) - Byte.toUnsignedInt((byte) sourcePixels[li]);
            resultingColorPixel = Byte.toUnsignedInt(((Integer) Math.round(val * iarr)).byteValue());
            outputPixels[outputIndex] = (0xFF << 24) | (resultingColorPixel << 16) | (resultingColorPixel << 8) | (resultingColorPixel);
            li += width;
            sourceIndex += width;
            outputIndex += width;
        }
        for (int j = (height - radius); j < height; j++) {
            val += lv - Byte.toUnsignedInt((byte) sourcePixels[li]);
            resultingColorPixel = Byte.toUnsignedInt(((Integer) Math.round(val * iarr)).byteValue());
            outputPixels[outputIndex] = (0xFF << 24) | (resultingColorPixel << 16) | (resultingColorPixel << 8) | (resultingColorPixel);
            li += width;
            outputIndex += width;
        }
    }
} 
```

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-19T02:03:20.713

*   第 1 步：SIMD 1 维高斯模糊
*   第 2 步：转置
*   第 3 步：重复第 1 步

最好在小块上完成，因为全图像转置很慢，而使用[PUNPCK](http://en.wikipedia.org/wiki/X86_instruction_listings#MMX_instructions)链（[PUNPCKHBW、PUNPCKHDQ、PUNPCKHWD、PUNPCKLBW、PUNPCKLDQ、PUNPCKLWD](http://www.rz.uni-karlsruhe.de/rz/docs/VTune/reference/vc264.htm)）可以非常快速地完成小块转置。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-09-19T00:44:45.020

我会考虑为此使用 CUDA 或其他一些 GPU 编程工具包，特别是如果您想使用更大的内核。如果做不到这一点，总会在装配中手动调整你的循环。

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2010-09-14T19:06:04.110

我在研究中为这个问题苦苦挣扎，并尝试了一种有趣的快速高斯模糊方法。首先，如前所述，最好将模糊分成两个 1D 模糊，但根据您的硬件实际计算像素值，您实际上可以预先计算所有可能的值并将它们存储在查找表中。

换句话说，预先计算`Gaussian coefficient`*的每个组合`input pixel value`。当然，您需要离散化您的系数，但我只是想添加此解决方案。如果您有[IEEE](http://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers)订阅，您可以在*[Fast image blurring using Lookup Table for real time feature extract](http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5213780)*中阅读更多内容。

最终，我最终还是使用了[CUDA](http://en.wikipedia.org/wiki/CUDA) :)

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2009-09-04T03:01:41.863

在一维中：

重复使用几乎任何内核进行模糊将倾向于高斯内核。这就是高斯分布的奇妙之处，也是统计学家喜欢它的原因。所以选择容易模糊的东西并多次应用它。

例如，使用盒形内核很容易模糊。首先计算一个累积和：

```
y(i) = y(i-1) + x(i) 
```

然后：

```
blurred(i) = y(i+radius) - y(i-radius) 
```

重复几次。

[或者您可能会使用各种IIR](http://en.wikipedia.org/wiki/Infinite_impulse_response)滤波器来回切换几次，它们的速度同样快。

在 2D 或更高版本中：

正如DarenW所说，一个接一个地模糊每个维度。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2018-02-19T14:38:12.667

我在不同的地方看到了几个答案，并在这里收集它们，以便我可以尝试围绕它们并记住它们以供以后使用：

无论您使用哪种方法，都应使用 1D 过滤器[分别过滤水平和垂直维度](https://stackoverflow.com/a/98818/1048186)，而不是使用单个方形过滤器。

*   标准的“慢”方法：卷积滤波器
*   SIFT 中分辨率降低的分层图像金字塔
*   由中心极限定理推动的重复框模糊。Box Blur 是 Viola 和 Jones 人脸检测的核心，如果我没记错的话，他们称其为整体图像。我认为类似 Haar 的功能也使用了类似的东西。
*   [Stack Blur](http://incubator.quasimondo.com/processing/fast_blur_deluxe.php)：卷积和框模糊方法之间的基于队列的替代方案
*   [IIR 滤波器](https://dsp.stackexchange.com/questions/9745/which-iir-filters-approximate-a-gaussian-filter)
    *   [Derich 滤波器](https://dsp.stackexchange.com/a/9748/13601)（[维基百科](https://en.wikipedia.org/wiki/Deriche_edge_detector)）二阶 IIR 滤波器
    *   [van Vliet 过滤器](https://dsp.stackexchange.com/a/9748/13601)我对这个一无所知
    *   [贝塞尔过滤器](https://dsp.stackexchange.com/a/9747/13601)虽然有一些关于这些的争论

在回顾了所有这些之后，我想起了简单的、糟糕的近似在实践中通常效果很好。在另一个领域，Alex Krizhevsky 发现 ReLU 比他开创性的 AlexNet 中的经典 sigmoid 函数更快，尽管乍一看它们似乎是 Sigmoid 的可怕近似。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2014-03-10T10:49:40.033

二维数据的高斯模糊有几种快速方法。你应该知道什么。

1.  这是可分离滤波器，因此只需要两个 1d 卷积。
2.  对于大内核，您可以处理缩小的图像副本，而不是放大回来。
3.  可以通过多个盒子过滤器（也是可分离的）来完成良好的近似，（可以调整迭代次数和内核大小）
4.  现有 O(n) 复杂度算法（适用于任何内核大小），用于通过 IIR 滤波器进行精确的高斯近似。

您的选择取决于所需的速度、精度和实施复杂性。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2014-05-24T07:53:19.460

尝试按照我在这里的方式使用 Box Blur： [Approximating Gaussian Blur Using Extended Box Blur](https://stackoverflow.com/questions/23489902/approximating-gaussian-blur-using-extended-box-blur)

这是最好的近似值。

使用 Integral Images 可以让它更快。
如果你这样做，请分享你的解决方案。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2018-07-02T16:38:09.813

CWP 的 Dave Hale 有一个 minejtk 包，其中包括递归高斯滤波器（Deriche 方法和 Van Vliet 方法）。java子程序可以在[https://github.com/dhale/jtk/blob/0350c23f91256181d415ea7369dbd62855ac4460/core/src/main/java/edu/mines/jtk/dsp/RecursiveGaussianFilter.java找到](https://github.com/dhale/jtk/blob/0350c23f91256181d415ea7369dbd62855ac4460/core/src/main/java/edu/mines/jtk/dsp/RecursiveGaussianFilter.java)

Deriche 的方法对于高斯模糊（以及高斯的导数）似乎是一种非常好的方法。

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2016-06-23T10:50:18.397

***用现在（截至 2016 年）实施的新库***来回答这个老问题，因为 Java 的 GPU 技术有许多新的进步。

正如其他几个答案所建议的那样，CUDA 是一种替代方案。但是***java***现在有CUDA支持。

IBM CUDA4J 库：提供用于管理和访问 GPU 设备、库、内核和内存的 Java API。使用这些新的 API，可以使用 Java 内存模型、异常和自动资源管理的便利性来编写管理 GPU 设备特性并将工作卸载到 GPU 的 Java 程序。

Jcuda：NVIDIA CUDA 和相关库的 Java 绑定。使用 JCuda，可以从 Java 程序与 CUDA 运行时和驱动程序 API 进行交互。

Aparapi：允许 Java 开发人员通过在 GPU 上执行数据并行代码片段来利用 GPU 和 APU 设备的计算能力，而不是局限于本地 CPU。

一些***Java OpenCL 绑定***库

[https://github.com/ochafik/JavaCL：OpenCL](https://github.com/ochafik/JavaCL)的 Java 绑定：一个面向对象的 OpenCL 库，基于自动生成的低级绑定

[http://jogamp.org/jocl/www/：OpenCL](http://jogamp.org/jocl/www/)的 Java 绑定：一个面向对象的 OpenCL 库，基于自动生成的低级绑定

[http://www.lwjgl.org/：OpenCL](http://www.lwjgl.org/)的 Java 绑定：自动生成的低级绑定和面向对象的便利类

[http://jocl.org/：OpenCL](http://jocl.org/)的 Java 绑定：原始 OpenCL API 的 1:1 映射的低级绑定

上述所有这些库都将有助于在 CPU 上比 Java 中的任何实现更快地实现高斯模糊。

# windows - 使用标准 Windows 命令行/批处理命令模拟 unix 'cut'

> ID：98363
> 
> 赞同：6
> 
> 时间：2008-09-19T00:34:28.430
> 
> 标签：windows, unix, command-line

有没有办法在 Windows XP 上模拟 unix cut 命令，而不求助于 cygwin 或其他非标准 Windows 功能？

示例：使用 tasklist /v，通过窗口标题查找特定任务，然后从该列表中提取 PID 以传递给 taskkill。

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-09-19T00:53:17.683

仅供参考，tasklist 和 taskkill 已经具有过滤功能：

```
tasklist /FI "imagename eq chrome.exe"
taskkill /F /FI "imagename eq iexplore.exe" 
```

如果您想要更通用的功能，批处理脚本（呃）可以提供帮助。例如：

```
for /f "tokens=1,2 delims= " %%i in ('tasklist /v') do (
  if "%%i" == "%~1" (
    echo TASKKILL /PID %%j
  )
) 
```

Windows 命令行有相当多的帮助。键入“help”以获取带有简单摘要的命令列表，然后键入“help”以获取有关该命令的更多信息（例如“help for”）。

# ruby - Java .properties 文件等效于 Ruby？

> ID：98376
> 
> 赞同：28
> 
> 时间：2008-09-19T00:36:12.310
> 
> 标签：ruby, file-io

我需要将一些简单的属性存储在一个文件中并从 Ruby 中访问它们。

我非常喜欢 .properties 文件格式，它是 Java 中此类事物的标准（使用 java.util.Properties 类）......它简单、易于使用且易于阅读。

那么，是否有一个 Ruby 类可以让我轻松地从这样的文件中加载一些键值对？

我不想使用 XML，所以请不要建议 REXML（我的目的不保证“尖括号税”）。

我已经考虑推出我自己的解决方案......它可能是大约 5-10 行代码顶部，但我仍然宁愿使用现有的库（如果它本质上是从文件构建的哈希）......因为那会把它降低到 1 行....

* * *

更新：它实际上是一个直接的 Ruby 应用程序，而不是 rails，但我认为 YAML 会做得很好（它在我的脑海中，但我忘记了它......见过但从未使用过），谢谢大家！

* * *

## 回答 #1

> 赞同：26
> 
> 时间：2008-09-19T00:44:43.617

这是针对 Rails 应用程序还是 Ruby 应用程序？

真的，您可以将您的属性粘贴到 yaml 文件中，然后再粘贴`YAML::Load(File.open("file"))`。

* * *

**来自 Mike Stone 的注释：**实际上这样做会更好：

```
File.open("file") { |yf| YAML::load(yf) } 
```

或者

```
YAML.load_file("file") 
```

正如 ruby​​ 文档所建议的那样，否则文件在垃圾收集之前不会关闭，但无论如何都是好的建议:-)

* * *

## 回答 #2

> 赞同：10
> 
> 时间：2008-09-19T04:46:51.803

另一种选择是简单地使用另一个 Ruby 文件作为配置文件。

例如，创建一个名为“选项”的文件

```
{
    :blah   => 'blee',
    :foo    => 'bar',
    :items  => ['item1', 'item2'],
    :stuff  => true
} 
```

然后在您的 Ruby 代码中执行以下操作：

```
ops = eval(File.open('options') {|f| f.read })
puts ops[:foo] 
```

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-09-19T02:40:50.623

如上所述，YAML 将完美地做到这一点。例如，在我的一个 Ruby 脚本中，我有一个 YAML 文件，例如：

```
migration:
  customer: Example Customer
  test:     false
sources:
- name:     Use the Source
  engine:   Foo
- name:     Sourcey
  engine:   Bar 
```

然后我在 Ruby 中将其用作：

```
config = YAML.load_file(File.join(File.dirname(__FILE__), ARGV[0]))
puts config['migration']['customer']

config['sources'].each do |source|
  puts source['name']
end 
```

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2013-03-25T03:41:15.890

*inifile* - [http://rubydoc.info/gems/inifile/2.0.2/frames](http://rubydoc.info/gems/inifile/2.0.2/frames)将支持基本的 .properties 文件以及带有 [SECTIONS] 的 .ini 文件，例如。

```
[SECTION]
key=value 
```

当您的数据结构复杂但可能包含空格、制表符、行尾等时，YAML 是很好的选择——如果文件不是由程序员维护，这可能会导致问题。相比之下`.properties`，`.ini`文件更宽容，如果您不需要通过 YAML 获得的深层结构，则可能是合适的。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-19T00:53:56.573

Devender Gollapally 写了一个[类](http://devender.wordpress.com/2006/05/01/reading-and-writing-java-property-files-with-ruby)来做到这一点：

...虽然我建议更好地使用 YAML 文件。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-19T00:49:35.417

您可以考虑使用 YAML，而不是 .properties 样式的配置文件。YAML 在 Ruby on Rails 中用于数据库配置，并在其他语言（Python、Java、Perl 等）中广受欢迎。

Ruby YAML 模块的概述在这里：[http ://www.ruby-doc.org/core/classes/YAML.html](http://www.ruby-doc.org/core/classes/YAML.html)

YAML的主页在这里：http: [//yaml.org](http://yaml.org/)

# mapping - 在 Scheme 标准中是否存在这样的过程，如果存在，它是如何调用的？

> ID：98394
> 
> 赞同：3
> 
> 时间：2008-09-19T00:39:41.040
> 
> 标签：mapping, scheme

我查找了一个过程的名称，它将过程的树结构应用于数据的树结构，产生结果的树结构——所有三棵树都具有相同的结构。

这样的过程可能具有以下签名：

```
（地图树数据功能树）
```

它的返回值将是 functree 的元素在相应数据元素上的元素应用的结果。

示例（假设该过程称为映射树）：

示例 1：

```
(定义 *2 (lambda (x) (* 2 x)))
; *3 和 *5 的类似定义

(map-tree '(100 (10 1)) '(*2 (*3 *5)))
```

会产生结果

```
(200 (30 5))
```

示例 2：

```
（地图树'（（（（aa .ab）（bb .bc））（cc .（cd .ce）））
        '((汽车 cdr) cadr))
```

产生结果

```
((aa bc) 光盘)
```

但是，我在查阅的 SLIB 文档中没有找到这样的功能。

这样的程序是否已经存在？
如果不是，该过程的合适名称是什么，您将如何对其参数进行排序？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-19T01:03:14.227

我没有一个很好的函数名称。我在下面粘贴我的实现（我称之为`map-traversing`；其他人应该建议一个更好的名字）。我已经使参数顺序反映了`map`它本身。

```
(define (map-traversing func data)
  (if (list? func)
      (map map-traversing func data)
      (func data))) 
```

使用您的样本数据，我们有：

```
(map-traversing `((,car ,cdr) ,cadr) '(((aa . ab) (bb . bc)) (cc cd . ce))) 
```

第二个示例需要 SRFI 26。（允许写入`(cut * 2 <>)`而不是`(lambda (x) (* 2 x))`。）

```
(map-traversing `(,(cut * 2 <>) (,(cut * 3 <>) ,(cut * 5 <>))) '(100 (10 1))) 
```

最重要的是，与您的示例不同，您的函数必须全部不加引号。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T03:09:40.897

我发现使用地图遍历的以下定义，您不需要取消引用函数：

```
（定义（地图遍历函数数据）
  （如果（列表？函数）
      (map map-traversing func 数据)
      (apply (eval func (interaction-environment)) (list data))))
```

注意：在我安装的 Guile 版本中，由于某种原因，只有 (interaction-environment) 不会引发 Unbound variable 错误。其他环境，即 (scheme-report-environment 5) 和 (null-environment 5) 会引发此错误。

注 2：随后，我在 [1] 中发现，要使 (scheme-report-environment 5) 和 (null-environment 5) 工作，您首先需要 (use-modules (ice-9 r5rs))

[1]: [http://www.mail-archive.com/bug-guile@gnu.org/msg04368.html](http://www.mail-archive.com/bug-guile@gnu.org/msg04368.html) 'Re: guile -c "(scheme-report-environment 5)" ==> 错误: 未绑定变量：方案报告环境'

# git - 如何检查远程 git 存储库的配置？

> ID：98400
> 
> 赞同：4
> 
> 时间：2008-09-19T00:41:23.047
> 
> 标签：git, git-svn

我有一个 svn 存储库的 git-svn 克隆，我想鼓励我的同事将 git 视为一种选择。问题是从 svn 克隆 repo 需要 3 天，但从我的 git 实例克隆需要 10 分钟。

我有一个脚本可以让人们克隆我的 git 存储库并将其重新指向原始 SVN，但它需要知道我如何设置一些配置值。我希望脚本能够通过网络提取这些值。

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-19T01:12:12.600

我想说更好的方法是，而不是要求你的同事做一个 git clone，只需给他们一个你现有的 git-svn checkout 的压缩包。这样，您不必重新指向或查询任何内容，因为它已经完成了。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-20T09:36:25.007

如果他们可以直接访问您的存储库（即，不是通过 ssh 或其他网络协议），那么我会说您可以运行

```
 git config -f/path/to/your/repo/.git/config --get ... 
```

从配置文件中查询参数。否则，据我所知，他们必须首先`scp`（或`rcp`或`ftp`或...）将您的配置文件放到暂存空间（而不是覆盖他们的），然后对本地配置文件执行相同的查询：

```
 scp curries_box:/home/currie/repo/.git/config /tmp/currie_config
git config -f/tmp/currie_config --get ... 
```

我唯一的另一个想法是您可以在存储库中维护 .git/config 文件的副本。然后，当他们克隆时，他们会有一个副本......虽然你必须手动更新它......也许你可以设计一个[钩子](http://git-scm.com/docs/githooks)来自动更新或至少检测何时应该完成更新。

# c# - 如何从继承自 CollectionBase 的类重构为泛型？

> ID：98426
> 
> 赞同：2
> 
> 时间：2008-09-19T00:46:25.283
> 
> 标签：c#, generics, .net-3.5, .net-2.0, refactoring

我正在开发一个大约 250,000 行代码的应用程序。我目前是唯一一个开发这个最初在 .NET 1.1 中构建的应用程序的开发人员。Pervasive through 是一个继承自 CollectionBase 的类。所有数据库集合都继承自此类。我正在考虑重构以从通用集合 List 继承。不用说，Martin Fowler 的重构书没有任何建议。我应该尝试这个重构吗？如果是这样，解决此重构的最佳方法是什么？

是的，自始至终都有单元测试，但没有 QA 团队。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T00:53:34.297

不。除非你有一个非常好的商业理由来让你的代码库通过这个练习。您的重构所节省的成本或收入是多少？如果我是你的经理，我可能会建议不要这样做。对不起。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T04:09:47.650

如果您**要**完成它，请不要使用**List< T >**。相反，请使用[System.Collections.ObjectModel。**Collection< T >**](http://msdn.microsoft.com/en-us/library/ms132397.aspx)，它更像是 CollectionBase 的精神继承者。

该类`Collection<T>`提供了受保护的方法，可用于在添加和删除项目、清除集合或设置现有项目的值时自定义其行为。如果您使用`List<T>`没有办法覆盖`Add()`当有人向集合投放广告时处理的方法。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T04:32:38.687

CollectionBase 从继承的类中暴露的程度如何？
泛型能比 CollectionBase 做得更好吗？

我的意思是这个类被大量使用，但它只是一个类。重构的关键是不扰乱程序的现状。该类应始终保持与外部世界的契约。如果你能做到这一点，你重构的代码不是 25 万行，而可能只有 2500 行（随机猜测，我不知道这个类有多大）。

但是，如果这门课有很多曝光，您可能不得不将该曝光视为合同，并尝试将曝光排除在外。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T00:54:01.910

250,000 行需要重构很多，另外你应该考虑以下几个：

1.  你有一个 QA 部门可以对重构的代码进行 QA 吗？
2.  你有旧代码的单元测试吗？
3.  是否有围绕项目的时间表，即您是否在用户发现错误时维护代码？

如果您回答 1 和 2 否，我将首先为现有代码编写单元测试。使它们广泛而彻底。一旦你有了这些，分支一个版本，然后开始重构。单元测试应该能够帮助您正确地重构泛型。

如果 2 是肯定的，那么就根据这些单元测试进行分支并开始重构。

QA 部门也会有很大帮助，因为您可以将新代码提交给他们进行测试。

最后，如果客户/用户需要修复错误，请先修复它们。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-19T04:05:27.083

我认为重构和保持代码最新是避免代码腐烂/异味的一个非常重要的过程。许多开发人员要么与他们的代码结婚，要么对他们的单元测试缺乏足够的信心，无法将事情拆开并清理干净并正确执行。

如果你不花时间清理它并使代码变得更好，那么从长远来看你会后悔的，因为你必须在未来的许多年里维护那个代码，否则谁会讨厌你。你说你有单元测试，你应该能够信任这些测试，以确保当你重构代码时它仍然可以工作。

所以我说做吧，把它清理干净，让它变得漂亮。如果您不确定您的单元测试可以处理重构，请多写一些。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-19T03:54:48.137

我同意托马斯的观点。

我觉得在重构时你应该经常问自己的问题是“做这件事和用我的时间做其他事情我能得到什么？” 答案可以是很多东西，从提高可维护性到更好的性能，但它总是以牺牲其他东西为代价。

如果没有看到代码，我很难判断，但这听起来是一个非常糟糕的重构情况。测试是好的，但它们不是万无一失的。只需要其中一个做出错误的假设，您的重构可能会引入一个令人讨厌的错误。如果没有 QA 来捕捉它，那就不好了。

我个人也对像这样的大规模重构有点担心。曾经让我失去了一份工作。这是我在政府之外的第一份工作（这往往更宽容一点，一旦你获得“终身职位”就很难被解雇），我是唯一的网络程序员。我得到了一个写得很糟糕的遗留 ASP 应用程序，落在了我的腿上。我的首要任务是将这该死的东西重构为不那么...恶心的东西。我的雇主希望把火扑灭，仅此而已。六个月后，我又开始找工作了：p 这个故事的寓意：在开始之前先咨询你的经理。

# geocoding - 如何将地址转换为纬度/经度？

> ID：98449
> 
> 赞同：72
> 
> 时间：2008-09-19T00:50:07.427
> 
> 标签：geocoding, latitude-longitude, street-address

我将如何将地址或城市转换为纬度/经度？有没有我可以“租用”这项服务的商业机构？这将用于具有全时 Internet 访问权限的 Windows PC 上的商业桌面应用程序。

* * *

## 回答 #1

> 赞同：50
> 
> 时间：2008-09-19T00:51:26.893

谷歌有一个地理编码 API，对于他们拥有谷歌地图数据的大多数位置来说，它似乎工作得很好。

[http://googlemapsapi.blogspot.com/2006/06/geocoding-at-last.html](http://googlemapsapi.blogspot.com/2006/06/geocoding-at-last.html)

他们提供在线地理编码（通过 JavaScript）：

[http://code.google.com/apis/maps/documentation/services.html#Geocoding](http://code.google.com/apis/maps/documentation/services.html#Geocoding)

或后端地理编码（通过 HTTP 请求）：

[http://code.google.com/apis/maps/documentation/services.html#Geocoding_Direct](http://code.google.com/apis/maps/documentation/services.html#Geocoding_Direct)

这些数据通常与谷歌地图本身使用的数据相同。（请注意，有一些例外情况，例如英国或以色列，其数据来自不同来源且质量略有下降）

* * *

## 回答 #2

> 赞同：27
> 
> 时间：2008-10-17T16:53:44.470

没有什么可添加的新内容，但我在以前的工作中积累了丰富的 GIS 和地理编码方面的实际经验。这是我记得的：

如果您的应用程序需要“每隔一段时间”，我肯定会推荐 Google 或 Yahoo Geocoding API，但请仔细阅读它们的许可条款。

我知道 Google Maps API 通常很容易获得商业网页的许可，但不能在付费访问的情况下使用。换句话说，您可以使用它来做广告或提供增加广告收入的服务，但您不能向访问您的网站的人收费，甚至不能将其置于密码系统后面。

尽管有这些限制，但它们都是很好的选择，因为它们经常更新街道数据库。大多数免费的后端工具和库使用不经常更新的 Census 和 TIGER 道路数据，因此您不太可能成功地对快速增长的区域或新细分中的地址进行地理编码。

大多数服务还限制您每天可以进行的地理编码查询的数量，因此可以查找添加到数据库中的新客户的地址，但如果您运行批处理作业来提供数千个地址您的数据库进入地理编码器，您将被关闭。

我认为这个还没有被提及，但是 ESRI 有包含地理编码的[ArcWeb Web 服务](http://ashburnarcweb.esri.com/v2006/index.jsp)，虽然它们不是很便宜。上次我使用它们时，每次查找的成本约为 1.5 美分，但您必须预付一定的金额才能开始使用。同样，主要优势是他们使用的道路数据会及时更新，您可以在谷歌不允许的商业情况下使用这些数据。*ArcWeb 服务还将像*谷歌地图一样提供高分辨率卫星和航拍照片，再次按请求定价。

如果您想自己动手或访问更准确的数据，您可以从[TeleAtlas](http://www.teleatlas.com/Markets/Enterprise/index.htm)等公司购买 GIS 数据订阅，但这并不便宜。如果您的需求非常本地化，您只能购买一个州或县的数据。有几层数据——仅 GIS 功能、GIS 加上详细的街道、所有这些加上地理编码数据，所有这些加上交通流量/方向/速度限制。当然，随着等级的增加，价格也会上涨。

最后，关于[地理编码](http://en.wikipedia.org/wiki/Geocoding)的维基百科文章有一些关于算法和技术的好信息。即使您没有在自己的代码中执行此操作，了解您可以从各种数据源中获得什么样的错误和准确性也很有用。

* * *

## 回答 #3

> 赞同：10
> 
> 时间：2008-09-23T19:37:40.060

[雅虎！地图网络服务 - 地理编码 API](http://developer.yahoo.com/maps/rest/V1/geocode.html)准确地对英国邮政编码进行地理编码，这与 Google 的 API 不同。

不幸的是，雅虎已弃用此服务，您可以访问[http://developer.yahoo.com/geo/placefinder/](http://developer.yahoo.com/geo/placefinder/)获取雅虎的服务

* * *

## 回答 #4

> 赞同：9
> 
> 时间：2012-01-05T04:28:01.073

试试这个：[http ://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&sensor=false](http://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&sensor=false)

更多信息在这里：[http ://code.google.com/apis/maps/documentation/geocoding/](http://code.google.com/apis/maps/documentation/geocoding/)

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2008-09-19T01:03:14.180

当您将地址或对象转换为纬度/经度时，它称为地理编码。

周围有很多地理编码解决方案。适合您项目的解决方案取决于每个地理编码解决方案的许可条款的可接受性。Microsoft Virtual Earth 和 Google Maps 都提供在非常严格的许可下免费使用的解决方案......

[https://developers.google.com/maps/documentation/javascript/tutorial](https://developers.google.com/maps/documentation/javascript/tutorial)

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2008-10-17T16:23:12.333

之前为此推出了我自己的解决方案，我可以全心全意地为此推荐[Geo::Coder::US](http://search.cpan.org/~sderle/Geo-Coder-US/) Perl 模块。只需下载所有人口普查数据并使用包含的导入器为您的国家创建伯克利数据库并将 Perl 脚本指向它。使用模块的内置地址解析，您就拥有了：离线地理编码系统！

* * *

## 回答 #7

> 赞同：4
> 
> 时间：2014-07-31T18:25:30.307

**尝试使用此代码，我使用地址这样工作：**

**它是使用 GET 方法发送请求并获取 lat 和 lng 的链接。** [http://maps.google.com/maps/api/geocode/json?address=YOUR ADDRES&sensor=false](http://maps.google.com/maps/api/geocode/json?address=YOUR%20ADDRES&sensor=false)

**例如：** [http://maps.google.com/maps/api/geocode/json?address=W Main St, Bergenfield, NJ 07621&sensor=false](http://maps.google.com/maps/api/geocode/json?address=W%20Main%20St,%20Bergenfield,%20NJ%2007621&sensor=false)

**1\. 创建您的 GET 方法。**

```
 public static String GET(String url) throws Exception {//GET Method
        String result = null;
        InputStream inputStream = null;
        try {
            HttpClient httpclient = new DefaultHttpClient();
            HttpGet httpGet = new HttpGet(url);

        Log.v("ExecuteGET: ", httpGet.getRequestLine().toString());

        HttpResponse httpResponse = httpclient.execute(httpGet);
        inputStream = httpResponse.getEntity().getContent();
        if (inputStream != null) {
            result = convertInputStreamToString(inputStream);
            Log.v("Result: ", "result\n" + result);
        } 
    } catch (Exception e) {
        e.printStackTrace();
    }
    return result;
} 
```

**2\. 创建发送请求的方法**

```
@SuppressWarnings("deprecation")
    public static String getLatLng(String accessToken) throws Exception{
        String query=StaticString.gLobalGoogleUrl+"json?address="+URLEncoder.encode(accessToken)+"&sensor=false";
        Log.v("GETGoogleGeocoder", query+"");
        return GET(query);
    } 
```

> **gLobalGoogleUrl** ="http://maps.google.com/maps/api/geocode/"

**3.调用getLatLng方法**

```
String result=getLatLng("W Main St, Bergenfield, NJ 07621"); 
```

**4.解析JSONObject**

现在**结果**是**JSONObject**，其中包含有关地址和 lan,lng 的信息。[**使用gson()**](https://code.google.com/p/google-gson/)解析 JSONObject（结果） 。之后使用 lat,lng。

**如果您对代码有疑问，请询问。**

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2009-01-15T09:38:29.730

You could also try the [OpenStreetMap](http://www.openstreetmap.org/) [NameFinder](http://wiki.openstreetmap.org/wiki/Namefinder) (or the current [Nominatim](https://stackoverflow.com/questions/2283689/can-anyone-recommend-a-free-geocoding-service/2387299#2387299)), which contains open source, wiki-like street data for (potentially) the entire world.

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-09-19T00:52:16.017

您需要一个地理编码应用程序。这些可以在线获得，也可以作为应用程序后端获得。

*   网上申请：

    *   谷歌有一个[地理编码 API](http://code.google.com/apis/maps/documentation/services.html#Geocoding)
*   后端应用：

    *   [地质斯坦](http://www.centrus.com/GeoStan.html)

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-09-19T00:59:42.787

Maptsraction ( [http://www.mapstraction.com](http://www.mapstraction.com) ) 允许您在任意数量的地理编码服务之间进行选择。如果您需要做大量工作，这可能会有所帮助，因为我知道 Google 对您一天可以做的数量有限制。

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2008-09-19T01:01:06.200

[虚拟地球](http://blogs.msdn.com/virtualearth/archive/2008/04/08/geocoding-with-virtual-earth.aspx)做到了。[geocoder.us](http://geocoder.us)上还有一个网络服务

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2010-10-12T21:08:52.100

您可以使用 bing maps 肥皂服务，您可以在其中参考反向地理编码服务以从地址查找 lat/long 是链接 [http://msdn.microsoft.com/en-us/library/cc980922.aspx](http://msdn.microsoft.com/en-us/library/cc980922.aspx)

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2009-03-04T06:34:25.377

您可以使用 Microsoft 的 MapPoint Web 服务。

我创建了[一篇](http://www.codestrider.com/BlogRead.aspx?b=b5e8e275-cd18-4c24-b321-0da26e01bec5)关于如何将地址转换为地理代码（纬度/经度）的博客文章。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-09-19T01:28:57.160

[雅虎！地图网络服务 - 地理编码 API](http://developer.yahoo.com/maps/rest/V1/geocode.html)

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2015-03-13T08:22:11.457

你在问地理编码器。谷歌为此提供了一个 API。另一个提供者也是如此。

**[您可以在My Current Location](http://mycurrentlocation.net)** .net中查看实现演示

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2014-01-14T20:48:54.450

以为我会在列表中再添加一个。德州农工大学在这里提供价格合理的服务：http: [//geoservices.tamu.edu/Services/Geocode/](http://geoservices.tamu.edu/Services/Geocode/)

如果您有大量地址要进行地理编码并且不想向 Google 或 Microsoft 支付 10k 的费用，这是一个不错的选择。我们最终还是在谷歌地图中使用了返回的数据。

* * *

## 回答 #17

> 赞同：-1
> 
> 时间：2009-02-08T20:02:20.207

[USC WebGIS Geocoder](https://webgis.usc.edu)是免费的，并提供多个 API，或者您可以上传数据库以进行在线批处理。

* * *

## 回答 #18

> 赞同：-1
> 
> 时间：2017-12-15T11:59:09.433

如果您需要一次性解决方案，可以尝试：[https ://addresstolatlong.com/](https://addresstolatlong.com/)

我已经使用了很长时间，它对我来说效果很好。

# opengl - OpenGL：纹理和纯色对环境光的反应不同？

> ID：98451
> 
> 赞同：4
> 
> 时间：2008-09-19T00:50:35.380
> 
> 标签：opengl, textures

这是我在 OpenGL 应用程序中遇到的一个相当老的问题。

我有一个相当复杂的模型，其中的一些多边形是无纹理的，并且使用带有 glColor() 的纯色着色，而其他多边形是有纹理的。一些纹理与无纹理的多边形颜色相同，两者之间不应有可见的接缝。

问题是当我打开光源的环境分量时，两种多边形之间的接缝出现了。

看到这张图片： [http ://www.shiny.co.il/shooshx/colorBug2.png](http://www.shiny.co.il/shooshx/colorBug2.png)

左图没有任何环境光，右图有环境光（0.2,0.2,0.2）。

纹理上颜色的 RGB 值与彩色面的 RGB 值相同。纹理 alpha 到处都设置为 1.0。

为了给纹理着色，我使用 GL_MODULATE。

谁能想到会发生这种情况的原因以及可能的解决方案？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T01:07:21.223

你提到你用 设置颜色`glColor()`，所以我假设它`GL_COLOR_MATERIAL`是打开的？你用什么设置`glColorMaterial()`？在这种情况下，它应该是`GL_AMBIENT_AND_DIFFUSE`，以便`glColor()`调用影响环境颜色以及漫反射颜色。（这是默认设置。）

`glMaterial()`在渲染纹理映射面之前，您还可以尝试将所有材质颜色设置为白色（使用）。通过一些设置（不记得是哪个设置），纹理本身会被当前颜色调制。

希望这有助于或至少为您指明一个有用的方向。

# visual-studio - 什么是最佳的 VSTF 源结构？有没有最佳实践？

> ID：98454
> 
> 赞同：0
> 
> 时间：2008-09-19T00:51:06.910
> 
> 标签：visual-studio, tfs, version-control

还有许多与此主题相关的其他问题：

1.  ~~[什么是 php 应用程序的良好标准代码布局](https://stackoverflow.com/questions/5214/whats-a-good-standard-code-layout-for-a-php-application)~~（已删除）
2.  [如何构建 Java 应用程序，换句话说：我在哪里放置我的类？](https://stackoverflow.com/questions/7596/how-to-structure-a-java-application-in-other-words-where-do-i-put-my-classes)
3.  [推荐的源代码管理目录结构？](https://stackoverflow.com/questions/41513/recommended-source-control-directory-structure)
4.  [版本控制中的项目结构](https://stackoverflow.com/questions/16829/structure-of-projects-in-version-control)

我找不到任何特定于 VSTF 的东西，它具有团队构建、集成单元测试等功能。我想知道这些功能是否会导致稍微不同的源布局建议。

请发布您幸运的高级目录结构示例，并解释您喜欢它们的原因。我会让人们对“最佳”方法进行投票，几天后我会给出答案。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T01:00:35.420

这是我喜欢的一个：

*   **私人**; 所有当前的系统可交付成果
    *   **文件**；构成产品的解决方案中所有文档的汇总，输出将是 Sandcastle 的 MSDN 样式文档
    *   **常见的**；Visual Studio SLN 包含所有其他解决方案通用的所有项目。
    *   **工具**；Visual Studio SLN 包含其输出为工具的所有项目。示例可能是在较大系统上执行一组管理任务的控制台应用程序
    *   **开发商**；每个开发人员都有自己的文件夹，他们可以用来存储他们想要的任何东西
        *   **特定开发者 (1..n)** ; 这包含此特定开发人员选择存储在源代码控制系统中的任何构建设置、脚本和工具（他们可以在这里做任何他们想做的事情）
    *   **具体交付解决方案（1..n）**；包含特定主要可交付成果的所有项目的 Visual Studio SLN
        *   **常见的**；包含在当前解决方案中共享的 Visual Studio 项目的解决方案文件夹
        *   **用户界面**；包含定义用户体验的 Visual Studio 项目的解决方案文件夹
        *   **数据层**；包含定义数据访问层的 Visual Studio 项目的解决方案文件夹
        *   **服务**；包含定义 Web 服务的 Visual Studio 项目的解决方案文件夹
        *   **工具**；包含 Visual Studio 项目的解决方案文件夹，这些项目定义了特定于此交付物的工具（可执行实用程序）
        *   **测试**；包含包含单元测试的 Visual Studio 项目的解决方案文件夹
*   **公共**; 与系统相关的所有外部依赖项（例如 3rd 方库）
    *   **供应商**；特定供应商提供的依赖项
*   **建立**；包含与项目构建相关的代码的 Visual Studio SLN，在我们的例子中主要是自定义 MSBuild 任务和 Powershell 脚本
*   **目标**；产品的每次成功构建以及点发布
    *   **调试**；从每周构建和持续集成输出的所有调试构建。开发者不用手动管理这个目录
        *   **内部编号**；与当前内部版本号对应的目录
            *   **解决方案输出**；包含给定解决方案中每个项目的所有构建输出的目录
    *   **释放**；达到里程碑时手动输出的所有发布版本
        *   **内部编号**；与当前内部版本号对应的目录
            *   **解决方案输出**；包含给定解决方案中每个项目的所有构建输出的目录

*注意：*所有解决方案都有一个 Tests 文件夹和单元测试项目。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-12-29T07:04:18.040

一些想法：

*   **树根中的文件很少**。在大型团队中，设置权限，以便没有人可以在没有某种授权的情况下将新文件添加到树的根目录。

默认工作区将包含：

*   **工具**包含构建和运行单元测试所需的所有可执行代码，包括您的自定义工具和脚本（可能假设机器上已经安装了 Visual Studio 和 PowerShell）。

*   **ReferencedAssemblies**包含您从其他地方获取的内容，包括您购买或下载的内容以及团队中某人编写但不属于该项目的内容。

    *   如果可用，源代码也应该在此处，以便您自己维护。（如果不可用，您将承担很大的风险。）
*   **Source** - 所有源代码，包括项目文件。

*   **文档**- 不作为构建的一部分使用的项目，但对于开发工作的正常运行是必需的。

*   **二进制文件**- 已*发送*给客户的位，包括 .PDB 和其他服务所需的工件。（在小型项目中，我为每个版本分配源代码，但通常标签/标签是更好的选择。）

* * *

在其他地方（例如 $/personal），每个人都可以随心所欲地处理（$/personal/USERNAME）。例如，我的副项目放在这里。

# vxworks - 为什么 vxWorks 中没有 main() 函数？

> ID：98465
> 
> 赞同：6
> 
> 时间：2008-09-19T00:53:05.423
> 
> 标签：vxworks

当使用 vxWorks 作为开发平台时，我们不能使用标准的 main() 函数来编写我们的应用程序。为什么我们不能有一个主函数？

* * *

## 回答 #1

> 赞同：14
> 
> 时间：2008-09-19T00:54:29.350

在 6.0 版本之前，VxWorks 只支持任务的内核执行环境，不支持进程，这是 Unix 或 Windows 等 OS 上的传统应用程序执行环境。任务有一个入口点，它是作为任务执行的代码的地址。此地址对应于 C 或汇编函数。它可以是一个名为“main”的符号，但是内核环境不支持关于 main() 函数的 C/C++ 语言假设（特别是对 argc 和 argv 参数的传统处理）。此外，在 VxWorks 6.0 之前，所有任务都执行内核代码。你可以把内核想象成一个共同的代码库，所有的代码都链接在一起，然后你会发现你不能有多个同名的符号（“main”），因为这会产生名称冲突。

现在，只有将应用程序代码链接到内核映像时，这才是准确的。如果您要下载应用程序代码，则模块加载器将接受加载多个模块，每个模块都带有一个 main() 例程。然而，在系统符号表中注册的最后一个“主”符号是唯一可以通过目标 shell 访问的符号。如果要启动执行第一个加载模块之一的代码的任务，则必须使用前一个 main() 函数的地址。这是可能的，但不方便。为任务的入口点赋予不同的名称更为实用（可能像“xxxStart”，其中“xxx”是对任务应该执行的操作有意义的名称）。

从 VxWorks 6.0 开始，操作系统支持进程环境。这意味着，除其他外，您可以拥有一个传统的 main() 例程，并且它的 argc 和 argv 参数得到正确处理，并且应用程序代码在不同于内核上下文的上下文（用户上下文）中执行，从而确保应用程序代码（可能是不稳定的）和内核代码（不应该是不稳定的）之间的隔离。软垫

# java-me - Problems with sound on a 6265i Nokia using J2ME and Netbeans 6.1

> ID：98476
> 
> 赞同：1
> 
> 时间：2008-09-19T00:54:28.383
> 
> 标签：java-me, nokia, midp, cldc, netbeans6.1

Currently, I have some basic code to play a simple tone whenever a button is pressed in the command item menu.

Using: `Manager.playTone(note, duration, volume);`

I also have a blackberry that I'm testing this same midlet on and the sound works fine. So, is this something specific to Nokia phones that aren't allowing me to play the sound?

I've made sure to build it using the correct CLDC and MIDP versions.

I've also tried the audio demos that are in the Netbeans IDE, and still no luck. It throws a "cannot create player" message.

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T15:34:23.033

[http://discussion.forum.nokia.com/forum/showthread.php?t=91500](http://discussion.forum.nokia.com/forum/showthread.php?t=91500)

This thread on Forum Nokia seems to suggest that certain Nokia models have problems playing tones with the Manager.playTone() function, more specifically a MediaException is thrown, as you are having (MediaException is just the default exception if any problem occurs when trying to play a tone).

You can try sleeping the thread after calling Manager.playTone for greater than the length of the tone. There is a possibility that you get into a state where you are trying to play two or more tones at once and the phone might not allow more than one player to be created at a time.

If all else fails you can use the Nokia UI Sound class (com.nokia.mid.sound.Sound) to play the tone. It is deprecated and replaced with the call you are making, but it might be your only solution for this device. Just make your own playTone method and have it call the Nokia function for this device (and maybe other Nokia devices if need be) and the J2ME standard call on all other devices. You can accomplish this with the Netbeans ME Preprocessor.

[http://www.theoreticlabs.com/dev/api/nokia-ui-1.1/com/nokia/mid/sound/Sound.html](http://www.theoreticlabs.com/dev/api/nokia-ui-1.1/com/nokia/mid/sound/Sound.html)

# chuck - ChuckK 中 int 的最大值

> ID：98479
> 
> 赞同：2
> 
> 时间：2008-09-19T00:54:58.727
> 
> 标签：chuck

ChuckK 中 int 的最大值是多少？它有一个符号常数吗？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-09-19T02:06:08.197

最新版本中的新功能！

```
<<<Math.INT_MAX>>>; 
```

不过作为参考，它使用`long`C++ 中的 " " 关键字来表示整数。所以在 32 位计算机上，最大值应该是`0x7FFFFFFF`, 或`2147483647`. 在 64 位计算机上它将是`0x7FFFFFFFFFFFFFFFFF`, 或`9223372036854775807`.

Kassen 和 Stephen Sinclair 在[chuck-users 邮件列表中](https://lists.cs.princeton.edu/mailman/listinfo/chuck-users)的回答。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T00:59:52.973

[ChucK API 参考](http://chuck.cs.princeton.edu/doc/program/stdlib.html)使用 C`int`类型，因此最大值将取决于您的本地计算机（2^31-1，在标准 32 位 x86 上约为 20 亿）。我没有看到任何对检索限制的引用，但如果 ChucK 可以使用 C 进行扩展，您可以添加一个返回的函数`MAXINT`。

# c# - 如何使用 C# 向文件中插入字符

> ID：98484
> 
> 赞同：13
> 
> 时间：2008-09-19T00:56:05.150
> 
> 标签：c#, .net, file, random-access

我有一个巨大的文件，我必须在特定位置插入某些字符。在 C# 中执行此操作而无需再次重写整个文件的最简单方法是什么。

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-09-19T01:10:35.070

文件系统不支持在文件中间“插入”数据。如果您确实需要可以以某种方式写入的文件，我建议您考虑使用嵌入式数据库。

您可能想看看[SQLite](http://sqlite.org/)或[BerkeleyDB](http://www.oracle.com/technology/products/berkeley-db/index.html)。

再说一次，您可能正在使用文本文件或旧的二进制文件。在这种情况下，您唯一的选择是重写文件，至少从插入点到结尾。

我会看看[FileStream](http://msdn.microsoft.com/en-us/library/system.io.filestream(VS.80).aspx)类在 C# 中执行随机 I/O。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-19T00:58:17.017

您可能需要从插入更改到最后的位置重写文件。您最好始终写入文件末尾并使用诸如排序和 grep 之类的工具以所需的顺序获取数据。我假设您在这里谈论的是文本文件，而不是二进制文件。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T02:06:32.190

没有办法在不重写字符的情况下将字符插入文件。使用 C# 可以使用任何 Stream 类来完成。如果文件很大，我建议您在 C# 代码中使用 GNU Core Utils。他们是最快的。我曾经使用核心工具（大小为 4GB、8GB 或更多等）处理非常大的文本文件。像 head、tail、split、csplit、cat、shuf、shred、uniq 这样的命令确实对文本操作有很大帮助。

例如，如果您需要将一些字符放入 2GB 文件中，您可以使用 split -b BYTECOUNT，将输出放入文件中，将新文本附加到其中，然后获取其余内容并添加到其中。这应该比任何其他方式都快。

希望它有效。试试看。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T01:01:42.703

您可以使用随机访问来写入文件的特定位置，但您无法以文本格式执行此操作，您必须直接使用字节。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2009-01-22T13:46:45.080

如果您知道要将新数据写入的具体位置，请使用 BinaryWriter 类：

```
using (BinaryWriter bw = new BinaryWriter (File.Open (strFile, FileMode.Open)))
{
    string strNewData = "this is some new data";
    byte[] byteNewData = new byte[strNewData.Length];

    // copy contents of string to byte array
    for (var i = 0; i < strNewData.Length; i++)
    {
        byteNewData[i] = Convert.ToByte (strNewData[i]);
    }

    // write new data to file
    bw.Seek (15, SeekOrigin.Begin);  // seek to position 15
    bw.Write (byteNewData, 0, byteNewData.Length);
} 
```

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2016-04-20T15:17:47.980

你可以看看这个项目： [Win Data Inspector](http://windatainspector.codeplex.com/)

基本上，代码如下：

```
// this.Stream is the stream in which you insert data

{

long position = this.Stream.Position;

long length = this.Stream.Length;

MemoryStream ms = new MemoryStream();

this.Stream.Position = 0;

DIUtils.CopyStream(this.Stream, ms, position, progressCallback);

ms.Write(data, 0, data.Length);

this.Stream.Position = position;

DIUtils.CopyStream(this.Stream, ms, this.Stream.Length - position, progressCallback);

this.Stream = ms;

}

#region Delegates

public delegate void ProgressCallback(long position, long total);

#endregion 
```

**DIUtils.cs**

```
public static void CopyStream(Stream input, Stream output, long length, DataInspector.ProgressCallback callback)
{
    long totalsize = input.Length;
    long byteswritten = 0;
    const int size = 32768;
    byte[] buffer = new byte[size];
    int read;
    int readlen = length < size ? (int)length : size;
    while (length > 0 && (read = input.Read(buffer, 0, readlen)) > 0)
    {
        output.Write(buffer, 0, read);
        byteswritten += read;
        length -= read;
        readlen = length < size ? (int)length : size;
        if (callback != null)
            callback(byteswritten, totalsize);
    }
} 
```

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T01:05:42.257

根据您项目的范围，您可能希望决定将每一行文本与您的文件一起插入到**表数据结构中。有点像数据库表**，这样您就可以在任何给定时刻插入到特定位置，而不必每次都读入、修改和输出整个文本文件。这是因为您的数据正如您所说的那样“巨大”。您仍然会重新创建该文件，但至少您以这种方式创建了一个可扩展的解决方案。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-19T01:34:00.877

这可能是“可能的”，具体取决于文件系统如何存储文件以在中间快速插入（即添加额外的）字节。如果远程可行，则可能只能一次完成一个完整的块，并且只能通过对文件系统本身进行低级修改或使用文件系统特定接口来进行。

文件系统通常不是为这种操作而设计的。如果你需要快速插入，你真的需要一个更通用的数据库。

根据您的应用程序，中间立场是将您的插入内容捆绑在一起，因此您只需对文件进行一次重写而不是二十次。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2011-12-08T20:30:13.253

您将始终必须从插入点重写剩余的字节。如果该点为 0，那么您将重写整个文件。如果在最后一个字节之前是 10 个字节，那么您将重写最后 10 个字节。

无论如何，没有直接支持“插入到文件”的功能。但是下面的代码可以准确地做到这一点。

```
var sw = new Stopwatch();
var ab = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ";

// create
var fs = new FileStream(@"d:\test.txt", FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite, 262144, FileOptions.None);
sw.Restart();
fs.Seek(0, SeekOrigin.Begin);
for (var i = 0; i < 40000000; i++) fs.Write(ASCIIEncoding.ASCII.GetBytes(ab), 0, ab.Length);
sw.Stop();
Console.WriteLine("{0} ms", sw.Elapsed.TotalMilliseconds);
fs.Dispose();

// insert
fs = new FileStream(@"d:\test.txt", FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite, 262144, FileOptions.None);
sw.Restart();
byte[] b = new byte[262144];
long target = 10, offset = fs.Length - b.Length;
while (offset != 0)
{
    if (offset < 0)
    {
        offset = b.Length - target;
        b = new byte[offset];
    }
    fs.Position = offset; fs.Read(b, 0, b.Length);
    fs.Position = offset + target; fs.Write(b, 0, b.Length);
    offset -= b.Length;
}
fs.Position = target; fs.Write(ASCIIEncoding.ASCII.GetBytes(ab), 0, ab.Length);
sw.Stop();
Console.WriteLine("{0} ms", sw.Elapsed.TotalMilliseconds); 
```

为了获得更好的文件 IO 性能，请使用上面代码中的“神奇的两个幂数”。文件的创建使用了 262144 字节 (256KB) 的缓冲区，这根本没有帮助。如果您运行代码，则插入的相同缓冲区执行“性能工作”，您可以从 StopWatch 结果中看到。在我的 PC 上进行的草稿测试给出了以下结果：

创建时间为 13628.8 毫秒，插入时间为 3597.0971 毫秒。

请注意，插入的目标字节是 10，这意味着几乎整个文件都被重写了。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2017-05-16T17:03:29.717

为什么不放一个指向文件末尾的指针（字面意思是文件当前大小的四个字节），然后在文件末尾写入插入数据的长度，最后是要插入的数据本身。例如，如果你在文件中间有一个字符串，并且你想在字符串中间插入几个字符，你可以在字符串中的一些四个字符上写一个指向文件末尾的指针，然后写这四个字符与您首先要插入的字符一起。这都是关于订购数据的。当然，只有当您自己编写整个文件时才能这样做，我的意思是您没有使用其他编解码器。

# eclipse - 在 Eclipse 中进行 Subversion 合并的正确方法是什么？

> ID：98489
> 
> 赞同：17
> 
> 时间：2008-09-19T00:57:48.827
> 
> 标签：eclipse, svn, merge, subversive

我很习惯如何在 Eclipse 中进行 CVS 合并，另外我对 Subclipse 和 Subversive 与 SVN 存储库一起工作的方式很满意，但我不太确定如何正确地进行合并。

当我进行合并时，似乎想将合并后的文件粘贴在项目中的单独目录中，而不是像我在 CVS 中习惯的那样覆盖要在合并中替换的旧文件。

这个问题并不特定于 Subclipse 或 Subversive。

谢谢您的帮助！

* * *

## 回答 #1

> 赞同：72
> 
> 时间：2010-02-05T22:06:54.280

**将整个分支合并到主干**

1.  检查分支项目历史以确定分支的版本

    *   默认情况下，Eclipse 团队“历史”仅显示过去 25 次修订，因此您必须单击该视图中标记为“全部显示”的按钮
    *   当您说“全部显示”时，它会带您回到分支日期，并向您显示主干的所有历史记录，因此您必须在分支的位置搜索您的评论
    *   *注意*：如果您将 Tortise SVN 用于同一任务（导航到分支并选择“显示日志”），它将仅显示分支历史记录，以便您可以准确判断分支开始的位置
2.  所以现在我知道 82517 是分支历史的第一个版本 ID。所以 82517 之后的所有分支版本都有我想合并到主干的更改

3.  现在转到 Eclipse 工作区中的“主干”项目并选择“右键单击 - 团队 - 合并”

4.  默认视图是 1 url 合并

    *   选择要合并的分支的 URL
    *   在修订下选择“全部”
    *   按确定
5.  这将带您进入“团队同步”视角（如果不是，您应该自己去那里）以解决冲突（见下文）

**将更多分支更改重新合并到主干中**

1.  检查主干项目历史以确定您上次合并到主干的时间（您应该对此发表评论）

    *   为了争论，假设这个版本是 82517
2.  所以现在我知道分支中任何大于82517的版本都需要合并到trunk

3.  现在转到 Eclipse 工作区中的“主干”项目并选择“右键单击 - 团队 - 合并”

4.  默认视图是 1 url 合并

    *   选择要合并的分支的 URL
    *   在修订下选择“修订”单选按钮，然后单击“浏览”
    *   这将打开最新 25 个分支修订的列表
    *   选择数字大于 82517 的所有修订
    *   按 OK（您应该在单选按钮旁边的输入字段中看到修订列表）
    *   按确定
5.  这将带您进入“团队同步”视角（如果不是，您应该自己去那里）以解决冲突（见下文）

**解决冲突**

1.  您应该处于“团队同步”的角度。这看起来就像任何用于提交目的的常规同步，您会看到新文件和有冲突的文件。

2.  对于您看到冲突的每个文件，选择“右键单击 - 编辑冲突” **（不要双击文件，它会弹出提交差异版本工具，这是非常不同的）**

    *   如果您看到诸如“<<<<<<< .working”或“>>>>>>>> .merge-right.r84513”之类的内容，则说明您处于错误的编辑模式
3.  解决该文件中的所有冲突后，告诉文件“标记为合并”

4.  一旦所有文件都没有冲突，您就可以同步您的 Eclipse 项目并将文件提交到 SVN

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-19T01:03:17.723

我通常检查两个分支，然后使用相互比较选项对两个源树进行类似同步的比较。将更改集成到一个分支后，您可以重新提交回存储库。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-19T01:29:27.067

使用 Eclipse 集成，它工作得非常好。

CVS 的主要变化是您只合并来自一个分支的增量，即从一个修订版更改到另一个修订版。也就是说你必须以某种方式跟踪正确的开始版本（除非你有 svn 1.5 合并历史）

如果您做对了，那么您只能使用比较编辑器进行正确的更改。

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2011-02-25T07:53:35.403

首先，如果您在 Eclipse 中查看文件时在文件中看到“>>>>>”等，这可能意味着您没有使用正确的比较编辑器查看文件。尝试在“项目”视图或“同步”视图中右键单击文件并选择“编辑冲突”以调出一个比较编辑器，该编辑器将以图形而不是文本的形式显示冲突区域。请注意，为“编辑冲突”出现的比较编辑器与您在同步视图中双击文件时获得的不同 - doublieclick 比较编辑器显示当前文件与其存在方式之间的差异当您上次检查或更新它时，编辑冲突比较对话框显示两个更改源之间的差异（例如，

其次，您可能希望了解某些版本的 Eclipse 颠覆性插件中的错误，该错误会导致所有接受合并更改的文件被错误地标记为具有冲突。此错误已修复，但很多人似乎还没有更新以获得修复。更多细节在这里：

[https://bugs.eclipse.org/bugs/show_bug.cgi?id=312585](https://bugs.eclipse.org/bugs/show_bug.cgi?id=312585)

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-23T15:17:01.043

请记住，使用 svn 将修改后的树恢复为干净状态是相当容易的。只需在合并目标分支上有一个干净的工作区并运行合并命令以从合并源分支导入修改，然后同步您的工作区，您将获得通常的 eclipse 比较窗口，显示所有合并修改的文件和冲突。

如果由于某种原因您无法解决冲突，您可以在项目上 svn revert 并返回到干净状态，否则您就地进行合并，完成后您可以提交。请注意，您不必提交，一旦处理完冲突，您还可以返回到开发视图，验证代码是否编译，运行单元测试，然后再次同步并提交（一旦冲突在本地解决了他们不会回来）

上次我查看时，当您使用 subclipse merge 命令时，它会覆盖合并文件（使用冲突标记来显示冲突区域）并将合并的原始左侧和右侧放在同一位置。它不应该将任何东西放在不同的目录中。

根据经验，最好在一次提交中提交所有合并修改，并且只在提交中包含合并修改，以便以后可以在需要时回滚合并。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2010-05-02T01:55:39.790

openCollabNet 的 subclipse 合并工具非常简洁。有许多可用的合并类型，我只是在无缝时使用它执行的合并。我推荐它。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2010-06-03T01:17:07.823

在 Eclipse 中同步视图缺少的一件事是签入功能。在团队同步视图中，我可以查看我的所有更改并解决冲突，因此直接在此处签入而不是返回 Java 视图并进行签入会相当直观。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-19T01:17:04.023

我建议不要尝试使用 Eclipse 的插件作为您对 Subversion 的主要访问。

如果你在 Windows 上开发，TortoiseSVN 是我见过的用于 Subversion 访问的最佳程序。浏览到您要合并的目录，右键单击它并使用 Tortoise SVN 合并选项。假设是非交互式合并，一旦发生冲突，您必须检查每个冲突文件并编辑冲突，然后再将它们标记为已解决。对于这个过程，我推荐一个名为 KDiff3 的程序，它显示您的本地存储库副本（合并之前存储在 .svn 中的内容）、您的本地副本（包括任何更改）以及来自存储库的副本，并允许您很容易看到（如果需要，甚至可以手动修改）合并的结果。它还自动处理一堆小冲突。

KDiff3 是可移植的，TortoiseSVN 是一个 windows shell 扩展，所以如果你使用其他环境，我会尝试只使用 SVN 来合并。但这会更痛苦:)

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2017-11-07T12:37:20.470

我来到这里是因为我正在寻找一种在外部合并编辑器 (KDIFF3) 中合并但从 eclipse 开始合并的方法。我对上面提供的答案不满意。所以这里是如何在 Eclipse 中将 kdiff3 配置为 SVN 的合并和差异编辑器：

转到 Windows -> Preferences → Team -> SVN -> Diff Viewer 添加新配置（添加按钮）：扩展名或 mimetype：* - 如果您希望可以为不同的编辑器指定不同的 mimetype，我不需要，因此阿尔昆特。

**Diff**：程序路径 C:\Program Files\KDiff3\kdiff3.exe （或任何你有合并编辑器的地方 - 对于 windows 路径，请随时在评论中添加 linux 版本或编辑此答案。）

参数：${base} ${mine} ${theirs}

**合并**：程序路径 C:\Program Files\KDiff3\kdiff3.exe

参数：${base} ${mine} ${theirs} -o ${merged}

这可能也适用于其他合并编辑器，但使用不同的参数语法（弄清楚并让我们知道:)）。

用法与往常一样（团队->编辑冲突）用于合并和比较-> foo 用于差异视图。

干杯

# unique - 生成唯一帐号 - 递归调用

> ID：98497
> 
> 赞同：5
> 
> 时间：2008-09-19T00:59:11.163
> 
> 标签：unique, records

嗨，我需要生成 9 位数的唯一帐号。这是我的伪代码：

```
function generateAccNo()

    generate an account number between 100,000,000 and 999,999,999

    if the account number already exists in the DB 
        call generateAccNo()    /* recursive call */
    else
        return new accout number
    end if

end function 
```

该函数似乎运行良好，但是我有点担心递归调用。

这会导致任何内存泄漏（Apache 下的 PHP 5）吗？

这是解决此问题的可接受方法吗？

感谢您的输入。

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-09-19T01:00:50.350

你意识到这很可能会导致堆栈溢出，对吧？随着客户数量的增加，找不到可接受的帐号的概率也会增加。

另外，为什么你不能只做连续的帐号，每次都增加一个？使用这种方法，您只需要读取数据库中当前的最大 id 并增加它。

很抱歉这么直率，但你的解决方案是解决问题的糟糕方法。它会使用大量内存（因为堆栈可能会无限增长），并且会对数据库进行大量昂贵的调用。

**您真的应该考虑其他一些方法：**
我强烈建议您每次创建客户时都增加客户编号。事实上，如果你正确地设置了你的数据库（在 id 列上自动增加），你甚至不必设置 id。每当您插入新客户时，都会为您设置 ID。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-19T01:48:39.300

我真的不认为它归结为递归与循环，随着数据集的增长以及随机数生成未正确实现，两者都容易出现问题。想到两个想法：

. 图形用户界面

如果尽可能少地需要一个真正唯一的 id，请考虑使用 GUID，如果不能在代码中创建一个，您的数据库很可能能够在插入时为您分配。尽管它不是非常用户友好，但它保证是唯一的。但是，结合数据库在插入时生成的顺序 AccountRecordId，您将拥有可靠的组合

. 复合键：随机+顺序

解决所有需求的一种方法，虽然表面上感觉有点笨拙，但是从 5 位（或更多）的顺序 db 密钥创建一个复合帐号，然后再创建一个 5 位随机数。如果随机数重复，则无关紧要，因为顺序 ID 将保证整个帐号的唯一性

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T01:03:30.030

这里不需要使用递归调用。在针对不存在作为条件的功能测试中运行一个简单的while循环，例如

```
function generateAccNo()

    generate an account number between 100,000,000 and 999,999,999

    while ( the account number already exists in the DB ) {
         generate new account number;
    }
    return new account number

end function 
```

但是，如果此代码用于玩具以外的任何东西，则随机生成和测试是生成唯一帐号的次优方法。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T01:03:00.720

看起来不错，但我认为你需要某种死亡条件，在你放弃之前你要让它运行多少次？

我知道这在巨大的数字范围内似乎不太可能，但可能会出现问题，只会让你回到上一个电话，这将再次称自己为恶心。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-19T01:20:41.253

按顺序生成帐号存在安全风险 - 您应该找到其他算法来执行此操作。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-19T01:27:53.233

或者，您可以维护一个单独的表，其中包含一个生成的、已知是唯一的帐号的缓冲区。这个表应该有一个自动递增的整数 id。当您想要一个帐号时，只需拉出缓冲区中索引最低的记录并将其从该表中删除。有一些定期运行的进程来补充缓冲区并确保它有容量>>正常使用。优点是最终用户创建帐号所花费的时间基本上是恒定的。

另外，我应该注意递归或迭代的处理开销或风险，真正的问题是确定性和重复数据库查询的开销。我喜欢 TheZenker 的随机 + 顺序解决方案。保证生成唯一的 id 而不会增加不必要的开销。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T01:02:02.937

您不需要在这里使用递归。一个简单的循环将同样快并且消耗更少的堆栈空间。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-19T01:02:14.887

你可以把它放在一个while循环中：

```
function generateAccNo()

    while (true) {    

      generate an account number between 100,000,000 and 999,999,999

      if the account number already exists in the DB 
          /* do nothing */
      else
          return new accout number
      end if
    }

end function 
```

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-19T01:04:08.720

为什么不：

```
lock_db
do
    account_num <= generate number
while account_num in db

put row with account_num in db

unlock_db 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-19T01:05:35.470

为什么不让数据库处理这个？在 SQL Server 中，您可以只拥有一个从 100000000 开始的标识列。或者您可以在您拥有的任何数据库中使用 sql。只需获取最大 id 加 1。

# serial-number - 如何以编程方式获取设备序列号？

> ID：98516
> 
> 赞同：3
> 
> 时间：2008-09-19T01:02:57.287
> 
> 标签：serial-number

我需要进行设备审核，为此我需要获取 Windows PC、显示器等序列号。

所以我面临着去每台电脑并手动写下数字。

有没有办法我可以通过编程方式获得这个，这样每个用户都可以运行一个小程序并将结果通过电子邮件发送给我？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-19T01:08:19.973

如果此信息在任何地方，它会在 WMI ( [http://en.wikipedia.org/wiki/Windows_Management_Instrumentation](http://en.wikipedia.org/wiki/Windows_Management_Instrumentation) ) 中 - 例如，您可以编写一个 VBscript 脚本来查询此信息并将其保存到服务器上的远程共享.

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T01:15:41.280

一般没有。但是，如果您的计算机都是戴尔的，那么您可能可以获得 PC 本身的一些信息（可能是序列号？）。

如果显示器支持[VESA EDID](http://www.bluechiptechnology.co.uk/products/Mutimedia/Digital_Signage/_guide/Display_Data_Channel_(DDC)_and_Extended_Display_Identification_Data_(EDID)%20standards.pdf)（DDC、EDID、EEDID），它还可能包含一个 32 位序列号 - 这可能与显示器标签上打印的序列号有任何关系，也可能没有任何关系。您可以通过显示驱动程序访问它 - Windows 可以访问它的一部分（以显示监视器分辨率和时间），所以我希望制造商/型号/序列号也隐藏在某个地方。

然而，制作这样一个可以在所有系统和监视器上运行的程序可能比简单地去每个站并记录它要多得多，除非所有系统都具有相同的硬件。

祝你好运！

-亚当

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T01:09:59.423

我不太确定这是否正是您想要的，但是[DameWare](http://www.dameware.com/)制作的付费软件可以让您轻松远程连接到其他机器并获取大量信息。我还没有太多使用它，但我认为有一种方法可以制作批处理脚本，这样它就可以为你提取类似的信息，或者查看机器上安装了哪些应用程序。更糟糕的情况是，您不必跑到每台机器上。（我假设您的意思是像 MS 产品 ID 这样的 SN）

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T01:12:33.347

WMI 绝对是要走的路。您可以通过该 API 获得相当多的有用审计信息。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2009-06-18T01:45:01.030

Michael Baird 似乎编写了一个 VBS 脚本来读取 EDID 信息。该脚本从注册表中读取并解析监视器 EDID 信息，以检索资产信息。

[http://cwashington.netreach.net/depo/view.asp?Index=980&ScriptType=vbscript](http://cwashington.netreach.net/depo/view.asp?Index=980&ScriptType=vbscript)

# c# - 如何将十六进制值解析为 uint？

> ID：98559
> 
> 赞同：80
> 
> 时间：2008-09-19T01:12:01.337
> 
> 标签：c#

```
uint color; 
bool parsedhex = uint.TryParse(TextBox1.Text, out color); 
//where Text is of the form 0xFF0000
if(parsedhex)
   //... 
```

不起作用。我究竟做错了什么？

* * *

## 回答 #1

> 赞同：127
> 
> 时间：2008-09-19T01:14:31.893

尝试

```
Convert.ToUInt32(hex, 16)  //Using ToUInt32 not ToUInt64, as per OP comment 
```

* * *

## 回答 #2

> 赞同：51
> 
> 时间：2008-09-19T01:19:05.563

您可以使用重载`TryParse()`，它将 NumberStyle 参数添加到`TryParse`提供十六进制值解析的调用中。使用`NumberStyles.HexNumber`which 允许您将字符串作为十六进制数字传递。

**注意**：问题`NumberStyles.HexNumber`在于它*不*支持解析带有前缀的值（即`0x`、`&H`或`#`），因此您必须在尝试解析值之前将其剥离。

基本上你会这样做：

```
uint color;
var hex = TextBox1.Text;

if (hex.StartsWith("0x", StringComparison.CurrentCultureIgnoreCase) ||
    hex.StartsWith("&H", StringComparison.CurrentCultureIgnoreCase)) 
{
    hex = hex.Substring(2);
}

bool parsedSuccessfully = uint.TryParse(hex, 
        NumberStyles.HexNumber, 
        CultureInfo.CurrentCulture, 
        out color); 
```

有关如何使用 NumberStyles 枚举的示例，请参阅[TryParse(String, NumberStyles, IFormatProvider, Int32)的文档。](https://docs.microsoft.com/en-us/dotnet/api/system.int32.tryparse?view=net-5.0#System_Int32_TryParse_System_String_System_Globalization_NumberStyles_System_IFormatProvider_System_Int32__)

* * *

## 回答 #3

> 赞同：16
> 
> 时间：2008-09-19T01:18:36.640

或者喜欢

```
string hexNum = "0xFFFF";
string hexNumWithoutPrefix = hexNum.Substring(2);

uint i;
bool success = uint.TryParse(hexNumWithoutPrefix, System.Globalization.NumberStyles.HexNumber, null, out i); 
```

* * *

## 回答 #4

> 赞同：6
> 
> 时间：2013-10-10T17:06:15.613

这是一个尝试解析样式的函数：

```
 private static bool TryParseHex(string hex, out UInt32 result)
    {
        result = 0;

        if (hex == null)
        {
            return false;
        }

        try
        {
            result = Convert.ToUInt32(hex, 16);

            return true;
        }
        catch (Exception exception)
        {
            return false;
        }
    } 
```

# c++ - 我在哪里可以找到世界上最快的 atof 实施？

> ID：98586
> 
> 赞同：20
> 
> 时间：2008-09-19T01:17:55.317
> 
> 标签：c++, c, performance, assembly, floating-point

我正在寻找针对美国英语语言环境、ASCII 和非科学记数法优化的 IA32 上极快的 atof() 实现。windows 多线程 CRT 在每次调用 isdigit() 时都会检查语言环境的变化，因此在这里很糟糕。我们目前的最佳表现源自 perl + tcl 的 atof 实现中的最佳表现，其性能比 msvcrt.dll 的 atof 高出一个数量级。我想做得更好，但我没有想法。BCD 相关的 x86 指令似乎很有希望，但我无法让它胜过 perl/tcl C 代码。任何 SO'ers 都可以挖掘到最好的链接吗？也欢迎基于非 x86 汇编的解决方案。

基于初步答案的澄清：

对于此应用程序，~2 ulp 的不准确性很好。
要转换的数字将小批量通过网络以 ascii 消息的形式到达，我们的应用程序需要以尽可能低的延迟进行转换。

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-09-19T02:26:15.450

你的精度要求是什么？如果你真的需要它“正确”（总是得到最接近指定小数的浮点值），可能很难击败标准库版本（除了删除你已经完成的语言环境支持），因为这需要进行任意精度算术。如果您愿意容忍一两个 ulp 的错误（并且比次规范的错误更多），那么 cruzer 提出的这种方法可以工作并且可能更快，但它绝对不会产生 <0.5ulp 的输出。您将在分别计算整数和小数部分的准确性方面做得更好，并在最后计算分数（例如，对于 12345.6789，将其计算为 12345 + 6789 / 10000.0，而不是 6*.1 + 7*.01 + 8 *.001 + 9*0.0001) 从 0 开始。1 是一个无理二进制分数，当您计算 0.1^n 时，误差会迅速累积。这也使您可以使用整数而不是浮点数来完成大部分数学运算。

自（IIRC）286以来，BCD指令还没有在硬件中实现，现在只是微编码。它们不太可能具有特别高的性能。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2011-11-14T12:53:10.113

我刚刚完成编码的这个实现的运行速度是我桌面上内置的“atof”的两倍。它在 2 秒内转换 1024*1024*39 数字输入，而我系统的标准 gnu 'atof' 需要 4 秒。（包括设置时间和获取内存等等）。

**更新：** 对不起，我必须撤销我两倍快的索赔。如果你要转换的东西已经在一个字符串中，它会更快，但是如果你传递的是硬编码的字符串文字，它与 atof 大致相同。但是，我将把它留在这里，因为可能通过对 ragel 文件和状态机进行一些调整，您可能能够为特定目的生成更快的代码。

[https://github.com/matiu2/yajp](https://github.com/matiu2/yajp)

对您来说有趣的文件是：

[https://github.com/matiu2/yajp/blob/master/tests/test_number.cpp](https://github.com/matiu2/yajp/blob/master/tests/test_number.cpp)

[https://github.com/matiu2/yajp/blob/master/number.hpp](https://github.com/matiu2/yajp/blob/master/number.hpp)

您也可能对进行转换的状态机感兴趣：

[![号码解析状态机图](https://i.stack.imgur.com/ntLTP.png)](https://i.stack.imgur.com/ntLTP.png)

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2012-05-03T04:18:13.693

在我看来，您想（手动）构建相当于每个状态处理第 N 个输入数字或指数数字的状态机；这个状态机的形状像一棵树（没有循环！）。目标是尽可能进行整数运算，并且（显然）隐式记住状态中的状态变量（“前导减号”、“位置 3 的小数点”），以避免分配、存储和以后获取/测试这些值. 仅在输入字符上使用普通的旧“if”语句实现状态机（因此您的树将成为一组嵌套的 if）。对缓冲区字符的内联访问；您不希望函数调用`getchar`减慢您的速度。

可以简单地抑制前导零；你可能需要一个循环来处理非常长的前导零序列。无需将累加器归零或乘以十即可收集第一个非零数字。前 4-9 个非零数字（对于 16 位或 32 位整数）可以通过整数乘以常数值 10 来收集（大多数编译器将其转换为几次移位和加法）。[在顶部：零位不需要任何工作，直到找到一个非零位，然后需要 N 个连续零的乘法 10^N；您可以将所有这些连接到状态机]。前 4-9 之后的数字可以使用 32 位或 64 位乘法来收集，具体取决于您机器的字长。由于您不关心准确性，因此您可以在收集 32 或 64 位价值后简单地忽略数字；一世' 根据您的应用程序对这些数字的实际操作，猜测当您有一些固定数量的非零数字时，您实际上可以停止。在数字字符串中找到的小数点只会导致状态机树中的分支。该分支知道该点的隐含位置，因此以后如何适当地按 10 的幂进行缩放。如果您不喜欢这段代码的大小，您可以通过努力组合一些状态机子树。

[在顶部：将整数和小数部分保留为单独的（小）整数。这将需要在最后进行额外的浮点运算来组合整数和小数部分，可能不值得]。

[在顶部：将数字对的 2 个字符收集到一个 16 位值中，查找 16 位值。这避免了寄存器中的乘法以换取内存访问，这在现代机器上可能不是一个胜利]。

在遇到“E”时，如上所述将指数收集为整数；在预先计算的乘数表中查找准确的预先计算/缩放的 10 次幂（如果指数中存在“-”符号，则为倒数）并将收集的尾数相乘。（永远不要做浮点除法）。由于每个指数收集例程都位于树的不同分支（叶）中，因此它必须通过偏移 10 指数的幂来调整小数点的明显或实际位置。

`ptr++`[顶部：如果您知道数字的字符线性存储在缓冲区中并且不跨越缓冲区边界，则可以避免成本。在沿着树枝的第 k 个状态中，您可以将第 k 个字符访问为`*(start+k)`. 一个好的编译器通常可以在寻址模式下将“...+k”隐藏在索引偏移中。]

如果做得对，该方案对每个非零数字进行大约一次廉价的乘加，尾数转换为浮点数，以及通过指数和小数点位置缩放结果的浮点乘法。

我还没有实现上述。我已经用循环实现了它的版本，它们非常快。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2009-10-28T16:20:40.910

我已经实现了一些你可能会觉得有用的东西。与 atof 相比，它的速度大约是 x5，如果与 atof 一起使用，`__forceinline`速度大约是 x10。另一件好事是它似乎与 crt 实现具有完全相同的算术。当然它也有一些缺点：

*   它只支持单精度浮点数，
*   并且不扫描任何特殊值，如#INF 等......

```
__forceinline bool float_scan(const wchar_t* wcs, float* val)
{
int hdr=0;
while (wcs[hdr]==L' ')
    hdr++;

int cur=hdr;

bool negative=false;
bool has_sign=false;

if (wcs[cur]==L'+' || wcs[cur]==L'-')
{
    if (wcs[cur]==L'-')
        negative=true;
    has_sign=true;
    cur++;
}
else
    has_sign=false;

int quot_digs=0;
int frac_digs=0;

bool full=false;

wchar_t period=0;
int binexp=0;
int decexp=0;
unsigned long value=0;

while (wcs[cur]>=L'0' && wcs[cur]<=L'9')
{
    if (!full)
    {
        if (value>=0x19999999 && wcs[cur]-L'0'>5 || value>0x19999999)
        {
            full=true;
            decexp++;
        }
        else
            value=value*10+wcs[cur]-L'0';
    }
    else
        decexp++;

    quot_digs++;
    cur++;
}

if (wcs[cur]==L'.' || wcs[cur]==L',')
{
    period=wcs[cur];
    cur++;

    while (wcs[cur]>=L'0' && wcs[cur]<=L'9')
    {
        if (!full)
        {
            if (value>=0x19999999 && wcs[cur]-L'0'>5 || value>0x19999999)
                full=true;
            else
            {
                decexp--;
                value=value*10+wcs[cur]-L'0';
            }
        }

        frac_digs++;
        cur++;
    }
}

if (!quot_digs && !frac_digs)
    return false;

wchar_t exp_char=0;

int decexp2=0; // explicit exponent
bool exp_negative=false;
bool has_expsign=false;
int exp_digs=0;

// even if value is 0, we still need to eat exponent chars
if (wcs[cur]==L'e' || wcs[cur]==L'E')
{
    exp_char=wcs[cur];
    cur++;

    if (wcs[cur]==L'+' || wcs[cur]==L'-')
    {
        has_expsign=true;
        if (wcs[cur]=='-')
            exp_negative=true;
        cur++;
    }

    while (wcs[cur]>=L'0' && wcs[cur]<=L'9')
    {
        if (decexp2>=0x19999999)
            return false;
        decexp2=10*decexp2+wcs[cur]-L'0';
        exp_digs++;
        cur++;
    }

    if (exp_negative)
        decexp-=decexp2;
    else
        decexp+=decexp2;
}

// end of wcs scan, cur contains value's tail

if (value)
{
    while (value<=0x19999999)
    {
        decexp--;
        value=value*10;
    }

    if (decexp)
    {
        // ensure 1bit space for mul by something lower than 2.0
        if (value&0x80000000)
        {
            value>>=1;
            binexp++;
        }

        if (decexp>308 || decexp<-307)
            return false;

        // convert exp from 10 to 2 (using FPU)
        int E;
        double v=pow(10.0,decexp);
        double m=frexp(v,&E);
        m=2.0*m;
        E--;
        value=(unsigned long)floor(value*m);

        binexp+=E;
    }

    binexp+=23; // rebase exponent to 23bits of mantisa

    // so the value is: +/- VALUE * pow(2,BINEXP);
    // (normalize manthisa to 24bits, update exponent)
    while (value&0xFE000000)
    {
        value>>=1;
        binexp++;
    }
    if (value&0x01000000)
    {
        if (value&1)
            value++;
        value>>=1;
        binexp++;
        if (value&0x01000000)
        {
            value>>=1;
            binexp++;
        }
    }

    while (!(value&0x00800000))
    {
        value<<=1;
        binexp--;
    }

    if (binexp<-127)
    {
        // underflow
        value=0;
        binexp=-127;
    }
    else
    if (binexp>128)
        return false;

    //exclude "implicit 1"
    value&=0x007FFFFF;

    // encode exponent
    unsigned long exponent=(binexp+127)<<23;
    value |= exponent;
}

// encode sign
unsigned long sign=negative<<31;
value |= sign;

if (val)
{
    *(unsigned long*)val=value;
}

return true;
} 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-19T02:06:52.640

我记得我们有一个 Winforms 应用程序在解析一些数据交换文件时执行得很慢，我们都认为这是 db 服务器抖动，但我们聪明的老板实际上发现瓶颈在于将解析的字符串转换为的调用小数点！

最简单的方法是对字符串中的每个数字（字符）进行循环，保持一个运行总数，将总数乘以 10，然后加上下一个数字的值。继续这样做，直到到达字符串的末尾或遇到一个点。如果遇到点，请将整数部分与小数部分分开，然后有一个乘数，每个数字除以 10。继续添加它们。

示例：123.456

running total = 0，加 1（现在是 1） running total = 1 * 10 = 10，加 2（现在是 12） running total = 12 * 10 = 120，加 3（现在是 123）遇到点，准备小数部分乘数 = 0.1，乘以 4，得到 0.4，加到总和，使 123.4 乘数 = 0.1 / 10 = 0.01，乘以 5，得到 0.05，加到总和，使 123.45 乘数 = 0.01 / 10 = 0.001，乘以 6，得到 0.006，加到总和，得到 123.456

当然，测试数字的正确性以及负数会使其更加复杂。但是，如果您可以“假设”输入是正确的，那么您可以使代码更简单、更快。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-19T02:39:55.477

您是否考虑过让 GPU 来完成这项工作？如果您可以将字符串加载到 GPU 内存中并让它全部处理它们，您可能会找到一个运行速度比处理器快得多的好算法。

或者，在 FPGA 中进行 - 您可以使用 FPGA PCI-E 板来制作任意协处理器。使用 DMA 将 FPGA 指向包含要转换的字符串数组的内存部分，并让它快速浏览它们，将转换后的值留在后面。

你看过四核处理器吗？在大多数情况下，真正的瓶颈是内存访问......

-亚当

# automation - 最好的 AutoHotKey 宏？

> ID：98597
> 
> 赞同：23
> 
> 时间：2008-09-19T01:20:50.440
> 
> 标签：automation, macros

我将 AutoHotKey 用于 Windows 宏。我最常使用它来定义启动/聚焦特定应用程序的热键，以及将即时电子邮件消息发送到我的 ToDo 列表的热键。我还有一个紧急情况，它会杀死我所有占用大量内存的大型应用程序（Outlook、Firefox 等）。

那么，有没有人有好的 AHK 宏可以分享？

* * *

## 回答 #1

> 赞同：14
> 
> 时间：2008-09-19T09:09:14.327

非常简单和有用的片段：

```
SetTitleMatchMode RegEx ;
; Stuff to do when Windows Explorer is open
;
#IfWinActive ahk_class ExploreWClass|CabinetWClass
    ; create new folder
    ;
    ^!n::Send !fwf

    ; create new text file
    ;
    ^!t::Send !fwt

    ; open 'cmd' in the current directory
    ;
    ^!c::
        OpenCmdInCurrent()
    return
#IfWinActive

; Opens the command shell 'cmd' in the directory browsed in Explorer.
; Note: expecting to be run when the active window is Explorer.
;
OpenCmdInCurrent()
{
    WinGetText, full_path, A  ; This is required to get the full path of the file from the address bar

    ; Split on newline (`n)
    StringSplit, word_array, full_path, `n
    full_path = %word_array1%   ; Take the first element from the array

    ; Just in case - remove all carriage returns (`r)
    StringReplace, full_path, full_path, `r, , all  
    full_path := RegExReplace(full_path, "^Address: ", "") ;

    IfInString full_path, \
    {
        Run, cmd /K cd /D "%full_path%"
    }
    else
    {
        Run, cmd /K cd /D "C:\ "
    }
} 
```

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2012-03-04T12:55:51.840

这是一个如此简单但有用的脚本：

```
^SPACE::  Winset, Alwaysontop, , A 
```

使用 CTRL + Space 将任何窗口设置为始终位于顶部。

* * *

## 回答 #3

> 赞同：9
> 
> 时间：2010-02-25T02:59:42.783

在选定的文本/单词上添加引号在
编写电子邮件或编码期间很有用...

双击单词，按 Win+X，周围有引号

```
; Win + X
#x:: ; Attention:  Strips formatting from the clipboard too!
Send ^c
clipboard = "%clipboard%"
; Remove space introduced by WORD
StringReplace, clipboard, clipboard,%A_SPACE%",", All
Send ^v
return 
```

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2009-04-23T07:15:24.920

; 我的开始菜单中有这个，这样重启电脑后戴上耳机就不会损坏耳朵

```
sleep, 5000
SoundSet, 1.5 ; really low volume 
```

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2010-02-25T02:57:04.253

我使用 AutoHotKey创建新的**Outlook对象**

; Win+Shift+M = 新电子邮件

```
#+m::  Run "mailto:" 
```

; 外表

```
#^M::  Run "%ProgramFiles%\Microsoft Office\Office12\OUTLOOK.EXE" /recycle 
```

; Win+Shift+A = 创建新的日历约会

```
#+A::  Run "%ProgramFiles%\Microsoft Office\Office12\OUTLOOK.EXE"/c ipm.appointment 
```

; Win+Shift+T = 创建新任务；Win+Shift+K = 新任务

```
#+T::  Run "%ProgramFiles%\Microsoft Office\Office12\OUTLOOK.EXE"/c ipm.task
#+K::  Run "%ProgramFiles%\Microsoft Office\Office12\OUTLOOK.EXE"/c ipm.task 
```

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2011-03-17T08:14:08.140

这是一个非常简单的片段，可以使用鼠标按钮快速关闭当前窗口。

这是您在 Windows 中最常执行的操作之一，您会惊讶于不再需要为那个小 X 拍摄而节省了多少时间。使用 5 键鼠标，我发现这是一个非常有用的重新分配“前进”按钮。

```
#IfWinActive  ;Close active window when mouse button 5 is pressed
  XButton2::
    SendInput {Alt Down}{F4}{Alt Up}
    Return
#IfWinActive 
```

考虑到使用选项卡式文档的程序（如网络浏览器），这里有一个更全面的版本：

```
;-----------------------------------------------------------------------------
; Bind Mouse Button 5 to Close Tab / Close Window command
;-----------------------------------------------------------------------------

; Create a group to hold windows which will use Ctrl+F4 instead of Alt+F4
GroupAdd, CtrlCloseGroup, ahk_class IEFrame             ; Internet Explorer
GroupAdd, CtrlCloseGroup, ahk_class Chrome_WidgetWin_0  ; Google Chrome
; (Add more programs that use tabbed documents here)
Return

; For windows in above group, bind mouse button to Ctrl+F4
#IfWinActive, ahk_group CtrlCloseGroup
  XButton2::
    SendInput {Ctrl Down}{F4}{Ctrl Up}
    Return
#IfWinActive  

; For everything else, bind mouse button to Alt+F4
#IfWinActive
  XButton2::
    SendInput {Alt Down}{F4}{Alt Up}
    Return
#IfWinActive  

; In FireFox, bind to Ctrl+W instead, so that the close command also works
; on the Downloads window.
#IfWinActive, ahk_class MozillaUIWindowClass
  XButton2::
    SendInput {Ctrl Down}w{Ctrl Up}
    Return
#IfWinActive 
```

Visual Studio 2010 不能轻易添加到`CtrlCloseGroup`上面，因为它的窗口类/标题不容易预测（我认为）。这是我用来处理它的片段，包括几个额外的有用绑定：

```
SetTitleMatchMode, 2  ; Move this line to the top of your script

;-----------------------------------------------------------------------------
; Visual Studio 2010
;-----------------------------------------------------------------------------

#IfWinActive, Microsoft Visual Studio

  ; Make the middle mouse button jump to the definition of any token
  MButton::
    Click Left  ; put the cursor where you clicked
    Send {Shift Down}{F2}{Shift Up}
    Return

  ; Make the Back button on the mouse jump you back to the previous area
  ; of code you were working on.
  XButton1::
    Send {Ctrl Down}{Shift Down}{F2}{Shift Up}{Ctrl Up}
    Return

  ; Bind the Forward button to close the current tab
  XButton2::
    SendInput {Ctrl Down}{F4}{Ctrl Up}
    Return

#IfWinActive 
```

我还发现在 Outlook 中将 ALT+1、ALT+2 等映射到我编写的宏很有用，这些宏将当前选定的消息移动到特定文件夹（例如“个人归档”、“工作归档”等）但这有点复杂。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-19T02:16:32.413

AutoHotKey 论坛中有很多不错的：

[http://www.autohotkey.com/forum/forum-2.html&sid=8149586e9d533532ea76e71e8c9e5b7b](http://www.autohotkey.com/forum/forum-2.html&sid=8149586e9d533532ea76e71e8c9e5b7b)

有多好？真的取决于你想要/需要什么。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-19T09:24:53.930

我一直使用这个，通常是为了快速访问 MySQL 命令行。

[http://lifehacker.com/software/featured-windows-download/make-a-quake+style-command-prompt-with-autohotkey-297607.php](http://lifehacker.com/software/featured-windows-download/make-a-quake+style-command-prompt-with-autohotkey-297607.php)

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2013-01-22T09:21:14.847

修复在“确认文件替换”对话框顶部出现“正在复制”对话框时将文件复制到 FTP 服务器的问题（非常烦人）：

```
SetTimer, FocusOnWindow, 500
return

FocusOnWindow:
IfWinExist, Confirm File Replace
    WinActivate
return 
```

一种停用无用的大写锁定键：

```
Capslock::
return 
```

CTRL + shift + c 将光标下方的颜色复制到剪贴板（十六进制）

```
^+c::
MouseGetPos,x,y
PixelGetColor,rgb,x,y,RGB
StringTrimLeft,rgb,rgb,2
Clipboard=%rgb%
Return 
```

在活动字段中写下您的电子邮件地址（Win 键 + m）

```
#m::
Send, my@email.com{LWINUP}
Sleep, 100
Send, {TAB}
return 
```

# .net - 最喜欢的 Visual Studio 键盘快捷键

> ID：98606
> 
> 赞同：336
> 
> 时间：2008-09-19T01:22:57.957
> 
> 标签：.net, visual-studio, keyboard-shortcuts

你最喜欢的 Visual Studio 键盘快捷键是什么？我总是愿意把手放在键盘上，远离鼠标！

**请每个答案**一个。****

 *** * *

## 回答 #1

> 赞同：227
> 
> 时间：2008-09-19T01:50:32.400

`Ctrl`+`-`和相反的`Ctrl`+ `Shift`+ `-`。

将光标向后（或向前）移动到上一个位置。无需再向后滚动或`PgUp`/`PgDown`找出您所在的位置。

这会在 Visual Studio 中切换打开的窗口：

`Ctrl`+`tab`和相反的`Ctrl`+ `Shift`+`tab`

* * *

## 回答 #2

> 赞同：130
> 
> 时间：2008-09-19T05:36:18.767

对我来说，自动完成代码、匹配括号或显示一些花哨的工具面板无关紧要。相反，它只是*让我看到代码。*

由于您周围有所有面板，您用于实际编写代码的区域变得太小了。

在这种情况下，`Shift`++会`Alt`派上`Enter`用场，让代码窗口在*全屏*模式下成为焦点。再次点击它，您将恢复所有面板。

* * *

## 回答 #3

> 赞同：124
> 
> 时间：2008-09-19T02:02:17.503

增量搜索 - `Ctrl`+`I`

它基本上是没有对话框的查找对话框。只需开始输入您要搜索的内容（查看底部状态栏位置以查看您输入的内容）。再次按`Ctrl`+`I`或`F3`搜索下一个实例。按 Escape 退出。按两次`Ctrl`+开始新搜索`I`会重复上次搜索。

* * *

## 回答 #4

> 赞同：98
> 
> 时间：2008-09-19T01:30:11.963

展开智能标签（解决菜单）：`Ctrl`+ `.`（句点）

展开在您执行重命名标识符等操作时显示的标记。

* * *

## 回答 #5

> 赞同：95
> 
> 时间：2008-09-19T03:25:28.490

`Ctrl`+ `K`, `Ctrl`+`C`评论区块

`Ctrl`+ `K`, `Ctrl`+`U`取消评论区块

* * *

## 回答 #6

> 赞同：77
> 
> 时间：2008-09-19T01:25:41.553

股票Visual Studio？`F12`-*编辑.GoToDefinition*。

拥有 DevExpress 的重构！安装意味着`Ctrl`+```是我一直以来的最爱；）

* * *

## 回答 #7

> 赞同：71
> 
> 时间：2008-09-19T01:51:26.763

“片段”的`TAB`关键。

例如，键入`try`，然后按两次 Tab 键。

结果是：

```
try 
{           

}
catch (Exception)
{

    throw;
} 
```

然后你可以扩展它。

C# 片段的完整列表：http: [//msdn.microsoft.com/en-us/library/vstudio/z41h7fat.aspx](http://msdn.microsoft.com/en-us/library/vstudio/z41h7fat.aspx)

* * *

## 回答 #8

> 赞同：61
> 
> 时间：2008-09-19T02:30:41.240

`Ctrl`+`]`用于匹配大括号和括号。

`Ctrl`++选择匹配括号之间的代码`Shift`。`]`

* * *

## 回答 #9

> 赞同：60
> 
> 时间：2008-09-19T03:34:39.653

`Ctrl`+`Shift` +`F`

好旧的*在文件中查找*。

* * *

## 回答 #10

> 赞同：51
> 
> 时间：2008-09-19T10:30:31.900

`Ctrl`+ `Space`，Visual Studio 给出了可能的补全。

* * *

## 回答 #11

> 赞同：47
> 
> 时间：2008-09-19T01:23:44.913

`Ctrl`+ `K`*,* `Ctrl` + `D`// 自动（重新）格式化

另请参阅：[答案](https://stackoverflow.com/questions/26452/visual-studio-2005-shortcuts#36666)

* * *

## 回答 #12

> 赞同：43
> 
> 时间：2008-09-19T03:48:33.020

`Ctrl`+ `C`, `Ctrl`+`V`复制当前行

`Ctrl`+`L`删除当前行

`Ctrl`+`F3`搜索当前选择

`Ctrl`+ `K`, `Ctrl`+`K`创建书签（很有用）

`Ctrl`+ `K`, `Ctrl`+`N`转到下一个书签

而且，这里还有一些更有趣的东西：
按`Ctrl`+`/`将光标放入可以键入命令的框中。

例如，按`Ctrl`+`/`并输入“>of”，现在开始在您的项目中输入文件的名称，它将自动完成。这是在当前解决方案中打开文件的一种非常快速的方法。

* * *

## 回答 #13

> 赞同：40
> 
> 时间：2008-09-19T05:04:53.383

`Ctrl`++`Shift`粘贴`V`/循环通过剪贴板环

* * *

## 回答 #14

> 赞同：34
> 
> 时间：2008-11-10T03:28:32.627

`Shift`+`ESC`

这会隐藏/关闭 Visual Studio 中的任何“假窗口”窗口。这包括解决方案资源管理器、对象浏览器、输出窗口、立即窗口、单元测试窗口等，并且无论它们是固定的、浮动的、可停靠的还是选项卡式的，仍然适用。

进入窗口的快捷方式（例如`Ctrl`++或`Alt`++ ）做你需要做的事情，然后+摆脱它。如果你不摆脱它，让它再次获得焦点的唯一方法是使用相同的键盘快捷键（或鼠标，这是我们试图避免的......）`L``Ctrl``Alt``I``Shift``Esc`

一旦掌握了窍门，它就非常有用。

* * *

*Grrr ....在我发现这个之前，点击`Ctrl`+`F4`关闭“窗口”只是为了看到我当前的代码窗口关闭的次数太疯狂了，现在它只是偶尔发生..*

* * *

## 回答 #15

> 赞同：34
> 
> 时间：2008-09-19T01:24:05.317

我喜欢`Ctrl`+ `M`，`Ctrl`+ `M`。展开/折叠当前代码块。

* * *

## 回答 #16

> 赞同：34
> 
> 时间：2008-09-19T01:26:30.740

我经常使用但其他人很少使用的一种是：

> `Shift`+ `Alt`+`F10`然后`Enter`

如果您键入类名`Collection<string>`，但没有正确的命名空间导入，则此快捷方式组合将自动插入导入（而插入符号紧跟在“>”之后）。

**更新：**

来自对此答案的评论的等效快捷方式（感谢[asterite](https://stackoverflow.com/users/20459/asterite)！）：

> `Ctrl`+`.`

比我原来的推荐舒服多了。

* * *

## 回答 #17

> 赞同：24
> 
> 时间：2009-03-10T22:59:37.453

Visual Studio 2005/2008 键绑定海报：

*   [Visual C# 2008 键绑定参考海报](http://www.microsoft.com/downloads/details.aspx?FamilyID=E5F902A8-5BB5-4CC6-907E-472809749973&displaylang=en)
*   [Visual C# 2005 键盘快捷键参考海报](http://www.microsoft.com/downloads/details.aspx?familyid=C15D210D-A926-46A8-A586-31F8A2E576FE&displaylang=en)
*   [Visual Basic 2008 键绑定参考海报](http://www.microsoft.com/downloads/details.aspx?familyid=255b8cf1-f6bd-4b55-bb42-dd1a69315833&displaylang=en)
*   [Visual Basic 2005 键盘快捷键参考海报](http://www.microsoft.com/downloads/details.aspx?familyid=6BB41456-9378-4746-B502-B4C5F7182203&displaylang=en)

这些不包括自定义，但它们是很好的参考资料，绝对有助于找到新的快捷方式。

此外，将所有当前绑定转储到 HTML 文件的宏：

[http://www.codinghorror.com/blog/archives/000315.html](http://www.codinghorror.com/blog/archives/000315.html)

* * *

## 回答 #18

> 赞同：24
> 
> 时间：2008-09-19T01:59:32.237

我最喜欢的：（`F12`转到定义）和`Shift`+ `F12`（查找参考资料）。后者对（转到下一个结果）

很有用。`F8`

`Ctrl`+`-`和`Ctrl`+ `Shift`+`-`映射到我鼠标的后退和前进按钮。

`Ctrl`+`.`也很有用，特别是对于添加事件处理程序和“使用”语句。

* * *

## 回答 #19

> 赞同：22
> 
> 时间：2008-11-10T03:31:30.060

`Alt`+ `Shift`+箭头键( `←`, `↑`, `↓`, `→`)

这使您可以选择块中的内容。例如，您可以选择块中的所有“int”，然后搜索并替换为 double。

```
**int** x = 1;
**int** y = 2;
**int** z = 3; 
```

* * *

## 回答 #20

> 赞同：19
> 
> 时间：2008-09-19T01:24:32.257

[在解决方案资源管理器](http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Other_tools)中打开并设置焦点：`Ctrl`++`Alt``L`

* * *

## 回答 #21

> 赞同：19
> 
> 时间：2008-09-19T03:01:53.477

`Ctrl`+ `M`, `O`. 可以折叠和展开特定文件中的所有代码部分。

* * *

## 回答 #22

> 赞同：18
> 
> 时间：2008-09-19T03:34:25.473

其他编辑应该使用的一个： +`Ctrl`没有*选择任何内容*将复制当前行。 大多数其他编辑将什么都不做。复制一行后，粘贴会将这一行放在当前行之前，`C` **即使您位于该行的中间*。大多数其他编辑器将从您所在的位置开始粘贴，这几乎不是您想要的。*

 *复制一行只是：按住 Ctrl，按 c，然后按 v。 ( `Ctrl`+ `C`, `Ctrl`+ `V`)

* * *

## 回答 #23

> 赞同：17
> 
> 时间：2008-09-19T03:00:04.603

`CTRL`+ `F5`（不调试就开始）

`CTRL`+ `SHIFT`+ `B`（构建解决方案）

* * *

## 回答 #24

> 赞同：14
> 
> 时间：2009-09-17T20:24:44.230

这是我经常使用的列表：

`Ctrl`+ `I`：用于渐进式搜索。如果您在 之后没有输入任何内容`I`，并一直按`I`（按住`Ctrl`键），它将搜索您搜索的最后一个项目。`Ctrl`++`Shift`将`I`反向搜索。一旦输入了一些搜索字符串，您可能还想使用`F3`(和`Shift`+ )。`F3`

`Ctrl`+ `K` `Ctrl`+ `C`：用于评论突出显示的区域。如果没有突出显示，则当前行将被注释。当然，您可以连续按住`Ctrl`并按。`K``C`

`Ctrl`+ `K` `Ctrl`+ `U`：用于取消注释突出显示的区域。像上面一样工作。

`Ctrl`+ `/`：将光标移至顶部的小搜索框。您可以键入**“文件名”**（不带引号）来打开文件。如果您的项目包含多个文件，则非常有用。

`Ctrl`++ `K` `Ctrl`：`K`将书签当前行。如果您想暂时查看代码的其他部分并返回到原来的位置，这将很有用。

`Ctrl`+ `K` `Ctrl`+ `N`：如果有多个书签，将带您到下一个书签。

`Ctrl`+ `-`: 将光标移动到之前的位置

`Ctrl`+ `Shift`+ `-`：将光标带到下一个位置（如果存在）

`Ctrl`+ `Shift`+ `B`: 构建你的项目

`Ctrl`+ `C`：虽然这是通常的复制，但如果没有突出显示，它会复制当前行。`Ctrl`+相同`X`（用于剪切）

`Ctrl`+ `Space`: 使用 IntelliSense 自动完成

`Ctrl`+ `]`：将带您到匹配的大括号。适用于各种大括号：'('、'{'、'['。对大块很有用。

`F12`: 将带你到函数定义/变量定义。

`Alt`+ `P`+ `P`：将打开项目属性。虽然没有多少人使用它，但如果您想快速更改程序的命令行参数，它很有用。

`F5`: 开始调试

`Shift`+ `F5`: 停止调试

调试时，可以使用`Ctrl`++`Alt`添加`Q`快速观看。其他调试快捷方式可以在调试下拉菜单中找到。

* * *

## 回答 #25

> 赞同：13
> 
> 时间：2008-09-19T08:57:24.337

`Ctrl`+`F10`

调试时运行到光标处。在我找到键盘快捷键之前已经找了很久了...

* * *

## 回答 #26

> 赞同：12
> 
> 时间：2008-09-19T03:46:20.170

如果“最喜欢”是根据我使用它的频率来衡量的，那么：

`F10`: 调试.StepOver

:)

* * *

## 回答 #27

> 赞同：12
> 
> 时间：2011-09-08T16:29:07.877

当[IntelliSense](http://en.wikipedia.org/wiki/IntelliSense)下拉菜单显示时，按住`Ctrl`会使列表变为半透明，这样您就可以看到隐藏在它后面的内容 :)

* * *

## 回答 #28

> 赞同：12
> 
> 时间：2009-09-17T20:48:25.137

通过使用，这对：

*   `Ctrl`+ `Enter`：在当前行上方插入空行。
*   `Ctrl`+ `Shift`+ `Enter`: 在当前行下方插入空行。

* * *

## 回答 #29

> 赞同：11
> 
> 时间：2008-10-02T14:12:07.743

`Ctrl`+ `Alt`+ `P` -> 附加到进程

* * *

## 回答 #30

> 赞同：11
> 
> 时间：2010-07-22T16:54:31.630

没见过这个...

`Ctrl`+`Up`

`Ctrl`+`Down`

滚动窗口而不移动光标。

* * *

## 回答 #31

> 赞同：8
> 
> 时间：2009-03-10T19:10:28.910

选择单词：`Ctrl`+`W`

没有这条捷径我活不下去。每天使用超过 100 次（或 200 次以上）。

* * *

## 回答 #32

> 赞同：8
> 
> 时间：2009-03-11T00:01:51.033

`Ctrl`+ `Shift`+`S`

保存所有更改的文件。救了我好几次。

* * *

## 回答 #33

> 赞同：7
> 
> 时间：2008-10-22T15:54:30.687

`Ctrl`+ `Shift`+ `R`Tools.RecordTemporaryMacro（再次停止录制）

`Ctrl`+ `Shift`+ `P`Tools.RunTemporaryMacro

避免尝试进行正则表达式搜索和替换！

* * *

## 回答 #34

> 赞同：7
> 
> 时间：2008-09-19T01:48:02.513

旧的`Ctrl`+`Tab`用于在打开的文档之间来回翻转。

Visual Studio 实际上提供了一个非常好的`Ctrl`+`Tab`实现；我特别欣赏`Ctrl`+`Tab`文档激活顺序是最近使用的顺序，而不是简单的“从左到右”的顺序，这样`Ctrl`+ `Tab`（按一次就松开）可以反复使用，在两者之间来回翻转最近使用的文档，即使打开了两个以上的文档。

* * *

## 回答 #35

> 赞同：7
> 
> 时间：2008-09-19T02:00:40.440

`Ctrl`+ `R`+ `**T**`（运行当前测试）

`Ctrl`+ `R`+ `**A**`（运行项目中的所有测试）

* * *

## 回答 #36

> 赞同：7
> 
> 时间：2008-09-19T04:12:03.383

到目前为止，最有用的（在`Ctrl`++之后`Shift`）`B`是：

*   `Ctrl`+ `K`*,* `C` - 注释掉选择

*   `Ctrl`+ `k`*,* `U` - 取消注释选择

* * *

## 回答 #37

> 赞同：7
> 
> 时间：2010-10-14T09:46:41.197

环绕：`Ctrl`+ `K`, `S`.

当您想在标签中包含一些文本时，这很棒。

* * *

## 回答 #38

> 赞同：4
> 
> 时间：2008-09-19T02:35:16.567

`Ctrl`+`I`用于增量搜索

* * *

## 回答 #39

> 赞同：4
> 
> 时间：2008-09-19T08:25:14.103

我喜欢我的代码干净整洁，所以我最喜欢的键盘快捷键如下：

`Ctrl`+ `K`, `D`- 格式化文档

`Ctrl`+ `K`, `F`- 格式化所选代码

`Ctrl`+ `E`, `S`- 显示空格

`Ctrl`+ `L`- 切割线

`Alt`+ `Enter`- 在下面插入行

* * *

## 回答 #40

> 赞同：4
> 
> 时间：2009-09-28T22:16:33.587

`Ctrl`+`I`用于增量搜索。

* * *

## 回答 #41

> 赞同：4
> 
> 时间：2011-03-03T21:30:15.503

在调试模式下，`Alt` `*`跳转到当前断点，执行停止。

* * *

## 回答 #42

> 赞同：3
> 
> 时间：2008-12-16T21:00:34.200

`Alt` + `B` + `U` - Build the current project.

* * *

## 回答 #43

> 赞同：3
> 
> 时间：2008-09-19T03:29:48.493

当我在 ASP.NET 应用程序上使用“开始调试”时，我讨厌关闭额外的选项卡。相反，我通常使用“不调试就开始”（`Ctrl`+ `F5`）。

如果我最终需要调试，我使用`Ctrl`++ （附加到进程）`Alt`并选择 WebDev.WebServer.exe。然后我仍然在我的前一页上，我只打开了一个标签。`P`

* * *

## 回答 #44

> 赞同：3
> 
> 时间：2008-09-21T14:22:04.890

`F9`: 切换和取消切换断点！

* * *

## 回答 #45

> 赞同：3
> 
> 时间：2008-10-02T14:09:31.650

### 剪切和粘贴线条

每个人都知道`Ctrl`+`X`和`Ctrl`+`C`用于剪切/复制文本；但是你知道吗，在 VS 中，如果你想剪切或复制一行，你不必先选择文本？如果未选择任何内容，则将剪切或复制整行。

* * *

## 回答 #46

> 赞同：3
> 
> 时间：2008-10-02T14:10:15.050

### 显示隐藏的窗口

*   `ctrl`+ `alt`+ `L`+ 解决方案资源管理器

*   `ctrl`+ `alt`+ `S`+ 服务器资源管理器

*   `ctrl`+ `alt`+ `O`+ 输出

*   `ctrl`+ `alt`+ `X`+ 工具箱

*   `ctrl`+ `shift`+ `W`, `1`+ 观看

*   `ctrl`+ `\`, `E`+ 错误列表

*   `ctrl`+ `shift`+ `C`+ 类视图

我喜欢将我所有的屏幕空间用于代码，并将其他所有内容都隐藏起来。这些快捷方式可以在我需要这些窗口时方便地使用它们，因此它们可以在其余时间不碍事。

* * *

## 回答 #47

> 赞同：3
> 
> 时间：2008-09-19T03:50:27.430

`Ctrl`+ `[`(移动到对应的})

`Ctrl`+ `Shift`+ `V`(循环剪贴板)

* * *

## 回答 #48

> 赞同：3
> 
> 时间：2008-09-19T02:40:50.093

`Ctrl`+ `Alt`+ `E`= 异常/捕获设置和代码片段

* * *

## 回答 #49

> 赞同：3
> 
> 时间：2008-09-19T13:37:12.800

`Ctrl`用于查找选定项目和上一个选定项目的+`F3`和`Ctrl`+ `Shift`+组合`F3`对我来说非常有效。

* * *

## 回答 #50

> 赞同：3
> 
> 时间：2011-09-30T08:27:30.660

`CTRL`+ `Alt`+`↓`

这会导致打开文件列表在编辑器窗口的右上角弹出打开。很酷的是它是可搜索的，因此您可以离开键并开始输入文件名以将焦点转移到该文件。当您打开数以万计的文件时非常方便。

* * *

## 回答 #51

> 赞同：3
> 
> 时间：2011-04-06T19:10:05.537

`Ctrl`+`,`用于“导航至”窗口（[链接](http://weblogs.asp.net/scottgu/archive/2009/10/21/searching-and-navigating-code-in-vs-2010-vs-2010-and-net-4-0-series.aspx)）

* * *

## 回答 #52

> 赞同：3
> 
> 时间：2009-07-10T13:02:24.830

`Ctrl`++显示您正在`Shift`为其`space`键入参数的当前函数的语法/重载。

* * *

## 回答 #53

> 赞同：3
> 
> 时间：2010-05-31T04:07:02.103

在+上方打开一个**换行符** `Ctrl``Enter`

在下面打开一个**换行符** `Ctrl`+ `Shift`+`Enter`

* * *

## 回答 #54

> 赞同：3
> 
> 时间：2011-03-03T22:04:39.423

好吧，如果你**真的**

> 总是让我的手放在键盘上，远离鼠标！

比你应该去[这里](http://www.microsoft.com/downloads/en/details.aspx?FamilyID=92CED922-D505-457A-8C9C-84036160639F&displaylang=en)

这不是我最喜欢的，它只是一切！

一天一个捷径将使鼠标远离。

* * *

## 回答 #55

> 赞同：2
> 
> 时间：2008-12-29T18:30:21.680

我经常使用的一些方便的是：

`Ctrl`+ `J`-> 强制 Intellisence 弹出。

`Ctrl`+ `Alt`+ `L`-> 显示解决方案资源管理器。

* * *

## 回答 #56

> 赞同：2
> 
> 时间：2008-10-02T14:09:48.513

### 评论

*   `Ctrl`+ `K`, `Ctrl`+ `C`- 评论当前项目

*   `Ctrl`+ `K`, `Ctrl`+ `U`- 取消注释当前项目

这样做的好处是它适用于您当前所在的元素 - 您不必选择一整行 VB 代码来对其进行注释，例如，您只需键入`Ctrl`+ `K`、`Ctrl`+`C`来注释当前行。在 aspx 页面上，您可以注释掉一大段代码——例如整个 ListView——只需转到第一行并点击`Ctrl`+ `K`、`Ctrl`+即可`C`。

* * *

## 回答 #57

> 赞同：2
> 
> 时间：2008-09-19T05:00:53.160

如果您将键盘设置设置为“Visual C# 2005”设置，则窗口切换和文本编辑和弦非常出色。您点击 Ctrl + Key 的第一个组合，然后松开并点击下一个字母。

*   `Ctrl`+ `E`, `C`: 评论所选文本

*   `Ctrl`+ `E`, `U`: 取消注释选中的文本

*   `Ctrl`+ `W`, `E`: 显示错误列表

*   `Ctrl`+ `W`, `J`: 显示对象浏览器

*   `Ctrl`+ `W`, `S`: 显示解决方案资源管理器

*   `Ctrl`+ `W`, `X`: 显示工具箱

我仍然使用`F4`显示属性窗格，所以我不知道那个和弦。

如果您转到“工具”>“自定义”菜单选项并按下“键盘”按钮，它会为您提供一个命令列表，您可以搜索以查看是否有可用的快捷键，或者您可以选择“按下快捷键：”文本框并测试快捷键您要分配以查看它们是否冲突。

**附录：**我刚刚发现了另一个我认为我会经常使用的很棒的：`Ctrl`+ `K`，`S`

弹出一个智能框，询问你想用什么包围选定的文本。这正是我需要在条件或 try/catch 中包装块的所有时候所需要的。

* * *

## 回答 #58

> 赞同：2
> 
> 时间：2008-09-19T02:01:00.470

`Ctrl`+ `Shift`+ `B`- 构建

* * *

## 回答 #59

> 赞同：2
> 
> 时间：2008-09-19T04:07:18.013

[Sara Ford 的博客](http://blogs.msdn.com/saraford/default.aspx)上有一些很棒的提示、旅行和捷径。

* * *

## 回答 #60

> 赞同：2
> 
> 时间：2008-09-19T04:13:22.413

`F7`和`Shift`+`F7`在设计器/代码视图之间切换

`Ctrl`+`Break`停止构建。

非常适合那些“哦，我意识到这不会编译，我不想浪费我的时间”的时刻。

`Alt`+`Enter`打开 resharper 智能标签

***书签快捷方式***

`Ctrl`+`K` `Ctrl`+`K`放置书签

`Ctrl`+`K` `Ctrl`+`N`转到下一个书签

`Ctrl`+`K` `Ctrl`+`P`转到上一个书签

***重构快捷方式***。

每个都以`Ctrl`+`R`。

使用`Ctrl`+`R`进行重命名。`Ctrl`+`M`用于提取方法。`Ctrl`+`E`用于封装字段。

* * *

## 回答 #61

> 赞同：2
> 
> 时间：2009-05-08T11:03:18.307

`Ctrl + BP`(上一个书签), `Ctrl + BN`(下一个书签)

* * *

## 回答 #62

> 赞同：2
> 
> 时间：2009-09-28T22:22:02.767

`Ctrl`+`W`用于选择当前单词

* * *

## 回答 #63

> 赞同：2
> 
> 时间：2009-11-14T14:49:25.747

`Ctrl`+`U`和`Ctrl`++组合用于将字符`Shift`块`U`转换为全部大写/小写。

* * *

## 回答 #64

> 赞同：2
> 
> 时间：2010-02-28T08:32:24.357

`**Ctrl** + **K** + **C**`- 将当前选定的代码设置为注释 - 将当前选定的注释设置为代码`**Ctrl** + **K** + **U**`

* * *

## 回答 #65

> 赞同：1
> 
> 时间：2008-11-07T08:46:04.230

如果您安装[Visual Assist X](http://www.wholetomato.com)，我强烈建议您这样做，这些很有用：

*   `Alt`+ `O`: 在标题/实现 (.h/.cpp) 之间切换当前文档

*   `Alt`+ `G`：转到定义/声明

* * *

## 回答 #66

> 赞同：1
> 
> 时间：2008-10-04T19:23:19.727

`F7`从设计视图切换到代码视图。

* * *

## 回答 #67

> 赞同：1
> 
> 时间：2008-09-24T09:31:54.813

我刚刚发现`Shift`+`F11`退出了当前函数。

当您想在 foo(bar(baz()) 中调试函数 foo 时，这非常有用。使用`F11`, `Shift`+`F11`跳入和跳出 bar 和 baz。

* * *

## 回答 #68

> 赞同：1
> 
> 时间：2008-09-24T09:31:56.513

`Alt`+ `Shift`+方向键（`←``↑``↓``→`）或鼠标移动=块/列选择

真的很方便

* * *

## 回答 #69

> 赞同：1
> 
> 时间：2009-03-11T01:24:18.027

`Alt`+ `F4`;)

但更严重的是，在我对 VS 的有限使用中， `Ctrl`+可能受到了很多打击。`Space`

* * *

## 回答 #70

> 赞同：1
> 
> 时间：2009-03-11T01:59:53.450

`Ctrl`+ `Shift`+ `R`-> 使用 Resharper 重构

* * *

## 回答 #71

> 赞同：1
> 
> 时间：2011-02-24T16:37:52.457

`Ctrl`++显示空格（非常适合制表符或空格强制执行）`R`。`W`

此外，`Alt`在用鼠标选择的同时按住会创建一个矩形区域。

* * *

## 回答 #72

> 赞同：1
> 
> 时间：2008-10-02T14:09:00.810

### 查找和替换

*   `Ctrl`+`F`和`Ctrl`+ `H`- 分别查找、查找和替换

*   `Ctrl`+ `shift`+`F`和`Ctrl`+ `shift`+ `H`- 分别在文件中查找、在文件中查找和替换

“在文件中查找”对我来说是一个巨大的生产力助推器。与其逐个跳转到每个结果，它只是向您显示整个项目或解决方案中的结果列表。它使查找示例代码或查看函数是否在任何地方使用变得非常简单。

* * *

## 回答 #73

> 赞同：1
> 
> 时间：2008-09-19T05:18:57.157

`Ctrl`+ `Shift`+ `8`- 回溯到上一个“ `F12`/转到定义”

* * *

## 回答 #74

> 赞同：1
> 
> 时间：2009-03-11T02:37:30.457

`Ctrl`+ ` E `+ ` D `: 格式化文档

**团队提示**：在 Visual Studio 中设置商定的格式选项（它们非常灵活），然后将设置导出到 .settings 文件以供每个开发人员导入。

现在，如果所有开发人员都学会了自动格式化所有内容，它不仅*可以毫不费力地在整个项目中产生完美的格式化一致性*，而且还可以在将多个签入合并到源代码管理时大大减少 diff 工具中恼人的错误差异。

哦，我喜欢好工具！

* * *

## 回答 #75

> 赞同：1
> 
> 时间：2008-11-10T07:10:59.960

`F7`构建，然后`F8`一一查看错误和警告。

* * *

## 回答 #76

> 赞同：1
> 
> 时间：2009-10-28T05:15:10.987

很简单，但是

`Ctrl`+`L`

删除整行。非常适合快速代码编辑。

* * *

## 回答 #77

> 赞同：1
> 
> 时间：2008-10-22T15:42:17.453

不是键盘快捷键，而是使用鼠标，您可以使用鼠标上的前进和后退按钮转到代码中的先前位置并返回到当前位置。

* * *

## 回答 #78

> 赞同：1
> 
> 时间：2008-09-19T09:04:28.657

`Ctrl`+ `M`*,* `Ctrl` + `O`: 折叠到定义。我一直将它与#regions 一起使用

（尽管[Jeff 说了什么](http://www.codinghorror.com/blog/archives/001147.html)），以了解我屏幕上的代码概览。

* * *

## 回答 #79

> 赞同：1
> 
> 时间：2009-07-01T02:21:10.763

我是`Ctrl`++在调试时打开 quickwatch`D`的忠实粉丝。`Q`

* * *

## 回答 #80

> 赞同：1
> 
> 时间：2009-05-27T19:00:10.843

插入片段：

`Ctrl`+ `K`, `Ctrl`+`S`

我经常使用 if`try..catch`和`#region`

* * *

## 回答 #81

> 赞同：1
> 
> 时间：2009-09-17T20:49:25.090

`Ctrl`+ `Shift`+`V`多次循环通过剪贴板环。

* * *

## 回答 #82

> 赞同：1
> 
> 时间：2009-09-17T20:51:52.697

控制+撇号。

哦，等等，那是*在*我将它从那个令人尴尬的 Alt+Shift+F10 或其他任何东西重新映射之后。

当您重新映射*选项以帮助将*其与原来难以命中的快捷方式绑定时，它变得更加有用。

* * *

## 回答 #83

> 赞同：1
> 
> 时间：2012-04-18T18:40:46.570

`Ctrl`+ `K`，`D`自动格式化代码。

* * *

## 回答 #84

> 赞同：1
> 
> 时间：2010-07-22T16:52:21.090

我映射了所有的展开/折叠命令，以便它们可以与左侧一起使用，只有这样我的右手才会停留在鼠标上。
`Ctrl`+ `E`, `Ctrl`+`E`切换扩展，`Ctrl`+ `E`, `Ctrl`+`D`折叠所有定义，`Ctrl`+ `E`, `Ctrl`+`A`切换所有大纲。

* * *

## 回答 #85

> 赞同：0
> 
> 时间：2008-11-07T08:32:03.497

简单的一个。`F8`：转到下一个构建错误。

发现现在它可以在任何类型的列表窗口中工作（通常在底部聚集在一起的那些。

* * *

## 回答 #86

> 赞同：0
> 
> 时间：2008-09-19T02:25:58.443

使用类似 Emacs 的键绑定，它是`TAB`：P

* * *

## 回答 #87

> 赞同：0
> 
> 时间：2008-09-19T02:35:12.667

[雷](https://stackoverflow.com/questions/98606/favorite-visual-studio-keyboard-shortcuts#98648)说的。`Ctrl`+ `.`.

我真的不喜欢智能标签（那些看起来想要帮助你的蓝色和红色小下划线），直到我发现你不需要浪费时间试图将鼠标悬停在获取菜单的确切像素上节目。

我认为`Ctrl`+`.`打开智能标签菜单每天可以为我节省大约五分钟，并大大降低了我的血压。

* * *

## 回答 #88

> 赞同：0
> 
> 时间：2008-09-19T03:32:15.603

`Ctrl`+`K`然后`Ctrl`+`H`将一行代码添加到内置任务/待办事项列表

( `Ctrl`+ `Alt`+ `K`)。非常便利！

* * *

## 回答 #89

> 赞同：0
> 
> 时间：2008-09-24T09:26:42.483

节省大量时间复制和剪切：

*   `Ctrl`+`C`行中没有选择：复制整行

*   `Ctrl`+`X`没有选择 - 剪切整行

* * *

## 回答 #90

> 赞同：0
> 
> 时间：2009-03-11T01:55:12.367

我已将File.Close 映射到`CTRL`++ 。那和+意味着您可以完全关闭您想要的任何文件。`SHIFT``W``CTRL``TAB`

* * *

## 回答 #91

> 赞同：0
> 
> 时间：2008-12-20T11:13:27.607

对比 2008

1.  `Ctrl`+ `E`, `D`:*格式代码*

2.  `Ctrl`+ `M`, `O`:*折叠到定义*

3.  `Ctrl`+ `Z` ：*撤消*:)

4.  `F9`:*断点*

5.  `Ctrl`+ `Shift`+ `F9`:*删除所有断点*

* * *

## 回答 #92

> 赞同：0
> 
> 时间：2008-09-19T03:10:56.793

我有两个我经常使用，第一个是标准的，第二个你必须映射：

`Ctrl`+ `A`, `Ctrl`+ `E`, `F`（全选，格式选择）

`Ctrl`+ `E`, `R`（删除未使用的使用和排序）

两者都有助于尽早并经常还清“糟糕的债务”

* * *

## 回答 #93

> 赞同：0
> 
> 时间：2008-09-19T13:47:33.663

Another useful Find short key sequence is Ctrl (+ Shift) F --> ALT C --> ALT W for switching between exact and fuzzy searches.

* * *

## 回答 #94

> 赞同：0
> 
> 时间：2008-10-02T14:09:14.833

### 概述

*   `ctrl`+ `M`, `ctrl`+ `M`- 折叠/展开当前元素

*   `ctrl`+ `M`, `ctrl`+ `O`- 全部折叠（例如，给你一个复杂类的一个很好的概览）

*   `ctrl`+ `M`, `ctrl`+ `O`- 全部切换

这适用于 VB/C# 代码（例如折叠/展开函数）和 aspx 页面（例如折叠/展开 GridView 定义）。

一个很好的用途是剪切或复制一大块标记或代码：例如，移动一个大的、蔓延的`<table>`或`<asp:gridview>`定义：

1.  转到第一行

2.  `ctrl`+ `M`, `ctrl`+`M`折叠它

3.  `ctrl`+`X`剪切它（您不必选择它，只要您的插入点仍在该行中）

4.  移动到您想要的位置，然后`ctrl`+`V`粘贴。

* * *

## 回答 #95

> 赞同：0
> 
> 时间：2008-10-02T14:10:01.227

### 片段

每个片段都有一个快捷方式，您可以通过键入一个单词然后按 Tab 来访问该快捷方式。我用得最多的是一个标准的属性定义；只需键入**属性**然后选项卡。

* * *

## 回答 #96

> 赞同：0
> 
> 时间：2008-10-27T15:18:46.727

`Ctrl`+`-` and `Ctrl`+`Shift`+`-`

`Alt`+`D`, `P` Attach the debugger to the application.

(first letter of any application you want to debug, works most of the time)

`Ctrl`+`Shift`+`F`

`Ctrl`+`I` (incremental seach)

* * *

## 回答 #97

> 赞同：0
> 
> 时间：2008-09-24T12:19:25.563

“道具”并点击标签......为你存根财产......

* * *

## 回答 #98

> 赞同：0
> 
> 时间：2008-10-22T15:50:09.807

这是我认为有用的快捷方式[列表](http://www.wwwcoder.com/Weblogs/tabid/283/EntryID/774/Default.aspx)的链接（VS2003），但有些仍然适用，

我最喜欢的是`F12`和`Ctrl`+`-`导航到声明并返回

* * *

## 回答 #99

> 赞同：0
> 
> 时间：2010-10-01T08:13:33.487

希望这还没有发布，如果是，请道歉。我刚刚在 Visual Studio 2008 中发现了一个有用的键盘快捷键。打开 QuickWatch 窗口后，突出显示其中包含字符串值的行，然后点击`Space Bar`. 文本可视化窗口将显示其中的值。

我发现它对于检查 jQuery innerText 值非常有用，因为默认情况下 QuickWatch 窗口太小而无法完全显示更长的字符串。

* * *

## 回答 #100

> 赞同：0
> 
> 时间：2008-09-19T08:11:07.257

`Ctrl`+`X`

This cuts (to clipboard) the current line of code.

* * *

## 回答 #101

> 赞同：0
> 
> 时间：2008-09-19T11:07:34.057

没有什么比 ++ `Ctrl`-构建解决方案！`Shift``B`

就导航控制而言，`Ctrl`+`-`和`Ctrl`+`+`很好......

但我更喜欢`Ctrl`+ `K`+ `K`---> 创建书签......

和`Ctrl`​​+ `K`+ `N`---> 导航到下一个书签......很棒的东西......

* * *

## 回答 #102

> 赞同：0
> 
> 时间：2012-09-05T17:03:44.383

`Ctrl`+`.`

包括缺少的库。

* * *

## 回答 #103

> 赞同：0
> 
> 时间：2008-10-02T14:08:01.780

### 打开和关闭换行

`Ctrl`+ `E`, `Ctrl`+`W`

有时您希望看到所有缩进都已到位的代码流；有时您需要查看 GridView 声明中的所有 50 个属性。这使您可以轻松地来回切换。

* * *

## 回答 #104

> 赞同：0
> 
> 时间：2008-10-02T14:08:17.957

### 格式化文档

```
   Ctrl+ K, Ctrl+D
```

1.  在一个 aspx 页面上，这将负责正确缩进所有标记并确保所有内容都符合 XHTML（为属性添加引号、更正大小写、关闭自动关闭标签）。我发现这样可以更容易地找到不匹配的标签并确保我的标记有意义。**如果您不喜欢它的缩进方式，您可以在Tools/Options/Text Editor/HTML/Format/Tag Specific Options**下控制哪些标签在自己的行上以及它们周围有多少空间 。

2.  在您的 C# 或 VB 代码中，这将更正任何未自动捕获的大小写或格式问题。

3.  对于 CSS 文件，您可以选择紧凑（每行一个定义）、半扩展或扩展（每条规则单独一行）；您可以选择它如何处理大小写。

* * *

## 回答 #105

> 赞同：0
> 
> 时间：2008-10-02T14:08:31.060

### 刷新 javascript 智能感知和代码着色。

`ctrl`+ `shift`+`J`

我发现 Javascript 的智能感知是不稳定的——这通常可以解决问题。

* * *

## 回答 #106

> 赞同：0
> 
> 时间：2008-09-19T02:55:39.513

`Ctrl`+ `Shift`+ `S`// 保存

`Ctrl`+ `Shift`+ `B`// 构建

* * *

## 回答 #107

> 赞同：0
> 
> 时间：2008-10-08T05:19:58.833

不使用鼠标打开文件：

`CTRL`++ （打开命令窗口`ALT`）`A`后跟 >open somedoc

我还没有看到这个。不敢相信这里发布了多少很酷的快捷方式！

* * *

## 回答 #108

> 赞同：0
> 
> 时间：2010-07-23T16:19:37.347

人们提到 Ctrl+C 和 Ctrl+V 在未选择任何内容时粘贴一行，但我使用 Ctrl+X 定期移动代码行。

* * *

## 回答 #109

> 赞同：0
> 
> 时间：2008-12-16T20:34:15.033

嗯，没人说`F1`求救。

是不是谷歌在获取您需要的信息方面更快更好。

* * *

## 回答 #110

> 赞同：0
> 
> 时间：2009-10-28T05:26:13.130

`Ctrl`+ `M`, `L`- 扩展所有区域

* * *

## 回答 #111

> 赞同：0
> 
> 时间：2008-09-30T15:56:52.220

`Ctrl`+ `M`*,* `Ctrl` +`L`将展开每个折叠的代码位。它是`Ctrl`+ `M`*,* `Ctrl` +的反义词`O`

* * *

## 回答 #112

> 赞同：0
> 
> 时间：2008-09-24T09:54:59.297

`Ctrl`+ `K`, `Ctrl`+ `D`- 格式化当前文档。

帮助我修复缩进并快速删除不需要的空格

* * *

## 回答 #113

> 赞同：0
> 
> 时间：2009-12-06T06:16:24.010

`Ctrl`+ `A`, `K`,`F`

全选，[漂亮](http://en.wikipedia.org/wiki/Prettyprint)的打印。

* * *

## 回答 #114

> 赞同：0
> 
> 时间：2011-06-16T07:57:59.343

我很惊讶没有在列表中找到这个，因为我一直在使用它：

`Ctrl`+ `K`, `Ctrl`+ `M`- 实现方法存根。

编写一个对不存在的方法的调用，然后使用该快捷方式在正确的位置创建该方法，使用正确的参数和返回值，但使用一个仅引发 NotImplementedException 的方法体。

非常适合自上而下的编码。

* * *

## 回答 #115

> 赞同：0
> 
> 时间：2009-03-10T21:18:05.233

我一直使用的那些：

*   `ctrl`+`]` 配套支架

*   `ctrl`+ `shift`+`]`选择到大括号的末尾

*   `ctrl`+ `shift`+`q`取消制表符

*   `ctrl`+ `k`, `ctrl`+`c`注释掉当前选中的块

*   `ctrl`+ `k`, `ctrl`+`u`取消注释掉当前选中的块

*   `alt`+鼠标移动垂直选择

*   `ctrl`+ `alt`+`x`工具箱

*   `ctrl`+ `shift`+`b`构建

* * *

## 回答 #116

> 赞同：0
> 
> 时间：2009-03-10T21:33:25.820

`Ctrl`++`Shift`关闭`F4`所有窗口。你必须自己映射它：

指示：

*   在 Visual Studio 中，转到工具 | 选项
*   在环境下选择键盘
*   在显示包含的命令中，输入 Window.CloseAllDocuments。您应该在其下方的列表框中获得一个条目
*   将光标放在 按快捷键并按`Ctrl`+ `Shift`+ `F4`。
*   点击确定

[感谢 codebetter.com](http://codebetter.com/blogs/kyle.baley/archive/2008/05/31/close-everything-and-unzip-all.aspx)的Kyle Baley 。我修改了他的示例以使用 shift 而不是 alt 因为它对我来说更容易。

* * *

## 回答 #117

> 赞同：0
> 
> 时间：2009-04-27T16:15:29.537

这是我最喜欢的调试键盘快捷键：

*   `F5`: 启动调试器/运行到下一个断点
*   `Shift+F5`: 停止调试
*   `F10`: 跳过下一条语句
*   `F11`: 进入下一条语句
*   `Ctrl+F10`: 运行到光标位置
*   `F9`: 添加或删除断点

* * *

## 回答 #118

> 赞同：0
> 
> 时间：2009-07-01T21:26:18.193

我沉迷于[http://blog.jpboodhoo.com/UsefulVSKeySequencesShortcuts.aspx中的一些非常微妙的东西](http://blog.jpboodhoo.com/UsefulVSKeySequencesShortcuts.aspx)

例如`Alt-W U`，在全屏模式下自动折叠所有内容，当它变得太多时

* * *

## 回答 #119

> 赞同：0
> 
> 时间：2009-08-30T13:38:14.567

循环粘贴`Ctrl + Shift + V`

展开 折叠当前块 -`Ctrl + M + M`

代码片段 - 用于创建属性类型 prop 并按`tab`。

* * *

## 回答 #120

> 赞同：0
> 
> 时间：2009-11-14T14:02:26.560

我认为没有任何捷径可供我提及，所以让我提一下我希望 Visual Studio 拥有的捷径 :-) 我真正想念的一个捷径是 Eclipse 中存在的一个捷径是“开放资源”（`Ctrl + Shift + S`）它允许您输入文件名，IDE 会显示与之匹配的文件。在使用投标代码库时非常有用！

* * *

## 回答 #121

> 赞同：0
> 
> 时间：2011-05-05T19:53:34.460

`Ctrl`+`Shift`+`Alt`+`B` Rebuild Solution.

`Ctrl`+ `R`, `Ctrl`+`T` 当前上下文中的调试测试

* * *

## 回答 #122

> 赞同：0
> 
> 时间：2010-10-14T15:23:52.727

[Visual Studio 2010 键绑定海报](http://www.microsoft.com/downloads/en/details.aspx?displaylang=en&FamilyID=92ced922-d505-457a-8c9c-84036160639f)

* * *

## 回答 #123

> 赞同：0
> 
> 时间：2011-07-03T12:19:44.253

我认为`Ctrl`++`K`绝对`D`是我的最爱。我使用它比任何其他快捷方式都多。它有助于根据我们指定的缩进和代码格式设置来格式化文档。

* * *

## 回答 #124

> 赞同：-1
> 
> 时间：2008-09-19T07:24:55.730

`Ctrl`+`-`和`Ctrl`+ `Shift`+ `-`。但是，如果您是键盘爱好者，请选择 Resharper

# eclipse - 如何让 Eclipse 显示 .* 文件？

> ID：98610
> 
> 赞同：531
> 
> 时间：2008-09-19T01:23:28.970
> 
> 标签：eclipse, file, hidden

默认情况下，Eclipse 不会显示我在项目中维护的 .htaccess 文件。它只是在包查看器树中显示一个空文件夹。我怎样才能让它出现？没有明显的偏好。

* * *

## 回答 #1

> 赞同：838
> 
> 时间：2008-09-19T01:27:15.950

在包资源管理器中，在视图的右上角，有一个小的向下箭头。工具提示会说查看菜单。从该菜单中，选择过滤器

![过滤器菜单](https://i.stack.imgur.com/NWo2x.jpg)

从那里，取消选中 .* 资源。

所以`Package Explorer -> View Menu -> Filters -> uncheck .* resources`。

对于 Eclipse Kepler 和 OS X，这有点不同：

```
Package Explorer -> Customize View -> Filters -> uncheck .* resources 
```

* * *

## 回答 #2

> 赞同：37
> 
> 时间：2009-09-16T03:03:24.273

科里是正确的

@ 如果您使用的是 Eclipse PDT，这是通过打开 PHP 资源管理器视图来完成的

我只花了大约半个小时寻找小箭头，直到我真正查看了“PHP Explorer”视图是什么。这是一个屏幕截图：

![PHP透视图编辑图片](https://i.stack.imgur.com/NWo2x.jpg)

* * *

## 回答 #3

> 赞同：34
> 
> 时间：2013-01-23T15:41:29.883

对于**项目浏览器视图**：
**1.**单击右上角的箭头（***视图菜单***）
**2.**从菜单中选择***自定义视图...***项目
**3.**取消选中 *。***过滤器***选项卡下的*资源*复选框**4.**单击***确定***

 ****--
日食朱诺

* * *

## 回答 #4

> 赞同：20
> 
> 时间：2011-06-25T01:16:28.973

我正在使用 64 位 Eclipse for PHP Devleopers 版本：Helios Service Release 2

它与 RSE..

以上解决方案都不适合我...我所做的与 scubabble 的回答类似，但是在单击 RSE 包资源管理器顶部的向下箭头（查看菜单）后，我不得不将鼠标悬停在“首选项”上并单击“远程”系统”

然后我在出现的首选项窗口左侧打开“远程系统”导航树并转到“文件”

在文件类型列表下方是一个未选中的复选框：“显示隐藏文件”

核实！

* * *

## 回答 #5

> 赞同：10
> 
> 时间：2012-04-24T13:24:27.720

在 Mac 上：Eclipse -> 首选项 -> 远程系统 -> 文件 -> 单击显示隐藏文件。

* * *

## 回答 #6

> 赞同：10
> 
> 时间：2018-06-26T15:14:02.923

**1\. 从`Package Explorer`打开`Filters...`对话框：**

[![在此处输入图像描述](https://i.stack.imgur.com/Nxl2M.png)](https://i.stack.imgur.com/Nxl2M.png)

**2.然后取消选中`.* resources`选项：**

[![在此处输入图像描述](https://i.stack.imgur.com/D4tSB.png)](https://i.stack.imgur.com/D4tSB.png)

* * *

## 回答 #7

> 赞同：8
> 
> 时间：2008-09-19T01:25:44.813

在您的包资源管理器中，下拉菜单并选择“过滤器...”。您可以调整在那里显示/隐藏的文件类型。

查看我的 Red Hat Developer Studio（大约 Eclipse 3.2），我看到列表中的顶部项目是“.* 资源”，默认情况下它被排除在外。

* * *

## 回答 #8

> 赞同：7
> 
> 时间：2009-08-03T16:38:43.143

如果使用 Zend Studio，同样的箭头，转到 RSE 视图，单击向下箭头，点击首选项，然后选中显示隐藏文件。

这对我有用。

* * *

## 回答 #9

> 赞同：7
> 
> 时间：2009-11-29T02:12:56.023

就我而言，我想查看 .htaccess 文件，但不是所有其他 .* 资源。
在 Zend Studio for Eclipse 中，在 PHP Explorer（不是 Remote System Explorer）中，单击向下的箭头（在左/右箭头旁边）。
选择过滤器。
取消选中 .* 资源
在“名称过滤器模式”区域中，键入要忽略的文件名。
我使用过：.svn、.cvs、.DS_Store、.buildpath、.project

* * *

## 回答 #10

> 赞同：4
> 
> 时间：2009-03-06T17:03:19.917

如果您使用的是 Eclipse PDT，这可以通过打开 PHP 资源管理器视图，然后单击该窗口右上角的倒三角形来完成。将出现一个上下文窗口，其中提供了过滤器选项。单击“过滤器”菜单选项会打开一个新窗口，其中可以取消选中 .* 文件，从而允许编辑 .htaccess 文件。

我一直在寻找这个，所以我在这里回答我自己的问题。我相信其他人也会遇到同样的问题，所以我希望这对其他人也有帮助。

* * *

## 回答 #11

> 赞同：4
> 
> 时间：2014-06-30T11:10:16.520

Eclipse 在“导航器”视图中显示隐藏文件。您可以通过 Window->Show View->Navigator 添加它。

* * *

## 回答 #12

> 赞同：3
> 
> 时间：2021-02-20T12:10:18.723

弹簧工具套件 4

版本：4.9.0.RELEASE 构建 ID：202012132054

对于 Mac：

[![在此处输入图像描述](https://i.stack.imgur.com/AVDQ5.png)](https://i.stack.imgur.com/AVDQ5.png)

* * *

## 回答 #13

> 赞同：2
> 
> 时间：2014-09-25T15:22:04.053

`Preferences -> Remote Systems -> Files -> Show hidden files`

（确保已选中）

# visual-studio - 组合框项目比较和编译器警告

> ID：98622
> 
> 赞同：1
> 
> 时间：2008-09-19T01:25:14.270
> 
> 标签：visual-studio, compiler-construction

在 VisualStudio (Pro 2008) 中，我刚刚注意到一些不一致的行为，并想知道其背后是否有任何逻辑推理

在 WinForms 项目中，如果我使用该行

```
if(myComboBox.Items[i] == myObject) 
```

当我将类型对象与类型 MyObject 进行比较时，我收到一个编译器警告，我可能会收到“可能的意外引用”。很公平。

但是，如果我改为使用接口进行比较：

```
if(myComboBox.Items[i] == iMyInterface) 
```

编译警告消失了。

任何人都可以考虑是否有任何逻辑原因导致这种情况发生，或者只是编译器的一个工件不检查接口以获取比较警告。有什么想法吗？

**编辑**在我的示例中，组合框绑定到一个列表，但该列表是使用生成的`list<IMyInterface>.Cast<MyObject>().ToList<MyObject>()`

就好像编译器只是假设我绑定到 IMyInterface 列表。

（已更改对象和接口方法以保护无辜者）

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-04T21:46:45.630

第一个示例的编译警告是因为您的类的任何自定义 == 运算符都将被忽略并比较引用（可能不是您想要的，因此是警告）。

无法指定在接口上应覆盖运算符，因此这将*始终*是参考比较。不需要警告，因为您应该始终期待这一点。

这是覆盖 == 运算符的示例：

```
class Program
{
    static void Main(string[] args)
    {
        object t1 = new MyTest() { Key = 1 };
        MyTest t2 = new MyTest() { Key = 1 };

        Console.WriteLine((MyTest)t1 == t2); // Uses overriden == operator, returns true
        Console.WriteLine(t1 == t2); // Reference comparison, returns false
    }
}

public class MyTest
{
    public int Key { get; set; }

    public override bool Equals(object obj)
    {
        return this.Key == (obj as MyTest).Key;
    }

    public override int GetHashCode()
    {
        return this.Key.GetHashCode();
    }

    public static bool operator ==(MyTest t1, MyTest t2)
    {
        return t1.Equals(t2);
    }

    public static bool operator !=(MyTest t1, MyTest t2)
    {
        return !t1.Equals(t2);
    }

} 
```

如果 Key 属性相等，则认为 MyTest 类是相等的。如果您要创建一个接口，则不能指定它应该包含自定义 == 运算符，因此比较将始终是参考比较（因此在我们的示例代码中为 false）。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T01:39:26.670

拉格达莱克，

生成警告是因为您需要在比较之前将 Items 集合中的项目转换回绑定到组合框的原始类型；否则你可能会得到意想不到的结果，因为编译器会发出警告。

这是一个例子：

```
myComboBox.DataSource = Collection<Car>; 
```

因此，如果组合框绑定到**汽车**对象的集合，您将在比较之前将它们回退：

```
if((car)myComboBox.Items[i] == thisCar) 
```

那么你不应该得到任何警告。

您可以做的另一种方法是：

```
using(myComboBox.Items[i] as car){
 if(myComboBox.Items[i] == thisCar)
} 
```

让我知道。祝你好运！我从记忆中走出来，希望我没有打错任何东西。:o)

# .net - 有什么方法可以更改 .NET JIT 编译器以提高性能而不是编译时间？

> ID：98624
> 
> 赞同：14
> 
> 时间：2008-09-19T01:25:41.570
> 
> 标签：.net, performance, clr, jit, ngen

我想知道是否有任何方法可以通过指定更深入优化的首选项来改变 .NET JIT 编译器的行为。如果做不到这一点，如果它还没有做某种配置文件引导的优化，那就太好了。

* * *

## 回答 #1

> 赞同：20
> 
> 时间：2008-09-19T01:29:27.113

这是在编译程序集时设置的。有两种类型的优化：

*   IL优化
*   JIT 本机代码质量。

默认设置是这个

```
 /optimize- /debug- 
```

这意味着未优化的 IL 和优化的本机代码。

```
 /optimize /debug(+/full/pdbonly) 
```

这意味着未优化的 IL 和未优化的本机代码（最佳调试设置）。

最后，要获得最快的性能：

```
/optimize+ /debug(-/+/full/pdbonly) 
```

这会产生优化的 IL 和优化的本机代码。

在生成未优化的 IL 时，编译器将在整个代码中插入 NOP 指令。通过允许在控制流指令（例如 for、while、if、else、try、catch 等）上设置断点，这使得代码更易于调试。

无论如何，CLR 在优化代码方面做得非常好。一旦方法被 JIT 化，调用或 callvirt 指令上的指针将直接指向本机代码。

此外，CLR 将利用 JIT 代码时可用的任何架构技巧。这意味着通过 JIT 运行的程序集将比使用 Ngen 预编译的程序集运行得更快（尽管启动时间稍慢），因为 NGen 将为所有平台编译，并且不会利用任何技巧。

# c++ - 2d游戏物理？

> ID：98628
> 
> 赞同：12
> 
> 时间：2008-09-19T01:26:22.503
> 
> 标签：c++, physics

任何人都可以指向一个用于 2D 游戏物理库等的库，用于为 2D 平台/横向滚动游戏编程重力、跳跃动作等吗？或者你能推荐一些像马里奥、索尼克等横向卷轴的算法吗？

* * *

## 回答 #1

> 赞同：22
> 
> 时间：2008-09-19T01:31:31.260

听起来[花栗鼠](http://chipmunk-physics.net/)可能会满足您的需求。

* * *

## 回答 #2

> 赞同：12
> 
> 时间：2008-09-19T01:35:38.020

您最好的选择很可能是[Box2D](http://www.box2d.org/)。它执行 2D 物理，有大量选项，并且很容易集成到现有项目中。它默认对固定体进行 CCD，但任何刚体都可以有选择地包含在 CCD 计算中。

* * *

## 回答 #3

> 赞同：9
> 
> 时间：2008-09-19T01:39:03.563

如果您只需要重力，您可以在 5 分钟内自行编程。自由落体的物体以每秒 9.8 米的速度向下加速——也就是说，自由落体时物体的向下*速度*增加了 9.8 米每秒。对于游戏，您需要将 9.8 除以帧速率。对于跳跃，只需选择一个显着的负垂直速度，在角色跳跃的那一刻将其应用于角色，然后按每帧重力增量递减。除非您正在为您的 2d 侧滚轴寻找 3d 背景，否则这确实是您对马里奥之类的东西所需要的全部。

如果你想更漂亮，你可以尝试考虑一个物体的冲击力，使坠落的物体伤人或开裂路面之类的。为此，请使用动能公式：KE = 1/2 * M * V^2，其中 M 是质量，V 是速度。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-09-19T01:29:17.597

***你在找什么平台？***您使用什么库将取决于此。

对于 XNA 框架，Farseer 相当不错。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2008-09-21T19:02:18.680

要回答问题的第二部分，如果您想了解简单的 2D 平台游戏的工作原理，请阅读[N 的教程](http://www.harveycartel.org/metanet/tutorials.html)。是的，N 是一款基于 Flash 的游戏，但这并不意味着它不像“真实”游戏那样构建，因此碰撞检测（和响应）教程非常适用。它们很容易阅读，页面中嵌入了一些直观的演示，以展示几何概念。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-19T01:32:13.673

你可以看看 Havok 引擎。我相信他们发布了用于非商业用途的免费版本。它有一个约束套件，可让您将物理约束到 2 个平面，在您的情况下，x 和 y。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-19T01:33:40.880

大多数 2D 横向滚动平台游戏中的物理原理非常简单，您可以自己轻松实现它们。你在寻找什么样的效果？

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-19T01:35:11.267

如果你有时间，你可以使用 PhysX，但对于 2D 来说，它可能会过度杀戮。除此之外，如果您打算让您的游戏在 PC 上运行并想要一些很酷的物理效果，请尝试在谷歌上搜索“verlet 集成”，我知道周围有很多 verlet 实现（非常适合粒子和 2D 布娃娃）。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-09-19T01:35:25.867

我在个人项目中使用过[Box2D 。](http://www.box2d.org/)它是一个 2D 物理模拟 API。但是，如果您想要的更多是游戏/图形 API，则可能有点矫枉过正。

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-09-19T02:29:32.243

这家伙在 Javascript 游戏方面做了很多工作：

[http://blog.nihilogic.dk/](http://blog.nihilogic.dk/)

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2008-09-21T18:55:03.720

[你也可以用opende](http://opende.sourceforge.net/)做2d 物理

# scheme - 学习计划的好处？

> ID：98641
> 
> 赞同：24
> 
> 时间：2008-09-19T01:29:01.827
> 
> 标签：scheme

我刚刚开始了我的一门课程，因为课程刚刚开始 2 周前，我们现在正在在一门课程中学习 Scheme，因为我稍后会认为是某种原因，但到目前为止，他所教的基本上是如何在 scheme 中写作. 当我坐在这里试图保持清醒时，我只是想了解为什么我想知道这个，以及为什么有人使用它。它擅长什么？下周我打算问他，除了如何在计划中写东西之外，在这里学习的目标是什么。

* * *

## 回答 #1

> 赞同：35
> 
> 时间：2008-09-19T01:35:18.380

它是一种函数式编程语言，可以很好地拓宽您的经验。

即使你不在现实世界中使用它也不意味着它没有任何价值。它将帮助您掌握递归之类的知识，并帮助您以与平时不同的方式思考问题。

我*希望*我的学校强迫我们学习一门函数式编程语言。

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2008-09-19T02:59:09.893

像 LISP（以及非常密切相关的 Scheme）这样的语言之于编程就像拉丁语之于英语一样。

学习完课程后，您可能在日常生活中再也不会说拉丁语了，但简单地学习拉丁语这样的语言会提高您使用英语的能力。

Scheme 也是如此。

* * *

## 回答 #3

> 赞同：9
> 
> 时间：2008-09-19T03:18:13.967

我在这里看到所有这些人都在说，虽然他们再也不会真正使用 Scheme，但它仍然是一种值得学习的语言，因为它强制了某种思维方式。虽然这可能是真的，但我希望你会学习 Scheme，因为你最终会发现它很有用，而不仅仅是作为学习的练习。

虽然它不像编译语言那么快，在服务网站或解析文本方面也不是特别有用，但我发现 Scheme（和其他扩展的 lisps）在简单、优雅和强大的功能操作方面没有可比性复杂的数据结构。老实说，我认为在 Scheme 中。这是我解决问题的语言。不要放弃或仅仅容忍 Scheme - 给它一个机会，它不会让你失望。

顺便说一句，Scheme 的最佳 IDE 是[DrScheme](http://www.drscheme.org/)，它包含语言扩展，可以做任何你可以用另一种语言做的事情，如果你发现它不能做的事情，你可以使用 C FFI 并自己编写。

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2008-09-19T18:33:00.343

我建议在学习时保持**开放的心态**。在学校的大部分时间里，我们并不完全理解我们在学习特定科目的内容/原因。但正如我一生中经历过的大约一百万次一样，事实证明它非常有用，并且至少意识到它会对你有所帮助。不管你信不信，Scheme 会让你成为一个更好的程序员。

* * *

## 回答 #5

> 赞同：6
> 
> 时间：2008-09-19T02:05:06.653

有人说，Scheme 的最大优势在于作为一种教学语言。虽然学习函数式编程非常有益（这是一种全新的思维方式），但学习方案的另一个好处是它也是“纯粹的”。当然它不能做很多像 java 这样的东西，但这也是它的优点，它是一种完全由括号、字母数字字符和少数其他标点符号组成的语言。

在我的介绍课程中，我们学习了 Java，我看到我的很多朋友都在为“public static void main”而苦苦挣扎，尽管这不是程序的重点，而且教授们别无选择，只能“挥手”直到他们'重新更先进。您在 Scheme 中看不到这一点。

如果您真的想了解Scheme 可以用Java 等语言很难实现的小菜一碟，我建议您看一下： http: [//mitpress.mit.edu/sicp/full-text/book/ book-ZH-12.html#%_sec_1.3](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3)

这可能是关于 Scheme 的最好的书。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-09-19T03:42:46.233

NASA 使用 Scheme 对一些火星探测器进行编程。它在市场上的使用非常具体，但就像我确定你的老师告诉你的那样，你在 Scheme 中学到的东西将延续到一般的编程中。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-19T18:23:35.497

尽量不要被括号和 car/cdr 之类的细节所困扰。您所学的大部分内容都以一种或另一种方式翻译成其他语言。不要担心你是否可以将 Scheme 带到市场，你很可能会在其他课程中学习一些其他更具市场价值的语言。你在这里学到的东西更重要。

如果您正在学习方案，则可以了解有关如何实现对象系统的所有信息（提示：对象系统并不总是关于具有绑定到它的方法和实例变量的类型......）。虽然这种知识对你 95% 的日常工作没有帮助，但对于 5% 的工作，你将依赖于这些知识。

此外，您可以了解完全不同的计算风格，例如流/惰性评估，甚至逻辑编程。您还可以了解更多关于一般计算机程序是如何被解释的；从如何评估程序代码的基础知识，到更深层次的方面，例如制作自己的解释器和编译器）。了解这类信息是优秀程序员与优秀程序员的区别。

Scheme 并不是真正的函数式语言，它与方法无关。也许更重要的是，如果您想探索不同的计算方法，Scheme 是一种很好的语言选择。例如，在 Scheme 之上构建了一种高度并行的函数式语言“Termite”。

简而言之，学习计划的重点是让您可以学习编程的基础知识。

如果您需要一些帮助以使方案编程更愉快，请不要害怕问。许多程序员（例如）被括号挂断了，当有完美的方法来使用方案源代码时，使括号成为珍惜而不是讨厌的东西。例如，带有 paredit-mode、某种方案交互模式和高亮括号模式的 emacs 非常棒。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-19T01:46:58.117

我的问题是，当我们学习这个时，我们就一起学习了 clisp。我无法保持两条海峡来挽救我的生命。

我从他们身上学到的是如何编写更好的 c 和 java 代码。这仅仅是因为我学到了不同的编程风格。我已经将更多的函数式风格应用到我的一些编程中，并且在某些情况下它对我有所帮助。

如果我没有必要，我再也不想用 scheme 或 lisp 编程，但我很高兴我至少在它们中做了一点，只是为了学习不同的编程方式。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2014-02-06T22:05:14.297

像 Scheme 这样的函数式语言在数学、人工智能、语言学和其他高度理论的计算机科学领域（机器学习、自然语言处理等）有很大的应用。这是由于没有副作用的函数式编程语言的纯度，以及它们轻松导航高阶程序的能力。对函数式编程语言的深入了解对于解决许多刚刚超出计算机科学前沿的问题至关重要。作为奖励，你会在高阶过程和递归方面做得很好。

# 2d - 检测精灵之间碰撞的最佳方法？

> ID：98642
> 
> 赞同：3
> 
> 时间：2008-09-19T01:29:15.930
> 
> 标签：2d, collision-detection, allegro

在 2d 游戏精灵中检测碰撞的最佳方法是什么？我目前在 allegro 和 G++ 工作

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-19T01:35:37.550

任何体面的 2D 图形库要么为从对齐的精灵到多边形到像素的所有内容提供自己的碰撞检测功能，要么拥有一个或多个优秀的第三方库来执行这些功能。您对引擎/库/框架的选择应该决定您的碰撞检测选择，因为它们可能比您单独生产的优化得多。

对于 Allegro 有[Collegro](http://www.playingwithyarn.net/collegro/)。对于 SDL，有[SDL_Collide.h](http://www.angelfire.com/vamp/genjix/sdl_lib/SDL_Collide.h)或[SDL-Collide](http://sdl-collide.sourceforge.net/)。您可以将[I_COLLIDE](http://www.cs.unc.edu/~geom/I_COLLIDE/index.html)与 OpenGL 一起使用。DarkBASIC 有一个内置的碰撞系统和[DarkPhysics](http://darkphysics.thegamecreators.com/index.php)，用于非常精确的交互，包括碰撞。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-19T01:48:13.170

有很多方法可以检测碰撞检测。如果取决于您使用的是 2d 还是 3d 环境，您使用的方法将略有改变。还要记住，在建立碰撞检测系统时，要考虑到您可能想要在游戏中实现的任何物理特性（大多数下降 3d 游戏都需要），以增强它的真实性。

简短的版本是使用边界框。或者换句话说，将世界上的每个实体都做成一个盒子，然后检查盒子的每个轴是否与其他实体发生碰撞。

使用大量实体来测试冲突，您可能需要检查八叉树。您可以简单地将世界划分为多个扇区，然后仅检查同一扇区中的对象之间的碰撞。

更多资源，你可以去 sourceforge 搜索 Bullet 动态引擎，它是一个开源的碰撞检测和物理引擎，或者你可以查看[http://www.gamedev.net](http://www.gamedev.net)，它有大量的游戏开发资源话题。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T01:46:49.100

使用库，我推荐[Box2D](http://www.box2d.org/)

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T01:38:48.353

这个问题很笼统。在 2d 游戏中进行碰撞检测有很多方法。这将有助于了解您正在尝试做什么。

不过，作为一个起点，有一些非常简单的方法可以在圆形、矩形等之间进行检测。我不是 gamedev.net 的忠实粉丝，但是那里有一些关于这种检测的好资源。一篇这样的文章在[这里](http://www.gamedev.net/reference/articles/article735.asp)。它涵盖了一些可能有助于您入门的基本材料。

基本的 2d 游戏可以使用矩形或圆形来“包围”屏幕上的对象。检测矩形何时重叠或圆形何时重叠是相当简单的数学运算。如果您需要更复杂的东西（例如凸任意多边形），那么解决方案会更复杂。同样，gamedev.net 在这里可能会有所帮助。

但要真正回答您的问题，我们需要知道您要做什么？什么类型的游戏？你想碰撞什么类型的物体？您是否试图与屏幕边界等发生冲突？

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2009-04-27T11:57:56.037

在 2D 中检查两个球之间的碰撞很容易。你可以用谷歌搜索，但基本上你检查两个球半径的长度是否大于或等于两个球中心之间的距离。

然后，您可以通过获取球中心之间的单位向量并将其与球半径之一相乘来找到碰撞点。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2009-08-19T06:01:11.803

碰撞检测系统的实现是一件复杂的事情，但是您要考虑三点。

*   物体的世界。空间分区。如果您对世界中的每个 2d 精灵与其他所有东西进行碰撞检查，那么您的程序会很慢！你需要优先考虑。您需要对空间进行分区。您可以使用正交网格系统并将您的世界分割成二维网格。或者您可以使用 BSP 树，使用行作为分隔符函数。

*   广泛的相位碰撞检测这使用圆柱体或椭圆等边界体积（以最接近您的精灵的形状）来确定对象是否值得进行更详细的比较。数学很容易。学习你的二维矩阵变换。而对于 2d 路口，您甚至可以使用高功率显卡来完成大量工作！

*   窄相碰撞检测 既然您已经确定两个或多个对象值得比较，您就可以进入微调部分。此阶段的目标是确定碰撞结果。穿透深度、包含的体积等……这些信息将被输入到您计划的任何物理引擎中。在 3d 中，这是 GJK 距离算法和我们都非常喜欢的其他整洁算法的领域！

您可以通用地实现所有这些并以多态方式指定广义和狭义分辨率，或者如果您使用较低级别的语言工作，则可以提供一个挂钩。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T01:32:00.133

之间有什么碰撞？这取决于您是否使用精灵、凹多边形、凸多边形、矩形、正方形、圆形、点...

# c++ - 什么是严格的别名规则？

> ID：98650
> 
> 赞同：906
> 
> 时间：2008-09-19T01:30:27.830
> 
> 标签：c++, c, undefined-behavior, strict-aliasing, type-punning

当询问[C 中常见的未定义行为时](https://stackoverflow.com/questions/98340/what-are-the-common-undefinedunspecified-behavior-for-c-that-you-run-into)，人们有时会提到严格的别名规则。
他们在说什么？

* * *

## 回答 #1

> 赞同：640
> 
> 时间：2008-09-19T02:36:24.677

遇到严格别名问题的典型情况是，将结构（如设备/网络消息）覆盖到系统字长的缓冲区（如指向`uint32_t`s 或`uint16_t`s 的指针）上。当您将结构覆盖到这样的缓冲区上时，或者通过指针转换将缓冲区覆盖到这样的结构上时，您很容易违反严格的别名规则。

所以在这种设置中，如果我想向某个东西发送消息，我必须有两个不兼容的指针指向同一个内存块。然后我可能会天真地编写如下代码：

```
typedef struct Msg
{
    unsigned int a;
    unsigned int b;
} Msg;

void SendWord(uint32_t);

int main(void)
{
    // Get a 32-bit buffer from the system
    uint32_t* buff = malloc(sizeof(Msg));

    // Alias that buffer through message
    Msg* msg = (Msg*)(buff);

    // Send a bunch of messages    
    for (int i = 0; i < 10; ++i)
    {
        msg->a = i;
        msg->b = i+1;
        SendWord(buff[0]);
        SendWord(buff[1]);   
    }
} 
```

[严格的别名规则使此设置非法：取消引用一个指针，该指针对不属于兼容类型或 C 2011 6.5 第 7](http://en.cppreference.com/w/c/language/type) ¹段允许的其他类型之一的对象进行别名是未定义的行为。不幸的是，你仍然可以用这种方式编码，*可能*会得到一些警告，让它编译得很好，只是在你运行代码时会出现奇怪的意外行为。

（GCC 在给出别名警告的能力上似乎有些不一致，有时给我们一个友好的警告，有时不是。）

要了解为什么这种行为是未定义的，我们必须考虑严格的别名规则购买编译器的原因。基本上，有了这条规则，它就不必考虑插入指令来刷新`buff`每次循环运行的内容。相反，在优化时，通过一些关于别名的令人讨厌的非强制假设，它可以省略这些指令，在循环运行之前加载`buff[0]`并加载`buff[1]`到 CPU 寄存器中，并加速循环体。在引入严格别名之前，编译器必须生活在一种妄想状态，其内容`buff`可能会被任何先前的内存存储所改变。因此，为了获得额外的性能优势，并假设大多数人不键入双关指针，引入了严格的别名规则。

请记住，如果您认为该示例是人为的，那么如果您将缓冲区传递给另一个为您发送的函数（如果您有的话），甚至可能会发生这种情况。

```
void SendMessage(uint32_t* buff, size_t size32)
{
    for (int i = 0; i < size32; ++i) 
    {
        SendWord(buff[i]);
    }
} 
```

并重写了我们之前的循环以利用这个方便的功能

```
for (int i = 0; i < 10; ++i)
{
    msg->a = i;
    msg->b = i+1;
    SendMessage(buff, 2);
} 
```

编译器可能会或可能不会或足够聪明地尝试内联 SendMessage，它可能会或可能不会决定再次加载或不加载 buff。如果`SendMessage`是另一个单独编译的 API 的一部分，它可能有加载 buff 内容的指令。再说一次，也许你在 C++ 中，这是编译器认为它可以内联的一些模板化头实现。或者，这只是您在 .c 文件中为您自己的方便而编写的内容。无论如何，可能仍会出现未定义的行为。即使我们知道幕后发生的一些事情，它仍然违反规则，因此不能保证明确定义的行为。因此，仅仅通过包装一个接受我们的单词分隔缓冲区的函数并不一定有帮助。

**那么我该如何解决呢？**

*   使用工会。大多数编译器都支持这一点，而不会抱怨严格的别名。这在 C99 中是允许的，在 C11 中是明确允许的。

    ```
     union {
          Msg msg;
          unsigned int asBuffer[sizeof(Msg)/sizeof(unsigned int)];
      }; 
    ```

*   您可以在编译器中禁用严格别名（ gcc 中的[f[no-]strict-aliasing](http://gcc.gnu.org/onlinedocs/gcc-4.6.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-825)））

*   您可以使用`char*`别名而不是系统的单词。规则允许`char*`（包括`signed char`和`unsigned char`）例外。它总是假定`char*`别名其他类型。但是，这不会以另一种方式起作用：没有假设您的结构别名为字符缓冲区。

**初学者小心**

当两种类型相互叠加时，这只是一个潜在的雷区。您还应该了解[字节序](http://en.wikipedia.org/wiki/Endianness)、[字对齐以及如何通过正确](http://web.archive.org/web/20170708093042/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/aligned.html)[打包结构](http://grok2.com/structure_packing.html)来处理对齐问题。

## 脚注

¹ C 2011 6.5 7 允许左值访问的类型有：

*   与对象的有效类型兼容的类型，
*   与对象的有效类型兼容的类型的限定版本，
*   与对象的有效类型相对应的有符号或无符号类型，
*   对应于对象有效类型的限定版本的有符号或无符号类型，
*   聚合或联合类型，在其成员中包括上述类型之一（递归地包括子聚合或包含联合的成员），或
*   一种字符类型。

* * *

## 回答 #2

> 赞同：263
> 
> 时间：2008-09-19T01:38:15.797

我找到的最好的解释是 Mike Acton，[Understanding Strict Aliasing](http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html)。它稍微专注于 PS3 开发，但基本上只是 GCC。

来自文章：

> “严格别名是由 C（或 C++）编译器做出的假设，即取消引用指向不同类型对象的指针永远不会引用相同的内存位置（即彼此别名。）”

所以基本上，如果你有一个`int*`指向某个包含 an 的内存`int`，然后你将 a`float*`指向那个内存并将它用作 a`float`你就违反了规则。如果您的代码不遵守这一点，那么编译器的优化器很可能会破坏您的代码。

该规则的例外是 a `char*`，它允许指向任何类型。

* * *

## 回答 #3

> 赞同：146
> 
> 时间：2011-08-10T04:43:33.067

这是**C++03**标准第 3.10 节中的严格别名规则（其他答案提供了很好的解释，但没有提供规则本身）：

> 如果程序尝试通过以下类型之一以外的左值访问对象的存储值，则行为未定义：
> 
> *   对象的动态类型，
> *   对象的动态类型的 cv 限定版本，
> *   与对象的动态类型相对应的有符号或无符号类型，
> *   对应于对象动态类型的 cv 限定版本的有符号或无符号类型，
> *   聚合或联合类型，在其成员中包含上述类型之一（递归地包括子聚合或包含联合的成员），
> *   一个类型，它是对象的动态类型的（可能是 cv 限定的）基类类型，
> *   一个`char`或`unsigned char`类型。

**C++11**和**C++14**措辞（强调更改）：

> 如果程序尝试通过非下列类型之一的*泛左值访问对象的存储值，则行为未定义：*
> 
> *   对象的动态类型，
> *   对象的动态类型的 cv 限定版本，
> *   *与对象的动态类型类似（如 4.4 中定义）的类型，*
> *   与对象的动态类型相对应的有符号或无符号类型，
> *   对应于对象动态类型的 cv 限定版本的有符号或无符号类型，
> *   *聚合或联合类型，在其元素或非静态数据成员*中包括上述类型之一（递归地包括子聚合或包含联合的*元素或非静态数据成员*），
> *   一个类型，它是对象的动态类型的（可能是 cv 限定的）基类类型，
> *   一个`char`或`unsigned char`类型。

两个变化很小：*glvalue*而不是*lvalue*，以及聚合/联合情况的澄清。

第三个更改提供了更强的保证（放宽了强别名规则）：*类似类型*的新概念现在可以安全地使用别名。

* * *

还有**C**措辞（C99；ISO/IEC 9899:1999 6.5/7；在 ISO/IEC 9899:2011 §6.5 ¶7 中使用完全相同的措辞）：

> 对象的存储值只能由具有以下类型^(73) 或 88))之一的左值表达式访问：
> 
> *   与对象的有效类型兼容的类型，
> *   与对象的有效类型兼容的类型的限定版本，
> *   与对象的有效类型相对应的有符号或无符号类型，
> *   对应于对象有效类型的限定版本的有符号或无符号类型，
> *   聚合或联合类型，在其成员中包括上述类型之一（递归地包括子聚合或包含联合的成员），或
> *   一种字符类型。
> 
> ^(73) 或 88))此列表的目的是指定对象可能或可能不会被别名的情况。

* * *

## 回答 #4

> 赞同：139
> 
> 时间：2018-07-08T02:07:40.980

## 笔记

这摘自我的[“什么是严格的别名规则以及我们为什么要关心？”](https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8) 写上去。

## 什么是严格别名？

在 C 和 C++ 中，别名与允许我们访问存储值的表达式类型有关。在 C 和 C++ 中，标准都指定了允许哪些表达式类型为哪些类型设置别名。允许编译器和优化器假设我们严格遵循别名规则，因此术语*严格别名规则*。如果我们尝试使用不允许的类型访问值，则将其归类为[未定义行为](http://en.cppreference.com/w/cpp/language/ub)( **UB** )。一旦我们有未定义的行为，所有的赌注都被取消了，我们的程序的结果就不再可靠了。

不幸的是，由于严格的别名违规，我们通常会获得我们期望的结果，从而使具有新优化的编译器的未来版本可能会破坏我们认为有效的代码。这是不可取的，了解严格的别名规则以及如何避免违反它们是一个值得的目标。

为了更多地了解我们为什么关心，我们将讨论违反严格别名规则时出现的问题，类型双关，因为类型双关中使用的常用技术经常违反严格的别名规则以及如何正确键入双关。

### 初步示例

让我们看一些示例，然后我们可以确切地讨论标准所说的内容，检查一些进一步的示例，然后看看如何避免严格的混叠并捕获我们错过的违规行为。这是一个不应令人惊讶的示例（[现场示例](https://wandbox.org/permlink/7sCJTAyrifZ0zfFA)）：

```
int x = 10;
int *ip = &x;

std::cout << *ip << "\n";
*ip = 12;
std::cout << x << "\n"; 
```

我们有一个*int**指向一个 int 占用的内存*，*这是一个有效的别名。优化器必须假设通过**ip的赋值可以更新****x**占用的值。

下一个示例显示了导致未定义行为的别名（[现场示例](https://wandbox.org/permlink/8qA8JyJRVHtS9LPf)）：

```
int foo( float *f, int *i ) { 
    *i = 1;               
    *f = 0.f;            

   return *i;
}

int main() {
    int x = 0;

    std::cout << x << "\n";   // Expect 0
    x = foo(reinterpret_cast<float*>(&x), &x);
    std::cout << x << "\n";   // Expect 0?
} 
```

在函数**foo**中，我们接受一个*int**和一个*float**，在这个例子中，我们调用**foo**并设置两个参数指向同一个内存位置，在这个例子中包含一个*int*。请注意，[reinterpret_cast](http://en.cppreference.com/w/cpp/language/reinterpret_cast)告诉编译器将表达式视为具有由其模板参数指定的类型。在这种情况下，我们告诉它将表达式**&x**视为其类型为*float**。我们可能天真地期望第二个**cout**的结果为**0**，但使用**-O2**启用优化后，gcc 和 clang 都会产生以下结果：

```
0
1 
```

这可能不是预期的，但完全有效，因为我们调用了未定义的行为。*浮点数*不能有效地为int*对象*起别名。因此，优化器可以假设在取消引用**i时存储的***常量 1*将是返回值，因为通过**f**进行的存储不能有效地影响*int*对象。在编译器资源管理器中插入代码表明这正是正在发生的事情（[现场示例](https://godbolt.org/g/yNV5aj)）：

 *****```
foo(float*, int*): # @foo(float*, int*)
mov dword ptr [rsi], 1  
mov dword ptr [rdi], 0
mov eax, 1                       
ret 
```

[使用基于类型的别名分析 (TBAA)](http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/2000/0010/0010d/0010d.htm)的优化器假定将返回**1**并将常量值直接移动到带有返回值的寄存器**eax中。**TBAA 使用语言规则关于允许使用别名的类型来优化加载和存储。在这种情况下，TBAA 知道*float*不能别名和*int并优化***i**的负载。

## 现在，到规则书

标准到底说我们被允许和不允许做什么？标准语言并不简单，因此对于每个项目，我将尝试提供代码示例来演示其含义。

### C11 标准是怎么说的？

**C11**标准在第 6.5 节表达式第 7 段中说明了以下*内容*：

> 对象的存储值只能由具有以下类型之一的左值表达式访问：^(88)) — 与对象的有效类型兼容的类型，

```
int x = 1;
int *p = &x;   
printf("%d\n", *p); // *p gives us an lvalue expression of type int which is compatible with int 
```

> — 与对象的有效类型兼容的类型的限定版本，

```
int x = 1;
const int *p = &x;
printf("%d\n", *p); // *p gives us an lvalue expression of type const int which is compatible with int 
```

> — 与对象的有效类型相对应的有符号或无符号类型，

```
int x = 1;
unsigned int *p = (unsigned int*)&x;
printf("%u\n", *p ); // *p gives us an lvalue expression of type unsigned int which corresponds to 
                     // the effective type of the object 
```

[gcc/clang 有一个扩展](https://twitter.com/shafikyaghmour/status/957702383810658304)并且允许将[unsigned](https://gcc.gnu.org/ml/gcc/2003-10/msg00184.html) *int**分配给*int** ，即使它们不是兼容的类型。

> — 对应于对象有效类型的限定版本的有符号或无符号类型，

```
int x = 1;
const unsigned int *p = (const unsigned int*)&x;
printf("%u\n", *p ); // *p gives us an lvalue expression of type const unsigned int which is a unsigned type 
                     // that corresponds with to a qualified verison of the effective type of the object 
```

> — 在其成员中包含上述类型之一的聚合或联合类型（递归地，包括子聚合或包含联合的成员），或

```
struct foo {
  int x;
};

void foobar( struct foo *fp, int *ip );  // struct foo is an aggregate that includes int among its members so it can
                                         // can alias with *ip

foo f;
foobar( &f, &f.x ); 
```

> — 一种字符类型。

```
int x = 65;
char *p = (char *)&x;
printf("%c\n", *p );  // *p gives us an lvalue expression of type char which is a character type.
                      // The results are not portable due to endianness issues. 
```

### C++17 草案标准怎么说

*[basic.lval] 第 11*节中的 C++17 标准草案说：

> 如果程序尝试通过非下列类型之一的泛左值访问对象的存储值，则行为未定义：^(63) (11.1) — 对象的动态类型，

```
void *p = malloc( sizeof(int) ); // We have allocated storage but not started the lifetime of an object
int *ip = new (p) int{0};        // Placement new changes the dynamic type of the object to int
std::cout << *ip << "\n";        // *ip gives us a glvalue expression of type int which matches the dynamic type 
                                  // of the allocated object 
```

> (11.2) — 对象动态类型的 cv 限定版本，

```
int x = 1;
const int *cip = &x;
std::cout << *cip << "\n";  // *cip gives us a glvalue expression of type const int which is a cv-qualified 
                            // version of the dynamic type of x 
```

> (11.3) — 与对象的动态类型类似（如 7.5 中定义）的类型，
> 
> (11.4) — 对应于对象动态类型的有符号或无符号类型，

```
// Both si and ui are signed or unsigned types corresponding to each others dynamic types
// We can see from this godbolt(https://godbolt.org/g/KowGXB) the optimizer assumes aliasing.
signed int foo( signed int &si, unsigned int &ui ) {
  si = 1;
  ui = 2;

  return si;
} 
```

> (11.5) — 有符号或无符号类型，对应于对象动态类型的 cv 限定版本，

```
signed int foo( const signed int &si1, int &si2); // Hard to show this one assumes aliasing 
```

> (11.6) — 一种聚合或联合类型，在其元素或非静态数据成员中包括上述类型之一（递归地包括子聚合或包含联合的元素或非静态数据成员），

```
struct foo {
 int x;
};

// Compiler Explorer example(https://godbolt.org/g/z2wJTC) shows aliasing assumption
int foobar( foo &fp, int &ip ) {
 fp.x = 1;
 ip = 2;

 return fp.x;
}

foo f; 
foobar( f, f.x ); 
```

> (11.7) — 一种类型，它是对象的动态类型的（可能是 cv 限定的）基类类型，

```
struct foo { int x ; };

struct bar : public foo {};

int foobar( foo &f, bar &b ) {
  f.x = 1;
  b.x = 2;

  return f.x;
} 
```

> (11.8) — char、unsigned char 或 std::byte 类型。

```
int foo( std::byte &b, uint32_t &ui ) {
  b = static_cast<std::byte>('a');
  ui = 0xFFFFFFFF;                   

  return std::to_integer<int>( b );  // b gives us a glvalue expression of type std::byte which can alias
                                     // an object of type uint32_t
} 
```

值得注意的是，上面的列表中没有包含*signed char* ，这与*C*中的一个显着区别*是字符类型*。

## 什么是类型双关语

我们已经到了这一点，我们可能想知道，我们为什么要别名？答案通常是*键入 pun*，通常使用的方法违反严格的别名规则。

有时我们想绕过类型系统并将对象解释为不同的类型。这称为*类型双关语*，将一段内存重新解释为另一种类型。*类型双关语*对于希望访问对象的底层表示以查看、传输或操作的任务很有用。我们发现使用类型双关语的典型领域是编译器、序列化、网络代码等……

传统上，这是通过获取对象的地址，将其转换为我们想要重新解释它的类型的指针，然后访问该值来完成的，或者换句话说，通过别名。例如：

```
int x =  1 ;

// In C
float *fp = (float*)&x ;  // Not a valid aliasing

// In C++
float *fp = reinterpret_cast<float*>(&x) ;  // Not a valid aliasing

printf( "%f\n", *fp ) ; 
```

正如我们之前看到的，这不是一个有效的别名，所以我们调用了未定义的行为。但是传统的编译器并没有利用严格的别名规则，而且这种类型的代码通常可以正常工作，不幸的是，开发人员已经习惯了这种方式。类型双关语的一种常见替代方法是通过联合，这在 C 中有效，但在 C++ 中*未定义行为（*[请参阅实时示例](https://wandbox.org/permlink/oOf9bPlcWDYrYqPF)）：

```
union u1
{
  int n;
  float f;
} ;

union u1 u;
u.f = 1.0f;

printf( "%d\n”, u.n );  // UB in C++ n is not the active member 
```

这在 C++ 中是无效的，有些人认为联合的目的仅仅是为了实现变体类型，并认为使用联合进行类型双关是一种滥用。

### 我们如何正确输入双关语？

C 和 C++ 中*类型双关*的标准方法是**memcpy**。这可能看起来有点笨拙，但优化器应该认识到**memcpy**用于*类型双关*并优化它并生成一个寄存器来注册移动。例如，如果我们知道*int64_t*的大小与*double*相同：

```
static_assert( sizeof( double ) == sizeof( int64_t ) );  // C++17 does not require a message 
```

我们可以使用**memcpy**：

```
void func1( double d ) {
  std::int64_t n;
  std::memcpy(&n, &d, sizeof d); 
  //... 
```

在足够的优化级别上，任何体面的现代编译器都会生成与前面提到的**reinterpret_cast**方法或*union**类型双关语*方法相同的代码。检查生成的代码，我们看到它只使用了 register mov（[实时编译器资源管理器示例](https://godbolt.org/g/BfZGwX)）。

## C++20 和 bit_cast

在 C++20 中，我们可能会获得**bit_cast**（[实现在来自提案的链接中可用](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0476r2.html)），它为类型双关语提供了一种简单而安全的方法，并且可以在 constexpr 上下文中使用。

以下是如何使用**bit_cast将***unsigned int*类型双关语转换为*float*的示例，（[现场查看](https://wandbox.org/permlink/i5l0g4IYuCFgLzzl)）：

```
std::cout << bit_cast<float>(0x447a0000) << "\n" ; //assuming sizeof(float) == sizeof(unsigned int) 
```

在*To*和*From*类型不具有相同大小的情况下，它需要我们使用中间结构 15。我们将使用一个包含**sizeof( unsigned int )**字符数组（*假设 4 字节 unsigned int*）作为*From*类型和*unsigned int*作为*To*类型的结构：

```
struct uint_chars {
 unsigned char arr[sizeof( unsigned int )] = {} ;  // Assume sizeof( unsigned int ) == 4
};

// Assume len is a multiple of 4 
int bar( unsigned char *p, size_t len ) {
 int result = 0;

 for( size_t index = 0; index < len; index += sizeof(unsigned int) ) {
   uint_chars f;
   std::memcpy( f.arr, &p[index], sizeof(unsigned int));
   unsigned int result = bit_cast<unsigned int>(f);

   result += foo( result );
 }

 return result ;
} 
```

不幸的是，我们需要这种中间类型，但这是**bit_cast**的当前约束。

## 捕获严格的别名违规行为

我们没有很多好的工具来捕捉 C++ 中的严格别名，我们拥有的工具将捕捉一些严格别名违规的情况以及一些未对齐的加载和存储的情况。

使用标志**-fstrict-aliasing**和**-Wstrict-aliasing**的 gcc可以捕获某些情况，尽管并非没有误报/误报。例如，以下情况将在 gcc 中生成警告（[现场查看](https://wandbox.org/permlink/cfckjTgwNTYHDIry)）：

```
int a = 1;
short j;
float f = 1.f; // Originally not initialized but tis-kernel caught 
               // it was being accessed w/ an indeterminate value below

printf("%i\n", j = *(reinterpret_cast<short*>(&a)));
printf("%i\n", j = *(reinterpret_cast<int*>(&f))); 
```

虽然它不会捕捉到这种额外的情况（[现场观看](https://wandbox.org/permlink/dwd9jhy53AF7a2D0)）：

```
int *p;

p=&a;
printf("%i\n", j = *(reinterpret_cast<short*>(p))); 
```

尽管 clang 允许使用这些标志，但它显然并没有真正实现警告。

我们可以使用的另一个工具是 ASan，它可以捕获未对齐的负载和存储。尽管这些不是直接的严格混叠违规，但它们是严格混叠违规的常见结果。例如，以下情况在使用**-fsanitize=address使用 clang 构建时会产生运行时错误**

```
int *x = new int[2];               // 8 bytes: [0,7].
int *u = (int*)((char*)x + 6);     // regardless of alignment of x this will not be an aligned address
*u = 1;                            // Access to range [6-9]
printf( "%d\n", *u );              // Access to range [6-9] 
```

我要推荐的最后一个工具是 C++ 特定的，严格来说不是一个工具，而是一种编码实践，不允许 C 风格的强制转换。gcc 和 clang 都将使用**-Wold-style-cast**生成 C 风格转换的诊断。这将强制任何未定义的类型双关语使用 reinterpret_cast，通常 reinterpret_cast 应该是更仔细的代码审查的标志。在代码库中搜索 reinterpret_cast 以执行审计也更容易。

对于 C，我们已经涵盖了所有工具，并且我们还有 tis-interpreter，这是一个静态分析器，可以详尽地分析 C 语言的大部分子集的程序。给定早期示例的 C 版本，其中使用**-fstrict-aliasing 会遗漏**一种情况（[现场查看](https://wandbox.org/permlink/ebLBJ17Pg7TsnIgY)）

```
int a = 1;
short j;
float f = 1.0 ;

printf("%i\n", j = *((short*)&a));
printf("%i\n", j = *((int*)&f));

int *p; 

p=&a;
printf("%i\n", j = *((short*)p)); 
```

tis-interpeter 能够捕获所有三个，以下示例调用 tis-kernal 作为 tis-interpreter（为简洁起见，编辑了输出）：

```
./bin/tis-kernel -sa example1.c 
...
example1.c:9:[sa] warning: The pointer (short *)(& a) has type short *. It violates strict aliasing
              rules by accessing a cell with effective type int.
...

example1.c:10:[sa] warning: The pointer (int *)(& f) has type int *. It violates strict aliasing rules by
              accessing a cell with effective type float.
              Callstack: main
...

example1.c:15:[sa] warning: The pointer (short *)p has type short *. It violates strict aliasing rules by
              accessing a cell with effective type int. 
```

最后是目前正在开发的[TySan 。](https://www.youtube.com/watch?v=vAXJeN7k32Y)此清理程序在影子内存段中添加类型检查信息并检查访问以查看它们是否违反别名规则。该工具可能应该能够捕获所有混叠违规，但可能会有很大的运行时开销。

* * *

## 回答 #5

> 赞同：47
> 
> 时间：2011-06-19T23:46:55.567

严格别名不仅仅指指针，它也影响引用，我为 boost developer wiki 写了一篇关于它的论文，它很受欢迎，我把它变成了我的咨询网站上的一个页面。它完全解释了它是什么，为什么它让人们如此困惑以及如何处理它。[严格别名白皮书](http://dbp-consulting.com/tutorials/StrictAliasing.html)。特别是它解释了为什么联合是 C++ 的危险行为，以及为什么使用 memcpy 是唯一可跨 C 和 C++ 移植的修复程序。希望这会有所帮助。

* * *

## 回答 #6

> 赞同：36
> 
> 时间：2013-05-14T02:37:04.090

作为 Doug T. 已经写过的内容的附录，这是一个简单的测试用例，它可能会使用 gcc 触发它：

检查.c

```
#include <stdio.h>

void check(short *h,long *k)
{
    *h=5;
    *k=6;
    if (*h == 5)
        printf("strict aliasing problem\n");
}

int main(void)
{
    long      k[1];
    check((short *)k,k);
    return 0;
} 
```

用 编译`gcc -O2 -o check check.c`。通常（对于我尝试过的大多数 gcc 版本）这会输出“严格别名问题”，因为编译器假定“h”不能与“check”函数中的“k”地址相同。因此，编译器优化了`if (*h == 5)`离开并总是调用 printf。

对这里感兴趣的是 x64 汇编代码，由 gcc 4.6.3 生成，在 ubuntu 12.04.2 for x64 上运行：

```
movw    $5, (%rdi)
movq    $6, (%rsi)
movl    $.LC0, %edi
jmp puts 
```

所以 if 条件完全从汇编代码中消失了。

* * *

## 回答 #7

> 赞同：22
> 
> 时间：2017-04-26T22:42:55.587

根据 C89 的基本原理，标准的作者不想要求编译器给出如下代码：

```
int x;
int test(double *p)
{
  x=5;
  *p = 1.0;
  return x;
} 
```

应该要求`x`在赋值语句和返回语句之间重新加载 的值，以便允许`p`可能指向的可能性`x`，并且赋值`*p`可能因此改变 的值`x`。编译器应该有权假定*在上述情况下*不会出现别名的概念是没有争议的。

不幸的是，C89 的作者以这样一种方式编写了他们的规则，如果从字面上理解，即使是下面的函数也会调用未定义的行为：

```
void test(void)
{
  struct S {int x;} s;
  s.x = 1;
} 
```

因为它使用 type 的左值`int`来访问 type 的对象`struct S`，而`int`不是可以用来访问 a 的类型`struct S`。因为将结构和联合的所有非字符类型成员的所有使用都视为未定义行为是荒谬的，所以几乎每个人都认识到至少在某些情况下，一种类型的左值可用于访问另一种类型的对象. 不幸的是，C 标准委员会未能定义这些情况是什么。

大部分问题是缺陷报告 #028 的结果，该报告询问了以下程序的行为：

```
int test(int *ip, double *dp)
{
  *ip = 1;
  *dp = 1.23;
  return *ip;
}
int test2(void)
{
  union U { int i; double d; } u;
  return test(&u.i, &u.d);
} 
```

缺陷报告 #28 指出程序调用未定义行为是因为写入“double”类型的联合成员并读取“int”类型之一的操作调用了实现定义的行为。这种推理是荒谬的，但构成了有效类型规则的基础，这些规则不必要地使语言复杂化，而对解决原始问题却无能为力。

解决原始问题的最佳方法可能是将有关规则目的的脚注视为规范性的，并使规则无法执行，除非在实际涉及使用别名的冲突访问的情况下。给定类似的东西：

```
 void inc_int(int *p) { *p = 3; }
 int test(void)
 {
   int *p;
   struct S { int x; } s;
   s.x = 1;
   p = &s.x;
   inc_int(p);
   return s.x;
 } 
```

内部没有冲突，`inc_int`因为对通过访问的存储的所有访问`*p`都是使用 type 的左值完成的`int`，并且没有冲突，`test`因为`p`显然是从 a 派生的`struct S`，并且到下一次`s`使用时，将对该存储进行所有访问通过`p`将已经发生。

如果代码稍微改变...

```
 void inc_int(int *p) { *p = 3; }
 int test(void)
 {
   int *p;
   struct S { int x; } s;
   p = &s.x;
   s.x = 1;  //  !!*!!
   *p += 1;
   return s.x;
 } 
```

`p`在这里，标记行上的和 访问之间存在别名冲突，`s.x`因为在执行时存在另一个引用，*该引用将用于访问相同的 storage*。

如果缺陷报告 028 说最初的示例调用了 UB，因为这两个指针的创建和使用之间存在重叠，这将使事情变得更加清晰，而无需添加“有效类型”或其他此类复杂性。

* * *

## 回答 #8

> 赞同：19
> 
> 时间：2008-09-19T01:38:01.117

通过指针强制转换（而不是使用联合）进行[类型双关是打破严格别名的主要示例。](http://en.wikipedia.org/wiki/Type_punning)

* * *

## 回答 #9

> 赞同：15
> 
> 时间：2017-12-24T12:04:46.780

看了很多答案，觉得有必要补充一下：

严格的别名（我会稍微描述一下）**很重要，因为**：

1.  内存访问可能很昂贵（性能方面），这就是为什么数据在写回物理内存之前**在 CPU 寄存器中进行操作的原因。**

2.  如果将两个不同 CPU 寄存器中的数据写入同一个内存空间，**我们无法预测**在 C 中编码时哪些数据会“存活”。

    在汇编中，我们手动对 CPU 寄存器的加载和卸载进行编码，我们将知道哪些数据保持不变。但是 C（谢天谢地）抽象了这个细节。

由于两个指针可以指向内存中的同一位置，这可能会导致**处理可能的冲突的复杂代码**。

这个额外的代码很慢并且**会损害性能**，因为它执行额外的内存读/写操作，这些操作既慢又（可能）不必要。

Strict aliasing rule 允许我们在假设两个指针不指向同一个内存块的情况下*避免***冗余机器代码**（另请参见关键字）。*`restrict`*

 *严格别名声明可以安全地假设指向不同类型的指针指向内存中的不同位置。

如果编译器注意到两个指针指向不同的类型（例如， an`int *`和 a `float *`），它将假定内存地址不同，并且**无法**防止内存地址冲突，从而产生更快的机器代码。

**例如**：

让我们假设以下函数：

```
void merge_two_ints(int *a, int *b) {
  *b += *a;
  *a += *b;
} 
```

为了处理`a == b`（两个指针都指向同一个内存）的情况，我们需要排序和测试我们将数据从内存加载到 CPU 寄存器的方式，所以代码最终可能是这样的：

1.  加载`a`和`b`从内存中。

2.  添加`a`到`b`.

3.  **保存** `b`并**重新加载** `a`。

    （从 CPU 寄存器保存到内存，从内存加载到 CPU 寄存器）。

4.  添加`b`到`a`.

5.  保存`a`（从 CPU 寄存器）到内存。

第 3 步非常慢，因为它需要访问物理内存。但是，需要防止出现`a`和`b`指向相同内存地址的实例。

严格的别名将允许我们通过告诉编译器这些内存地址明显不同来防止这种情况发生（在这种情况下，这将允许进一​​步优化，如果指针共享内存地址则无法执行）。

1.  这可以通过两种方式告诉编译器，通过使用不同的类型来指向。IE：

    ```
    void merge_two_numbers(int *a, long *b) {...} 
    ```

2.  使用`restrict`关键字。IE：

    ```
    void merge_two_ints(int * restrict a, int * restrict b) {...} 
    ```

现在，通过满足 Strict Aliasing 规则，可以避免第 3 步，并且代码将运行得更快。

事实上，通过添加`restrict`关键字，整个函数可以优化为：

1.  加载`a`和`b`从内存中。

2.  添加`a`到`b`.

3.  将结果保存到`a`和 到`b`.

这种优化以前不可能完成，因为可能发生碰撞（在哪里`a`和`b`将增加三倍而不是加倍）。

* * *

## 回答 #10

> 赞同：11
> 
> 时间：2008-09-19T01:33:31.770

严格的别名不允许不同的指针类型指向相同的数据。

[这篇文章](http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html)应该可以帮助你全面了解这个问题。

* * *

## 回答 #11

> 赞同：-3
> 
> 时间：2018-07-09T03:24:02.720

从技术上讲，在 C++ 中，严格的别名规则可能永远不适用。

注意间接定义（[* 运算符](http://eel.is/c++draft/expr.unary.op#def:indirection)）：

> 一元 * 运算符执行间接：应用它的表达式应该是指向对象类型的指针，或指向函数类型的指针，**结果是一个左值，指向****表达式指向**的对象或函数。

同样来自[glvalue的定义](http://eel.is/c++draft/basic.lval#1.1)

> 泛左值是一个表达式，它的求值决定了一个对象的身份，(...snip)

因此，在任何定义明确的程序跟踪中，glvalue 指的是一个对象。**所以所谓的严格别名规则永远不适用。**这可能不是设计师想要的。

# oop - 从小项目到大项目

> ID：98653
> 
> 赞同：4
> 
> 时间：2008-09-19T01:31:33.880
> 
> 标签：oop

我已经非常习惯于用 1,000 行或更少的代码编写小项目（乒乓球、俄罗斯方块、简单的 3d 游戏等）。然而，随着我编程能力的提高，我的组织却没有。我似乎让一切都相互依赖，所以我很难改变某件事的实现。

有什么想法可以让我的代码井井有条并能够处理大型项目吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T01:46:08.853

白板是你最好的朋友

原型设计（不一定是工作原型，使用记事卡或其他方法）

先计划！在你知道你的要求/目标之前不要编码

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T01:33:05.390

提前草拟建筑设计。它不必太详细，但想象一下您希望如何将事物总体上组合在一起。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-21T04:41:35.207

首先阅读重构（因 Martin Fowler 而闻名）。

通过学习重构，您可以学习如何编写易于更改、可读和简化的代码。

我建议在您首先了解重构之前不要学习设计模式。通过重构，您可以了解干净可读代码的主题。了解重构后，请继续阅读设计模式。当您需要编写更复杂的设计时，设计模式非常有用。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T01:34:21.970

使用设计模式是很好的第一步。

此外，花一点时间编写有关系统架构和应用程序要求的良好文档。

如果您还没有这样做，使用源代码管理将有所帮助。

在决定推出自己的库之前，寻找可能确实想要的库。

# javascript - Scriptaculous 无法使用最新的原型

> ID：98669
> 
> 赞同：0
> 
> 时间：2008-09-19T01:33:46.823
> 
> 标签：javascript, prototypejs, scriptaculous

这是我一直遇到的一个非常奇怪的问题。当我从官方网站下载*Scriptaculous时，* [script.aculo.us](http://script.aculo.us "脚本.aculo.us")捆绑在 ZIP 中的是*prototype.js*版本 1.6.0.1。这工作得很好，我可以按照 wiki 示例开始学习。[但是，当我从prototypejs.org](http://www.prototypejs.org/ "原型 JS")升级到原型1.6.0.2（最新版本）时， 一切都中断了。我已阅读文档，将新文件命名为*prototype.js*，但没有任何效果。任何帮助是极大的赞赏！

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T01:37:57.437

scriptaculous 是一个建立在原型之上的 JS 库。因此，他们将在发布计划中落后于原型。为确保 scriptaculous 仅与下载中的原型文件一起使用。

当然，只要有足够的时间和精力，您就可以找到从原型 1.6.0.1 到 1.6.0.2 的所有更改参考，但在较新版本的原型中真的有您今天需要的东西吗？如果没有，那么就等着纨绔子弟更新吧。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-04T12:47:44.847

从他们的源代码库中直接获取最新的 script.aculo.us 版本。他们网站上提供的压缩版本是古老的。我正在运行上周从他们的 repo 中获取的最新 script.aculo.us，并使用最新的 Prototype (1.6.0.3)，没有出现故障。

# python - python中数据库连接池的最佳解决方案是什么？

> ID：98687
> 
> 赞同：38
> 
> 时间：2008-09-19T01:36:03.447
> 
> 标签：python, mysql, connection-pooling

我开发了一些自定义的类似 DAO 的类来满足我的项目的一些非常特殊的要求，这是一个不在任何类型的框架内运行的服务器端进程。

该解决方案效果很好，只是每次发出新请求时，我都会通过 MySQLdb.connect 打开一个新连接。

将其切换为在 python 中使用连接池的最佳“直接”解决方案是什么？我正在想象类似 Java 的 commons DBCP 解决方案。

该进程运行时间很长，并且有许多线程需要发出请求，但不是同时发出请求……特别是在短暂地写出大量结果之前，它们做了很多工作。

编辑添加：经过更多搜索后，我发现[anitpool.py](http://furius.ca/antiorm/)看起来不错，但由于我对 python 比较陌生，我想我只是想确保我没有错过更明显/更惯用/更好的解决方案。

* * *

## 回答 #1

> 赞同：24
> 
> 时间：2008-09-19T04:11:38.877

在 MySQL 中？

我想说不要打扰连接池。它们通常是麻烦的根源，并且对于 MySQL，它们不会为您带来您希望的性能优势。这条道路可能需要付出很多努力——政治上——因为在这个领域有很多关于连接池优势的最佳实践和教科书式的冗长。

连接池只是无状态应用程序（例如 HTTP 协议）的后 Web 时代和有状态的长寿命批处理应用程序的前 Web 时代之间的桥梁。由于在 web 前的数据库中连接非常昂贵（因为过去没有人关心建立连接需要多长时间），所以后 web 应用程序设计了这种连接池方案，以便每次点击都不会产生如此巨大的处理开销在 RDBMS 上。

由于 MySQL 更像是一个 Web 时代的 RDBMS，因此连接非常轻量级和快速。我为 MySQL 编写了许多根本不使用连接池的大容量 Web 应用程序。

只要没有需要克服的政治障碍，您可能会从不这样做中受益。

* * *

## 回答 #2

> 赞同：18
> 
> 时间：2008-09-19T01:38:19.027

包装你的连接类。

限制您建立的连接数。返回未使用的连接。拦截关闭以释放连接。

更新：我在 dbpool.py 中放了这样的东西：

```
import sqlalchemy.pool as pool
import MySQLdb as mysql
mysql = pool.manage(mysql) 
```

* * *

## 回答 #3

> 赞同：18
> 
> 时间：2008-09-19T02:13:07.260

IMO，“更明显/更惯用/更好的解决方案”是使用现有的 ORM 而不是发明类似 DAO 的类。

在我看来，ORM 比“原始”SQL 连接更受欢迎。为什么？因为 Python*是*面向对象的，从 SQL 行到对象的映射*是*绝对必要的。处理不映射到 Python 对象的 SQL 行的用例并不多。

我认为[SQLAlchemy](http://www.sqlalchemy.org/)或[SQLObject](http://www.sqlobject.org/)（以及相关的连接池）是更惯用的 Pythonic 解决方案。

池作为一个单独的特性并不是很常见，因为纯 SQL（没有对象映射）对于受益于连接池的复杂、长时间运行的进程并不是很流行。是的，使用了纯 SQL ，但它*总是*用于更简单或更受控制的应用程序中，而池化没有帮助。

我想你可能有两种选择：

1.  修改您的类以使用 SQLAlchemy 或 SQLObject。虽然这起初看起来很痛苦（所有工作都被浪费了），但您应该能够利用所有的设计和思想。这只是采用广泛使用的 ORM 和池化解决方案的练习。
2.  使用您概述的算法推出您自己的简单连接池 - 您循环通过的简单连接集或列表。

* * *

## 回答 #4

> 赞同：9
> 
> 时间：2014-07-14T16:53:14.827

旧线程，但对于通用池（连接或任何昂贵的对象），我使用类似的东西：

```
def pool(ctor, limit=None):
    local_pool = multiprocessing.Queue()
    n = multiprocesing.Value('i', 0)
    @contextlib.contextmanager
    def pooled(ctor=ctor, lpool=local_pool, n=n):
        # block iff at limit
        try: i = lpool.get(limit and n.value >= limit)
        except multiprocessing.queues.Empty:
            n.value += 1
            i = ctor()
        yield i
        lpool.put(i)
    return pooled 
```

哪个是懒惰的构造，有一个可选的限制，并且应该推广到我能想到的任何用例。当然，这假设您确实需要任何资源的池化，而对于许多现代 SQL 类您可能不需要。用法：

```
# in main:
my_pool = pool(lambda: do_something())
# in thread:
with my_pool() as my_obj:
    my_obj.do_something() 
```

这确实假设 ctor 创建的任何对象在需要时都具有适当的析构函数（某些服务器不会终止连接对象，除非它们被显式关闭）。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2009-05-14T17:41:51.780

我一直在寻找同样的东西。

我找到了[pysqlpool](https://pythonhosted.org/PySQLPool/tutorial.html)和sqlalchemy[池模块](https://docs.sqlalchemy.org/en/14/)

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2011-08-22T22:05:55.430

如果您的应用决定开始使用多线程，那么创建自己的连接池是一个坏主意。为多线程应用程序创建连接池比为单线程应用程序创建连接池要复杂得多。在这种情况下，您可以使用 PySQLPool 之类的东西。

如果您正在寻找性能，那么使用 ORM 也是一个坏主意。

如果您要处理必须同时处理大量选择、插入、更新和删除的大型/重型数据库，那么您将需要性能，这意味着您需要编写自定义 SQL 来优化查找和锁定时间。使用 ORM，您通常没有这种灵活性。

所以基本上，是的，您可以创建自己的连接池并使用 ORM，但前提是您确定不需要我刚才描述的任何内容。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2017-06-10T17:32:34.367

回复一个旧线程但我上次检查时，MySQL 提供连接池作为其驱动程序的一部分。

您可以在以下位置查看它们：

> [https://dev.mysql.com/doc/connector-python/en/connector-python-connection-pooling.html](https://dev.mysql.com/doc/connector-python/en/connector-python-connection-pooling.html)

从 TFA，假设您要明确打开连接池（如 OP 所述）：

```
dbconfig = {  "database": "test", "user":"joe" }
cnxpool = mysql.connector.pooling.MySQLConnectionPool(pool_name = "mypool",pool_size = 3, **dbconfig) 
```

然后通过 get_connection() 函数从池中请求访问该池。

```
cnx1 = cnxpool.get_connection()
cnx2 = cnxpool.get_connection() 
```

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2018-11-11T07:05:22.527

使用`DBUtils`，简单可靠。

```
pip install DBUtils 
```

# linux - 我需要一个 Win/Linux 的二进制比较工具

> ID：98693
> 
> 赞同：3
> 
> 时间：2008-09-19T01:37:32.757
> 
> 标签：linux, windows, binary, comparison

首先，我不需要文本比较，所以 Beyond Compare 不能满足我的需要。

我正在寻找一个可以在字节级别报告两个文件之间差异的实用程序。最低限度是需要查看文件中的百分比变化，或有关受影响字节/扇区的报告。

有什么可以让我免于自己做这件事的麻烦吗？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-19T01:44:31.540

我找到[了 VBinDiff](http://www.cjmweb.net/vbindiff/)。我没有使用它，但它可能会做你想要的。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T01:42:14.353

我想这取决于文件中究竟包含什么，但这里有一个快速的：

```
hexdump file1 > file1.tmp
hexdump file2 > file2.tmp
diff file1.tmp file2.tmp 
```

由于每行通常报告 16 个字节，因此从技术上讲，这不会为您提供更改的字节数，但可以让您大致了解文件更改发生的位置。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T01:56:22.430

[UltraCompare](http://www.ultraedit.com/products/ultracompare.html)是二进制比较的最佳选择。它有一个非常有用的智能比较器。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T01:57:24.347

您可以使用[xdelta](http://xdelta.org/)。这是一个开源二进制差异工具，您可以使用它来制作二进制补丁，但我认为它也提供了有关发现差异的信息。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2011-11-04T20:45:59.463

ECMerge 最近推出了一种[二进制差异](http://www.elliecomputing.com)，它可以比较几个千兆字节的文件（限制在*tera*字节以上）。它适用于 linux、windows、mac os x 和 solaris。它为您提供逐个字节或每个块的统计信息。

您可以参数同步窗口（如果需要）和最小匹配。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-19T01:52:01.130

有可用于 Windows的[Araxis Merge 。](http://www.araxis.com/merge/index.html)这是描述其二进制比较功能的[页面。](http://www.araxis.com/merge/topic_comparing_binary_files.html)

# oop - 设计原则

> ID：98695
> 
> 赞同：15
> 
> 时间：2008-09-19T01:37:52.727
> 
> 标签：oop, principles

在进行班级设计时，您通常遵循哪些原则？

* * *

## 回答 #1

> 赞同：28
> 
> 时间：2008-09-19T01:39:35.950

### 面向对象类设计的原则（“SOLID”原则）

*   **SRP：单一职责原则**一个类应该有一个并且只有一个改变的理由。
*   **OCP：开放封闭原则**您应该能够扩展类行为，而无需修改它。
*   **LSP：Liskov 替换原则**派生类必须可以替换它们的基类。
*   **ISP：接口隔离原则**制作特定于客户端的细粒度接口。
*   **DIP：依赖倒置原则** 依赖于抽象，而不是具体。

资料来源：[http ://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)

视频（鲍勃叔叔）：[Robert C. Martin 的清洁编码（鲍勃叔叔）](https://www.youtube.com/watch?v=ZPDC13_9PkI)

* * *

## 回答 #2

> 赞同：7
> 
> 时间：2008-09-19T03:09:03.397

不要忘记得[墨忒耳法则](http://en.wikipedia.org/wiki/Law_of_Demeter)。

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-09-19T01:41:48.877

[SOLID](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)原则。
或者至少我尽量不远离他们。

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2008-09-19T03:34:32.150

The most fundamental design pattern should be KISS (keep it simple stupid) Which means that sometimes not using classes for some elements at all it the right solution.

That and CRC(Class, Responsibility, Collaborators) cards (write the card down in your header files, not on actual cards that way they because easy to understand documentation too)

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-19T02:15:19.717

如上所述，一些基本的面向对象设计原则是 OCP、LSP、DIP 和 ISP。

Robert C. Martin (of Object Mentor) 对这些内容进行了出色的概述：[OOD 原则和模式](http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf)

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-19T01:46:37.510

“[资源获取即初始化](http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)”范式很方便，尤其是在用 C++ 编写和处理操作系统资源（文件句柄、端口等）时。

这种方法的一个关键好处是对象一旦创建，就是“完整的”——不需要两阶段初始化，也不可能部分初始化对象。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-19T02:24:52.520

松耦合，高内聚。

组合优于继承。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-19T01:40:33.700

领域驱动设计通常是一个很好的原则。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-19T02:03:32.710

基本上我摆脱了对接口的编程。我尝试将通过案例更改的内容封装起来，以避免代码重复并将代码隔离为可管理的（对于我的大脑而言）块。稍后，如果需要，我可以很容易地重构代码。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-19T03:22:34.923

SOLID 原则和 Liskov 模式，以及单一责任模式。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2017-03-12T16:33:43.530

A thing which I would like to add to all this is layering, Define layers in your application, the overall responsibility of a layer, they way two layers will interact. Only classes which have the same responsibility as that of the layer should be allowed in that layer. Doing this resolves a lot of chaos, ensures exceptions are handled appropriately, and it makes sure that new developers know where to place their code.

另一种设计方法是将您的类设计为可配置的，创建一种可以将配置插入到您的类中的机制，而不是覆盖子类中的方法，确定哪些更改，查看是否可以配置并确保此功能是从配置派生

* * *

## 回答 #12

> 赞同：-2
> 
> 时间：2008-09-19T01:47:12.890

我通常会尝试将类融入其中一种 oo[设计模式。](http://en.wikipedia.org/wiki/Design_pattern_(computer_science))

# c++ - const 成员函数的语义是什么？

> ID：98705
> 
> 赞同：14
> 
> 时间：2008-09-19T01:38:28.013
> 
> 标签：c++, methods, constants

我知道该函数不允许更改对象的状态，但我想我在某处读到允许编译器假设如果使用相同的参数调用该函数，它将返回相同的值，因此可以重用缓存值（如果可用）。例如

```
class object
{
    int get_value(int n) const
    {
        ...
    }

...

object x;

int a = x.get_value(1);
    ...
int b = x.get_value(1); 
```

然后编译器可以优化第二次调用，或者使用寄存器中的值或者干​​脆做`b = a;`

这是真的？

* * *

## 回答 #1

> 赞同：26
> 
> 时间：2008-09-19T08:56:48.350

`const`是关于程序语义而不是关于实现细节。当成员函数`const`不改变对象的可见状态时，您应该标记它，并且应该可以在本身的对象上调用`const`。在`const`类的成员函数中`X`，类型`this`为`X const *`：指向常量`X`对象的指针。因此，所有成员变量都有效地`const`在该成员函数内（除了`mutable`那些）。如果你有一个`const`对象，你只能调用`const`它的成员函数。

您可以使用`mutable`指示成员变量即使在`const`成员函数内也可能发生变化。这通常用于识别用于缓存结果的变量，或者用于不影响实际可观察​​状态的变量，例如互斥体（您仍然需要在`const`成员函数中锁定互斥体）或使用计数器。

```
class X
{
    int data;
    mutable boost::mutex m;
public:
    void set_data(int i)
    {
        boost::lock_guard<boost::mutex> lk(m);
        data=i;
    }
    int get_data() const // we want to be able to get the data on a const object
    {
        boost::lock_guard<boost::mutex> lk(m); // this requires m to be non-const
        return data;
    }
}; 
```

如果您通过指针而不是直接保存数据（包括智能指针，例如`std::auto_ptr`or `boost::shared_ptr`），则指针变为`const`成员`const`函数，而不是指向的数据，因此您可以修改指向的数据。

至于缓存：通常编译器不能这样做，因为状态可能会在调用之间发生变化（尤其是在我使用互斥锁的多线程示例中）。但是，如果定义是内联的，那么编译器可以将代码拉入调用函数并优化它在那里可以看到的内容。这可能会导致该函数*实际上*只被调用一次。

下一版本的[C++ 标准 (C++0x)](http://www.open-std.org/jtc1/sc22/wg21/)将有一个新的关键字`constexpr`. 标记的函数`constexpr`返回一个常量值，因此可以缓存结果。在这样的函数中可以做的事情是有限制的（以便编译器可以验证这个事实）。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-19T01:52:14.157

不。

const 方法是一种不改变对象（即其字段）状态的方法，但您不能假设给定相同的输入，确定 const 方法的返回值。换句话说，`const`关键字并不意味着该函数是一对一的。例如，返回当前时间的方法是 const 方法，但它的返回值在调用之间发生变化。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-19T01:55:31.920

成员变量上的关键字[mutable](http://msdn.microsoft.com/en-us/library/4h2h0ktk(VS.80).aspx)允许 const 函数改变手头对象的状态。

不，它不会缓存数据（至少不是所有调用），因为以下代码是一个有效的 const 函数，会随时间变化：

```
int something() const { return m_pSomeObject->NextValue(); } 
```

请注意，指针可以是 const，尽管指向的对象不是 const，因此对 SomeObject 上的 NextValue 的调用可能会也可能不会改变它自己的内部状态。这会导致函数在每次调用时返回不同的值。

但是，我无法回答编译器如何使用 const 方法。我听说它可以优化某些东西，尽管我必须查一下才能确定。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-19T01:47:15.400

*成员函数上的 const 关键字将this*参数标记为常量。该函数仍然可以静音全局数据（因此无法缓存），但不能静音对象数据（允许调用 const 对象）。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-19T01:48:19.190

在这种情况下，`const`成员函数意味着也`this`被视为`const`指针。实际上，这意味着您不允许修改成员函数`this`内部的状态。`const`

对于无副作用的功能（即您要实现的功能），GCC 有一个称为“功能属性” `pure`（您可以通过说来使用它`__attribute__((pure))`）： http: [//gcc.gnu.org/onlinedocs/gcc/Function -Attributes.html](http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html)

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-19T01:43:47.297

我对此表示怀疑，该函数仍然可以调用一个改变世界状态且不违反 const 的全局函数。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T01:54:08.537

除了成员函数可以修改全局数据这一事实之外，成员函数还可以修改相关对象的显式声明的可变成员。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-19T01:55:40.793

Corey 是正确的，但请记住，任何标记为**可变的成员变量都** *可以*在 const 成员函数中进行修改。

这也意味着可以从其他 const 函数或通过其他 const 引用调用这些函数。

* * *

编辑：妈的，被打了9秒……9！！！:)

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-20T00:35:49.673

const 方法也可以修改静态局部变量。例如，以下是完全合法的（并且对 bar() 的重复调用将返回递增的值 - 而不是缓存的 0）：

```
class Foo
{
public:
    int bar() const
    {
        static int x = 0;
        return x++;
    }
}; 
```

# parsing - 关于如何在应用程序上添加导入 Finale 音乐文件的功能的建议？

> ID：98711
> 
> 赞同：1
> 
> 时间：2008-09-19T01:40:31.720
> 
> 标签：parsing

我正在开发一个音乐写作应用程序，并希望添加导入 Finale 音乐文件的功能。现在，我唯一知道的是它们是谜二进制文件。

有没有人对我可以从哪里开始有任何建议，以便我能够解析这些类型的文件？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-19T19:42:06.573

Finale 文件不仅仅是二进制文件，而是压缩、加密的二进制文件。ETF 文件是文本文件，在旧版本的 Finale 插件开发工具包中确实有一些文档。但 ETF 导出在几个版本前已从 Finale 中删除。

如前所述，最好的办法是导入 MusicXML 文件。这将在更短的开发时间内为您提供更高质量的导入。MusicXML 支持自 2006 年以来内置于 Finale，PrintMusic 自 2006 年以来，Allegro 和 Songwriter 自 2007 年以来内置，并将于 2009 年进入 NotePad 和 Reader。插件可用于从 Finale 导出 MusicXML 文件，一直到 Windows 上的 2000 年， 2004 在 Mac OS X PPC 上，2007 在 Mac OS X Intel 上。Finale 中的 MusicXML 支持已经开发了近 10 年，并提供了将 Finale 文件近乎无损地导出为开放、标准、免版税的格式。

超过 150 个程序支持 MusicXML，因此通过添加 MusicXML 支持，您不仅可以获得 Finale 文件支持，还支持最初使用 Sibelius、capella、Encore 或（通过 PDFtoMusic Pro）任何可以打印 PDF 版本的程序创建的文件乐谱。

[在http://www.makemusic.com/musicxml](http://www.makemusic.com/musicxml)上有很多关于 MusicXML 的信息。这包括 MusicXML DTD 和 XSD、教程、示例文件等。[在http://www.makemusic.com/musicxml/mailing-list](http://www.makemusic.com/musicxml/mailing-list)上还有一个 MusicXML 开发者邮件列表可供注册。

MusicXML 有很多特性，所以不要试图一次性解决所有这些。从支持音高和节奏的基础开始，然后根据客户的需求随着时间的推移添加越来越多的功能。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-19T03:28:47.840

获取一个*好的*十六进制编辑器并开始查看一些文件。寻找共同的结构。做一些侦探工作。在文件中查找可能是计数、大小或偏移量的字段。在 Finale 中进行细微的更改并观察文件中的更改。使用十六进制编辑器进行更改，然后将更改后的文件加载回 Finale 并查看更改是否符合您的预期。

所以这是一个完全没有帮助的答案，但扭转文件格式的最佳方法是跳进去然后去做。顺便说一句，您可能要经历一个很长的过程，但至少它很有趣。

哦，祈祷文件格式没有被压缩......

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T03:43:19.943

我不知道较旧的 .mus 文件，但较新的 .eft 文件在此处进行了部分描述：

[http://www.lilypond.org/web/devel/misc/etfformat](http://www.lilypond.org/web/devel/misc/etfformat)。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T03:54:35.097

我会研究 MusicXml 格式，[http://www.recordare.com/xml.html](http://www.recordare.com/xml.html)。

Finale 应该能够导出到 MusicXml。（我认为它与较新版本的 Finale 附带的插件一起使用）。从那里开始，它应该是相对简单的，因为它毕竟是 xml。

# finalbuilder - FinalBuilder 枚举文件和文件夹

> ID：98722
> 
> 赞同：1
> 
> 时间：2008-09-19T01:42:13.683
> 
> 标签：finalbuilder

使用 FinalBuilder 枚举一组文件和文件夹的最佳方法是什么？

我的问题的上下文是，我想将源文件夹与目标文件夹进行比较，并替换目标文件夹中比源文件夹更旧的任何匹配文件。

有什么建议么？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T02:05:29.663

好的，为了将来参考，事实证明在“迭代器”类别下有两个非常有用的操作。

1.  文件/文件集迭代器
2.  文件夹迭代器

进一步挖掘发现了 Robocopy Mirror 操作，它完全符合我的要求，即将目标文件夹与源文件夹同步。无需编写我自己的文件迭代例程。

> ID：98728
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98729
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98730
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98731
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98732
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98733
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98734
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98735
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98736
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98737
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98738
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98739
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98740
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98741
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98742
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98743
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98744
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98745
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98746
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98747
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98748
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98749
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98750
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98751
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98752
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98753
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98754
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98755
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98756
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98757
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98758
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98759
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98760
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98761
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98762
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98763
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98764
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98765
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98766
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98767
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98768
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98769
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98770
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98771
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98772
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98773
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98774
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98775
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98776
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98777
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98778
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98779
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98780
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98781
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98782
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98783
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98784
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98785
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98786
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98787
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98788
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98789
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98790
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98791
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98792
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98793
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98794
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98795
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98796
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98797
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98798
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98799
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98800
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98801
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98802
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98803
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98804
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98805
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98806
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98807
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98808
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98809
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98810
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98811
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98812
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98813
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98814
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98815
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98816
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98817
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98818
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98819
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98820
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98821
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98822
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98823
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98824
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98825
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98826
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98827
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98828
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98829
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98830
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98831
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98832
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98833
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98834
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98835
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98836
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98837
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98838
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98839
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98840
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98841
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98842
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98843
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98844
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98845
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98846
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98847
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98848
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98849
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98850
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98851
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98852
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98853
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98854
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98855
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98856
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98857
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98858
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98859
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98860
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98861
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98862
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98863
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98864
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98865
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98866
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98867
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98868
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98869
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98870
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98871
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98872
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98873
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98874
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98875
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98876
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98877
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98878
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98879
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98880
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98881
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98882
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98883
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98884
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98885
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98886
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98887
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98888
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98889
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98890
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98891
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98892
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98893
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98894
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98895
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98896
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98897
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98898
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98899
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98900
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98901
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98902
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98903
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98904
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98905
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98906
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98907
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98908
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98909
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98910
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98911
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98912
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98913
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98914
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98915
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98916
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98917
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98918
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98919
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98920
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98921
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98922
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98923
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98924
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98925
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98926
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98927
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98928
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98929
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98930
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98931
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98932
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98933
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98934
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98935
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98936
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98937
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98938
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98939
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98940
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98941
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98942
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98943
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98944
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98945
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98946
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98947
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98948
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98949
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98950
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98951
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98952
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98953
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98954
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98955
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98956
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98957
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98958
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98959
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98960
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98961
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98962
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98963
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98964
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98965
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98966
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98967
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98968
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98969
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98970
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98971
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98972
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98973
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98974
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98975
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98976
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98977
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98978
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98979
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98980
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98981
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98982
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98983
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98984
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98985
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98986
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98987
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98988
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98989
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98990
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98991
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98992
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98993
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98994
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98995
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98996
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98997
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98998
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None

> ID：98999
> 
> 赞同：
> 
> 时间：
> 
> 标签：

None*****************