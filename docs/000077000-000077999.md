# StackOverflow 问答 000077000-000077999

# c++ - 当我的程序崩溃时如何自动生成堆栈跟踪

> ID：77005
> 
> 赞同：663
> 
> 时间：2008-09-16T20:58:35.487
> 
> 标签：c++, gcc, crash, stack-trace, assert

我正在使用 GCC 编译器在 Linux 上工作。当我的 C++ 程序崩溃时，我希望它自动生成堆栈跟踪。

我的程序由许多不同的用户运行，它也可以在 Linux、Windows 和 Macintosh 上运行（所有版本都使用 编译`gcc`）。

我希望我的程序能够在崩溃时生成堆栈跟踪，并且下次用户运行它时，它会询问他们是否可以将堆栈跟踪发送给我，以便我可以追踪问题。我可以处理向我发送信息，但我不知道如何生成跟踪字符串。有任何想法吗？

* * *

## 回答 #1

> 赞同：572
> 
> 时间：2008-09-16T21:30:26.377

对于 Linux，我相信 Mac OS X，如果您使用 gcc 或任何使用 glibc 的编译器，您可以使用 backtrace() 函数`execinfo.h`打印堆栈跟踪，并在遇到分段错误时正常退出。文档可以[在 libc 手册](http://www.gnu.org/software/libc/manual/html_node/Backtraces.html)中找到。

这是一个示例程序，它安装`SIGSEGV`处理程序并在出现段错误时打印堆栈`stderr`跟踪。这里的`baz()`函数导致触发处理程序的段错误：

```
#include <stdio.h>
#include <execinfo.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

void handler(int sig) {
  void *array[10];
  size_t size;

  // get void*'s for all entries on the stack
  size = backtrace(array, 10);

  // print out all the frames to stderr
  fprintf(stderr, "Error: signal %d:\n", sig);
  backtrace_symbols_fd(array, size, STDERR_FILENO);
  exit(1);
}

void baz() {
 int *foo = (int*)-1; // make a bad pointer
  printf("%d\n", *foo);       // causes segfault
}

void bar() { baz(); }
void foo() { bar(); }

int main(int argc, char **argv) {
  signal(SIGSEGV, handler);   // install our handler
  foo(); // this will call foo, bar, and baz.  baz segfaults.
} 
```

编译时`-g -rdynamic`会在输出中获取符号信息，glibc 可以使用这些信息来制作漂亮的堆栈跟踪：

```
$ gcc -g -rdynamic ./test.c -o test 
```

执行这个得到你这个输出：

```
$ ./test
Error: signal 11:
./test(handler+0x19)[0x400911]
/lib64/tls/libc.so.6[0x3a9b92e380]
./test(baz+0x14)[0x400962]
./test(bar+0xe)[0x400983]
./test(foo+0xe)[0x400993]
./test(main+0x28)[0x4009bd]
/lib64/tls/libc.so.6(__libc_start_main+0xdb)[0x3a9b91c4bb]
./test[0x40086a] 
```

这显示了堆栈中每个帧来自的加载模块、偏移量和函数。在这里，您可以看到堆栈顶部的信号处理程序，以及`main`除`main`、`foo`、`bar`和之外的 libc 函数`baz`。

* * *

## 回答 #2

> 赞同：161
> 
> 时间：2011-07-06T15:51:26.417

它甚至比“man backtrace”更容易，有一个与 glibc 一起作为 libSegFault.so 分发的小文档库（GNU 特定），我相信它是由 Ulrich Drepper 编写的，用于支持程序 catchsegv（参见“man catchsegv”）。

这给了我们3种可能性。而不是运行“程序 -o hai”：

1.  在 catchsegv 中运行：

    ```
    $ catchsegv program -o hai 
    ```

2.  在运行时与 libSegFault 链接：

    ```
    $ LD_PRELOAD=/lib/libSegFault.so program -o hai 
    ```

3.  在编译时与 libSegFault 链接：

    ```
    $ gcc -g1 -lSegFault -o program program.cc
    $ program -o hai 
    ```

在所有 3 种情况下，您将获得更清晰的回溯，而优化更少（gcc -O0 或 -O1）和调试符号（gcc -g）。否则，你可能会得到一堆内存地址。

您还可以通过以下方式捕获更多堆栈跟踪信号：

```
$ export SEGFAULT_SIGNALS="all"       # "all" signals
$ export SEGFAULT_SIGNALS="bus abrt"  # SIGBUS and SIGABRT 
```

输出看起来像这样（注意底部的回溯）：

```
*** Segmentation fault Register dump:

 EAX: 0000000c   EBX: 00000080   ECX:
00000000   EDX: 0000000c  ESI:
bfdbf080   EDI: 080497e0   EBP:
bfdbee38   ESP: bfdbee20

 EIP: 0805640f   EFLAGS: 00010282

 CS: 0073   DS: 007b   ES: 007b   FS:
0000   GS: 0033   SS: 007b

 Trap: 0000000e   Error: 00000004  
OldMask: 00000000  ESP/signal:
bfdbee20   CR2: 00000024

 FPUCW: ffff037f   FPUSW: ffff0000  
TAG: ffffffff  IPOFF: 00000000  
CSSEL: 0000   DATAOFF: 00000000  
DATASEL: 0000

 ST(0) 0000 0000000000000000   ST(1)
0000 0000000000000000  ST(2) 0000
0000000000000000   ST(3) 0000
0000000000000000  ST(4) 0000
0000000000000000   ST(5) 0000
0000000000000000  ST(6) 0000
0000000000000000   ST(7) 0000
0000000000000000

Backtrace:
/lib/libSegFault.so[0xb7f9e100]
??:0(??)[0xb7fa3400]
/usr/include/c++/4.3/bits/stl_queue.h:226(_ZNSt5queueISsSt5dequeISsSaISsEEE4pushERKSs)[0x805647a]
/home/dbingham/src/middle-earth-mud/alpha6/src/engine/player.cpp:73(_ZN6Player5inputESs)[0x805377c]
/home/dbingham/src/middle-earth-mud/alpha6/src/engine/socket.cpp:159(_ZN6Socket4ReadEv)[0x8050698]
/home/dbingham/src/middle-earth-mud/alpha6/src/engine/socket.cpp:413(_ZN12ServerSocket4ReadEv)[0x80507ad]
/home/dbingham/src/middle-earth-mud/alpha6/src/engine/socket.cpp:300(_ZN12ServerSocket4pollEv)[0x8050b44]
/home/dbingham/src/middle-earth-mud/alpha6/src/engine/main.cpp:34(main)[0x8049a72]
/lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xe5)[0xb7d1b775]
/build/buildd/glibc-2.9/csu/../sysdeps/i386/elf/start.S:122(_start)[0x8049801] 
```

如果你想知道血淋淋的细节，不幸的是最好的来源是来源：参见[http://sourceware.org/git/?p=glibc.git;a=blob;f=debug/segfault.c](http://sourceware.org/git/?p=glibc.git;a=blob;f=debug/segfault.c)及其父目录[http://sourceware.org/git/?p=glibc.git;a=tree;f=debug](http://sourceware.org/git/?p=glibc.git;a=tree;f=debug)

* * *

## 回答 #3

> 赞同：127
> 
> 时间：2009-12-18T00:05:42.437

## Linux

[虽然已经建议](https://stackoverflow.com/questions/77005/how-to-generate-a-stacktrace-when-my-gcc-c-app-crashes/77336#77336)使用 execinfo.h 中的 backtrace() 函数打印堆栈跟踪并在遇到分段错误时优雅退出，但我没有提到确保生成的回溯指向实际位置所需的复杂性错误（至少对于某些架构 - x86 和 ARM）。

当您进入信号处理程序时，堆栈帧链中的前两个条目包含信号处理程序内部的返回地址和 libc 中的 sigaction() 内部的一个。信号前调用的最后一个函数的堆栈帧（即故障位置）丢失。

## 代码

```
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#ifndef __USE_GNU
#define __USE_GNU
#endif

#include <execinfo.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ucontext.h>
#include <unistd.h>

/* This structure mirrors the one found in /usr/include/asm/ucontext.h */
typedef struct _sig_ucontext {
 unsigned long     uc_flags;
 ucontext_t        *uc_link;
 stack_t           uc_stack;
 sigcontext_t      uc_mcontext;
 sigset_t          uc_sigmask;
} sig_ucontext_t;

void crit_err_hdlr(int sig_num, siginfo_t * info, void * ucontext)
{
 void *             array[50];
 void *             caller_address;
 char **            messages;
 int                size, i;
 sig_ucontext_t *   uc;

 uc = (sig_ucontext_t *)ucontext;

 /* Get the address at the time the signal was raised */
#if defined(__i386__) // gcc specific
 caller_address = (void *) uc->uc_mcontext.eip; // EIP: x86 specific
#elif defined(__x86_64__) // gcc specific
 caller_address = (void *) uc->uc_mcontext.rip; // RIP: x86_64 specific
#else
#error Unsupported architecture. // TODO: Add support for other arch.
#endif

 fprintf(stderr, "signal %d (%s), address is %p from %p\n", 
  sig_num, strsignal(sig_num), info->si_addr, 
  (void *)caller_address);

 size = backtrace(array, 50);

 /* overwrite sigaction with caller's address */
 array[1] = caller_address;

 messages = backtrace_symbols(array, size);

 /* skip first stack frame (points here) */
 for (i = 1; i < size && messages != NULL; ++i)
 {
  fprintf(stderr, "[bt]: (%d) %s\n", i, messages[i]);
 }

 free(messages);

 exit(EXIT_FAILURE);
}

int crash()
{
 char * p = NULL;
 *p = 0;
 return 0;
}

int foo4()
{
 crash();
 return 0;
}

int foo3()
{
 foo4();
 return 0;
}

int foo2()
{
 foo3();
 return 0;
}

int foo1()
{
 foo2();
 return 0;
}

int main(int argc, char ** argv)
{
 struct sigaction sigact;

 sigact.sa_sigaction = crit_err_hdlr;
 sigact.sa_flags = SA_RESTART | SA_SIGINFO;

 if (sigaction(SIGSEGV, &sigact, (struct sigaction *)NULL) != 0)
 {
  fprintf(stderr, "error setting signal handler for %d (%s)\n",
    SIGSEGV, strsignal(SIGSEGV));

  exit(EXIT_FAILURE);
 }

 foo1();

 exit(EXIT_SUCCESS);
} 
```

## 输出

```
signal 11 (Segmentation fault), address is (nil) from 0x8c50
[bt]: (1) ./test(crash+0x24) [0x8c50]
[bt]: (2) ./test(foo4+0x10) [0x8c70]
[bt]: (3) ./test(foo3+0x10) [0x8c8c]
[bt]: (4) ./test(foo2+0x10) [0x8ca8]
[bt]: (5) ./test(foo1+0x10) [0x8cc4]
[bt]: (6) ./test(main+0x74) [0x8d44]
[bt]: (7) /lib/libc.so.6(__libc_start_main+0xa8) [0x40032e44] 
```

在信号处理程序中调用 backtrace() 函数的所有危险仍然存在，不应被忽视，但我发现我在这里描述的功能对调试崩溃很有帮助。

需要注意的是，我提供的示例是在 Linux for x86 上开发/测试的。我也在 ARM 上使用`uc_mcontext.arm_pc`而不是`uc_mcontext.eip`.

这是我了解此实现细节的文章的链接： [http ://www.linuxjournal.com/article/6391](http://www.linuxjournal.com/article/6391)

* * *

## 回答 #4

> 赞同：90
> 
> 时间：2010-03-26T19:52:15.417

尽管提供了描述如何使用 GNU libc函数^(1的)[正确答案](https://stackoverflow.com/questions/77005/how-to-generate-a-stacktrace-when-my-gcc-c-app-crashes/77336#77336)，并且我提供[了自己的答案](https://stackoverflow.com/questions/77005/how-to-generate-a-stacktrace-when-my-gcc-c-app-crashes/1925461#1925461)，描述了如何确保从信号处理程序指向故障²的实际位置的回溯，但我没有看到任何提到从回溯中输出的 C++ 符号的[解构。](http://en.wikipedia.org/wiki/Name_mangling)`backtrace()`

当从 C++ 程序获取回溯时，输出可以通过`c++filt`¹来解开符号，或者直接使用¹。[`abi::__cxa_demangle`](http://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_demangling.html)

*   ¹ Linux & OS X [注意`c++filt`和`__cxa_demangle`是 GCC 特定的]
*   ² Linux

* * *

[以下 C++ Linux 示例使用与我的其他答案](https://stackoverflow.com/questions/77005/how-to-generate-a-stacktrace-when-my-gcc-c-app-crashes/1925461#1925461)相同的信号处理程序，并演示了如何`c++filt`用于对符号进行解码。

**代码**：

```
class foo
{
public:
    foo() { foo1(); }

private:
    void foo1() { foo2(); }
    void foo2() { foo3(); }
    void foo3() { foo4(); }
    void foo4() { crash(); }
    void crash() { char * p = NULL; *p = 0; }
};

int main(int argc, char ** argv)
{
    // Setup signal handler for SIGSEGV
    ...

    foo * f = new foo();
    return 0;
} 
```

**输出**（`./test`）：

```
signal 11 (Segmentation fault), address is (nil) from 0x8048e07
[bt]: (1) ./test(crash__3foo+0x13) [0x8048e07]
[bt]: (2) ./test(foo4__3foo+0x12) [0x8048dee]
[bt]: (3) ./test(foo3__3foo+0x12) [0x8048dd6]
[bt]: (4) ./test(foo2__3foo+0x12) [0x8048dbe]
[bt]: (5) ./test(foo1__3foo+0x12) [0x8048da6]
[bt]: (6) ./test(__3foo+0x12) [0x8048d8e]
[bt]: (7) ./test(main+0xe0) [0x8048d18]
[bt]: (8) ./test(__libc_start_main+0x95) [0x42017589]
[bt]: (9) ./test(__register_frame_info+0x3d) [0x8048981] 
```

**解耦输出**( `./test 2>&1 | c++filt`)：

```
signal 11 (Segmentation fault), address is (nil) from 0x8048e07
[bt]: (1) ./test(foo::crash(void)+0x13) [0x8048e07]
[bt]: (2) ./test(foo::foo4(void)+0x12) [0x8048dee]
[bt]: (3) ./test(foo::foo3(void)+0x12) [0x8048dd6]
[bt]: (4) ./test(foo::foo2(void)+0x12) [0x8048dbe]
[bt]: (5) ./test(foo::foo1(void)+0x12) [0x8048da6]
[bt]: (6) ./test(foo::foo(void)+0x12) [0x8048d8e]
[bt]: (7) ./test(main+0xe0) [0x8048d18]
[bt]: (8) ./test(__libc_start_main+0x95) [0x42017589]
[bt]: (9) ./test(__register_frame_info+0x3d) [0x8048981] 
```

* * *

以下内容基于我[原始答案](https://stackoverflow.com/questions/77005/how-to-generate-a-stacktrace-when-my-gcc-c-app-crashes/1925461#1925461)中的信号处理程序，并且可以替换上面示例中的信号处理程序，以演示如何[`abi::__cxa_demangle`](http://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_demangling.html)用于对符号进行解码。此信号处理程序产生与上述示例相同的解组输出。

**代码**：

```
void crit_err_hdlr(int sig_num, siginfo_t * info, void * ucontext)
{
    sig_ucontext_t * uc = (sig_ucontext_t *)ucontext;

    void * caller_address = (void *) uc->uc_mcontext.eip; // x86 specific

    std::cerr << "signal " << sig_num 
              << " (" << strsignal(sig_num) << "), address is " 
              << info->si_addr << " from " << caller_address 
              << std::endl << std::endl;

    void * array[50];
    int size = backtrace(array, 50);

    array[1] = caller_address;

    char ** messages = backtrace_symbols(array, size);    

    // skip first stack frame (points here)
    for (int i = 1; i < size && messages != NULL; ++i)
    {
        char *mangled_name = 0, *offset_begin = 0, *offset_end = 0;

        // find parantheses and +address offset surrounding mangled name
        for (char *p = messages[i]; *p; ++p)
        {
            if (*p == '(') 
            {
                mangled_name = p; 
            }
            else if (*p == '+') 
            {
                offset_begin = p;
            }
            else if (*p == ')')
            {
                offset_end = p;
                break;
            }
        }

        // if the line could be processed, attempt to demangle the symbol
        if (mangled_name && offset_begin && offset_end && 
            mangled_name < offset_begin)
        {
            *mangled_name++ = '\0';
            *offset_begin++ = '\0';
            *offset_end++ = '\0';

            int status;
            char * real_name = abi::__cxa_demangle(mangled_name, 0, 0, &status);

            // if demangling is successful, output the demangled function name
            if (status == 0)
            {    
                std::cerr << "[bt]: (" << i << ") " << messages[i] << " : " 
                          << real_name << "+" << offset_begin << offset_end 
                          << std::endl;

            }
            // otherwise, output the mangled function name
            else
            {
                std::cerr << "[bt]: (" << i << ") " << messages[i] << " : " 
                          << mangled_name << "+" << offset_begin << offset_end 
                          << std::endl;
            }
            free(real_name);
        }
        // otherwise, print the whole line
        else
        {
            std::cerr << "[bt]: (" << i << ") " << messages[i] << std::endl;
        }
    }
    std::cerr << std::endl;

    free(messages);

    exit(EXIT_FAILURE);
} 
```

* * *

## 回答 #5

> 赞同：33
> 
> 时间：2008-09-17T11:31:00.867

可能值得一看[Google Breakpad](https://chromium.googlesource.com/breakpad/breakpad)，一个跨平台的故障转储生成器和处理转储的工具。

* * *

## 回答 #6

> 赞同：21
> 
> 时间：2008-09-16T20:52:39.683

你没有指定你的操作系统，所以这很难回答。如果您使用的是基于 gnu libc 的系统，您也许可以使用 libc 函数`backtrace()`。

GCC 也有两个内置函数可以帮助你，但它们可能会也可能不会完全在你的架构上实现，它们是`__builtin_frame_address`和`__builtin_return_address`. 两者都需要立即整数级别（立即，我的意思是它不能是变量）。如果`__builtin_frame_address`给定级别非零，则获取同一级别的返回地址应该是安全的。

* * *

## 回答 #7

> 赞同：13
> 
> 时间：2013-04-04T03:21:22.083

感谢热心的极客让我注意到 addr2line 实用程序。

我编写了一个快速而肮脏的脚本来处理[此处](https://stackoverflow.com/a/1925461/1797414)提供的答案的输出：（非常感谢 jschmier！）使用 addr2line 实用程序。

该脚本接受一个参数：包含 jschmier 实用程序输出的文件的名称。

输出应为跟踪的每个级别打印如下内容：

```
BACKTRACE:  testExe 0x8A5db6b
FILE:       pathToFile/testExe.C:110
FUNCTION:   testFunction(int) 
   107  
   108           
   109           int* i = 0x0;
  *110           *i = 5;
   111      
   112        }
   113        return i; 
```

代码：

```
#!/bin/bash

LOGFILE=$1

NUM_SRC_CONTEXT_LINES=3

old_IFS=$IFS  # save the field separator           
IFS=$'\n'     # new field separator, the end of line           

for bt in `cat $LOGFILE | grep '\[bt\]'`; do
   IFS=$old_IFS     # restore default field separator 
   printf '\n'
   EXEC=`echo $bt | cut -d' ' -f3 | cut -d'(' -f1`  
   ADDR=`echo $bt | cut -d'[' -f3 | cut -d']' -f1`
   echo "BACKTRACE:  $EXEC $ADDR"
   A2L=`addr2line -a $ADDR -e $EXEC -pfC`
   #echo "A2L:        $A2L"

   FUNCTION=`echo $A2L | sed 's/\<at\>.*//' | cut -d' ' -f2-99`
   FILE_AND_LINE=`echo $A2L | sed 's/.* at //'`
   echo "FILE:       $FILE_AND_LINE"
   echo "FUNCTION:   $FUNCTION"

   # print offending source code
   SRCFILE=`echo $FILE_AND_LINE | cut -d':' -f1`
   LINENUM=`echo $FILE_AND_LINE | cut -d':' -f2`
   if ([ -f $SRCFILE ]); then
      cat -n $SRCFILE | grep -C $NUM_SRC_CONTEXT_LINES "^ *$LINENUM\>" | sed "s/ $LINENUM/*$LINENUM/"
   else
      echo "File not found: $SRCFILE"
   fi
   IFS=$'\n'     # new field separator, the end of line           
done

IFS=$old_IFS     # restore default field separator 
```

* * *

## 回答 #8

> 赞同：12
> 
> 时间：2008-09-16T20:57:12.730

需要注意的是，一旦你生成了一个核心文件，你就需要使用 gdb 工具来查看它。要让 gdb 理解您的核心文件，您必须告诉 gcc 使用调试符号检测二进制文件：为此，您使用 -g 标志进行编译：

```
$ g++ -g prog.cpp -o prog 
```

然后，你可以设置“ulimit -c unlimited”让它转储一个核心，或者只是在gdb中运行你的程序。我更喜欢第二种方法：

```
$ gdb ./prog
... gdb startup output ...
(gdb) run
... program runs and crashes ...
(gdb) where
... gdb outputs your stack trace ... 
```

我希望这有帮助。

* * *

## 回答 #9

> 赞同：12
> 
> 时间：2008-09-16T21:23:20.497

`ulimit -c <value>`在 unix 上设置核心文件大小限制。默认情况下，核心文件大小限制为 0。您可以`ulimit`使用`ulimit -a`.

此外，如果您从 gdb 中运行您的程序，它会在“违反分段”时停止您的程序（`SIGSEGV`通常是当您访问一块尚未分配的内存时），或者您可以设置断点。

ddd 和 nemiver 是 gdb 的前端，这使得新手更容易使用它。

* * *

## 回答 #10

> 赞同：11
> 
> 时间：2019-01-29T18:55:42.240

看起来在最后一个 c++ boost 版本中出现了一个库来提供你想要的东西，可能代码是多平台的。它是[boost::stacktrace](https://www.boost.org/doc/libs/1_69_0/doc/html/stacktrace.html)，您可以像[在 boost sample 中](https://www.boost.org/doc/libs/1_69_0/doc/html/stacktrace/getting_started.html)一样使用它：

```
#include <filesystem>
#include <sstream>
#include <fstream>
#include <signal.h>     // ::signal, ::raise
#include <boost/stacktrace.hpp>

const char* backtraceFileName = "./backtraceFile.dump";

void signalHandler(int)
{
    ::signal(SIGSEGV, SIG_DFL);
    ::signal(SIGABRT, SIG_DFL);
    boost::stacktrace::safe_dump_to(backtraceFileName);
    ::raise(SIGABRT);
}

void sendReport()
{
    if (std::filesystem::exists(backtraceFileName))
    {
        std::ifstream file(backtraceFileName);

        auto st = boost::stacktrace::stacktrace::from_dump(file);
        std::ostringstream backtraceStream;
        backtraceStream << st << std::endl;

        // sending the code from st

        file.close();
        std::filesystem::remove(backtraceFileName);
    }
}

int main()
{
    ::signal(SIGSEGV, signalHandler);
    ::signal(SIGABRT, signalHandler);

    sendReport();
    // ... rest of code
} 
```

在 Linux 中你编译上面的代码：

```
g++ --std=c++17 file.cpp -lstdc++fs -lboost_stacktrace_backtrace -ldl -lbacktrace 
```

[从boost 文档](https://www.boost.org/doc/libs/1_69_0/doc/html/stacktrace/getting_started.html)复制的示例回溯：

```
0# bar(int) at /path/to/source/file.cpp:70
1# bar(int) at /path/to/source/file.cpp:70
2# bar(int) at /path/to/source/file.cpp:70
3# bar(int) at /path/to/source/file.cpp:70
4# main at /path/to/main.cpp:93
5# __libc_start_main in /lib/x86_64-linux-gnu/libc.so.6
6# _start 
```

* * *

## 回答 #11

> 赞同：10
> 
> 时间：2008-09-18T02:55:24.980

我一直在研究这个问题一段时间。

并深埋在 Google 性能工具自述文件中

[http://code.google.com/p/google-perftools/source/browse/trunk/README](http://code.google.com/p/google-perftools/source/browse/trunk/README)

谈 libunwind

[http://www.nongnu.org/libunwind/](http://www.nongnu.org/libunwind/)

很想听听这个图书馆的意见。

-rdynamic 的问题在于它在某些情况下会相对显着地增加二进制文件的大小

* * *

## 回答 #12

> 赞同：10
> 
> 时间：2016-12-31T00:19:02.450

镇上的新国王已经到来 [https://github.com/bombela/backward-cpp](https://github.com/bombela/backward-cpp)

1 个标头放置在您的代码中，1 个库要安装。

我个人使用此功能调用它

```
#include "backward.hpp"
void stacker() {

using namespace backward;
StackTrace st;

st.load_here(99); //Limit the number of trace depth to 99
st.skip_n_firsts(3);//This will skip some backward internal function from the trace

Printer p;
p.snippet = true;
p.object = true;
p.color = true;
p.address = true;
p.print(st, stderr);
} 
```

* * *

## 回答 #13

> 赞同：9
> 
> 时间：2008-09-16T20:51:24.630

某些版本的 libc 包含处理堆栈跟踪的函数；你也许可以使用它们：

[http://www.gnu.org/software/libc/manual/html_node/Backtraces.html](http://www.gnu.org/software/libc/manual/html_node/Backtraces.html)

我记得很久以前使用[libunwind来获取堆栈跟踪，但您的平台可能不支持它。](http://www.nongnu.org/libunwind/)

* * *

## 回答 #14

> 赞同：9
> 
> 时间：2013-03-01T06:38:05.947

您可以使用[DeathHandler](https://github.com/vmarkovtsev/DeathHandler "死亡处理程序") - 可靠的小型 C++ 类，可为您完成所有工作。

* * *

## 回答 #15

> 赞同：9
> 
> 时间：2016-07-06T12:37:15.317

忘记更改您的来源并使用 backtrace() 函数或宏进行一些黑客攻击 - 这些只是糟糕的解决方案。

作为一个正常工作的解决方案，我建议：

1.  使用“-g”标志编译您的程序，以便将调试符号嵌入二进制文件（不要担心这不会影响您的性能）。
2.  在 linux 上运行下一个命令：“ulimit -c unlimited” - 允许系统进行大型故障转储。
3.  当您的程序崩溃时，您将在工作目录中看到文件“core”。
4.  运行下一个命令以将回溯打印到标准输出： gdb -batch -ex "backtrace" ./your_program_exe ./core

这将以人类可读的方式打印程序的正确可读回溯（带有源文件名和行号）。此外，这种方法将使您可以自由地自动化您的系统：有一个简短的脚本来检查进程是否创建了核心转储，然后通过电子邮件将回溯发送给开发人员，或者将其记录到一些日志记录系统中。

* * *

## 回答 #16

> 赞同：7
> 
> 时间：2008-09-16T20:47:19.897

```
ulimit -c unlimited 
```

是一个系统变量，它允许在您的应用程序崩溃后创建核心转储。在这种情况下，数量不受限制。在同一目录中查找名为 core 的文件。确保在启用调试信息的情况下编译代码！

问候

* * *

## 回答 #17

> 赞同：6
> 
> 时间：2008-09-16T20:55:21.470

看着：

男人 3 回溯

和：

```
#include <exeinfo.h>
int backtrace(void **buffer, int size); 
```

这些是 GNU 扩展。

* * *

## 回答 #18

> 赞同：6
> 
> 时间：2008-09-17T00:07:57.887

[请参阅ACE](http://www.cs.wustl.edu/~schmidt/ACE.html)（自适应通信环境）中的堆栈跟踪工具。它已经编写为涵盖所有主要平台（以及更多）。该库是 BSD 风格的许可，因此如果您不想使用 ACE，甚至可以复制/粘贴代码。

* * *

## 回答 #19

> 赞同：5
> 
> 时间：2008-09-16T21:01:04.903

我可以帮助Linux版本：可以使用函数backtrace，backtrace_symbols和backtrace_symbols_fd。请参阅相应的手册页。

* * *

## 回答 #20

> 赞同：5
> 
> 时间：2018-03-01T13:00:47.363

[作为仅限 Windows 的解决方案，您可以使用Windows 错误报告](https://msdn.microsoft.com/en-us/library/windows/desktop/bb513641.aspx)获得等效的堆栈跟踪（包含更多信息）。只需几个注册表项，就可以将其设置为[收集用户模式转储](https://msdn.microsoft.com/en-us/library/windows/desktop/bb787181.aspx)：

> 从 Windows Server 2008 和带有 Service Pack 1 (SP1) 的 Windows Vista 开始，可以配置 Windows 错误报告 (WER)，以便在用户模式应用程序崩溃后收集并在本地存储完整的用户模式转储。[...]
> 
> 默认情况下不启用此功能。启用该功能需要管理员权限。**要启用和配置该功能，请使用HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps**项下的以下注册表值。

您可以从具有所需权限的安装程序中设置注册表项。

与在客户端生成堆栈跟踪相比，创建用户模式转储具有以下优点：

*   它已经在系统中实现。如果您需要对要转储的信息量进行更细粒度的控制，您可以使用上述 WER，也可以自己调用[MiniDumpWriteDump 。](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680360.aspx)（确保从不同的进程调用它。）
*   **比堆栈跟踪更完整**。**其中，它可以包含局部变量、函数参数、其他线程的堆栈、加载的模块等等。数据量（以及随之而来的大小）是高度可定制的。**
***   无需发布调试符号。这既大大减少了部署的规模，也使逆向工程变得更加困难。*   很大程度上独立于您使用的编译器。使用 WER 甚至不需要任何代码。无论哪种方式，获得符号数据库 (PDB) 的方法对于离线分析都*非常*有用。我相信 GCC 可以生成 PDB，或者有工具可以将符号数据库转换为 PDB 格式。**

 **请注意，WER 只能由应用程序崩溃触发（即系统由于未处理的异常而终止进程）。`MiniDumpWriteDump`可以随时调用。如果您需要转储当前状态以诊断崩溃以外的问题，这可能会有所帮助。

必读，如果您想评估小型转储的适用性：

*   [有效的小型转储](http://www.debuginfo.com/articles/effminidumps.html)
*   [有效的小型转储（第 2 部分）](http://www.debuginfo.com/articles/effminidumps2.html)

* * *

## 回答 #21

> 赞同：4
> 
> 时间：2008-09-16T21:09:52.107

*nix：您可以拦截[SIGSEGV](http://en.wikipedia.org/wiki/SIGSEGV)（通常在崩溃之前引发此信号）并将信息保存到文件中。（例如，您可以使用 gdb 进行调试的核心文件除外）。

win：从 msdn检查[这个。](http://msdn.microsoft.com/en-us/library/ms680659(VS.85).aspx)

您还可以查看 google 的 chrome 代码，了解它是如何处理崩溃的。它有一个很好的异常处理机制。

* * *

## 回答 #22

> 赞同：4
> 
> 时间：2013-12-12T23:23:10.990

我在这里看到了很多执行信号处理程序然后退出的答案。这是要走的路，但请记住一个非常重要的事实：如果你想获取生成的错误的核心转储，你不能调用`exit(status)`. `abort()`改为打电话！

* * *

## 回答 #23

> 赞同：4
> 
> 时间：2014-03-20T11:59:22.827

我发现@tgamblin 解决方案不完整。它无法处理stackoverflow。我认为是因为默认情况下使用相同的堆栈调用信号处理程序，并且 SIGSEGV 被抛出两次。为了保护您需要为信号处理程序注册一个独立的堆栈。

您可以使用下面的代码进行检查。默认情况下，处理程序失败。使用定义的宏 STACK_OVERFLOW 就可以了。

```
#include <iostream>
#include <execinfo.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <string>
#include <cassert>

using namespace std;

//#define STACK_OVERFLOW

#ifdef STACK_OVERFLOW
static char stack_body[64*1024];
static stack_t sigseg_stack;
#endif

static struct sigaction sigseg_handler;

void handler(int sig) {
  cerr << "sig seg fault handler" << endl;
  const int asize = 10;
  void *array[asize];
  size_t size;

  // get void*'s for all entries on the stack
  size = backtrace(array, asize);

  // print out all the frames to stderr
  cerr << "stack trace: " << endl;
  backtrace_symbols_fd(array, size, STDERR_FILENO);
  cerr << "resend SIGSEGV to get core dump" << endl;
  signal(sig, SIG_DFL);
  kill(getpid(), sig);
}

void foo() {
  foo();
}

int main(int argc, char **argv) {
#ifdef STACK_OVERFLOW
  sigseg_stack.ss_sp = stack_body;
  sigseg_stack.ss_flags = SS_ONSTACK;
  sigseg_stack.ss_size = sizeof(stack_body);
  assert(!sigaltstack(&sigseg_stack, nullptr));
  sigseg_handler.sa_flags = SA_ONSTACK;
#else
  sigseg_handler.sa_flags = SA_RESTART;  
#endif
  sigseg_handler.sa_handler = &handler;
  assert(!sigaction(SIGSEGV, &sigseg_handler, nullptr));
  cout << "sig action set" << endl;
  foo();
  return 0;
} 
```

* * *

## 回答 #24

> 赞同：3
> 
> 时间：2008-09-16T21:00:42.067

[我将使用为Visual Leak Detector](http://www.codeproject.com/KB/applications/visualleakdetector.aspx)中的泄漏内存生成堆栈跟踪的代码。不过，这只适用于 Win32。

* * *

## 回答 #25

> 赞同：3
> 
> 时间：2019-04-11T06:45:28.983

如果您仍然想像我一样单独使用，您可以链接`bfd`并避免`addr2line`像我在这里所做的那样使用：

[https://github.com/gnif/LookingGlass/blob/master/common/src/platform/linux/crash.c](https://github.com/gnif/LookingGlass/blob/master/common/src/platform/linux/crash.c)

这将产生输出：

```
[E]        crash.linux.c:170  | crit_err_hdlr                  | ==== FATAL CRASH (a12-151-g28b12c85f4+1) ====
[E]        crash.linux.c:171  | crit_err_hdlr                  | signal 11 (Segmentation fault), address is (nil)
[E]        crash.linux.c:194  | crit_err_hdlr                  | [trace]: (0) /home/geoff/Projects/LookingGlass/client/src/main.c:936 (register_key_binds)
[E]        crash.linux.c:194  | crit_err_hdlr                  | [trace]: (1) /home/geoff/Projects/LookingGlass/client/src/main.c:1069 (run)
[E]        crash.linux.c:194  | crit_err_hdlr                  | [trace]: (2) /home/geoff/Projects/LookingGlass/client/src/main.c:1314 (main)
[E]        crash.linux.c:199  | crit_err_hdlr                  | [trace]: (3) /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xeb) [0x7f8aa65f809b]
[E]        crash.linux.c:199  | crit_err_hdlr                  | [trace]: (4) ./looking-glass-client(_start+0x2a) [0x55c70fc4aeca] 
```

* * *

## 回答 #26

> 赞同：2
> 
> 时间：2013-05-08T19:13:58.563

除了上述答案之外，这里还有如何让 Debian Linux OS 生成核心转储

1.  在用户的主文件夹中创建一个“coredumps”文件夹
2.  转到 /etc/security/limits.conf。在 ' ' 行下方，键入“soft core unlimited”，如果为 root 启用核心转储，则键入“root soft core unlimited”，以便为核心转储提供无限空间。
3.  注意：“* soft core unlimited”不包括root，这就是为什么必须在自己的行中指定root。
4.  要检查这些值，请注销，重新登录，然后键入“ulimit -a”。“核心文件大小”应设置为无限制。
5.  检查 .bashrc 文件（用户和 root，如果适用）以确保未在此处设置 ulimit。否则，上面的值将在启动时被覆盖。
6.  打开 /etc/sysctl.conf。在底部输入以下内容：“kernel.core_pattern = /home//coredumps/%e_%t.dump”。（%e 是进程名，%t 是系统时间）
7.  退出并输入“sysctl -p”以加载新配置检查 /proc/sys/kernel/core_pattern 并验证这与您刚刚输入的内容是否匹配。
8.  核心转储可以通过在命令行（“&”）上运行一个进程来测试，然后用“kill -11”杀死它。如果核心转储成功，您将在分段错误指示后看到“（核心转储）”。

* * *

## 回答 #27

> 赞同：1
> 
> 时间：2008-09-16T21:16:42.807

在 Linux/unix/MacOSX 上使用核心文件（您可以使用 ulimit 或[compatible system call](http://www.opengroup.org/onlinepubs/009695399/functions/setrlimit.html)启用它们）。在 Windows 上使用 Microsoft 错误报告（您可以成为合作伙伴并访问您的应用程序崩溃数据）。

* * *

## 回答 #28

> 赞同：0
> 
> 时间：2008-09-16T21:24:29.560

我忘记了“apport”的 GNOME 技术，但我对使用它知之甚少。它用于生成堆栈跟踪和其他诊断以进行处理，并且可以自动归档错误。这当然值得一试。

* * *

## 回答 #29

> 赞同：0
> 
> 时间：2022-02-16T13:47:03.300

```
gdb -ex 'set confirm off' -ex r -ex bt -ex q <my-program> 
```

# c++ - 我应该帮助哪个开源 C++ 数据库 GUI 项目？

> ID：77013
> 
> 赞同：3
> 
> 时间：2008-09-16T20:59:34.563
> 
> 标签：c++, database, qt, open-source, qt4

我正在寻找一个涉及使用数据库的 c++ GUI(s) 的开源项目。我以前没有做过，正在寻找一种方法让我的脚湿透。我可以从事哪些工作？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T21:02:42.670

[这个http://sourceforge.net/projects/sqlitebrowser/](http://sourceforge.net/projects/sqlitebrowser/)怎么样：

> SQLite 数据库浏览器是 SQLite 数据库的轻量级 GUI 编辑器，构建在 QT 之上。该项目的主要目标是允许非技术用户使用一组向导和类似电子表格的界面来创建、修改和编辑 SQLite 数据库。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T21:02:51.047

做一个你可以**参与**并充满热情的项目。希望是您每天使用的产品。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T21:01:00.113

任何你喜欢和觉得你可以贡献的东西。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-16T21:03:57.190

在我为开源项目做贡献的短暂经历中，我发现有两点让我一直在做贡献：

*   伟大的人——其他做出贡献的人与（实际上）合作和闲逛很有趣。
*   你关心的项目——只要它的目标是你想把空闲时间花在工作上的项目，哪个项目并不重要。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T21:03:39.110

Sourceforge 有一个帮助页面：http: [//sourceforge.net/people/](http://sourceforge.net/people/)

浏览帖子以查看某个项目是否属于您的专长或找到一个听起来很有趣的项目...

让我成为第一个感谢您愿意为开源运动贡献您的时间和知识的人。

# asp.net - Asp.net中_DoPostBack javascript方法的最佳方法是什么

> ID：77025
> 
> 赞同：1
> 
> 时间：2008-09-16T21:00:25.653
> 
> 标签：asp.net, asp.net-ajax

我想在`__DoPostBack`方法上设置断点，但是找到正确的文件来设置断点很痛苦。

该方法`__DoPostBack`包含在一个自动生成的 js 文件中，名为：

```
ScriptResource.axd?d=P_lo2... 
```

经过几次回发后，Visual Studio 中到处都是这些文件，检查当前页面引用的是哪个文件有点让人头疼。有什么想法吗？

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2008-09-16T21:07:35.043

如果您使用 IE7 进行测试，您可以使用 View -> Script Debugger -> Break on next statement 然后单击生成事件的按钮（__DoPostBack）

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T21:35:34.633

TBH，我认为在 Javascript 中设置断点没有多大价值，因为它几乎直接返回到服务器。

最好在您的服务器代码中设置断点。根据您尝试调试的内容，这将位于不同的位置。在页面事件周期或控件[IPostBackEventHandler.RaisePostBackEvent](http://msdn.microsoft.com/en-us/library/system.web.ui.ipostbackeventhandler.raisepostbackevent.aspx)处理程序中。

# google-visualization - 如何让 Google Charts 在散点图中显示多种颜色？

> ID：77034
> 
> 赞同：7
> 
> 时间：2008-09-16T21:01:16.323
> 
> 标签：google-visualization, scatter

我想在 Google Chart 散点图中显示多种颜色（以及可能的形状和大小）的数据点。有没有人有一个如何做到这一点的例子？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-16T21:41:28.863

在等待 SECONDS 在这里得到答案后，我回答了我自己的问题 :-)

您确实可以为不同的数据元素使用不同的颜色。例如：

[http://chart.apis.google.com/chart?chs=300x200&cht=s&chd=t:1,2,3|6,5,4&chds=1,3,0,10&chxt=x,y&chxl=0:|0 |1|2|1:|0|10&chm=d,ff0000,0,0,8,0|a,ff8080,0,1,42,0|c,ffff00,0,2,16,0](http://chart.apis.google.com/chart?chs=300x200&cht=s&chd=t:1,2,3|6,5,4&chds=1,3,0,10&chxt=x,y&chxl=0:|0|1|2|1:|0|10&chm=d,ff0000,0,0,8,0|a,ff8080,0,1,42,0|c,ffff00,0,2,16,0)

是 chm= 具有魔力。我试图有多个 chm= 语句。您只需要一个，但有多个由竖线分隔的描述。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T21:03:31.280

您只能在散点图中使用一个数据集，因此只能使用一种颜色。

[http://code.google.com/apis/chart/#scatter_plot](http://code.google.com/apis/chart/#scatter_plot)

*从 API 描述：*

> 散点图使用多个数据集的方式与其他图表类型不同。您只能在散点图中显示一个数据集。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T21:10:57.813

您可以通过在要显示的点处使用带有白线和彩色[形状标记](http://code.google.com/apis/chart/#shape_markers2)的线图来有效地伪造多色散点图。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2010-06-21T17:38:34.587

这是另一个例子：[推特图表](http://www.xefer.com/twitter/gruber)。我希望做同样的事情。需要找出如何做同心圆。

# c# - 在通过 asp:Repeater 生成的表中实现可折叠条目的最简洁方法？

> ID：77082
> 
> 赞同：1
> 
> 时间：2008-09-16T21:05:02.257
> 
> 标签：c#, repeater

在有人建议完全取消表格标签之前，我只是在修改一个非常大的系统的这一部分，所以修改表格结构对我来说真的不明智（应用程序充满了类似的表格）。

这是 C# .NET 中的 web 应用程序 - 数据来自 web 服务并显示在屏幕上的表格中。该表的行是使用 asp:Repeaters 生成的，因此这些行可以很好地交替 colers。该表以前每行包含一项数据。现在，基本上，表格有子标题......第一行是日期，第二行显示一行数据，接下来的所有行都是数据行，直到新日期的数据进来，在这种情况下将是另一个子标题行。

起初我以为我可以作弊，并且很容易做到这一点以保持当前的中继器结构——我只需要向一些单元格提供空字符串，这样它们中就不会出现任何数据。但是，现在我们正在考虑每个日期旁边的 +/- 折叠器之一，以便它们可以折叠所有数据。当按下按钮时，我的思绪立即隐藏行......但我不知道如何从后面的代码中隐藏行，除非该行具有唯一的 id，而且我不确定你是否可以使用中继器来做到这一点.

我希望我已经很好地表达了这个问题。我相信我会找到一种方法 TBH 但我刚刚在 slashdot 上看到了这个网站，并认为我会试一试 :)

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T21:07:24.030

当您在数据绑定事件中构建行时，您可以使用数据字段的 id 或用于使其唯一的其他内容添加唯一标识符。

然后，如果您想在开始时用数据填充它，则可以使用客户端方法来展开折叠，并在 Javascript 中为表格行元素切换 style.display 设置。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T21:07:26.167

~~只需将项目模板的内容包装在 asp:Panel 中，然后您就拥有了一个唯一的 ID。~~然后加入[一些 jquery](http://www.learningjquery.com/2007/03/accordion-madness)来调味；）

**编辑**：刚刚注意到你正在使用一张桌子。将 id 放在行上。然后切换它。

# php - 哪个更快，python 网页或 php 网页？

> ID：77086
> 
> 赞同：41
> 
> 时间：2008-09-16T21:05:26.673
> 
> 标签：php, python, performance, pylons

哪个更快，python 网页或 php 网页？

有谁知道 pylons（或任何其他框架）的速度与使用 php 制作的类似网站相比如何？

我知道通过 cgi 提供 python 基础网页比 php 慢，因为它每次启动时间都很长。

我喜欢使用 pylons，如果它比 php 慢，我仍然会使用它。但是，如果 pylons 比 php 快，我可能希望最终说服我的雇主允许我将站点转换为 pylons。

* * *

## 回答 #1

> 赞同：89
> 
> 时间：2008-09-17T03:44:12.750

听起来您不想比较两种**语言**，而是想比较两种**Web 系统**。

这很棘手，因为涉及到许多变量。

例如，Python Web 应用程序可以利用[mod_wsgi](http://code.google.com/p/modwsgi/)与 Web 服务器通信，这比 PHP 与 Web 服务器通信的任何典型方式都快（如果您使用 Apache，即使 mod_php 最终会变慢，因为 Apache 只能将 Prefork MPM 与 mod_php 一起使用，而不是像 Worker 这样的多线程 MPM）。

还有代码编译的问题。如您所知，每次文件更改时运行文件时，Python 都会即时编译为字节码（.pyc 文件）。因此，在第一次运行 Python 文件后，会跳过编译步骤，Python 解释器会简单地获取预编译的 .pyc 文件。正因为如此，有人可能会争辩说 Python 比 PHP 具有原生优势。但是，可以为 PHP 网站（我最喜欢的是[eAccelerator](http://eaccelerator.net/)）安装优化器和缓存系统，以达到大致相同的效果。

一般来说，存在足够多的工具，以至于一个人几乎可以做另一个人可以做的所有事情。当然，正如其他人所提到的，切换语言的业务案例不仅仅涉及速度。我现在的雇主有一个用 oCaml 编写的应用程序，结果证明这是一个错误，因为原作者离开了公司，其他人都不想碰它。同样，PHP-web 社区比 Python-web 社区大得多；与 Python 支持相比，网站托管服务更有可能提供 PHP 支持；等等

但回到速度。您必须认识到，这里的速度问题涉及许多活动部分。幸运的是，其中许多部分可以独立优化，为您提供各种途径来寻求性能提升。

* * *

## 回答 #2

> 赞同：30
> 
> 时间：2008-09-16T21:24:46.780

试图说服您的雇主从 PHP 移植到 Python 是没有意义的，尤其是对于现有系统，我认为您在问题中暗示了这一点。

这样做的原因是您已经拥有一个（大概）工作系统，并且已经投入了时间和精力（和经验）。为了微不足道的性能提升而放弃这一点（不是我声称会有一个）将是愚蠢的，没有一个称职的经理应该认可它。

它还可能会产生可维护性问题，具体取决于其他谁必须使用该系统，以及他们使用 Python 的经验。

* * *

## 回答 #3

> 赞同：7
> 
> 时间：2015-11-10T09:47:19.203

我认为 PHP (>5.5) 对于复杂的 Web 应用程序来说更快、更可靠，因为它针对网站脚本进行了优化。

您可以在网上找到的许多基准测试只是为了证明首选语言更好。但是您不能将 2 种语言与运行 X 次的数学任务进行比较。对于真正的基准测试，您需要两个具有数百个类/文件的可比框架以及一个同时运行 100 个客户端的 Web 应用程序。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-16T21:13:00.960

差不多。差异不应大到足以成为选择其中一个的理由。不要试图通过编写自己的小基准（`"hello world"`）来比较它们，因为您可能不会得到代表真实网站生成更复杂页面的结果。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-16T21:16:15.257

PHP 和 Python 非常相似，无需担心任何类型的切换。

从一种语言切换到另一种语言可能获得的任何性能改进都将远远超过简单地不花钱转换代码（你不是免费编码对吗？）而只是购买更多硬件。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-16T21:06:27.620

如果它没有坏，就不要修理它。

只需编写一个快速测试，但请记住，每种语言在某些功能上会比另一种更快。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-16T21:11:49.433

您需要能够为切换制定业务案例，而不仅仅是“它更快”。如果基于技术 B 构建的站点在一定时期（例如 3 年）内的开发人员维护时间要多出 20%，那么在运行技术 A 的系统中添加另一个 Web 服务器以弥合性能差距可能会更便宜。

仅仅说“我们应该切换到技术 B，因为技术 B*更快！* ”并没有真正的作用。

由于 Python 远不如 PHP 无处不在，如果它的托管、开发人员和其他维护成本（长期）使其适合这种情况，我不会感到惊讶。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2009-02-04T06:28:30.933

除非可用性成为问题，否则 IS 组织不会考虑这一点。

如果是这样，请查看复制、负载平衡和大量内存。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T21:08:06.820

唯一正确的答案是“视情况而定”。有很多变量会影响性能，您可以在任何一种情况下优化很多东西。

* * *

## 回答 #10

> 赞同：-1
> 
> 时间：2010-03-09T20:13:47.687

在我的新工作中，我不得不回到 Web 开发，如果不是 Pylons/Python，也许我会选择住在丛林中 :) 在我的主观意见中，PHP 是幼儿园的，我在第三年做到了我相信，许多自尊（或高估）的软件工程师都不想被 PHP 代码打扰。

为什么我的雇主同意？我们（团队）刚刚切换到 Python，他们也没什么好说的。该网站仍然是并且将是 PHP，但我们正在使用 Python 开发其他应用程序，包括 Web。铁塔的优点？您可以将您的 python 库集成到 Web 应用程序中，也就是说，恕我直言，这是一个巨大的优势。

至于性能，我们仍然遇到麻烦。

# eclipse - 现在有什么好的 Eclipse 持续测试插件吗？

> ID：77090
> 
> 赞同：13
> 
> 时间：2008-09-16T21:06:04.563
> 
> 标签：eclipse, testing

我过去使用过[MIT Continuous testing](http://groups.csail.mit.edu/pag/continuoustesting/)插件，但它早已过时，不再与任何接近现代版本的 Eclipse 兼容。

有人有好的替代品吗？免费的，自然是首选。

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2009-09-25T20:36:49.367

我发现[Infinitest](http://infinitest.github.com/)现在有一个似乎运行良好的 Eclipse 插件。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T21:21:47.070

[在 Object Mentor： Continuous Testing Explained](http://blog.objectmentor.com/articles/2007/09/20/continuous-testing-explained)的 Ben Rady 文章中有一个列表。不幸的是，唯一的 Eclipse 工具似乎是[CT-Eclipse](http://ct-eclipse.tigris.org/)，目前也没有维护。

还有用于 IntelliJ 和[Infinitest的](http://www.infinitest.org/)[Fireworks](http://swing1979.googlepages.com/fireworks) ，它不是 IDE 特定的，但也有一些 IntelliJ 集成。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-17T22:34:21.037

我的经验是，在 IDE 中进行连续测试会变得笨重且分散注意力，因此我更喜欢使用[CruiseControl](http://cruisecontrol.sourceforge.net/)之类的工具来进行此类测试。我发现一个非常有用的工具是[EclEmma](http://www.eclemma.org/)，它可以为您的单元提供非常快速的覆盖周转，帮助您决定何时完成对代码的特定区域的测试。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2010-06-07T00:03:15.543

Infinitest 决定它想要运行什么测试。通常它运行错误的。绿条有时好，有时无意义。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T07:39:13.633

我在一个小而简单的项目中拥有无限的良好经验。我没有遇到任何问题，并且发现它快速且有用。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2011-06-21T12:18:21.160

我也使用 Infinitest （并投票支持它的一个答案），但我想添加另一种方法，它**依赖于 build server**。每当您想实现某些东西时，请在您的 VCS 中创建一个分支，进行更改，提交到您的分支。如果您配置了构建服务器，它在每次签入时运行单元测试，那么您的单元测试就会在构建服务器上运行，而不会真正污染主干（或 HEAD，无论您如何称呼它），也无需等待测试运行结束。

我承认，就您提出的问题而言，这并不是真正的连续单元测试，但是对于大型项目或大型测试套件，即使是“正常”的连续测试运行器也可能会大大降低您的速度。

对于小型项目，我还推荐 Infinitest 或 CT Eclipse。

# pdf - Adobe Reader 错误代码

> ID：77102
> 
> 赞同：1
> 
> 时间：2008-09-16T21:07:06.543
> 
> 标签：pdf, pdf-generation

我正在以编程方式创建 PDF，最近对我的生成器的更改是创建的文档会在我的 Mac 上同时导致 Mac Preview 和 Adob​​e Reader 崩溃。在 Adob​​e Reader 崩溃之前，它会报告：

> 处理页面时出错。阅读本文档时出现问题 (18)。

我怀疑“18”可能会给我一些关于我创建的 PDF 有什么问题的信息。有没有解释这些状态码含义的文件？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-17T00:02:30.723

在按下 OK 的同时按住 Ctrl 键，您应该能够在文档中加载超过此点并可能获得更多详细信息。

您使用什么工具来创建 PDF (Aspose)？

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-17T14:44:38.047

我无法找到有关 Adob​​e 错误代码的任何信息，因此我最终[通过 Darwinports 安装了 xpdf](http://xpdf.darwinports.com/)。用 xpdf 加载我的 PDF 会吐出更多有用的错误信息，我能够找到问题所在。（当我将内容从一个文档复制到另一个文档时，我正在表单中创建循环引用。）

# c++ - 学习 C++ 时可以使用哪些好的编译器？

> ID：77126
> 
> 赞同：1
> 
> 时间：2008-09-16T21:09:00.797
> 
> 标签：c++, compiler-construction

对于初学者来说易于使用的 C++ 编译器有哪些建议？免费或开源的将是首选。

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2008-09-16T21:10:18.517

对于简单的事情，GCC 是一个不错的选择。

Visual Studio Express 版是主要 Windows C++ 编译器的免费版本。

如果您在 Windows 上，我会使用 VS。如果你在 linux 上，你应该使用 GCC。

*我说 GCC 是为了简单的事情，因为对于更复杂的项目，构建过程并不那么容易

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-16T21:11:11.323

G++ 是 GNU C++ 编译器。大多数 *nix 发行版都应该有可用的软件包。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-16T21:10:56.503

我建议使用[Dev C++](http://www.bloodshed.net/devcpp.html)。这是一个使用 mingw 端口作为后端的小型轻量级 IDE，这意味着您将编译事实上的 C/C++ 编译器[gcc](http://gcc.gnu.org/)

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T21:12:19.480

对于初学者： g++ --pedantic-errors -Wall

这将有助于从一开始就实施良好的编程。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-16T21:15:59.643

gcc 与 -Wall（启用所有警告）-Werror（将警告更改为错误）、-pedantic（获取非标准代码的警告）和 -ansi（制作标准 c++98）。

如果警告是您知道并需要关闭的内容，您可以随时将它们转回警告。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-09-16T21:26:25.233

我推荐 gcc，因为它设计用于命令行，你可以编译简单的程序并查看到底发生了什么：

```
g++ -o myprogram myprogram.cc
ls -l myprogram 
```

一个文件进去，两个文件出来。使用 Visual C++，大多数人将它与 GUI 一起使用，您必须在其中设置一个项目，并且 IDE 会生成一堆文件，如果您刚刚开始，这些文件可能会妨碍您。

如果您使用的是 Windows，您将在 MingW 或 Cygwin 之间进行选择。Cygwin 设置起来有点麻烦，因为您必须选择要安装的软件包，但我没有使用 MingW 的经验。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-16T21:11:27.827

您始终可以使用 Gnu Compiler Collection (GCC) 中的 C++ 编译器。它适用于地球上几乎所有的 Unix 系统、BSD、Mac OS、Linux 和 Windows（通过 Cygwin 或 mingw）。

许多 IDE 支持 GCC C++ 编译器，例如 Linux/KDE 下的 KDevelop 或其他帖子中提到的 Dev-CPP。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-16T21:10:14.523

Microsoft Visual Studio Express Edition 的 C++ 编译器很好

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-16T21:15:08.193

[CodeBlocks](http://www.codeblocks.org/)是一个非常好的 IDE，除了许多其他编译器 CL.EXE（来自 Visual Studio）和 gcc 之外，它还可以使用。它也有一个包含 gcc 的版本。

Visual Studio Express 版本也是一个很好的选择（如果您要开发调用 winapi 函数的应用程序，请使用 Platform SDK）。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-09-16T21:19:06.623

Eclipse 是一个很好的 mac，或者 Apple 自己的免费 Xcode，可以从他们的开发站点上删除。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-09-16T21:51:10.960

使用尚未提及的 g++ 或 MingW/Cygwin 的一个原因是启动和 IDE 将隐藏一些正在发生的事情。例如，理解编译和链接之间的差异将非常有用。从一开始就学习并理解它，你甚至不知道以后应该感谢自己。

-最大限度

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2008-09-16T22:17:52.927

`I say GCC for simple things because for a more complicated project the build process isn't so easy`

是的，但我不认为理解大型项目的构建过程与理解项目本身是正交的。我工作的最后一份工作是，他们有一个需要为目标平台 (LynxOS) 和仿真环境 (WinXP) 构建的庞大项目。他们选择将所有内容都放入一个用于 Windows 的 .VCP 文件中，并将其构建为一个大型可执行文件。在目标上它大约有 50 个单独的进程，因此他们编写了一个列出所有 3000 个源文件的生成文件，将它们全部编译到一个大库中，然后将每个可执行文件的各个 main.cpp 与一体化库链接，以制作 50 个可执行文件（它们可能与其他可执行文件共享 10% 的代码）。结果，没有开发人员知道哪些代码依赖于任何其他代码。因此，*无处不在*。分层构建系统可能有助于在原本杂乱无章的源代码存储库中强制执行某种顺序。

如果您不了解 .cpp 文件如何生成目标代码、什么是静态库、什么是共享库等等，那么在您学习 C/C++ 时，您仍然需要在某个时候学习它才能成为称职的 C/C++ 开发人员。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-16T21:47:56.710

命令行中的 Visual Studio 的行为就像 GCC。只需打开 Visual Studio 命令行窗口，然后：

```
`c:\temp> cl /nologo /EHsc /W4 foo.cpp
c:\temp> dir /b foo.*
foo.cpp  <-- your source file
foo.obj  <-- result of compiling the cpp file
foo.pdb  <-- debugging symbols (friendly names for debugging)
foo.exe  <-- result of linking the obj with libraries` 
```

* * *

 `## 回答 #14

> 赞同：0
> 
> 时间：2008-09-16T22:05:25.950

我同意 Iulian Șerbănoiu 的观点：**Code::Blocks 是一个非常好的解决方案**，可用于 Linux（它将使用 g++/gcc）和 Windows（它将使用 MS 编译器或 gcc）

请注意，您应该至少尝试一次或两次尝试使用良好的旧 makefile 进行编译，如果只是为了了解标头、源、包含等背后的逻辑等等。

作为初学者，不要忘记阅读有关 C++ 的书籍（在尝试学习该语言的怪癖时，会想到 Scott Meyers 和 Herb Sutter 的书籍），并学习开源高调项目以学习他们的代码风格（他们已经遇到了您将遇到的问题，并且可能找到了可行的解决方案......）。

# exception - 什么时候抛出异常？

> ID：77127
> 
> 赞同：477
> 
> 时间：2008-09-16T21:09:02.233
> 
> 标签：exception, language-agnostic

我为我的应用程序不期望的每个条件创建了异常。 `UserNameNotValidException`等`PasswordNotCorrectException`。

但是我被告知我不应该为这些条件创建例外。在我的 UML 中，那些是主要流程的异常，那么为什么它不应该是异常呢？

创建例外的任何指导或最佳实践？

* * *

## 回答 #1

> 赞同：679
> 
> 时间：2008-09-16T21:33:56.760

我个人的指导方针是：当发现当前代码块的基本假设为错误时，将引发异常。

示例 1：假设我有一个函数应该检查任意类并在该类继承自 List<> 时返回 true。这个函数提出了一个问题，“这个对象是 List 的后代吗？” 这个函数不应该抛出异常，因为在它的操作中没有灰色区域——每个单独的类要么继承自 List<>，要么不继承，所以答案总是“是”或“否”。

示例 2：假设我有另一个函数检查 List<> 并在其长度大于 50 时返回 true，如果长度小于则返回 false。这个函数提出了一个问题，“这个列表有超过 50 个项目吗？” 但是这个问题做了一个假设——它假设给出的对象是一个列表。如果我给它一个NULL，那么这个假设是错误的。在这种情况下，如果函数返回*true**或*false ，那么它就违反了自己的规则。该函数无法返回*任何内容*并声称它正确回答了问题。所以它不会返回 - 它会引发异常。

这与[“加载问题”](http://en.wikipedia.org/wiki/Fallacy_of_many_questions)的逻辑谬误相当。每个函数都会提出一个问题。如果给出的输入使该问题成为谬误，则抛出异常。使用返回 void 的函数很难画出这条线，但底线是：如果违反了函数对其输入的假设，它应该抛出异常而不是正常返回。

这个等式的另一面是：如果你发现你的函数经常抛出异常，那么你可能需要改进它们的假设。

* * *

## 回答 #2

> 赞同：294
> 
> 时间：2008-09-16T21:11:38.857

因为它们是会正常发生的事情。异常不是控制流机制。用户经常会弄错密码，这不是例外情况。异常应该是一个真正罕见的事情，`UserHasDiedAtKeyboard`类型的情况。

* * *

## 回答 #3

> 赞同：77
> 
> 时间：2008-09-17T08:33:19.547

我的小指南深受《代码完整》这本书的影响：

*   使用异常来通知不应忽略的事情。
*   如果错误可以在本地处理，则不要使用异常
*   确保异常与您例程的其余部分处于同一抽象级别。
*   例外应该保留给**真正的例外**。

* * *

## 回答 #4

> 赞同：39
> 
> 时间：2008-09-16T21:13:01.367

如果用户名无效或密码不正确，也不例外。这些是您在正常操作流程中应该期待的事情。异常是不属于正常程序操作的一部分并且相当罕见的事情。

编辑：我不喜欢使用异常，因为您无法仅通过查看调用来判断方法是否引发异常。这就是为什么只有在你不能以体面的方式处理这种情况时才应该使用异常（想想“内存不足”或“计算机着火”）。

* * *

## 回答 #5

> 赞同：31
> 
> 时间：2008-09-16T21:13:19.163

一条经验法则是在您通常无法预测的情况下使用例外。示例是数据库连接、磁盘上的文件丢失等。对于您可以预测的情况，即用户尝试使用错误密码登录，您应该使用返回布尔值并知道如何优雅地处理这种情况的函数。您不希望仅仅因为有人输入错误的密码就抛出异常来突然结束执行。

* * *

## 回答 #6

> 赞同：25
> 
> 时间：2008-09-16T21:39:01.553

其他人建议不应使用异常，因为如果用户输入错误，在正常流程中会出现错误登录。我不同意，我不明白理由。将其与打开文件进行比较。如果文件不存在或由于某种原因不可用，则框架将引发异常。使用上面的逻辑是微软的一个错误。他们应该返回一个错误代码。解析、webrequests 等也是如此。

我不认为正常流程中的不良登录部分是例外的。通常用户输入正确的密码，并且文件确实存在。例外情况是例外的，对这些情况使用例外是完全可以的。通过向上 n 层传播返回值来使代码复杂化是一种能源浪费，并且会导致代码混乱。做可能可行的最简单的事情。不要过早地使用错误代码进行优化，根据定义，异常的东西很少发生，除非你抛出异常，否则它们不会花费任何代价。

* * *

## 回答 #7

> 赞同：19
> 
> 时间：2008-09-16T21:13:13.267

我认为只有在无法摆脱当前状态时才应该抛出异常。例如，如果您正在分配内存并且没有要分配的内存。在您提到的情况下，您可以清楚地从这些状态中恢复，并可以相应地将错误代码返回给您的调用者。

* * *

你会看到很多建议，包括在这个问题的答案中，你应该只在“异常”情况下抛出异常。这似乎表面上合理，但却是有缺陷的建议，因为它用另一个主观问题（“什么是例外”）代替了一个问题（“我什么时候应该抛出异常”）。相反，请遵循 Herb Sutter 的建议（对于 C++，可在[Dobbs 博士的文章*When and How to Use Exceptions*](http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836)以及他与 Andrei Alexandrescu 合着的书*C++ Coding Standards*中找到）：当且仅当

*   不满足前提条件（这通常会使以下条件之一成为不可能）或
*   替代方案将无法满足后置条件或
*   替代方案将无法保持不变量。

为什么这样更好？它不是用*几个*关于前置条件、后置条件和不变量的问题来代替这个问题吗？由于几个相关的原因，这更好。

*   前置条件、后置条件和不变量是我们程序（其内部 API）的*设计*特征，而决定`throw`是实现细节。它迫使我们牢记，我们必须分别考虑设计及其实现，而我们在实现方法时的工作是产生满足设计约束的东西。
*   它迫使我们从前置条件、后置条件和不变量的角度进行思考，这是我们方法的调用者应该做出的*唯一*假设，并且可以精确地表达，从而实现程序组件之间的松散耦合。
*   然后，这种松散耦合允许我们在必要时重构实现。
*   后置条件和不变量是可测试的；它产生的代码可以很容易地进行单元测试，因为后置条件是我们的单元测试代码可以检查的谓词（断言）。
*   从后置条件的角度思考自然会产生一个*作为后置条件成功*的设计，这是使用异常的自然风格。程序的正常（“快乐”）执行路径是线性布局的，所有错误处理代码都移到`catch`子句中。

* * *

## 回答 #8

> 赞同：18
> 
> 时间：2008-09-16T21:11:17.250

异常会产生一些代价高昂的影响，例如，如果您有一个用户提供了无效密码，通常最好将失败标志或其他一些指示它无效的指示传回。

这是由于处理异常的方式，真正的错误输入和唯一的关键停止项应该是异常，而不是失败的登录信息。

* * *

## 回答 #9

> 赞同：10
> 
> 时间：2008-09-16T23:28:50.087

我想说对于何时使用例外没有硬性规定。但是，使用或不使用它们有充分的理由：

使用异常的原因：

*   普通案例的代码流程更清晰
*   可以将复杂的错误信息作为对象返回（尽管这也可以使用通过引用传递的错误“out”参数来实现）
*   语言通常提供一些工具来管理异常情况下的整洁清理（在 Java 中尝试/最终，在 C# 中使用，在 C++ 中使用 RAII）
*   在没有抛出异常的情况下，执行*有时*会比检查返回码更快
*   在 Java 中，必须声明或捕获已检查的异常（尽管这可能是反对的理由）

不使用异常的原因：

*   有时如果错误处理很简单，那就有点过头了
*   如果没有记录或声明异常，它们可能不会被调用代码捕获，这可能比调用代码只是忽略返回代码更糟糕（应用程序退出与静默失败 - 更糟糕的情况可能取决于场景）
*   在 C++ 中，使用异常的代码必须是异常安全的（即使您不抛出或捕获它们，而是间接调用抛出函数）
*   在 C++ 中，很难判断一个函数何时会抛出异常，因此如果你使用它们，你必须对异常安全持偏执的态度
*   与检查返回标志相比，抛出和捕获异常通常要昂贵得多

一般来说，我更倾向于在 Java 中使用异常而不是在 C++ 或 C# 中，因为我认为异常，无论是否声明，基本上都是函数的正式接口的一部分，因为更改你的异常保证可能中断调用代码。在 Java IMO 中使用它们的最大优势是您知道调用者必须处理异常，这提高了正确行为的机会。

正因为如此，在任何语言中，我总是会从一个公共类中派生出一层代码或 API 中的所有异常，以便调用代码始终保证捕获所有异常。此外，我认为在编写 API 或库时抛出特定于实现的异常类是不好的（即包装来自较低层的异常，以便调用者收到的异常在您的接口上下文中是可以理解的）。

请注意，Java 对一般异常和运行时异常进行了区分，因为后者不需要声明。当您知道错误是程序中的错误导致时，我只会使用运行时异常类。

* * *

## 回答 #10

> 赞同：6
> 
> 时间：2008-09-16T21:19:22.537

如果它是在循环中运行的代码可能会一遍又一遍地导致异常，那么抛出异常并不是一件好事，因为它们对于大 N 来说非常慢。但是如果性能不是那么抛出自定义异常并没有什么问题一个问题。只要确保您有一个它们都继承的基本异常，称为 BaseException 或类似的东西。BaseException 继承 System.Exception，但您的所有异常都继承 BaseException。您甚至可以拥有一个异常类型树来对相似类型进行分组，但这可能会也可能不会过大。

所以，简短的回答是，如果它不会导致显着的性能损失（除非你抛出很多异常，否则它不应该），然后继续。

* * *

## 回答 #11

> 赞同：5
> 
> 时间：2008-09-16T21:14:00.600

异常类就像“正常”类。当它“是”一种不同类型的对象，具有不同的字段和不同的操作时，您就创建了一个新类。

根据经验，您应该尝试在异常数量和异常粒度之间取得平衡。如果您的方法抛出超过 4-5 个不同的异常，您可能可以将其中一些合并到更“一般”的异常中（例如，在您的情况下为“AuthenticationFailedException”），并使用异常消息来详细说明出了什么问题。除非您的代码以不同方式处理它们中的每一个，否则您不需要创建许多异常类。如果确实如此，您是否应该只返回一个带有发生错误的枚举。这样会干净一些。

* * *

## 回答 #12

> 赞同：4
> 
> 时间：2011-12-19T11:22:35.950

抛出异常的经验法则非常简单。当您的代码进入不可恢复的无效状态时，您会这样做。如果数据被泄露，或者您无法回退到此时发生的处理，那么您必须终止它。事实上，你还能做什么？您的处理逻辑最终将在其他地方失败。如果你能以某种方式恢复，那么就这样做并且不要抛出异常。

在您的特定情况下，如果您被迫做一些愚蠢的事情，例如接受提款，然后才检查用户/密码，您应该通过抛出异常来终止该过程，以通知发生了不好的事情并防止进一步的损害。

* * *

## 回答 #13

> 赞同：3
> 
> 时间：2008-09-17T00:01:15.237

我同意 japollock 的观点——当你不确定手术的结果时，请接受。对 API 的调用、访问文件系统、数据库调用等。任何时候你都在超越你的编程语言的“边界”。

我想补充一点，请随意抛出一个标准异常。除非您打算做一些“不同”的事情（忽略、发送电子邮件、登录、显示 twitter 鲸鱼图片等），否则不要为自定义异常而烦恼。

* * *

## 回答 #14

> 赞同：2
> 
> 时间：2008-09-16T21:17:03.383

通常，您希望为应用程序中可能发生的任何“异常”事件抛出异常

在您的示例中，这两个异常看起来都像是您通过密码/用户名验证调用它们。在这种情况下，可以说有人会输错用户名/密码并不是什么特别的事情。

它们是 UML 主要流程的“例外”，但在处理中更多的是“分支”。

如果您试图访问您的 passwd 文件或数据库但无法访问，那将是一个例外情况，需要引发异常。

* * *

## 回答 #15

> 赞同：2
> 
> 时间：2008-09-16T21:17:41.213

首先，如果您的 API 的用户对特定的、细粒度的故障不感兴趣，那么为他们设置特定的异常就没有任何价值。

由于通常不可能知道什么对您的用户有用，因此更好的方法是拥有特定的异常，但要确保它们继承自一个公共类（例如，std::exception 或其在 C++ 中的派生类）。这允许您的客户在他们选择时捕获特定的异常，或者如果他们不关心，则可以捕获更一般的异常。

* * *

## 回答 #16

> 赞同：2
> 
> 时间：2008-09-16T22:02:53.727

异常适用于异常行为、错误、故障等事件。功能行为、用户错误等应该由程序逻辑来处理。由于错误的帐户或密码是登录例程中逻辑流程的预期部分，因此它应该能够毫无例外地处理这些情况。

* * *

## 回答 #17

> 赞同：2
> 
> 时间：2008-09-17T04:19:41.137

简单的答案是，只要操作是不可能的（因为任何一个应用程序或因为它会违反业务逻辑）。如果调用了一个方法并且无法执行编写该方法的目的，则抛出异常。一个很好的例子是，如果无法使用提供的参数创建实例，构造函数总是抛出 ArgumentExceptions。另一个示例是 InvalidOperationException，当由于类的另一个或多个成员的状态而无法执行操作时抛出该异常。

在您的情况下，如果调用像 Login(username, password) 这样的方法，如果用户名无效，则抛出 UserNameNotValidException 或 PasswordNotCorrectException 如果密码不正确，则确实是正确的。用户无法使用提供的参数登录（即不可能，因为它会违反身份验证），因此抛出异常。虽然我可能让你的两个异常继承自 ArgumentException。

话虽如此，如果您不希望抛出异常，因为登录失败可能很常见，一种策略是创建一个返回表示不同失败类型的方法。这是一个例子：

```
{ // class
    ...

    public LoginResult Login(string user, string password)
    {
        if (IsInvalidUser(user))
        {
            return new UserInvalidLoginResult(user);
        }
        else if (IsInvalidPassword(user, password))
        {
            return new PasswordInvalidLoginResult(user, password);
        }
        else
        {
            return new SuccessfulLoginResult();
        }
    }

    ...
}

public abstract class LoginResult
{
    public readonly string Message;

    protected LoginResult(string message)
    {
        this.Message = message;
    }
}

public class SuccessfulLoginResult : LoginResult
{
    public SucccessfulLogin(string user)
        : base(string.Format("Login for user '{0}' was successful.", user))
    { }
}

public class UserInvalidLoginResult : LoginResult
{
    public UserInvalidLoginResult(string user)
        : base(string.Format("The username '{0}' is invalid.", user))
    { }
}

public class PasswordInvalidLoginResult : LoginResult
{
    public PasswordInvalidLoginResult(string password, string user)
        : base(string.Format("The password '{0}' for username '{0}' is invalid.", password, user))
    { }
} 
```

大多数开发人员都被教导要避免异常，因为抛出异常会造成开销。有资源意识很好，但通常不会以牺牲您的应用程序设计为代价。这可能是您被告知不要抛出两个异常的原因。是否使用异常通常归结为异常发生的频率。如果这是一个相当普遍或相当可预期的结果，那么大多数开发人员将避免异常，而是创建另一种方法来指示失败，因为假定会消耗资源。

这是一个使用 Try() 模式避免在刚刚描述的场景中使用异常的示例：

```
public class ValidatedLogin
{
    public readonly string User;
    public readonly string Password;

    public ValidatedLogin(string user, string password)
    {
        if (IsInvalidUser(user))
        {
            throw new UserInvalidException(user);
        }
        else if (IsInvalidPassword(user, password))
        {
            throw new PasswordInvalidException(password);
        }

        this.User = user;
        this.Password = password;
    }

    public static bool TryCreate(string user, string password, out ValidatedLogin validatedLogin)
    {
        if (IsInvalidUser(user) || 
            IsInvalidPassword(user, password))
        {
            return false;
        }

        validatedLogin = new ValidatedLogin(user, password);

        return true;
    }
} 
```

* * *

## 回答 #18

> 赞同：2
> 
> 时间：2008-09-17T06:10:22.667

我会说，一般来说，每一个原教旨主义都会导致地狱。

您当然不希望以异常驱动的流程告终，但完全避免异常也是一个坏主意。你必须在这两种方法之间找到平衡。我不会做的是为每个异常情况创建一个异常类型。那是没有生产力的。

我通常更喜欢创建在整个系统中使用的两种基本类型的异常：*LogicalException*和*TechnicalException*。如果需要，这些可以通过亚型进一步区分，但通常不是必需的。

技术异常表示真正意外的异常，例如数据库服务器关闭、与 Web 服务的连接引发 IOException 等等。

另一方面，逻辑异常用于将不太严重的错误情况传播到上层（通常是一些验证结果）。

请注意，即使是逻辑异常也不打算定期用于控制程序流程，而是突出显示流程应该真正结束的情况。在 Java 中使用时，两种异常类型都是*RuntimeException*子类，并且错误处理高度面向方面。

*因此，在登录示例中，创建类似 AuthenticationException 之类的内容并通过UsernameNotExisting*、*PasswordMismatch*等枚举值区分具体情况可能是明智之举。这样您就不会最终拥有巨大的异常层次结构，并且可以将 catch 块保持在可维护级别. 您还可以轻松地使用一些通用的异常处理机制，因为您已经对异常进行了分类，并且非常清楚将什么传播给用户以及如何传播给用户。

我们的典型用法是在用户输入无效时，在 Web Service 调用期间抛出 LogicalException。异常被编组到 SOAPFault 详细信息，然后在客户端上再次解组到异常，这导致在某个网页输入字段上显示验证错误，因为异常具有到该字段的正确映射。

这当然不是唯一的情况：您不需要点击 Web 服务来抛出异常。您可以在任何特殊情况下自由地这样做（例如在您需要快速失败的情况下） - 这完全由您自行决定。

* * *

## 回答 #19

> 赞同：2
> 
> 时间：2011-10-06T15:32:51.097

对我来说，当所需的技术或业务规则失败时，应该抛出异常。例如，如果汽车实体与 4 个轮胎的数组相关联……如果一个或多个轮胎为空……应该触发一个异常 "NotEnoughTiresException" ，因为它可以在系统的不同级别被捕获并具有显着通过日志记录的意思。此外，如果我们只是尝试对 null 进行流控制并防止 car 的实例化。我们可能永远找不到问题的根源，因为轮胎本来就不应该是空的。

* * *

## 回答 #20

> 赞同：1
> 
> 时间：2008-09-16T21:14:43.390

避免抛出异常的主要原因是抛出异常涉及大量开销。

下面的文章指出的一件事是异常是针对异常条件和错误。

错误的用户名不一定是程序错误，而是用户错误...

这是 .NET 中异常的一个不错的起点：http: [//msdn.microsoft.com/en-us/library/ms229030 (VS.80).aspx](http://msdn.microsoft.com/en-us/library/ms229030(VS.80).aspx)

* * *

## 回答 #21

> 赞同：1
> 
> 时间：2008-09-16T21:21:14.090

抛出异常会导致堆栈展开，这会对性能产生一些影响（承认，现代托管环境对此进行了改进）。在嵌套情况下仍然反复抛出和捕获异常将是一个坏主意。

可能比这更重要的是，例外是针对特殊情况的。它们不应该用于普通的控制流，因为这会损害代码的可读性。

* * *

## 回答 #22

> 赞同：1
> 
> 时间：2008-09-16T21:54:36.693

我发现了三种情况。

1.  输入错误或丢失不应该是例外。使用客户端 js 和服务器端正则表达式来检测、设置属性并转发回带有消息的同一页面。

2.  应用异常。这通常是您在代码中检测并抛出的异常。换句话说，这些是您所期望的（文件不存在）。记录它，设置消息，然后转发回一般错误页面。这个页面通常有一些关于发生了什么的信息。

3.  意外的异常。这些是你不知道的。记录详细信息并将它们转发到一般错误页面。

希望这可以帮助

* * *

## 回答 #23

> 赞同：1
> 
> 时间：2008-09-16T23:10:36.123

安全性与您的示例混为一谈：您不应该告诉攻击者用户名存在，但密码错误。这是您不需要分享的额外信息。只需说“用户名或密码不正确”即可。

* * *

## 回答 #24

> 赞同：1
> 
> 时间：2008-09-17T18:43:45.273

我在使用例外方面存在哲学问题。基本上，您期望发生特定情况，但不是明确地处理它，而是将问题推到“其他地方”处理。任何人都可以猜测“其他地方”在哪里。

* * *

## 回答 #25

> 赞同：1
> 
> 时间：2010-06-24T16:45:18.060

在我看来，基本问题应该是如果发生某种情况，是否会期望调用者希望继续正常的程序流程。如果你不知道，要么有单独的 doSomething 和 trySomething 方法，前者返回错误而后者不返回，或者有一个例程接受一个参数来指示如果失败是否应该抛出异常）。考虑一个向远程系统发送命令并报告响应的类。某些命令（例如重新启动）会导致远程系统发送响应，但在一定时间内没有响应。因此，能够发送“ping”命令并​​找出远程系统是否在合理的时间长度内响应而不必抛出异常是很有用的 t（调用者可能会期望前几次“ping”尝试会失败，但最终会成功）。另一方面，如果有一系列命令，例如：

```
  exchange_command("打开临时文件");
  exchange_command("写临时文件数据 {whatever}");
  exchange_command("写临时文件数据 {whatever}");
  exchange_command("写临时文件数据 {whatever}");
  exchange_command("写临时文件数据 {whatever}");
  exchange_command("关闭临时文件");
  exchange_command("将临时文件复制到真实文件");

```

人们会希望任何操作失败以中止整个序列。虽然可以检查每个操作以确保其成功，但如果命令失败，让 exchange_command() 例程抛出异常会更有帮助。

实际上，在上述场景中，有一个参数来选择多种故障处理模式可能会有所帮助：从不抛出异常，仅针对通信错误抛出异常，或在命令未返回“成功”的任何情况下抛出异常"指示。

* * *

## 回答 #26

> 赞同：1
> 
> 时间：2011-03-22T13:44:30.810

“PasswordNotCorrectException”不是使用异常的好例子。用户密码错误是意料之中的，所以恕我直言，这几乎不是例外。你甚至可能从中恢复，显示一个很好的错误消息，所以它只是一个有效性检查。

未处理的异常最终会停止执行——这很好。如果您返回 false、null 或错误代码，您将不得不自己处理程序的状态。如果您忘记检查某处的条件，您的程序可能会继续运行错误数据，并且您可能很难弄清楚发生了*什么以及*发生*在哪里*。

当然，空的 catch 语句可能会导致同样的问题，但至少发现这些更容易，并且不需要您理解逻辑。

因此，根据经验：

在您不想要或根本无法从错误中恢复的任何地方使用它们。

* * *

## 回答 #27

> 赞同：0
> 
> 时间：2008-09-16T21:19:53.017

您可以针对该条件使用一些通用异常。例如，当方法的参数出现任何问题时使用 ArgumentException（ArgumentNullException 除外）。通常你不需要像 LessThanZeroException、NotPrimeNumberException 等异常。想想你的方法的用户。她要专门处理的条件的数量等于您的方法需要抛出的异常类型的数量。这样，您可以确定您将拥有的异常详细程度。

顺便说一句，请始终尝试为您的库的用户提供一些避免异常的方法。TryParse 是一个很好的例子，它的存在使您不必使用 int.Parse 并捕获异常。在您的情况下，您可能希望提供一些方法来检查用户名是否有效或密码是否正确，这样您的用户（或您）就不必进行大量异常处理。这有望带来更易读的代码和更好的性能。

* * *

## 回答 #28

> 赞同：0
> 
> 时间：2008-09-16T21:26:25.687

最终决定归结为使用异常处理或通过您自己的家庭滚动机制（如返回状态代码）来处理此类应用程序级错误是否更有帮助。我认为对于哪个更好没有硬性规定，但我会考虑：

*   谁在调用你的代码？这是某种公共 API 还是内部库？
*   您使用什么语言？例如，如果它是 Java，那么抛出（已检查）异常会给调用者带来显式负担，以某种方式处理此错误条件，而不是可以忽略的返回状态。这可能是好是坏。
*   如何处理同一应用程序中的其他错误情况？调用者不会想要处理一个以与系统中其他任何东西不同的特殊方式处理错误的模块。
*   有问题的例行程序会出现多少问题，如何以不同的方式处理它们？考虑处理不同错误的一系列 catch 块和打开错误代码之间的区别。
*   你有关于你需要返回的错误的结构化信息吗？抛出异常为您提供了一个更好的地方来放置这些信息，而不是仅仅返回一个状态。

* * *

## 回答 #29

> 赞同：0
> 
> 时间：2008-09-17T02:10:20.013

在决定例外是否合适时需要考虑一些有用的事情：

1.  在异常候选发生后您希望运行什么级别的代码 - 即调用堆栈应该展开多少层。您通常希望在尽可能接近异常发生的地方处理异常。对于用户名/密码验证，您通常会在同一代码块中处理失败，而不是让异常冒泡。所以例外可能是不合适的。（OTOH，在 3 次登录尝试失败后，控制流可能会转移到其他地方，此处可能会出现异常。）

2.  您是否希望在错误日志中看到此事件？并非每个异常都写入错误日志，但询问错误日志中的此条目是否有用是很有用的 - 即，您会尝试对此做些什么，或者是否会成为您忽略的垃圾。

* * *

## 回答 #30

> 赞同：-1
> 
> 时间：2008-09-17T01:28:33.513

主要有两类异常：

1) 系统异常（例如数据库连接丢失）或 2) 用户异常。（例如用户输入验证，'密码不正确'）

我发现创建自己的用户异常类很有帮助，当我想抛出一个用户错误时，我想以不同的方式处理（即向用户显示资源错误），那么我在主要错误处理程序中需要做的就是检查对象类型：

```
 If TypeName(ex) = "UserException" Then
               Display(ex.message)
            Else
               DisplayError("An unexpected error has occured, contact your help  desk")                   
               LogError(ex)
            End If 
```

* * *

## 回答 #31

> 赞同：-2
> 
> 时间：2008-09-16T22:47:05.507

异常与返回错误代码参数应该是关于流控制而不是哲学（错误是多么“异常”）：

```
void f1() throws ExceptionType1, ExceptionType2 {}

void catchFunction() {
  try{
    while(someCondition){
      try{
        f1(); 
      }catch(ExceptionType2 e2){
        //do something, don't break the loop
      }
    }
  }catch(ExceptionType1 e1){
    //break the loop, do something else
  } 
```

}

* * *

## 回答 #32

> 赞同：-3
> 
> 时间：2014-04-23T06:46:09.117

以下是我的建议：

我不认为抛出异常总是一个好方法，因为处理此类异常需要更多时间和内存。

在我看来，**如果可以用“亲切、礼貌”的方式处理某些事情（这意味着如果我们可以“通过使用 if…… 或类似的东西来预测此类错误），我们应该避免使用“异常”，而只返回一个标志像 "false" ，带有一个外部参数值告诉他/她详细的原因。**

一个例子是，我们可以像下面这样创建一个类：

```
public class ValueReturnWithInfo<T>
{
   public T Value{get;private set;}
   public string errorMsg{get;private set;}
   public ValueReturnWithInfo(T value,string errmsg)
   {
      Value = value;
      errMsg = errmsg;
   }
} 
```

我们可以使用这样的“多值返回”类来代替错误，这似乎是一种更好、更礼貌的处理异常问题的方式。

但是，请注意，**如果某些错误不能用“if”……那么简单地描述（这取决于您的编程经验）（例如 FileIO 异常），则必须抛出异常**。

# php - PHP 部署到 windows/unix 服务器

> ID：77128
> 
> 赞同：5
> 
> 时间：2008-09-16T21:09:04.713
> 
> 标签：php, windows, linux, deployment, automation

我们在 windows (xampp) 上开发了各种 php 项目，这些项目需要部署到混合的 linux/windows 服务器上。

我们过去曾使用[capistrano](http://www.capify.org/)从 windows 部署到 linux 服务器，但最近架构和 windows 服务器的变化使旧配置无法正常工作。该配方适用于 linux 部署，但设置 Windows 服务器所需的时间比我们现在要多。Capistrano 食谱的想法是有效的答案。显然，windows/linux 服务器不共享用户，所以这使它有点复杂（因为 capistrano 假设到处都使用相同的用户名/密码）。

目前我们正在为 windows 服务器使用 svn-update，我不喜欢，因为它使所有 svn 文件都挂在生产服务器上。（我们仍然必须在 Windows 上手动 svn-update 它们）并使用 winscp 手动更新文件并将目录与它们的 linux 对应物同步。

我的问题是，您建议使用哪些工具/设置来自动化此部署方案： **“Various php windows/linux developers deploying to 2+ mixed windows/linux machines”**

（ps：我们使用 linux 工具或任何通过 cygwin 工作的东西都没有问题，我们只需要让部署成为一个简单的一步操作）

*编辑：目前我们不能在全linux环境下工作，我们必须同时部署到linux和windows服务器。我们可以从任何地方开始部署，但我们希望能够从任一环境中进行部署。*

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-16T21:41:00.813

根据客户端环境，我使用 4 种不同的方法：

1.  Capistrano 和类似工具（有效但复杂）
2.  `rsync`从 + 到 Windows、Linux、Mac（简单，不强制执行）
3.  `svn`从 + 到 Windows、Linux、Mac（简单，不强制执行）
4.  On-server scripts (run through the browser, complex)

There are some requirements that drive what you need:

*   How much discipline you want to enforce
*   If you need database (or configuration) migrations (up and/or down)
*   If you want a static "we're down" page
*   Who can do the update
*   Configuration differences between servers

I strongly suggest enforcing enough discipline to save you from yourself: deploy to a development server, allow for upward migrations and simple database restore, and limit who can update the live server to a small number of responsible admins (where the dev server is open to more developers). Also consider pushing via a cron job (to the development server), so there's a daily snapshot of your incremental changes.

Most of the time, I find that either `svn` or `rsync` setups are enough, with a few server-side scripts, especially when the admin set is limited to a few developers.

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T21:15:47.240

这可能听起来很傻，但是……我曾经一直遇到这种问题，直到最后我决定如果我总是在 Linux 上*部署*，我真的应该至少尝试在 Linux 上进行*开发*。我做到了。这是无痛的。我再也没有回去过。

现在。我并不是说这适合所有人。但是，如果你安装了[VirtualBox](http://www.virtualbox.org/)，你可以在你的 windows 机器上运行 Linux 安装作为本地服务器。在虚拟机中共享一个文件夹，您就可以使用所有已知和受信任的 Windows 软件和技术*，并且*知道一切都在其目标平台上运行良好。

此外，您还可以返回 Capistrano（一个不错的选择）进行部署。

最重要的是，如果您认为自己了解 Linux / Unix，请等到您每天在桌面上使用它！谁知道你甚至会喜欢它:)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T21:13:34.327

Capistrano 是我见过的最好的部署工具。架构更改是否无法修复配置以使其再次工作？

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T22:13:17.460

Why you can't use capistrano anymore?

Why you dislike svn-update?

What things in your app requires an special deployment ?

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-17T11:56:49.277

You can setup `svn:ignore` property on configuration files, so that `svn update` doesn't erase them, and then use `svn export /target/path/` to get rid of `.svn` files in your Subversion repository.

# soap - 需要 kSOAP 编组帮助

> ID：77131
> 
> 赞同：3
> 
> 时间：2008-09-16T21:09:09.737
> 
> 标签：soap, java-me, ksoap

有没有人有一个使用 kSOAP 包的复杂对象编组示例？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-17T23:26:49.350

虽然这个例子不是可编译和完整的，但基本思想是有一个类告诉 kSOAP 如何将 XML 标记转为对象（即 readInstance()）以及如何将对象转为 XML 标记（即 writeInstance() ）。

```
public class MarshalBase64File implements Marshal {

  public static Class FILE_CLASS = File.class;

  public Object readInstance(XmlPullParser parser, String namespace, String name, PropertyInfo expected)
      throws IOException, XmlPullParserException {
    return Base64.decode(parser.nextText());
  }

  public void writeInstance(XmlSerializer writer, Object obj) throws IOException {
    File file = (File)obj;
    int total = (int)file.length();
    FileInputStream in = new FileInputStream(file);
    byte b[] = new byte[4096];
    int pos = 0;
    int num = b.length;
    if ((pos + num) > total) {
      num = total - pos;
    }
    int len = in.read(b, 0, num);
    while ((len != -1) && ((pos + len) < total)) {
      writer.text(Base64.encode(b, 0, len, null).toString());
      pos += len;
      if ((pos + num) > total) {
        num = total - pos;
      }
      len = in.read(b, 0, num);
    }
    if (len != -1) {
      writer.text(Base64.encode(b, 0, len, null).toString());
    }
  }

  public void register(SoapSerializationEnvelope cm) {
    cm.addMapping(cm.xsd, "base64Binary", MarshalBase64File.FILE_CLASS, this);
  }
} 
```

稍后，当您调用 SOAP 服务时，您会将对象类型（在本例中为 File 对象）映射到编组类。SOAP 信封将自动匹配每个参数的对象类型，如果它不是内置类型，则调用关联的编组器将其转换为 XML 或从 XML 转换。

```
public class MarshalDemo {

  public String storeFile(File file) throws IOException, XmlPullParserException {
    SoapObject soapObj = new SoapObject("http://www.example.com/ws/service/file/1.0", "storeFile");
    soapObj.addProperty("file", file);

    SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11);
    new MarshalBase64File().register(envelope);
    envelope.encodingStyle = SoapEnvelope.ENC;
    envelope.setOutputSoapObject(soapObj);

    HttpTransport ht = new HttpTransport(new URL(server, "/soap/file"));
    ht.call("http://www.example.com/ws/service/file/1.0/storeFile", envelope);

    String retVal = "";
    SoapObject writeResponse = (SoapObject)envelope.bodyIn;
    Object obj = writeResponse.getProperty("statusString");
    if (obj instanceof SoapPrimitive) {
      SoapPrimitive statusString = (SoapPrimitive)obj;
      String content = statusString.toString();
      retVal = content;
    }
    return retVal;
  }
} 
```

在这种情况下，我使用 Base64 编码来编组 File 对象。

# winapi - 是否可以将 WM_QUERYENDSESSION 消息发送到不同进程中的窗口？

> ID：77133
> 
> 赞同：4
> 
> 时间：2008-09-16T21:09:12.623
> 
> 标签：winapi, message

我想调试我编写的 Windows C++ 应用程序，看看为什么它没有像我期望的那样响应 WM_QUERYENDSESSION。显然，仅通过关闭系统来做到这一点有点棘手。是否有任何实用程序或代码可用于将假的 WM_QUERYENDSESSION 发送到我的应用程序窗口？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T21:15:46.460

我过去曾使用[Win32::GuiTest](http://winguitest.sourceforge.net) Perl 模块来做这种事情。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T21:16:11.060

Windows API SendMessage 可用于执行此操作。 [http://msdn.microsoft.com/en-us/library/ms644950(VS.85).aspx](http://msdn.microsoft.com/en-us/library/ms644950(VS.85).aspx)

是否可能它没有响应，因为其他一些正在运行的进程已经响应为零（使系统等待它。）

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T21:45:56.730

是的，当然有可能。几个月前我遇到了一个类似的问题，其中一些（未知，但可能是我的）应用程序正在阻止关闭，所以我编写了一些快速代码，使用 EnumWindows 枚举所有顶级窗口，向每个窗口发送一条 WM_QUERYENDSESSION 消息，记录返回的内容如果有人返回 FALSE，则 SendMessage 中的值将停止枚举。在 C++/MFC 中花了大约十分钟。这是它的胆量：

```
void CQes_testDlg::OnBtnTest()  
{  
   // enumerate all the top-level windows.  
   m_ctrl_ListMsgs.ResetContent();  
   EnumWindows (EnumProc, 0);  
}  

BOOL CALLBACK EnumProc (HWND hTarget, LPARAM lParam)  
{  
   CString csTitle;  
   CString csMsg;  
   CWnd *  pWnd = CWnd::FromHandle (hTarget);  
   BOOL    bRetVal = TRUE;  
   DWORD   dwPID;  

   if (pWnd)  
   {  
      pWnd->GetWindowText (csTitle);  
      if (csTitle.GetLength() == 0)  
      {  
         GetWindowThreadProcessId (hTarget, &dwPID);  
         csTitle.Format ("<PID=%d>", dwPID);  
      }  

      if (pWnd->SendMessage (WM_QUERYENDSESSION, 0, ENDSESSION_LOGOFF))  
      {  
         csMsg.Format ("window 0x%X (%s) returned TRUE", hTarget, csTitle);  
      }  
      else   
      {    
         csMsg.Format ("window 0x%X (%s) returned FALSE", hTarget, csTitle);  
         bRetVal = FALSE;  
      }  

      mg_pThis->m_ctrl_ListMsgs.AddString (csMsg);
   }
   else  
   {  
      csMsg.Format ("Unable to resolve HWND 0x%X to a CWnd", hTarget);  
      mg_pThis->m_ctrl_ListMsgs.AddString (csMsg);  
   }  
   return bRetVal;  
} 
```

mg_pThis 只是对话框的 this 指针的本地副本，因此辅助回调可以访问它。我告诉过你它又快又脏:-)

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T21:15:35.493

是的。如果您可以获得窗口句柄（可能使用 FindWindow()），只要 WPARAM 和 LPARAM 不是指针，您就可以向它发送/发布任何消息。

# domain-driven-design - DDD 中的数据访问？

> ID：77171
> 
> 赞同：10
> 
> 时间：2008-09-16T21:12:29.777
> 
> 标签：domain-driven-design, data-access

在阅读了 Evan 和 Nilsson 的书后，我仍然不确定如何在域驱动项目中管理数据访问。CRUD 方法应该是存储库的一部分，即 OrderRepository.GetOrdersByCustomer(customer) 还是应该是实体的一部分：Customer.GetOrders()。后一种方法看起来更面向对象，但它会将单个实体类型的数据访问分配给多个对象，即 Customer.GetOrders()、Invoice.GetOrders()、ShipmentBatch.GetOrders() 等。插入和更新呢？

* * *

## 回答 #1

> 赞同：15
> 
> 时间：2008-09-16T21:23:36.567

CRUD-ish 方法应该是 Repository...ish 的一部分。但我认为你应该问为什么你有一堆 CRUD 方法。他们*真正*做什么？他们*究竟是*为了什么？如果您实际调用您的应用程序使用的数据访问模式，我认为它会使存储库更加有用，并且当您的域发生某些类型的更改时，您不必进行霰弹枪手术。

```
CustomerRepo.GetThoseWhoHaventPaidTheirBill()

// or

GetCustomer(new HaventPaidBillSpecification())

// is better than

foreach (var customer in GetCustomer()) {
    /* logic leaking all over the floor */
} 
```

“保存”类型的方法也应该是存储库的一部分。

如果您有聚合根，这可以防止您发生存储库爆炸，或者让逻辑遍布各处：您没有 4 x # 的实体数据访问模式，只有您在聚合根上实际使用的那些。

那是我的 0.02 美元。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-09-16T22:16:40.557

DDD 通常更喜欢存储库模式，而不是您使用 Customer.Save 暗示的活动记录模式。

Active Record 模型的一个缺点是它几乎假定了一个单一的持久性模型，除非有一些特别侵入性的代码（在大多数语言中）。

存储库接口在域层中定义，但不知道您的数据是否存储在数据库中。例如，使用存储库模式，我可以创建一个 InMemoryRepository，以便我可以单独测试域逻辑，并在应用程序中使用依赖注入让服务层实例化一个 SqlRepository。

对很多人来说，拥有一个专门用于测试的存储库听起来很愚蠢，但是如果您使用存储库模型，您可能会发现您的特定应用程序并不真正需要数据库；有时一个简单的 FileRepository 就可以解决问题。在您知道自己需要数据库之前与自己结婚可能会受到限制。即使需要数据库，对 InMemoryRepository 运行测试也会快得多。

如果你没有太多的领域逻辑，你可能不需要 DDD。ActiveRecord 非常适合解决很多问题，特别是如果你有大部分数据和一点点逻辑。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-20T16:20:24.800

让我们退后一步。Evans 建议存储库返回聚合根，而不仅仅是实体。因此，假设您的客户是包含订单的聚合根，那么当您从其存储库中获取客户时，订单随之而来。您将通过导航从客户到订单的关系来访问订单。

```
customer.Orders; 
```

因此，为了回答您的问题，CRUD 操作存在于聚合根存储库中。

```
CustomerRepository.Add(customer);
CustomerRepository.Get(customerID);
CustomerRepository.Save(customer);
CustomerRepository.Delete(customer); 
```

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T21:41:23.403

我已经完成了您所说的两种方式，我现在首选的方法是持久无知（或 PONO - Plain Ole' .Net Object）方法，您的域类只担心成为域类。他们不知道它们是如何被持久化的，或者即使它们被持久化了。当然，有时您必须对此保持务实，并允许使用诸如 Id 之类的东西（但即便如此，我也只是使用具有 Id 的层超类型，因此我可以有一个点，其中存在诸如默认值之类的东西）

主要原因是我努力遵循单一职责的原则。通过遵循这个原则，我发现我的代码更易于测试和维护。在需要时进行更改也容易得多，因为我只有一件事要考虑。

需要注意的一件事是存储库可能遭受的方法膨胀。GetOrderbyCustomer..GetAllOrders..GetOrders30DaysOld..等等等等。这个问题的一个很好的解决方案是查看查询对象模式。然后你的存储库可以只接受一个查询对象来执行。

我还强烈建议您研究 NHibernate 之类的东西。它包含许多使存储库如此有用的概念（身份映射、缓存、查询对象......）

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-16T21:18:51.367

即使在 DDD 中，我也会将数据访问类和例程与实体分开。

原因是，

1.  可测试性提高
2.  关注点分离和模块化设计
3.  随着您添加实体、例程，从长远来看更易于维护

我不是专家，只是我的看法。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-16T21:28:56.320

Nilsson 的 Applying DDD&P 令人讨厌的地方在于，他总是以“我不会在现实世界的应用程序中那样做，但是……”开头，然后他的例子就来了。回到主题：我认为 OrderRepository.GetOrdersByCustomer(customer) 是要走的路，但在 ALT.Net 邮件列表上也有讨论（[http://tech.groups.yahoo.com/group/altdotnet/](http://tech.groups.yahoo.com/group/altdotnet/)）关于 DDD。

# sql-server - 源代码控制中的存储过程/数据库模式

> ID：77172
> 
> 赞同：68
> 
> 时间：2008-09-16T21:12:35.220
> 
> 标签：sql-server, database, version-control

你们在选择的源代码控制系统中跟踪存储过程和数据库模式吗？

当您进行更改时（添加表，更新存储过程，您如何将更改导入源代码管理？

我们在工作中使用 SQL Server，我已经开始使用 darcs 进行版本控制，但我会对一般策略以及任何方便的工具感到好奇。

*编辑：*哇，感谢所有伟大的建议，伙计们！我希望我可以选择多个“已接受的答案”！

* * *

## 回答 #1

> 赞同：43
> 
> 时间：2008-09-16T21:46:08.727

我们选择为所有内容编写脚本，包括所有存储过程和架构更改。不需要所见即所得的工具，也不需要花哨的“同步”程序。

架构更改很容易，您只需为该版本创建和维护一个文件，包括所有架构和数据更改。这将成为您从版本 x 到 x+1 的转换脚本。然后，您可以针对生产备份运行它并将其集成到您的“每日构建”中，以验证它是否可以正常工作。请注意，重要的是不要更改或删除已编写的模式/数据加载 sql，因为您最终可能会破坏以后编写的任何 sql。

```
-- change #1234
ALTER TABLE asdf ADD COLUMN MyNewID INT
GO

-- change #5678
ALTER TABLE asdf DROP COLUMN SomeOtherID
GO 
```

对于存储过程，我们为每个 sproc 选择一个文件，它使用 drop/create 形式。所有存储过程都在部署时重新创建。不利的一面是，如果在源代码控制之外进行了更改，则更改将丢失。同时，任何代码都是如此，但您的 DBA 需要注意这一点。这确实可以阻止团队以外的人使用您的存储过程，因为他们的更改会在升级中丢失。

使用 Sql Server，语法如下所示：

```
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[usp_MyProc]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [usp_MyProc]
GO

CREATE PROCEDURE [usp_MyProc]
(
    @UserID INT
)
AS

SET NOCOUNT ON

-- stored procedure logic.

SET NOCOUNT OFF

GO 
```

剩下要做的唯一事情是编写一个实用程序来整理所有单独的文件并使用整个更新集（作为单个脚本）创建一个新文件。为此，首先添加架构更改，然后递归目录结构并包括所有存储过程文件。

作为编写一切脚本的一个好处，您将在阅读和编写 SQL 方面变得更好。你也可以让整个过程更加精细，但这是如何在没有任何特殊软件的情况下对所有 sql 进行源代码控制的基本格式。

附录：Rick 是正确的，您将失去使用 DROP/CREATE 存储过程的权限，因此您可能需要编写另一个脚本来重新启用特定权限。此权限脚本将是最后运行的。我们的经验发现更多关于 ALTER verses DROP/CREATE 语义的问题。YMMV

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2008-09-16T21:15:16.727

在 Visual Studio 中创建一个“数据库项目”来编写和管理您的 SQL 代码，并将项目与解决方案的其余部分一起置于版本控制之下。

* * *

## 回答 #3

> 赞同：8
> 
> 时间：2008-09-16T21:17:53.913

我们在上一份工作中使用的解决方案是在脚本添加到源代码控制时对其进行编号：

01.CreateUserTable.sql
02.PopulateUserTable
03.AlterUserTable.sql
04.CreateOrderTable.sql

我们的想法是我们始终知道运行脚本的顺序，并且我们可以避免必须管理如果您尝试修改脚本 #1 可能出现的数据完整性问题（这可能会导致 #2 中的 INSERT 失败）。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-09-16T23:14:44.863

使用 SQL Server 中的删除/创建脚本要记住的一件事是对象级权限将丢失。我们更改了我们的标准，改为使用 ALTER 脚本，它维护了这些权限。

还有一些其他注意事项，例如删除对象会删除 sp_depends 使用的依赖关系记录，而创建对象只会创建该对象的依赖关系。因此，如果您删除/创建视图，sp_depends 将不再知道引用该视图的任何对象。

故事的寓意，使用 ALTER 脚本。

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2008-09-17T10:11:20.310

我同意（并赞成）罗伯特·保尔森的做法。那是假设您控制着一个有责任和纪律来坚持这种做法的开发团队。

为了将其“强制”到我的团队中，我们的解决方案至少维护了一个来自**[Visual Studio Team Edition for Database Professionals 的](http://www.microsoft.com/downloads/details.aspx?FamilyID=7DE00386-893D-4142-A778-992B69D482AD&displaylang=en)**数据库项目。与解决方案中的其他项目一样，数据库项目获得版本控制。将数据库中的所有内容分解成可维护的块，这使得它成为一个自然的开发过程，并在此过程中“约束”我的团队。

当然，作为一个 Visual Studio 项目，它远非完美。您会遇到许多怪癖，可能会让您感到沮丧或困惑。在完成您的任务之前，需要对项目的工作方式有一定的了解。例子包括

*   [从 CSV 文件部署数据](http://icelava.net/forums/post/2620.aspx)。
*   [根据构建类型选择性部署测试数据](http://icelava.net/forums/post/2756.aspx)。
*   [Visual Studio 在与嵌入了特定类型 CLR 程序集的数据库进行比较时崩溃](http://forums.microsoft.com/msdn/ShowPost.aspx?PostID=1750819&SiteID=1)。
*   无法区分实现不同身份验证方案的测试/生产数据库 - SQL 用户与 Active Directory 用户。

但是对于没有实践过对其数据库对象进行版本控制的团队来说，这是一个好的开始。另一个著名的替代品当然是[Red Gate 的 SQL Server 产品套件](http://www.red-gate.com/products/index.htm)，大多数使用它们的人认为它优于 Microsoft 的产品。

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2008-09-16T21:16:01.997

我认为您应该编写一个脚本来自动设置您的数据库，包括任何存储过程。然后应该将此脚本放在源代码管理中。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-16T21:54:36.350

根据我的经验，结合不同的观点。在 Oracle 世界中，一切都由“创建”DDL 脚本管理。正如 ahockley 提到的，每个对象都有一个脚本。如果对象需要更改，则修改其 DDL 脚本。有一个包装脚本可以调用所有对象脚本，这样您就可以将当前的数据库构建部署到您想要的任何环境中。这是为主要核心创建。

显然，在实时应用程序中，每当您推送需要新列的新构建时，您都不会删除表并创建新表。您将执行 ALTER 脚本并添加列。所以每次这种变化需要发生时，总是有两件事要做：1）编写alter DDL和2）更新核心创建DDL以反映变化。两者都进入源代码控制，但单个更改脚本更多的是瞬时更改，因为它仅用于应用增量。

您也可以使用像 ERWin 这样的工具来更新模型并转发生成 DDL，但我认识的大多数 DBA 不相信建模工具可以完全按照他们想要的方式生成脚本。您还可以使用 ERWin 定期将您的核心 DDL 脚本逆向工程到模型中，但要让它看起来正确（每次您这样做）都需要大惊小怪。

在 Microsoft 世界中，我们采用了类似的策略，但我们使用 Red Gate 产品来帮助管理脚本和增量。仍然将脚本放在源代码管理中。每个对象（表、sproc 等）仍然有一个脚本。一开始，一些 DBA 确实更喜欢使用 SQL Server GUI 来管理对象，而不是使用脚本。但这使得在企业成长过程中始终如一地管理企业变得非常困难。

如果 DDL 在源代码控制中，则使用任何构建工具（通常是 ant）来编写部署脚本都很简单。

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2011-10-20T19:37:30.657

我发现到目前为止，最简单、最快和最安全的方法就是硬着头皮使用 RedGate 的 SQL 源代码控制。在几分钟内编写脚本并存储在存储库中。我只是希望 RedGate 将该产品视为亏损的领导者，以便它能够得到更广泛的使用。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-09-16T22:00:49.270

在过去的经验中，我一直以这样一种方式控制数据库更改源，即对于产品的每个版本，任何数据库更改总是被脚本化并存储在我们正在处理的版本中。适当的构建过程将根据数据库中的表自动将数据库升级到当前版本，该表存储每个“应用程序”的当前版本。然后，我们编写的自定义 .net 实用程序应用程序将运行并确定数据库的当前版本，并按照脚本前缀编号的顺序针对它运行任何新脚本。然后我们会运行单元测试以确保一切正常。

我们将脚本存储在源代码管理中，如下所示（文件夹结构如下）：

我对表和存储过程的当前命名约定有点生疏，我的示例如此简单......

[根]
    [应用程序]
        [版本]
            [脚本]

\scripts
    MyApplication\
        1.2.1\
            001.MyTable.Create.sql
            002.MyOtherTable.Create.sql
            100.dbo.usp.MyTable.GetAllNewStuff.sql

通过使用将应用程序和版本考虑在内的版本表，应用程序将恢复每周的生产备份，并从当前版本开始针对数据库运行所需的所有脚本。通过使用 .net，我们可以轻松地将其打包到事务中，如果有任何失败，我们将回滚并发送电子邮件，因此我们知道该版本的脚本错误。

因此，所有开发人员都将确保在源代码控制中维护这一点，以便协调发布将确保我们计划针对数据库运行的所有脚本都能成功运行。

这可能比您要寻找的信息更多，但它对我们来说非常有效，并且考虑到结构很容易让所有开发人员参与进来。

当发布日临近时，运营团队将遵循发布说明并从源代码管理中获取脚本，并使用我们在夜间构建过程中使用的 .net 应用程序针对数据库运行包，该应用程序会自动将脚本打包到事务中，所以如果失败了，它会自动回滚，对数据库没有影响。

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-09-16T22:01:07.210

与上面的 Robert Paulson 类似，我们的组织将数据库置于源代码控制之下。然而，我们的不同之处在于我们试图限制我们拥有的脚本数量。

对于任何新项目，都有一套固定的程序。我们有一个版本 1 的模式创建脚本，一个存储过程创建脚本，可能还有一个初始数据加载创建脚本。所有 proc 都保存在一个公认的庞大文件中。如果我们使用企业库，我们会包含一个用于记录的创建脚本的副本；如果它是使用 ASP.NET 应用程序框架（身份验证、个性化等）的 ASP.NET 项目，我们也包含该脚本。（我们使用 Microsoft 的工具生成它，然后对其进行调整，直到它以可在不同站点上复制的方式工作。这不好玩，但宝贵的时间投资。）

我们使用神奇的 CTRL+F 来找到我们喜欢的 proc。:) （如果 SQL Management Studio 有像 VS 那样的代码导航功能，我们会很高兴的。叹息！）

对于后续版本，我们通常有 upgradeSchema、upgradeProc 和/或 updateDate 脚本。对于模式更新，我们尽可能地 ALTER 表，根据需要创建新表。对于 proc 更新，我们 DROP 和 CREATE。

这种方法确实会出现一个皱纹。生成数据库很容易，并且很容易让新数据库在当前数据库版本上加快速度。但是，必须注意 DAL 生成（我们目前 - 通常 - 使用 SubSonic），以确保 DB/schema/proc 更改与用于访问它们的代码完全同步。但是，在我们的构建路径中是一个生成 SubSonic DAL 的批处理文件，因此我们的 SOP 是检查 DAL 代码，重新运行该批处理文件，然后在架构和/或 procs 更改时将其全部检查回来。（当然，这会触发源代码构建，将共享依赖项更新为适当的 DLL ...）

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-09-16T23:27:06.083

存储过程每个 sp 使用标准如果存在顶部的 drop/create 语句获得 1 个文件。视图和函数也有自己的文件，因此它们更易于版本化和重用。

Schema 是所有 1 个脚本，然后我们将进行版本更改。

所有这些都存储在连接到 TFS（@work 或 VisualSVN Server @home 用于个人资料）的 Visual Studio 数据库项目中，其文件夹结构如下：
- 项目
- 函数
- 架构
- 存储过程
- 视图

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2008-09-16T23:43:40.317

在我的公司，我们倾向于将所有数据库项目作为单独的脚本存储在源代码控制中，就像您存储单独的代码文件一样。任何更新首先在数据库中进行，然后迁移到源代码存储库中，以便维护更改历史记录。
第二步，将所有数据库更改迁移到集成数据库。这个集成数据库准确地代表了生产数据库在部署后的样子。我们还有一个代表当前生产状态（或上次部署）的 QA 数据库。在集成数据库中进行所有更改后，我们使用模式差异工具（Red Gate 的 SQL Server SQL Diff）生成脚本，将所有更改从一个数据库迁移到另一个数据库。
我们发现这相当有效，因为它生成了一个脚本，我们可以轻松地与我们的安装程序集成。我们经常遇到的最大问题是开发人员忘记将他们的更改迁移到集成中。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-16T21:13:42.470

我们将存储过程保存在源代码控制中。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-09-16T21:14:42.593

编写所有脚本（对象创建等）并将这些脚本存储在源代码管理中。这些变化是如何实现的？这是如何完成事情的标准做法的一部分。需要添加表格吗？编写一个 CREATE TABLE 脚本。更新存储过程？编辑存储过程脚本。

我更喜欢每个对象一个脚本。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-09-16T21:15:50.423

对于 procs，将带有脚本包装器的 procs 写入普通文件，并应用这些文件中的更改。如果它应用正确，那么您可以签入该文件，并且您也可以从该文件中复制它。

对于架构更改，您可能需要签入脚本以逐步进行您所做的更改。编写脚本，应用它，然后签入。然后您可以构建一个流程，自动依次应用每个模式脚本。

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2008-09-16T21:16:40.530

我们确实将存储过程保存在源代码控制中。我们（或至少我）这样做的方式是在我的项目中添加一个文件夹，为每个 SP 添加一个文件，然后手动复制、粘贴代码。所以当我更改SP时，我需要手动更改源代码控制文件。

我很想知道人们是否可以自动执行此操作。

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2008-09-16T21:23:14.227

我强烈建议在源代码控制中维护模式和存储过程。

保持存储过程版本化允许它们在确定有问题时回滚。

Schema 是一个不太明显的答案，具体取决于您的意思。维护在源代码控制中定义表的 SQL 非常有用，用于复制环境（产品/开发/用户等）。

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2008-09-16T21:35:14.167

在我当前的项目中，我们一直在使用另一种方法——我们没有将数据库置于源代码控制之下，而是使用数据库差异工具来编写每个版本时的更改脚本。
到目前为止，它一直运行良好。

* * *

## 回答 #19

> 赞同：0
> 
> 时间：2008-09-16T21:41:15.773

我们将与应用程序相关的所有内容存储在 SCM 中。DB 脚本通常存储在它们自己的项目中，但就像任何其他代码一样被处理……设计、实现、测试、提交。

* * *

## 回答 #20

> 赞同：0
> 
> 时间：2008-09-16T22:10:07.983

我运行一个作业将其编写成一个正式的目录结构。

以下是从批处理文件调用的 VS2005 代码，命令行项目，可以完成工作。代码末尾的 app.config 键。

它基于我在网上找到的其他代码。设置起来有点痛苦，但一旦你开始工作，它就会很好地工作。

```
Imports Microsoft.VisualStudio.SourceSafe.Interop
Imports System
Imports System.Configuration

Module Module1

    Dim sourcesafeDataBase As String, sourcesafeUserName As String, sourcesafePassword As String, sourcesafeProjectName As String, fileFolderName As String

    Sub Main()
        If My.Application.CommandLineArgs.Count > 0 Then
            GetSetup()
            For Each thisOption As String In My.Application.CommandLineArgs
                Select Case thisOption.ToUpper
                    Case "CHECKIN"
                        DoCheckIn()
                    Case "CHECKOUT"
                        DoCheckOut()
                    Case Else
                        DisplayUsage()
                End Select
            Next
        Else
            DisplayUsage()
        End If
    End Sub

    Sub DisplayUsage()
        Console.Write(System.Environment.NewLine + "Usage: SourceSafeUpdater option" + System.Environment.NewLine + _
            "CheckIn - Check in ( and adds any new ) files in the directory specified in .config" + System.Environment.NewLine + _
            "CheckOut - Check out all files in the directory specified in .config" + System.Environment.NewLine + System.Environment.NewLine)
    End Sub

    Sub AddNewItems()
        Dim db As New VSSDatabase
        db.Open(sourcesafeDataBase, sourcesafeUserName, sourcesafePassword)
        Dim Proj As VSSItem
        Dim Flags As Integer = VSSFlags.VSSFLAG_DELTAYES + VSSFlags.VSSFLAG_RECURSYES + VSSFlags.VSSFLAG_DELNO
        Try
            Proj = db.VSSItem(sourcesafeProjectName, False)
            Proj.Add(fileFolderName, "", Flags)
        Catch ex As Exception
            If Not ex.Message.ToString.ToLower.IndexOf("already exists") > 0 Then
                Console.Write(ex.Message)
            End If
        End Try
        Proj = Nothing
        db = Nothing
    End Sub

    Sub DoCheckIn()
        AddNewItems()
        Dim db As New VSSDatabase
        db.Open(sourcesafeDataBase, sourcesafeUserName, sourcesafePassword)
        Dim Proj As VSSItem
        Dim Flags As Integer = VSSFlags.VSSFLAG_DELTAYES + VSSFlags.VSSFLAG_UPDUPDATE + VSSFlags.VSSFLAG_FORCEDIRYES + VSSFlags.VSSFLAG_RECURSYES
        Proj = db.VSSItem(sourcesafeProjectName, False)
        Proj.Checkin("", fileFolderName, Flags)
        Dim File As String
        For Each File In My.Computer.FileSystem.GetFiles(fileFolderName)
            Try
                Proj.Add(fileFolderName + File)
            Catch ex As Exception
                If Not ex.Message.ToString.ToLower.IndexOf("access code") > 0 Then
                    Console.Write(ex.Message)
                End If
            End Try
        Next
        Proj = Nothing
        db = Nothing
    End Sub

    Sub DoCheckOut()
        Dim db As New VSSDatabase
        db.Open(sourcesafeDataBase, sourcesafeUserName, sourcesafePassword)
        Dim Proj As VSSItem
        Dim Flags As Integer = VSSFlags.VSSFLAG_REPREPLACE + VSSFlags.VSSFLAG_RECURSYES
        Proj = db.VSSItem(sourcesafeProjectName, False)
        Proj.Checkout("", fileFolderName, Flags)
        Proj = Nothing
        db = Nothing
    End Sub

    Sub GetSetup()
        sourcesafeDataBase = ConfigurationManager.AppSettings("sourcesafeDataBase")
        sourcesafeUserName = ConfigurationManager.AppSettings("sourcesafeUserName")
        sourcesafePassword = ConfigurationManager.AppSettings("sourcesafePassword")
        sourcesafeProjectName = ConfigurationManager.AppSettings("sourcesafeProjectName")
        fileFolderName = ConfigurationManager.AppSettings("fileFolderName")

    End Sub

End Module

<add key="sourcesafeDataBase" value="C:\wherever\srcsafe.ini"/>
<add key="sourcesafeUserName" value="vssautomateuserid"/>
<add key="sourcesafePassword" value="pw"/>
<add key="sourcesafeProjectName" value="$/where/you/want/it"/>
<add key="fileFolderName" value="d:\yourdirstructure"/> 
```

* * *

## 回答 #21

> 赞同：-1
> 
> 时间：2015-02-11T07:24:07.513

如果您正在寻找一个简单、现成的解决方案，我们的[Sql Historian](http://tessik.com/sqlhistorian)系统使用后台进程自动将 DDL 更改同步到 TFS 或 SVN，对任何在数据库上进行更改的人都是透明的。以我的经验，最大的问题是在源代码控制中使用服务器上的更改来维护代码——这是因为通常你必须依靠人们（甚至是开发人员！）来更改他们的工作流程并记住检查他们的更改在他们已经在服务器上完成之后。把这个负担放在机器上会让每个人的生活更轻松。

# refactoring - 您如何向吝啬的老板证明重构工作的合理性？

> ID：77193
> 
> 赞同：16
> 
> 时间：2008-09-16T21:14:11.503
> 
> 标签：refactoring

您刚刚编写了一堆代码，以便在压力下交付一些重要的功能。你已经走捷径了，你已经将一些代码混入了一些过于臃肿的类，其名称如 SerialIndirectionShutoffManager..

你告诉你的老板你需要一周的时间来清理这些东西。

“清理什么？”

“我的密码——它是猪圈！”

“你的意思是还有一些错误修复？”

“不是，更像是……”

“你会让它跑得更快吗？”

“也许吧，但那不是……”

“那你应该在有机会的时候把它写好。现在我很高兴你在这里，是的，我得继续请你这个周末来..”

我读过 Matin Fowler 的书，但我不确定我是否同意他对此事的建议：

*   鼓励定期进行代码审查，因此鼓励将重构工作作为开发过程的一个自然部分。
*   只是不要说，你是开发人员，这是你职责的一部分。

这两种方法都是出于与经理沟通的需要。

你跟老板说什么？

* * *

## 回答 #1

> 赞同：25
> 
> 时间：2008-09-16T21:58:24.250

在原始估算中包含重构时间很重要。在你交付产品后去找你的老板，然后告诉他你实际上还没有完成，这是在说已经完成了。你实际上并没有达到交付的最后期限。这就像一个外科医生做手术，然后不确定他把所有东西都放回了应该的样子。

将开发的所有部分（例如重构、可用性研究、测试、QA、修订）包括在您的原始计划中是很重要的。归根结底，这与其说是管理问题，不如说是程序员问题。

然而，如果你继承了一个烂摊子，那么你将不得不向老板解释最后一组程序员急于将项目推出门外，并且它一直一瘸一拐地前进。您可以暂时解决问题（就像他们可能所做的那样），但是每个创可贴只会延迟问题并最终使问题的修复成本更高。

对你的老板诚实，并明白一个项目在完成之前是没有完成的。

* * *

## 回答 #2

> 赞同：22
> 
> 时间：2008-09-16T21:18:38.480

用他能听懂的语言说话。

重构正在偿还设计债务。

问问你的老板，为什么他每个月都要支付公司信用卡账单，而不是在收到催款通知之前不支付。告诉他重构就像每月付款一样。

* * *

## 回答 #3

> 赞同：7
> 
> 时间：2008-09-16T21:15:20.797

说谎。告诉他这是对新技术的研究。然后告诉他你认为成本并不能证明收益是合理的。他会认为你做得很好。

大声笑@人们降低改装/标记攻击性。

真的，如果是一个吝啬的老板，不懂好软件和便宜的软件，他不懂的东西最终会让他更快乐。如果是我，我会离开公司，去一个他们尊重他们的开发人员编写好的代码能力的地方。但话又说回来，这就是我处于高级职位的原因。

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2008-09-16T21:18:33.990

只需执行此操作并将其安排到您的正常流程中即可。估计重构时间到开始新的更改或完成更改（理想）。我总是在最初探索新代码（提取方法等）时进行重构。

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2008-09-16T21:18:22.537

告诉他与软件项目相关的 80% 的成本来自生命周期的维护阶段。现在为缓解未来问题而进行的任何重构，并提供一些示例，将在以后需要维护该代码时获得可观的成本收益。

这是假设您出于某种原因进行重构，而不是出于程序员的虚荣心。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-09-16T21:17:14.320

重构你应该一直做......所以你不应该证明它是合理的。

清理大混乱/重新设计可能包括重构以使其得到控制，但它不是“重构”

重构应该是片刻的事情......或者如果你没有工具支持，几分钟。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-16T21:21:50.500

在 Robert Glass 最近的一本书中（我必须查阅参考资料），他提到了一项关于维护良好的代码成本的研究。他们发现，维护良好的代码比维护不善的代码更容易被编辑。这听起来违反直觉，但当他们深入挖掘时发现了原因：

与维护不善的代码相比，维护良好的代码在同一时间范围内添加了更多功能。

你的老板喜欢功能吗？当然，他们都这样做。如果您提高代码的可维护性，您将能够在有限的预算下提供更多的功能。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-16T21:17:44.817

我喜欢 Martin Fowler 在“重构”中给出的答案。告诉你的老板，你将以你知道的最快方式开发软件。碰巧在大多数情况下，开发软件的最快方法是随时重构。

要告诉老板的另一件事是，您正在降低成本以进行未来的改进。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T21:19:20.663

现在我重构的钱少了……

或者以后有更多的钱来解决任何问题并让我进行重构。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T21:34:07.803

有时，是时候找一份新工作了。有些人只是希望你“完成它”。如果您曾经遇到过其中一种情况，而我曾经去过那里，那就离开吧。

但是，是的，关于未来成本的所有其他内容都是好主意。我只是认为大多数老板都在骗自己，因为他们想要什么就什么时候想要什么，他们只是看不到未来会发生什么。

所以，祝你老板好运。Hpefully他或她是合理的。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-16T21:39:23.453

不要....只是去一个与你更同步的地方找一份新工作。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-09-16T21:42:55.553

我认为你应该在不告诉你的老板的情况下开始工作。这确实是我尽力而为的方式。我只是不告诉我的老板我在做什么，并在我有时间的时候慢慢替换坏/遗留代码。

它不止一次地救了我的屁股。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-16T21:48:49.500

如果您的老板不了解重构或清理代码的必要性，那么您必须怀疑他是否有足够的工程知识来担任工程经理。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-09-16T22:00:54.417

很少有老板会给你时间重构……只要你边做边做。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-09-16T22:06:19.957

在我看来，重构最简单的情况是修复过于复杂的代码。测量相关源代码的 McCabe 圈复杂度（Source Monitor 是解决此类问题的绝佳工具）。具有高圈复杂度的源代码具有强相关性缺陷和不良修复。简而言之，这意味着复杂的代码更难修复，而且更可能有错误的修复。这对经理来说意味着产品的质量可能会更差，错误更难修复，项目的进度最终会更糟。然而，在重构复杂性的过程中，您正在提高代码的透明度，减少模糊/困难错误的可能性，并使其更易于维护（例如，维护程序员因此可以拥有更大的维护范围）。

此外，您可以证明（如果它不是维护周期中的死产品）降低复杂性会使应用程序在向项目中添加新需求时更容易扩展。

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2008-09-16T22:13:01.050

老板必须信任开发人员做出正确的技术决策（包括何时重构）。

建立信任或更换老板或更换开发人员。

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2011-08-02T19:59:04.973

另一个很好的比喻是维护一个整洁的建筑工地。这里唯一的问题是程序员不代表建筑工人，经理不代表工头。如果是这样的话，他的“第一次做对”的计数器仍然适用，因为一个称职和尽责的建筑工人有责任在他们工作的过程中保持工作空间的良好秩序。

真的**代码本身就**代表劳动者，开发过程就是工头。混乱是由围绕彼此的业务进行的各种行业产生的（即，不同的代码功能相互作用，每个功能都很好地完成了它的工作，但它们之间的接缝是杂乱无章的），并由工头坚定地清理密切关注混乱发生的位置，并采取行动将其清理干净（即要求重构的软件过程）。

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2012-07-19T15:40:52.880

我最近所做的就是向我的业务伙伴解释，重构过程有助于更快地开发新功能并降低新错误的可能性，因为代码具有更好的顺序和结构，甚至可以进行一些速度改进因为您可以比以前更容易地检查代码。

当业务人员明白这一点时，如果他们很聪明，他们会鼓励您进行持续的重构过程。

你可以用建筑比喻来解释这一点。如果您不进行重构，那么您将以糟糕的核心建筑而告终，因此您将遇到管道，窗户，门的问题。

# python - BlazeDS Livecycle Data Services 做了什么，而 PyAMF 或 RubyAMF 之类的东西不做？

> ID：77198
> 
> 赞同：4
> 
> 时间：2008-09-16T21:15:02.077
> 
> 标签：python, ruby-on-rails, ruby, apache-flex, blazeds

我正在进行技术审查并查看 AMF 与各种后端（Rails、Python、Grails 等）的集成。

有很多选择，问题是，Adobe 产品（BlazeDS 等）有什么像 RubyAMF / pyAMF 没有的？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-19T00:02:00.117

除了 NIO (RTMP) 通道，LCDS 还包括“数据管理”功能。

使用此功能，您基本上可以在 ActionScript 类中实现由 LCDS 定义的类似 CRUD 的接口，您将获得：

*   自动渐进式列表加载（滚动时加载大型列表/数据网格）
*   自动 crud 管理（您在闪存中本地获取对象，对其进行修改，将其发送回，数据库将自动更新）
*   解决冲突的功能（如果多个用户尝试同时更新同一记录）
*   如果我没记错的话，还有一些改进的与 LiveCycle ES 工作流引擎的集成

IMO，以这种方式开发可能非常快，但前提是您只有基本要求和简单的架构（忘记 SOA，否则它与 Flex 配合得很好）。我对 BlazeDS 很好。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-19T04:17:40.937

此处描述的 LCDS 数据管理功能当然是有效的，但我相信它们不会让您真正更快地开发解决方案。开发人员仍然必须编写所有数据访问代码、查询执行、从数据读取器中提取数据到值对象中。所有这些都已经用代码生成器解决了十几次。例如，Java 的 WebORB 中的数据管理方法（很像 .NET 和 PHP 的 WebORB）基于代码生成，它为客户端和服务器端创建代码。您可以从代码生成器中获取所有 ActionScript API 来执行完整的 CRUD。

此外，WebORB 提供视频流和实时消息传递功能，远远超出了 BlazeDS 和 LCDS 提供的组合，特别是考虑到该产品是免费的。只是谷歌它。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-17T13:13:50.197

Adobe 有两种产品：Livecycle Data Services ES (LCDS) 和 BlazeDS。BlazeDS 包含 LCDS 功能的子集，并且是开源的。不幸的是，NIO 通道（RTMP NIO/HTTP）和数据管理功能仅在 LCDS 中实现，而不是在 BlazeDS 中实现。

BlazeDS 只能用于将 Flex 与 Java 后端集成。它不仅提供使用 AMF 序列化（如 RubyAMF）的远程服务，还提供消息传递和协作功能 - 请查看此链接 ( [http://livedocs.adobe.com/blazeds/1/blazeds_devguide/help.html?content=lcoverview_3 .html](http://livedocs.adobe.com/blazeds/1/blazeds_devguide/help.html?content=lcoverview_3.html)）。另外我认为与 RubyAMF/pyAMF 相比，它的支持更好。

如果您的后端是 JAVA，并且您只想使用免费产品，您也可以使用 GraniteDS 或 WebORB（BlazeDS 的竞争对手）

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-16T21:42:49.797

好问题。我不是一个 ruby​​ 人（我使用 java 和 flex），但我认为 blazeds 与商业 livecycle ds 的区别是

1.  流协议支持 (rtmp) - 竞争彗星等，提供视频
2.  我不完全理解或需要的一些用于休眠分离对象和大型结果集缓存的高级东西
    3.  支持？可能是其他人，但那些是我知道的。

# java - 如何消除重复的枚举代码？

> ID：77213
> 
> 赞同：23
> 
> 时间：2008-09-16T21:15:52.357
> 
> 标签：java, enums, enumeration

我有大量实现此接口的枚举：

```
/**
 * Interface for an enumeration, each element of which can be uniquely identified by its code
 */
public interface CodableEnum {

    /**
     * Get the element with a particular code
     * @param code
     * @return
     */
    public CodableEnum getByCode(String code);

    /**
     * Get the code that identifies an element of the enum
     * @return
     */
    public String getCode();
} 
```

一个典型的例子是：

```
public enum IMType implements CodableEnum {

    MSN_MESSENGER("msn_messenger"),
    GOOGLE_TALK("google_talk"),
    SKYPE("skype"),
    YAHOO_MESSENGER("yahoo_messenger");

    private final String code;

    IMType (String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }   

    public IMType getByCode(String code) {
        for (IMType e : IMType.values()) {
            if (e.getCode().equalsIgnoreCase(code)) {
                return e;
            }
        }
    }
} 
```

可以想象，这些方法在 CodableEnum 的所有实现中几乎是相同的。我想消除这种重复，但坦率地说不知道如何。我尝试使用如下类：

```
public abstract class DefaultCodableEnum implements CodableEnum {

    private final String code;

    DefaultCodableEnum(String code) {
        this.code = code;
    }

    public String getCode() {
        return this.code;
    }   

    public abstract CodableEnum getByCode(String code);  
} 
```

但事实证明这毫无用处，因为：

1.  枚举不能扩展类
2.  枚举的元素（SKYPE、GOOGLE_TALK 等）不能扩展类
3.  我无法提供 getByCode() 的默认实现，因为 DefaultCodableEnum 本身不是 Enum。我尝试更改 DefaultCodableEnum 以扩展 java.lang.Enum，但这似乎是不允许的。

有什么不依赖反思的建议吗？谢谢，唐

* * *

## 回答 #1

> 赞同：13
> 
> 时间：2008-09-16T23:22:40.837

您可以将重复的代码分解为一个`CodeableEnumHelper`类：

```
public class CodeableEnumHelper {
    public static CodeableEnum getByCode(String code, CodeableEnum[] values) {
        for (CodeableEnum e : values) {
            if (e.getCode().equalsIgnoreCase(code)) {
                return e;
            }
        }
        return null;
    }
} 
```

每个`CodeableEnum`类仍然必须实现一个`getByCode`方法，但该方法的实际实现至少已经集中到一个地方。

```
public enum IMType implements CodeableEnum {
    ...
    public IMType getByCode(String code) {
        return (IMType)CodeableEnumHelper.getByCode(code, this.values());
    } 
} 
```

* * *

## 回答 #2

> 赞同：7
> 
> 时间：2008-09-16T21:43:23.210

抽象枚举可能非常有用（目前不允许）。但是，如果您想游说 Sun 中的某个人添加它，那么存在一个提案和原型：

[http://freddy33.blogspot.com/2007/11/abstract-enum-ricky-carlson-way.html](http://freddy33.blogspot.com/2007/11/abstract-enum-ricky-carlson-way.html)

太阳 RFE：

[http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6570766](http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6570766)

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-09-17T10:41:26.227

整理 dave 的代码：

```
public class CodeableEnumHelper {
    public static <E extends CodeableEnum> E getByCode(
        String code, E[] values
    ) {
        for (E e : values) {
            if (e.getCode().equalsIgnoreCase(code)) {
                return e;
            }
        }
        return null;
    }
}

public enum IMType implements CodableEnum {
    ...
    public IMType getByCode(String code) {
        return CodeableEnumHelper.getByCode(code, values());
    } 
} 
```

或者更有效：

```
public class CodeableEnumHelper {
    public static <E extends CodeableEnum> Map<String,E> mapByCode(
        E[] values
    ) {
        Map<String,E> map = new HashMap<String,E>();
        for (E e : values) {
            map.put(e.getCode().toLowerCase(Locale.ROOT), value) {
        }
        return map;
    }
}

public enum IMType implements CodableEnum {
    ...
    private static final Map<String,IMType> byCode =
        CodeableEnumHelper.mapByCode(values());
    public IMType getByCode(String code) {
        return byCode.get(code.toLowerCase(Locale.ROOT));
    } 
} 
```

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-16T21:45:25.220

我写的本地化组件也有类似的问题。我的组件旨在访问具有索引到资源包中的枚举常量的本地化消息，这不是一个难题。

我发现我正在到处复制和粘贴相同的“模板”枚举代码。我避免重复的解决方案是一个代码生成器，它接受一个带有枚举常量名称和构造函数参数的 XML 配置文件。输出是具有“重复”行为的 Java 源代码。

现在，我维护配置文件和生成器，而不是所有重复的代码。在我拥有枚举源代码的任何地方，现在都有一个 XML 配置文件。我的构建脚本检测过时的生成文件并调用代码生成器来创建枚举代码。

[你可以在这里](http://virtualteamtls.svn.sourceforge.net/viewvc/virtualteamtls/trunk/jill)看到这个组件。我复制和粘贴的模板被分解为[XSLT 样式表](http://virtualteamtls.svn.sourceforge.net/viewvc/virtualteamtls/trunk/jill/resources/com/iparelan/jill/jill.xsl?view=markup)。[代码生成器](http://virtualteamtls.svn.sourceforge.net/viewvc/virtualteamtls/trunk/jill/src/com/iparelan/jill/Jill.java?view=markup)运行样式表转换。与生成的枚举源代码相比，[输入文件](http://virtualteamtls.svn.sourceforge.net/viewvc/virtualteamtls/trunk/jill/src/com/iparelan/jill/jill.xml?view=markup)非常简洁。

HTH，
格雷格

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T21:24:58.060

不幸的是，我认为没有办法做到这一点。您最好的选择可能是完全放弃 emums 并使用传统的类扩展和静态成员。否则，习惯于复制该代码。对不起。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-17T00:02:55.980

创建一个类型安全的实用程序类，它将通过代码加载枚举：

界面归结为：

```
public interface CodeableEnum {
    String getCode();
} 
```

实用程序类是：

```
import java.lang.reflect.InvocationTargetException;

public class CodeableEnumUtils {
    @SuppressWarnings("unchecked")
    public static <T extends CodeableEnum>  T getByCode(String code, Class<T> enumClass) throws IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {
        T[] allValues = (T[]) enumClass.getMethod("values", new Class[0]).invoke(null, new Object[0]);
        for (T value : allValues) {
            if (value.getCode().equals(code)) {
                return value;
            }
        }
        return null;
} 
```

}

一个演示用法的测试用例：

```
import junit.framework.TestCase;

public class CodeableEnumUtilsTest extends TestCase {
    public void testWorks() throws Exception {
    assertEquals(A.ONE, CodeableEnumUtils.getByCode("one", A.class));
      assertEquals(null, CodeableEnumUtils.getByCode("blah", A.class));
    }

enum A implements CodeableEnum {
    ONE("one"), TWO("two"), THREE("three");

    private String code;

    private A(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }   
}
} 
```

现在您只是复制 getCode() 方法，而 getByCode() 方法在一个地方。将所有异常包装在一个 RuntimeException 中可能会很好:)

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2011-03-20T11:02:39.660

在这里，我有另一个解决方案：

```
interface EnumTypeIF {
String getValue();

EnumTypeIF fromValue(final String theValue);

EnumTypeIF[] getValues();

class FromValue {
  private FromValue() {
  }

  public static EnumTypeIF valueOf(final String theValue, EnumTypeIF theEnumClass) {

    for (EnumTypeIF c : theEnumClass.getValues()) {
      if (c.getValue().equals(theValue)) {
        return c;
      }
    }
    throw new IllegalArgumentException(theValue);
  }
} 
```

诀窍是内部类可用于保存“全局方法”。

对我来说工作得很好。好的，你必须实现 3 个方法，但这些方法只是委托者。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-16T21:28:28.863

看起来您实际上是在实现运行时类型信息。Java 将此作为一种语言特性提供。

我建议你查一下 RTTI 或反射。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T21:33:20.707

我不认为这是可能的。但是，如果您打算使用枚举值的名称作为代码，则可以使用枚举的 valueOf(String name) 方法。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T21:37:06.610

静态泛型方法怎么样？您可以在枚举的 getByCode() 方法中重用它，或者直接使用它。我总是为我的枚举使用整数 id，所以我的 getById() 方法只需要这样做：返回 values()[id]。它更快更简单。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-16T21:53:48.210

如果你真的想要继承，不要忘记你可以[自己实现枚举模式](http://snipplr.com/view/1655/typesafe-enum-pattern)，就像在糟糕的 Java 1.4 时代一样。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-09-16T22:39:10.363

与您想要的差不多，就是在 IntelliJ 中创建一个模板，该模板将“实现”通用代码（使用枚举的 valueOf(String name)）。不完美，但效果很好。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-17T11:00:54.277

在您的特定情况下， getCode() / getByCode(String code) 方法似乎非常接近（委婉地说）所有枚举提供的 toString() / valueOf(String value) 方法的行为。你为什么不想使用它们？

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2010-03-18T17:06:14.580

另一种解决方案是不将任何内容放入枚举本身，而只为每个枚举提供一个双向映射 Enum <-> 代码。例如，您可以为此使用Google Collections 中的[ImmutableBiMap](http://google-collections.googlecode.com/svn/trunk/javadoc/index.html?com/google/common/collect/ImmutableBiMap.html)。

这样就根本没有重复的代码。

例子：

```
public enum MYENUM{
  VAL1,VAL2,VAL3;
}

/** Map MYENUM to its ID */
public static final ImmutableBiMap<MYENUM, Integer> MYENUM_TO_ID = 
new ImmutableBiMap.Builder<MYENUM, Integer>().
put(MYENUM.VAL1, 1).
put(MYENUM.VAL2, 2).
put(MYENUM.VAL3, 3).
build(); 
```

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2010-05-19T15:42:13.547

在我看来，这将是最简单的方法，无需反射，也无需为您的枚举添加任何额外的包装器。

您创建一个枚举实现的接口：

```
public interface EnumWithId {

    public int getId();

} 
```

然后在一个助手类中，您只需创建一个像这样的方法：

```
public <T extends EnumWithId> T getById(Class<T> enumClass, int id) {
    T[] values = enumClass.getEnumConstants();
    if (values != null) {
        for (T enumConst : values) {
            if (enumConst.getId() == id) {
                return enumConst;
            }
        }
    }

    return null;
} 
```

然后可以像这样使用此方法：

```
MyUtil.getInstance().getById(MyEnum.class, myEnumId); 
```

# sql-server-2005 - 将 SQL2005 应用程序迁移到 SQL2008

> ID：77217
> 
> 赞同：3
> 
> 时间：2008-09-16T21:16:07.630
> 
> 标签：sql-server-2005, sql-server-2008, migration

我将很快将我们的生产 SQL2005 应用程序迁移到 SQL2008。搬家前后有什么要注意的吗？任何警告，建议？

谢谢！

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-19T01:09:33.327

将数据库移至 2008 服务器后更改数据库的兼容性级别。默认情况下，它仍将保持旧的兼容级别。这将使您可以为该数据库使用 SQL 2008 中的新功能。

如果您使用的是 SQL 2008 企业版，并且没有以 80-90% 的 CPU 运行，请打开数据压缩并压缩所有对象。这有很大的性能提升。不幸的是，您必须为每个对象手动执行此操作 - 没有一个可以抛出的开关。

如果您不使用 Enterprise，则在提高兼容性级别后，重建所有索引。（这几乎适用于任何版本升级。）

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T21:38:17.060

升级顾问也可以提供帮助。

查看数据库中包含生产数据的执行计划。

尽管我最好的建议是测试、测试、测试。

当人们从 2000 年到 2005 年开始迁移时，阻碍展示的不是破坏性功能，而是使用新优化器执行查询的方式发生了变化。

为 2000 年进行了大量优化的查询现在表现不佳甚至更糟，导致人们追逐非问题并普遍降低最终用户的信心。

# perl - 如何在 Perl 中将字符串中每个单词的首字母大写？

> ID：77226
> 
> 赞同：31
> 
> 时间：2008-09-16T21:17:00.170
> 
> 标签：perl, capitalize, title-case

将字符串中每个单词的首字母大写的最简单方法是什么？

* * *

## 回答 #1

> 赞同：52
> 
> 时间：2008-10-02T18:27:06.587

正如@brian 在评论中提到的，@piCookie 当前接受的答案是错误的！

```
$_="what's the wrong answer?";
s/\b(\w)/\U$1/g
print; 
```

这将打印“什么是错误的答案？” 注意大写错误的 S

正如[常见问题解答](http://faq.perl.org/perlfaq4.html#How_do_I_capitalize_)所说，您最好使用

```
s/([\w']+)/\u\L$1/g 
```

或 [文本::自动格式化](https://metacpan.org/module/Text::Autoformat)

* * *

## 回答 #2

> 赞同：18
> 
> 时间：2008-09-16T21:19:29.383

请参阅[常见问题解答](http://learn.perl.org/faq/perlfaq4.html#How-do-I-capitalize-all-the-words-on-one-line)。

我不相信`ucfirst()`满足 OP 的问题是将字符串中每个单词的第一个字母大写而不拆分字符串并稍后加入。

* * *

## 回答 #3

> 赞同：13
> 
> 时间：2008-09-16T21:17:52.710

看一下[ucfirst](http://perldoc.perl.org/functions/ucfirst.html)函数。

```
$line = join " ", map {ucfirst} split " ", $line; 
```

* * *

## 回答 #4

> 赞同：11
> 
> 时间：2008-10-08T10:49:54.630

```
$capitalized = join '', map { ucfirst lc $_ } split /(\s+)/, $line; 
```

通过捕获空白，将其插入列表中并用于重建原始间距。“ucfirst lc”将“teXT”大写为“Text”。

* * *

## 回答 #5

> 赞同：6
> 
> 时间：2008-09-16T22:14:12.123

```
$string =~ s/(\w+)/\u$1/g; 
```

应该可以正常工作

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2012-02-29T23:37:09.303

这仅将每行的第一个单词大写：

```
perl -ne "print (ucfirst($1)$2)  if s/^(\w)(.*)/\1\2/" file 
```

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-16T22:56:39.137

请注意，如果您的单词全部大写并且您希望它们（仅）大写，则常见问题解答解决方案不起作用。您可以制作更复杂的正则表达式，或者在应用常见问题解答解决方案之前对字符串执行 lc。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2010-02-25T14:29:00.213

您可以使用“ [Title Case](http://daringfireball.net/2008/05/title_case) ”，它是用 Perl 编写的一段非常酷的代码。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2017-11-24T16:56:27.913

试试这个 ：

```
echo "what's the wrong answer?" |perl -pe 's/^/ /; s/\s(\w+)/ \u$1/g; s/^ //' 
```

输出将是：

```
What's The Wrong Answer? 
```

* * *

## 回答 #10

> 赞同：-1
> 
> 时间：2008-09-17T02:41:36.443

map 中的[ucfirst](http://perldoc.perl.org/functions/ucfirst.html)函数当然可以做到这一点，但只是以非常基本的方式。如果您想要更复杂的东西，请查看[John Gruber 的 TitleCase 脚本](http://daringfireball.net/2008/08/title_case_update)。

# opengl - 使用 GPU 查询点 epsilon-close 到点云中的剖切面

> ID：77258
> 
> 赞同：4
> 
> 时间：2008-09-16T21:21:32.780
> 
> 标签：opengl, geometry, cloud, point

我正在尝试使用 GPU 功能解决当前的问题：“给定一个点云 P 和一个由点和法线 (Pp, Np) 描述的定向平面，返回云中距离等于或小于 EPSILON 的点从飞机上”。

与我的一位同事交谈后，我得出了以下解决方案：

1) 准备一个带有附加纹理坐标的点的顶点缓冲区，这样每个点都有不同的顶点坐标 2) 将投影状态设置为正交 3) 旋转网格，使平面的法线与 -z 轴对齐，并且偏移它使得 x,y,z=0 对应于 Pp 4) 设置 z 剪切平面使得 z:[-EPSILON;+EPSILON] 5) 渲染到纹理 6) 从显卡中检索纹理 7)从显卡读取纹理并查看渲染了哪些点（根据它们的索引），这些点是所需距离范围内的点。

现在问题如下： q1）我需要打开一个窗口框架才能进行这样的操作吗？我在 MATLAB 中工作并调用 MEX-C++。根据经验，我知道一旦你打开一个新框架，整个套装就会惨遭崩溃！q2) 为 GLPoint 提供纹理坐标的原语是什么？q3) 我不太清楚如何实现对纹理的渲染？任何参考，教程都会很棒... q4）您将如何从卡中检索此纹理？再次，任何参考，教程都会很棒......

我的日程安排很紧，因此，如果您能指出我应该学习的技术的名称，而不是像有人所做的那样指向 GLSL 规范文档和 OpenGL API，那就太好了。这些对我的问题的回答有点太模糊了。

非常感谢您的任何评论。

ps 另请注意，如果可能的话，我宁愿不使用像 CUDA 这样的任何资源，因此，在不需要我编写新着色器的情况下，获得使用尽可能多的 OpenGL 元素的东西。

注意：交叉发布在 [http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=245911#Post245911](http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=245911#Post245911)

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-17T08:35:49.133

很简单：设 n 为平面的法线，x 为点。

```
n_u = n/norm(n)         //this is a normal vector of unit length
d   = scalarprod(n,x)   //this is the distance of the plane to the origin

for each point p_i
    d_i = abs(scalarprod(p_i,n) - d)  //this is the distance of the point to the plane 
```

显然，“scalarprod”的意思是“标量积”，“abs”的意思是“绝对值”。如果您想知道为什么只阅读维基百科上有关标量产品的文章。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-18T16:03:28.830

我有一个问题要问 Andrea Tagliasacchi，为什么？

只有当您正在查看 1000 个点和可能的 100 个平面时，使用概述的方法才会有任何好处。相对于点和平面的点生成，正如我的下士 Touchy 所概述的那样。

此外，由于像素的有限性质，您经常会发现两个或更多点会投影到纹理中的同一像素。

如果您仍然想这样做，我可以在 C++ 中编写一个示例 glut 程序，但是我不知道这对 MATLAB 有什么帮助，因为我不熟悉它。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-22T19:23:51.257

IT seems to me you should be able to implement something similar to Corporal Touchy's method a a vertex program rather than in a for loop, right? Maybe use a C API to GPU programming, such as [CUDA](http://www.nvidia.com/object/cuda_what_is.html)?

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T21:50:14.443

好吧，首先作为一点免责声明：我对 3D 编程一无所知。

现在我的纯数学想法：

给定一个平面，由法线 N（单位长度）和平面到中心的距离 L（点 [0/0/0]）。点 X 到平面的距离由 N 和 X 的标量积减去 L 到中心的距离得出。因此，您只需要检查是否

|n 。x - L| <= ε

. 是标量积和 | | 绝对值

当然，您必须首先将平面与法线相交以获得距离 L。

也许这有帮助。

# c++ - operator>> 可以读取 int hex AND 十进制吗？

> ID：77266
> 
> 赞同：6
> 
> 时间：2008-09-16T21:22:34.230
> 
> 标签：c++, hex, istringstream

我可以说服`operator>>`C++ 读取一个`hex`值 AND 和一个`decimal`值吗？下面的程序演示了读取十六进制是如何出错的。我希望`istringstream`能够同时阅读`hex`和`decimal`。

```
#include <iostream>
#include <sstream>

int main(int argc, char** argv)
{
    int result = 0;
    // std::istringstream is("5"); // this works
    std::istringstream is("0x5"); // this fails

    while ( is.good() ) {
        if ( is.peek() != EOF )
            is >> result;
        else
            break;
    }

    if ( is.fail() )
        std::cout << "failed to read string" << std::endl;
    else
        std::cout << "successfully read string" << std::endl;

    std::cout << "result: " << result << std::endl;
} 
```

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2008-09-16T21:33:45.013

你需要告诉 C++ 你的基础是什么。

想要解析一个十六进制数？将“is >> result”行更改为：

```
is >> std::hex >> result; 
```

放置 std::dec 表示十进制数， std::oct 表示八进制。

* * *

## 回答 #2

> 赞同：12
> 
> 时间：2008-09-16T21:33:47.773

使用[`std::setbase(0)`](http://en.cppreference.com/w/cpp/io/manip/setbase)which 启用前缀相关解析。它将能够将`10`（dec）解析为十进制的 10，`0x10`（十六进制）解析为十进制的 16，`010`（八进制）解析为十进制的 8。

```
#include <iomanip>
is >> std::setbase(0) >> result; 
```

* * *

## 回答 #3

> 赞同：-2
> 
> 时间：2008-09-16T21:40:50.847

0x 是 C/C++ 特定的前缀。十六进制数字只是像十进制数字一样的数字。您需要检查这些字符是否存在，然后进行适当的解析。

# perl - 如何打包我的 Perl 脚本以在没有 Perl 的机器上运行？

> ID：77278
> 
> 赞同：20
> 
> 时间：2008-09-16T21:23:41.107
> 
> 标签：perl, compilation, executable, distribution

人们还经常问“我怎样才能编译 Perl？” 而他们真正想要的是创建一个可以在机器上运行的可执行文件，即使他们没有安装 Perl。

我知道有几种解决方案：

1.  [IndigoStar](http://www.indigostar.com/perl2exe.htm)的 perl2exe 是商业的。我从未尝试过。它的网站说它可以交叉编译 Win32、Linux 和 Solaris。
2.  来自 ActiveState 的[Perl 开发工具包。](http://www.activestate.com/Products/perl_dev_kit/)它是商业的。几年前我在 Windows 上使用过它，它很好地满足了我的需求。根据其网站，它可以在 Windows、Mac OS X、Linux、Solaris、AIX 和 HP-UX 上运行。
3.  [PAR](http://search.cpan.org/dist/PAR/)或者更确切地说是[PAR::Packer](http://search.cpan.org/dist/PAR-Packer/)，它是免费和开源的。根据测试报告，它适用于 Windows、Mac OS X、Linux、NetBSD 和 Solaris，但理论上它也应该适用于其他 UNIX 系统。最近我开始在 Linux 上使用 PAR 进行打包，并将在 Windows 上使用它。

其他推荐的解决方案？

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2008-09-17T07:23:28.403

除了问题中列出的三个工具之外，还有一个名为[Cava Packager](http://www.cavapackager.com/)的工具，由 Mark Dootson 编写，他过去也为[PAR](http://par.perl.org)做出过贡献。它仅在 Windows 下运行，具有漂亮的 Wx GUI，并且与典型的三个竞争者的工作方式不同，因为它将所有 Perl 依赖项组装在 source / lib 目录中，而不是创建包含所有内容的单个存档。有一个免费版本，但它不是开源的。除了测试，我没有使用过这个。

至于PAR，它确实是一个工具包。它带有一个打包工具，可以对独立的可执行文件进行依赖扫描和组装，但它也可以用来生成和使用所谓的 .par 文件，类似于 Java 的 JAR。它还带有[客户端](http://search.cpan.org/dist/PAR-Repository-Client)和[服务器](http://search.cpan.org/dist/PAR-Repository)，用于通过网络自动加载丢失的包等。我在[YAPC::EU 2008 上](http://yapceurope.org/)[的 PAR 演讲的幻灯片](http://steffen-mueller.net/talks/appdeployment/)对此进行了详细介绍。还有一个活跃的邮件列表：perl dot org 上的 par。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2011-05-21T16:06:53.897

自从第一次提出这个问题以来已经有一段时间了，但[Cava Packager](http://www.cavapackager.com/)目前可以为 Windows、Linux 和 Mac OS X 生成可执行包。它不再仅限于 Windows。

注意：如我的名字所示，我隶属于 Cava Packager。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2009-06-14T07:39:36.883

我是一个 Perl 新手，我刚刚下载了 Cava Packager，这是我发现的唯一一个工作。我已经在 Windows XP 上使用 PAR-Packager 尝试过 ActiveState 5.10.1005 和 Strawberry Perl。pp 只是挂在中流并且没有创建可执行文件。

Cava 提供了迄今为止在 Windows 上创建 exe 的唯一解决方案。谢谢。

* * *

## 回答 #4

> 赞同：-3
> 
> 时间：2008-09-16T21:29:03.667

您可以使用`perlcc`大多数 Perl 发行版附带的工具。我还发现`perl2exe`Active State 的 Perl 开发工具包对于发布 Perl 应用程序很有用。

# api-design - 您如何为您的网站设置 API 密钥系统？

> ID：77280
> 
> 赞同：19
> 
> 时间：2008-09-16T21:23:52.040
> 
> 标签：api-design

假设我有一个网站，其中包含一些可以从外部访问的信息。这些信息只需要由受人尊敬的客户更改。示例：Google Analytic 或 WordPress API 密钥。我怎样才能创建一个像这样工作的系统（无论编程语言如何）？

* * *

## 回答 #1

> 赞同：18
> 
> 时间：2008-09-16T21:28:59.453

许多聪明人正在制定一个标准，称为[OAuth](http://oauth.net/)。它已经有许多[示例实现](http://oauth.net/code)，因此很容易上手。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T21:25:06.280

简单的：

1.  为每个用户生成一个密钥
2.  拒绝没有此密钥的每个请求的访问

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T21:30:18.360

目前，我使用多个 MD5 与盐的串联。MD5 是根据用户数据的各种串联生成的。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T21:27:19.553

生成密钥的一种好方法是在数据库中的每个用户记录上存储一个 GUID（全局唯一标识符）。GUID 将是唯一的，几乎不可能猜到。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2014-09-12T18:44:01.180

还有一些基础设施服务可以为您管理所有这些，例如[http://www.3scale.net](http://www.3scale.net)（披露我在那里工作）、[http://www.mashery.com](http://www.mashery.com)和[http://www.apigee.com/](http://www.apigee.com/)。

# javascript - 无法使用模式对话框打开辅助对话框

> ID：77287
> 
> 赞同：4
> 
> 时间：2008-09-16T21:24:21.323
> 
> 标签：javascript, jquery-ui, z-index, jquery-ui-dialog, yui

我有一个`modal dialog`表单，其中包含一些“帮助链接”，它应该在其顶部打开其他非模态面板或对话框（同时保持主对话框处于模态）。

然而，这些总是隐藏在面具后面。 `YUI`似乎正在识别`z-index`那里的最高值并将掩码和模态对话框设置为高于此值。

如果我等待面板化帮助内容，那么我可以将它们设置为具有更高的 z-index。到现在为止还挺好。那么问题是次要的非模态对话框中的字段是不可聚焦的。它们下方的模态对话框似乎以某种方式阻止焦点转到不在初始模态对话框中的任何内容。

如果 YUI 根本不允许这样做，如果我可以使用 jQuery 执行此“对话框组模式”也是可以接受的。

帮助！

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-02T13:39:07.653

默认情况下，YUI 管理扩展 YAHOO.widget.Overlay 并使用覆盖面板的任何内容的 z-index。它通过 YAHOO.widget.Overlay 的“bringToTop”方法来做到这一点。您可以通过简单地将“bringToTop”方法更改为空函数来关闭它：

```
YAHOO.widget.Overlay.prototype.bringToTop = function() { }; 
```

该代码将永久关闭它，您可以将其放在 container.js 文件的底部。我发现这种方法有点像大锤方法，所以我们扩展了 YUI 类，并在调用“super.constructor”之后写入：

```
this.bringToTop = function() { }; 
```

如果你这样做，你实际上是在告诉 YUI 你将自己管理元素的 z 索引。这可能很好，但在做之前需要考虑一些事情。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-17T10:10:51.137

如果用户应该与其他元素交互，则原始对话框不能是模态的——这就是模态的定义。原始对话框*真的*需要模态吗？如果是这样，您是否尝试在打开其他元素之前切换原始对话框的模式属性？

# c++ - 在托管 C++ 中创建带有自定义按钮文本的 MessageBox 的简单方法是什么？

> ID：77293
> 
> 赞同：3
> 
> 时间：2008-09-16T21:24:44.130
> 
> 标签：c++

我想将开销保持在最低限度。现在我有：

```
// Launch a Message Box with advice to the user
DialogResult result = MessageBox::Show("This may take awhile, do you wish to continue?", "Warning", MessageBoxButtons::YesNo, MessageBoxIcon::Exclamation);

// The test will only be launched if the user has selected Yes on the Message Box
if(result == DialogResult::Yes)
{
    // Execute code
} 
```

不幸的是，我的客户更喜欢“继续”和“取消”来代替默认的“是”和“否”按钮文本。似乎应该有一个简单的方法来做到这一点。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T21:42:33.790

您可以使用“确定”和“取消”

通过`MessageBoxButtons::YesNo`替换`MessageBoxButtons::OKCancel`

[MessageBoxButtons 枚举](http://msdn.microsoft.com/en-us/library/system.windows.forms.messageboxbuttons.aspx)

除此之外，您必须创建一个新表单，因为我不相信 Enum 可以扩展。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-17T18:53:19.943

从我能找到的一切来看，[科林](https://stackoverflow.com/users/1736/corin)似乎是对的。这是我用来完成最初目标的代码。我通常不是托管 C++ 程序员，所以任何编辑都将不胜感激。

自定义消息框.h：

```
using namespace System::Windows::Forms;

/// <summary>
/// A message box for the test. Used to ensure user wishes to continue before starting the test.
/// </summary>
public ref class CustomMessageBox : Form
{
private:
    /// Used to determine which button is pressed, default action is Cancel
    static String^ Button_ID_ = "Cancel";

    // GUI Elements
    Label^ warningLabel_;
    Button^ continueButton_;
    Button^ cancelButton_;

    // Button Events
    void CustomMessageBox::btnContinue_Click(System::Object^ sender, EventArgs^ e);
    void CustomMessageBox::btnCancel_Click(System::Object^ sender, EventArgs^ e);

    // Constructor is private. CustomMessageBox should be accessed through the public ShowBox() method
    CustomMessageBox();

public:
    /// <summary>
    /// Displays the CustomMessageBox and returns a string value of "Continue" or "Cancel"
    /// </summary>
    static String^ ShowBox();
}; 
```

自定义消息框.cpp：

```
#include "StdAfx.h"
#include "CustomMessageBox.h"

using namespace System::Windows::Forms;
using namespace System::Drawing;

CustomMessageBox::CustomMessageBox()
{
    this->Size = System::Drawing::Size(420, 150);
    this->Text="Warning";
    this->AcceptButton=continueButton_;
    this->CancelButton=cancelButton_;
    this->FormBorderStyle= ::FormBorderStyle::FixedDialog;
    this->StartPosition= FormStartPosition::CenterScreen;
    this->MaximizeBox=false;
    this->MinimizeBox=false;
    this->ShowInTaskbar=false;

    // Warning Label
    warningLabel_ = gcnew Label();
    warningLabel_->Text="This may take awhile, do you wish to continue?";
    warningLabel_->Location=Point(5,5);
    warningLabel_->Size=System::Drawing::Size(400, 78);
    Controls->Add(warningLabel_);

    // Continue Button
    continueButton_ = gcnew Button();
    continueButton_->Text="Continue";
    continueButton_->Location=Point(105,87);
    continueButton_->Size=System::Drawing::Size(70,22);
    continueButton_->Click += gcnew System::EventHandler(this, &CustomMessageBox::btnContinue_Click);
    Controls->Add(continueButton_);

    // Cancel Button
    cancelButton_ = gcnew Button();
    cancelButton_->Text="Cancel";
    cancelButton_->Location=Point(237,87);
    cancelButton_->Size=System::Drawing::Size(70,22);
    cancelButton_->Click += gcnew System::EventHandler(this, &CustomMessageBox::btnCancel_Click);
    Controls->Add(cancelButton_);
}

/// <summary>
/// Displays the CustomMessageBox and returns a string value of "Continue" or "Cancel", depending on the button
/// clicked.
/// </summary>
String^ CustomMessageBox::ShowBox()
{
    CustomMessageBox^ box = gcnew CustomMessageBox();
    box->ShowDialog();

    return Button_ID_;
}

/// <summary>
/// Event handler: When the Continue button is clicked, set the Button_ID_ value and close the CustomMessageBox.
/// </summary>
/// <param name="sender">The source of the event.</param>
/// <param name="e">The <see cref="System.EventArgs"/> instance containing the event data.</param>
void CustomMessageBox::btnContinue_Click(System::Object^ sender, EventArgs^ e)
{
    Button_ID_ = "Continue";
    this->Close();
}

/// <summary>
/// Event handler: When the Cancel button is clicked, set the Button_ID_ value and close the CustomMessageBox.
/// </summary>
/// <param name="sender">The source of the event.</param>
/// <param name="e">The <see cref="System.EventArgs"/> instance containing the event data.</param>
void CustomMessageBox::btnCancel_Click(System::Object^ sender, EventArgs^ e)
{
    Button_ID_ = "Cancel";
    this->Close();
} 
```

最后是对原代码的修改：

```
// Launch a Message Box with advice to the user
String^ result = CustomMessageBox::ShowBox();

// The test will only be launched if the user has selected Continue on the Message Box
if(result == "Continue")
{
    // Execute Code
} 
```

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2012-11-16T00:43:56.190

更改消息如下。这可能是我认为最简单的方法。

```
DialogResult result = MessageBox::Show(
       "This may take awhile, do you wish to continue?**\nClick Yes to continue.\nClick No to cancel.**",
       "Warning",
       MessageBoxButtons::YesNo,
       MessageBoxIcon::Exclamation
); 
```

# validation - Infopath 2007 - 如何仅对当前视图执行数据验证？

> ID：77317
> 
> 赞同：2
> 
> 时间：2008-09-16T21:27:38.070
> 
> 标签：validation, views, infopath, office-2007

我有一个正在开发的 infopath 2007 表单，它使用 3 个不同的视图。
这 3 个不同的视图基本上是相同的表单，但显示的文本框不同，具体取决于用户选择的按钮。我遇到了一个问题，“视图 1”有一些表单验证，但用户选择了“视图 2”并提交它。'view 1' 的表单验证被触发，用户无法提交表单。如果用户当前正在提交“视图 2”，我如何忽略“视图 1”上的表单验证？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-17T15:55:58.873

而不是勾选标准的“此字段不能为空”复选框（例如），您需要使用数据验证规则。假设您有两个视图，每个视图中都有一个不能为空的文本框，但您只想强制执行当前视图。这是表单的结构：

领域：

*   currentView（数字）（默认 = 1）
*   text1（文本） text2（文本）
*   按钮1
*   按钮2

查看 1（默认）

text1 - 规则：如果（currentView = 1 AND text1 为空白）显示“不能为空白”

button1 - 动作：设置字段值（currentView = 2）；切换视图（到 2 个）

视图 2：

text2 - 规则：如果（currentView = 2 AND text2 为空白）显示“不能为空白”

button2 - 动作：设置字段值（currentView = 1）；切换视图（至 1）

有道理？

奥辛

# xml - 为什么 XSLT 从未见过在互联网繁荣时期出现的许多其他语言的流行？

> ID：77342
> 
> 赞同：13
> 
> 时间：2008-09-16T21:31:06.377
> 
> 标签：xml, xslt

XSLT（XML 样式表语言转换）的使用从未像互联网繁荣期间出现的许多其他语言一样流行。虽然它在使用，并且在某些情况下被大型成功公司（例如暴雪娱乐）使用，但它似乎从未成为主流。你为什么认为这是？

* * *

## 回答 #1

> 赞同：26
> 
> 时间：2008-09-16T21:54:31.110

一个问题是 XSLT*看起来很*复杂。任何开发人员都应该能够掌握语言结构，因为在大多数其他语言中都有类似物。问题是结构和数据看起来都完全相同，这使得很难区分两者，这使得 XSLT 比其他语言更难阅读。

第二个问题是它的用途比其他语言更有限。XSLT 擅长它的功能；对 XML 进行复杂或激进的转换。但它不像其他语言那样适用于广泛的问题，所以它的使用并不多。

第三，许多编程语言都有自己的用于转换 XML 的库。在使用 XML 的大部分时间，只需要进行小的更改或查找。XML 也可能由开发人员已经用另一种语言编写的程序生成或使用。这些因素意味着使用语言的内置实用程序更加方便。

所有这些问题导致的另一个问题是惯性。也就是说，人们不知道它，他们没有看到他们有太多需要它，所以如果有其他选择，他们会避免它作为解决方案。

您最终得到的是一种语言，它是许多开发人员在创建解决方案时的最后选择。XSLT 很可能会被避免，因为它最终会成为这项工作的最佳工具。

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2008-09-16T21:41:40.297

XSLT 使用函数式编程——这是大多数程序员不习惯的（因此我猜为什么有些人认为它不直观）。

* * *

## 回答 #3

> 赞同：7
> 
> 时间：2008-10-20T22:27:26.357

在我看来，标准 XSLT（我说的是 XSLT 1.0，因为这是我使用的唯一版本）中最烦人的事情之一是它缺乏对字符串转换和一些基本日期时间函数操作的支持。

我永远无法理解的一件事是为什么诸如 translate() 之类的函数被设计并实现到 xpath 中，而其他更有用的函数（例如*replace*、*to_lower*、*to_upper ，*或者 - 让我们疯狂一下 - 正则表达式却没有。

我猜这些问题中的一些问题是用[eXSLT](http://www.exslt.org/)（扩展的xslt？）解决了微软的MSXML以外的解析器。我说我猜是因为我实际上从未使用过它，因为它被声明为与 MSXML 不兼容。

我不明白为什么 XSLT 1.0 是按照“文本”操作不在语言范围内的原则设计的，因为很明显，无论何时转换文件都无法避免那些字符串转换问题（例如：转换以法语格式以美国格式给出的不规则填充日期，2008 年 1 月 1 日至 2008 年 1 月 31 日）呵呵...

这些文本操作问题通常是非常基本的，并且可以通过允许使用 JScript 函数扩展 XSL 在 MSXML 中轻松解决：您可以调用 JScript 函数来执行一些处理，就像调用任何 XSL 模板一样，但我总是发现该解决方案不优雅且最终创建了我自己的 XSL 模板库。首先是因为 JScript 方式破坏了您的 XSL 可移植性，然后是因为它迫使您将编程逻辑混合在一起：纯 XPath/XSLT 表达式中的一些位和 DOM/对象表示法中的其他位与 JScript。

没有可更新的变量是另一个让新手非常困惑的限制，有些人只是没有克服这一点并一直在努力解决这个问题。在一些简单的情况下，您可以使用参数化模板和递归调用（例如实现递增或递减计数器）的混合解决方法，但让我们面对现实吧，递归并不是那么自然。

我想我听说所有这些限制都在 XSLT 2.0 规范中得到解决，遗憾的是 MS 决定不实现它，而是推广 XQuery。这很可悲，为什么不同时实现它们呢？我认为 XSLT 仍然很有可能像 CSS 对 HTML 一样流行。仔细想想，学习 XSLT 最难的部分就是 XPath，其余的都不如理解 CSS 中的级联行为那么难，而且 CSS 变得如此流行……

因此，在我看来，正是这里提到的所有这些小东西的缺失以及在 XSLT 2.0 中处理它们所花费的时间（甚至连 MS 都不支持它）导致了这种不受欢迎的情况。我多么希望MS最终决定实施它......

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-09-16T21:36:29.170

因为大多数 XSLT 实现都有很高的内存占用（我想这是由语言的设计造成的），因为人们倾向于滥用 XSLT 来处理它并不特别适合的各种事情以及 XSL 的纯声明性质这使得某些类型的转换非常困难。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2008-09-16T21:39:33.143

它对 xml 很好，但对典型的编码来说不是很好。它缺乏典型的基本概念（即可变变量）并使应该简单的事情变得相当复杂（或不可能）。它的大部分问题源于这样一个事实，即 xml 是一种出色的数据表示语言，但不是一种出色的编程语言。话虽如此，我每天都使用它，并会在有意义的地方推荐它。结合外部命名空间，它可以变得更有用（调用 java 等）。最后，它是另一种需要学习的语言，许多程序员更愿意坚持使用他们习惯或类似于他们习惯的东西。

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2008-09-16T21:47:36.710

因为编写和维护使用 Java、C#、JavaScript 等反序列化 XML 流、对其进行转换和导出所需输出的代码更容易，而 XSLT 并没有提供实质性的性能优势。

XSLT 使某些事情变得容易，但它使其他事情变得非常非常困难。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-16T21:34:04.887

XSL 是主流并被广泛采用。你指的是什么其他语言？XSL 不是一种编程语言，**只是一种转换语言**，因此它的范围非常有限。

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2008-09-16T21:35:07.803

嗯……也许是因为写 xslt 很痛苦……几个月前我不得不写几个 xslt，我梦想着尖括号……

```
<Really> 
    <No>
        <fun/>
    </No>
</Really> 
```

（我知道，这不是 xslt）

* * *

## 回答 #9

> 赞同：3
> 
> 时间：2008-09-16T21:37:14.147

通常，您需要将 XML 数据转换为不同形式的 XML 数据但不对其进行任何其他处理的时间将非常有限。通常 XML 用作两个独立系统之间的中介，其中一个通常是定制的以处理另一个系统的输出。因此，只需编写一个系统来处理另一个系统的 XML 输出就更简单了，而无需执行某种转换的额外步骤。

* * *

## 回答 #10

> 赞同：3
> 
> 时间：2008-10-17T04:54:01.070

如前所述，XSLT（就像 JavaScript 的“优点”）是一种函数式编程语言。大多数传统程序员讨厌这种无国籍状态。还有太多的传统程序员讨厌尖括号。

但是，最重要的是，正确使用 XSLT 以一种与平台无关的方式解决了 Web 服务器的声明式 GUI 生成和数据绑定问题。像微软这样的供应商没有动力去庆祝这种“不方便”的力量。

但是，我认为 Microsoft 对 IDE (Visual Studio)*拥有世界上最好的 XSLT 支持。*

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2008-09-16T21:48:35.913

我认为归结为 XML 语法对于描述数据可以说是很好的，但对于本质上是一种编程语言 (XSLT) 来说，它并不是一个很好的语法。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2008-09-16T21:44:25.750

我认为它试图涵盖太多用例，从而成为图灵完备的（或者我听说过的）语言。如果您尝试进行任何重要的转换，您最终会用一种丑陋而冗长的语言编写复杂的循环、条件……最好使用 GPL 来完成。

在我看来，这种复杂性使得编写正确的 XSLT 实现变得困难，并且限制了可用的选择，因此，在经常喜欢修改小而高效的代码而不是企业代码的大声黑客中广泛使用。

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2008-09-16T21:46:49.427

XSLT 非常强大，但需要以不同的方式思考问题。由于在早期版本中没有提供有用的数据功能，它也给自己带来了麻烦。以 ToUpper() 样式方法为例，您通常使用以下方式实现它：

```
<xsl:variable name="lcletters">abcdefghijklmnopqrstuvwxyz</xsl:variable>
<xsl:variable name="ucletters">ABCDEFGHIJKLMNOPQRSTUVWXYZ</xsl:variable>  

<xsl:value-of select="translate($toconvert,$lcletters,$ucletters)"/> 
```

不是最简单的编码方式！

* * *

## 回答 #14

> 赞同：1
> 
> 时间：2008-09-16T21:58:28.137

当您拥有已经转义的数据以及输入和输出的明确定义时，xslt 非常适合 xml 到 xml。对我来说，将它用于 xml2html 之类的东西似乎让人头疼，而且几乎任何动态语言和 css 的输出都更容易用样式实现。

* * *

## 回答 #15

> 赞同：1
> 
> 时间：2010-09-21T13:53:43.767

我发现它非常适合“复合 Web 服务架构”。有时许多 Web 服务协同工作以获得最终输出。当这些 Web 服务需要通过 XML 在它们之间进行通信时，XSLT 可以将 xml 消息从一种形式转换为另一种形式。

# arrays - 扩展/合并 VB 数组

> ID：77382
> 
> 赞同：1
> 
> 时间：2008-09-16T21:35:31.187
> 
> 标签：arrays, vba, concatenation

我有一个带有公共字节数组的类。让我们说它

```
Public myBuff as byte() 
```

类中的事件获取字节数组中的数据块。我如何告诉事件代码将 get 块放在最后？让我们说

```
Private Sub GetChunk
  Dim chunk as byte
  '... get stuff in chunk
  Me.myBuff += chunk '(stick chunk on end of public array)
End sub 
```

还是我完全错过了重点？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T22:42:18.827

如果数组很小，并且很少添加新数据，那么一种简单的方法是：

```
public BufferSize as long 'or you can just use Ubound(mybuff), I prefer a tracker var tho
public MyBuff

private sub GetChunk()
dim chunk as byte
'get stuff
BufferSize=BufferSize+1

redim preserve MyBuff(buffersize)
mybuff(buffersize) = chunk
end sub 
```

如果 chunk 是一个字节数组，它看起来更像：

```
buffersize=buffersize+ubound(chunk) 'or if it's a fixed-size chunk, just use that number
redim preserve mybuff(buffersize)
for k%=0 to ubound(chunk) 'copy new information to buffersize
  mybuff(k%+buffersize-ubound(chunk))=chunk(k%)
next 
```

如果您经常这样做（例如，每秒多次），您会想要执行类似于 StringBuilder 类的工作方式的操作：

```
public BufSize&,BufAlloc& 'initialize bufalloc to 1 or a number >= bufsize
public MyBuff() as byte

sub getdata()
bufsize=bufsize+ubound(chunk)
if bufsize>bufalloc then
  bufalloc=bufalloc*2
  redim preserve mybuff(bufalloc)
end if
for k%=0 to ubound(chunk) 'copy new information to buffersize
  mybuff(k%+bufsize-ubound(chunk))=chunk(k%)
next
end sub 
```

每次指针通过缓冲区的末尾时，基本上都会将分配给 mybuf 的内存加倍。这意味着更少的内存洗牌。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T21:36:43.383

如果我没记错的话，在vb中你想用preserve来redim来增长一个数组。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T21:37:55.533

您将不断使用 ReDim 关键字，这是*非常*低效的。

你在使用.Net吗？如果是这样，请考虑改用 System.Collections.Generic.List(Of Byte)。你可以使用它的 .AddRange() 方法来追加你的字节，如果你真的需要一个数组，它的 .ToArray() 方法可以取出一个数组。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T21:38:06.577

你的问题似乎不是很清楚。您可能不应该公开字节数组。它可能应该是私有的，并且您应该提供一组公共函数，允许该类的用户对数组执行操作。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T21:41:37.817

我认为您可能正在寻找除数组之外的其他东西。如果您试图频繁地逐步扩展数据量，则应使用动态数据结构，例如`ArrayList`. 这有一个`Add`方法可以将特定对象或值添加到数组中，而不用担心空间。它还有一个`ToArray()`你可以使用的漂亮方法。

如果您出于特定原因（我猜是性能）尝试使用数组，请使用`ReDim Preserve array(newSize)`.

# java - 如何在运行时实例化给定数组类型的 Java 数组？

> ID：77387
> 
> 赞同：20
> 
> 时间：2008-09-16T21:36:10.500
> 
> 标签：java, arrays, collections

在 Java 集合框架中，Collection 接口声明了以下方法：

> [`<T> T[] toArray(T[] a)`](http://java.sun.com/javase/6/docs/api/java/util/Collection.html#toArray(T%5B%5D))
> 
> 返回一个包含此集合中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。如果集合适合指定的数组，则在其中返回。否则，将使用指定数组的运行时类型和此集合的大小分配一个新数组。

如果你想实现这个方法，你将如何创建一个只有在运行时才知道的**a类型的数组？**

* * *

## 回答 #1

> 赞同：34
> 
> 时间：2008-09-16T21:44:12.320

使用静态方法

```
java.lang.reflect.Array.newInstance(Class<?> componentType, int length) 
```

可以在此处找到有关其使用的教程：http: [//java.sun.com/docs/books/tutorial/reflect/special/arrayInstance.html](http://java.sun.com/docs/books/tutorial/reflect/special/arrayInstance.html)

* * *

## 回答 #2

> 赞同：20
> 
> 时间：2008-09-16T21:39:47.807

通过查看 ArrayList 是如何做到的：

```
public <T> T[] toArray(T[] a) {
    if (a.length < size)
        a = (T[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size);
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length > size)
        a[size] = null;
    return a;
} 
```

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-16T21:39:29.243

```
Array.newInstance(Class componentType, int length) 
```

* * *

## 回答 #4

> 赞同：-1
> 
> 时间：2008-09-16T21:44:45.673

要创建一个泛型类型的新数组（仅在运行时知道），您必须创建一个对象数组并将其简单地转换为泛型类型，然后按原样使用它。这是 Java 的泛型实现的限制（擦除）。

```
T[] newArray = (T[]) new Object[X]; // where X is the number of elements you want. 
```

然后该函数获取给定的数组 (a) 并使用它（事先检查它的大小）或创建一个新数组。

# ejb - 有什么好的开源负载/压力工具来测试 EJB？

> ID：77407
> 
> 赞同：0
> 
> 时间：2008-09-16T21:38:07.560
> 
> 标签：ejb, load-testing, stress-testing

我遇到过许多商业产品，但没有开源。

我意识到你可以用 JUnit / JMeter 做一些类似的事情，但我正在寻找更具体的东西。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2012-11-26T20:11:56.327

那么 clif [http://clif.ow2.org/](http://clif.ow2.org/)

或 jmeter [http://jmeter.apache.org/](http://jmeter.apache.org/)

我认为还有其他人，但这两个突然出现在我的脑海中。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T21:45:39.040

你可能想看看[Apache Jakarta Cactus](http://jakarta.apache.org/cactus/)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2009-10-06T15:32:36.217

Jmeter + 服务器日志记录 + 你的大脑。

* * *

## 回答 #4

> 赞同：-2
> 
> 时间：2008-09-17T21:08:55.440

负载测试是一项非常复杂的活动。您需要能够模拟许多上下文（例如，IP、端口）并在许多机器上划分负载生成器。这样做时，您需要监视服务器（被测应用程序）。

到今天为止，有几个非常好的商业工具需要一定程度的专业知识才能使用。我不认为有任何严肃的开源负载测试工具。

# ria - 处理站点的 RIA 版本和普通旧 HTML 版本之间的 URL 映射的最佳方法是什么？

> ID：77428
> 
> 赞同：2
> 
> 时间：2008-09-16T21:39:36.217
> 
> 标签：ria

因此，如果您有 RIA 版本（Silverlight 或 Flash）和标准 HTML 版本（甚至 AJAX），您是否应该为两者使用相同的 URL，或者是否可以为 RIA 应用程序设置不同的 URL 并相应地重定向？

因此，例如，如果您有一个网站 ( [http://example.com](http://example.com) )，是否可以将 RIA 应用程序的 about 页面 URL 设为[http://example.com/#/about](http://example.com/#/about)并将 html 设为[http ://example.com/about](http://example.com/about)？有关系吗？

当然，如果您采用不同 URL 的路线，则需要在它们之间进行映射。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T21:41:04.230

使用 2 种不同的链接格式是完全可以接受的。如果 2 个用户没有看到相同的内容，为什么他们应该使用相同的 URL。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T23:34:43.100

您页面的 URL 表示内容的身份。在我看来，如果内容相同但呈现方式不同（即 RIA 与 HTML），那么 URL 应该相同，您应该使用其他机制在不同的呈现形式之间进行选择。其他机制的选择包括 cookie、内容协商、会话标识符，或者，如果您的用户已被识别，则还包括持久的用户偏好模型。即使使用 URL 参数至少会保持 URL 的根一致（例如`http://your.si.te/foobar`vs. `http://your.si.te/foobar?view=plain`）

如果两个演示文稿的内容以某种有意义的方式不同，那么您应该在 URL 中使该差异有意义。在我看来，利用 # 的存在或不存在以及其他此类黑客行为将是一个错误。

尝试选择不随时间变化的 URL：所谓的[酷 URL](http://www.w3.org/Provider/Style/URI "很酷的网址")。这将有助于您的网站对您的用户的长期有用性：考虑如果他们在一年后回到书签页面会发生什么。一致性还将帮助您在[del.icio.us](http://del.icio.us)和类似的书签/评论网站中获得更好的关键链接或评论。

伊恩

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T23:12:41.123

我想我在这里真正需要的不是问题/答案格式，而是某种民意调查。虽然我同意（并接受）因为他们对同一内容有两种不同的看法，所以不同的 url 是可以的，但我想更多地分享这些 url。

感谢您的回复！

# javascript - 什么是好的 JavaScript 插件颜色选择器？

> ID：77431
> 
> 赞同：11
> 
> 时间：2008-09-16T21:40:15.403
> 
> 标签：javascript, color-picker

我制作了很多 Web 应用程序，有时我需要一个颜色选择器。什么是我可以像 API 一样使用并且不需要大量代码来插入的？我还需要它在所有浏览器中工作。

* * *

## 回答 #1

> 赞同：13
> 
> 时间：2008-09-16T21:43:08.407

[Farbtastic](http://acko.net/dev/farbtastic)是一个不错的 jQuery 颜色选择器

但显然在 IE6 中不起作用

[这](http://www.eyecon.ro/colorpicker/#about)是另一个看起来不错的 jQuery 颜色选择器，但不确定它的兼容性。

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2010-09-12T17:20:58.520

我最喜欢[jscolor](http://jscolor.com/try.php)，轻巧且有很多选择。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-16T21:44:22.303

我没有亲自实现这个，但我听说过它的好消息，它似乎是一个很棒的脚本：http: [//johndyer.name/post/2007/09/PhotoShop-like-JavaScript-Color-Picker。 aspx](http://johndyer.name/post/2007/09/PhotoShop-like-JavaScript-Color-Picker.aspx)

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2009-04-13T14:34:13.250

如果您使用原型和 script.aculo.us 这个很棒：

[http://code.google.com/p/colorpickerjs/](http://code.google.com/p/colorpickerjs/)

# r - 如何访问向量中的最后一个值？

> ID：77434
> 
> 赞同：335
> 
> 时间：2008-09-16T21:40:29.927
> 
> 标签：r, dataframe, vector

假设我有一个向量嵌套在一个或两个级别的数据框中。是否有一种快速而肮脏的方式来访问最后一个值，而不使用该`length()`函数？有什么 ala PERL 的`$#`特殊变量？

所以我想要类似的东西：

```
dat$vec1$vec2[$#] 
```

代替

```
dat$vec1$vec2[length(dat$vec1$vec2)] 
```

* * *

## 回答 #1

> 赞同：449
> 
> 时间：2008-09-17T13:32:45.113

I use the `tail` function:

```
tail(vector, n=1) 
```

The nice thing with `tail` is that it works on dataframes too, unlike the `x[length(x)]` idiom.

* * *

## 回答 #2

> 赞同：259
> 
> 时间：2016-05-15T12:39:46.470

为了回答这个问题，不是从美学角度而是从性能导向的角度来看，我将上述所有建议都放在了一个**基准测试**中。确切地说，我已经考虑了这些建议

*   `x[length(x)]`
*   `mylast(x)`, 其中`mylast`是通过 Rcpp 实现的 C++ 函数,
*   `tail(x, n=1)`
*   `dplyr::last(x)`
*   `x[end(x)[1]]]`
*   `rev(x)[1]`

并将它们应用于各种大小（10^3、10^4、10^5、10^6 和 10^7）的随机向量。在我们查看这些数字之前，我认为应该清楚的是，任何随着输入大小变得明显变慢的东西（即任何不是 O(1) 的东西）都不是一种选择。这是我使用的代码：

```
Rcpp::cppFunction('double mylast(NumericVector x) { int n = x.size(); return x[n-1]; }')
options(width=100)
for (n in c(1e3,1e4,1e5,1e6,1e7)) {
  x <- runif(n);
  print(microbenchmark::microbenchmark(x[length(x)],
                                       mylast(x),
                                       tail(x, n=1),
                                       dplyr::last(x),
                                       x[end(x)[1]],
                                       rev(x)[1]))} 
```

它给了我

```
Unit: nanoseconds
           expr   min      lq     mean  median      uq   max neval
   x[length(x)]   171   291.5   388.91   337.5   390.0  3233   100
      mylast(x)  1291  1832.0  2329.11  2063.0  2276.0 19053   100
 tail(x, n = 1)  7718  9589.5 11236.27 10683.0 12149.0 32711   100
 dplyr::last(x) 16341 19049.5 22080.23 21673.0 23485.5 70047   100
   x[end(x)[1]]  7688 10434.0 13288.05 11889.5 13166.5 78536   100
      rev(x)[1]  7829  8951.5 10995.59  9883.0 10890.0 45763   100
Unit: nanoseconds
           expr   min      lq     mean  median      uq    max neval
   x[length(x)]   204   323.0   475.76   386.5   459.5   6029   100
      mylast(x)  1469  2102.5  2708.50  2462.0  2995.0   9723   100
 tail(x, n = 1)  7671  9504.5 12470.82 10986.5 12748.0  62320   100
 dplyr::last(x) 15703 19933.5 26352.66 22469.5 25356.5 126314   100
   x[end(x)[1]] 13766 18800.5 27137.17 21677.5 26207.5  95982   100
      rev(x)[1] 52785 58624.0 78640.93 60213.0 72778.0 851113   100
Unit: nanoseconds
           expr     min        lq       mean    median        uq     max neval
   x[length(x)]     214     346.0     583.40     529.5     720.0    1512   100
      mylast(x)    1393    2126.0    4872.60    4905.5    7338.0    9806   100
 tail(x, n = 1)    8343   10384.0   19558.05   18121.0   25417.0   69608   100
 dplyr::last(x)   16065   22960.0   36671.13   37212.0   48071.5   75946   100
   x[end(x)[1]]  360176  404965.5  432528.84  424798.0  450996.0  710501   100
      rev(x)[1] 1060547 1140149.0 1189297.38 1180997.5 1225849.0 1383479   100
Unit: nanoseconds
           expr     min        lq        mean    median         uq      max neval
   x[length(x)]     327     584.0     1150.75     996.5     1652.5     3974   100
      mylast(x)    2060    3128.5     7541.51    8899.0     9958.0    16175   100
 tail(x, n = 1)   10484   16936.0    30250.11   34030.0    39355.0    52689   100
 dplyr::last(x)   19133   47444.5    55280.09   61205.5    66312.5   105851   100
   x[end(x)[1]] 1110956 2298408.0  3670360.45 2334753.0  4475915.0 19235341   100
      rev(x)[1] 6536063 7969103.0 11004418.46 9973664.5 12340089.5 28447454   100
Unit: nanoseconds
           expr      min         lq         mean      median          uq       max neval
   x[length(x)]      327      722.0      1644.16      1133.5      2055.5     13724   100
      mylast(x)     1962     3727.5      9578.21      9951.5     12887.5     41773   100
 tail(x, n = 1)     9829    21038.0     36623.67     43710.0     48883.0     66289   100
 dplyr::last(x)    21832    35269.0     60523.40     63726.0     75539.5    200064   100
   x[end(x)[1]] 21008128 23004594.5  37356132.43  30006737.0  47839917.0 105430564   100
      rev(x)[1] 74317382 92985054.0 108618154.55 102328667.5 112443834.0 187925942   100 
```

这立即排除了任何涉及`rev`或`end`因为它们显然不是`O(1)`（并且结果表达式以非惰性方式评估）。`tail`and`dplyr::last`距离不远，`O(1)`但它们也比`mylast(x)`and慢得多`x[length(x)]`。由于`mylast(x)`比它慢`x[length(x)]`并且没有任何好处（相反，它是自定义的并且不能优雅地处理空向量），我认为答案很明确：**请使用`x[length(x)]`**.

* * *

## 回答 #3

> 赞同：133
> 
> 时间：2008-09-17T13:27:17.140

If you're looking for something as nice as Python's x[-1] notation, I think you're out of luck. The standard idiom is

```
x[length(x)] 
```

but it's easy enough to write a function to do this:

```
last <- function(x) { return( x[length(x)] ) } 
```

This missing feature in R annoys me too!

* * *

## 回答 #4

> 赞同：52
> 
> 时间：2008-09-30T16:28:14.767

结合[lindelof](https://stackoverflow.com/a/83222/10221765)和[Gregg Lind 的](https://stackoverflow.com/a/83162/10221765)想法：

```
last <- function(x) { tail(x, n = 1) } 
```

在提示符下工作，我通常省略`n=`, ie `tail(x, 1)`。

与`last`from`pastecs`包不同，`head`并且`tail`(from `utils`) 不仅适用于向量，还适用于数据帧等，并且还可以“*没有第一个/最后 n 个元素*”返回数据，例如

```
but.last <- function(x) { head(x, n = -1) } 
```

（请注意，您必须为此使用`head`，而不是`tail`。）

* * *

## 回答 #5

> 赞同：21
> 
> 时间：2016-06-07T18:51:23.730

dplyr[包](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)包含一个功能`last()`：

```
last(mtcars$mpg)
# [1] 21.4 
```

* * *

## 回答 #6

> 赞同：19
> 
> 时间：2014-05-13T18:20:29.347

我刚刚使用以下代码在具有 663,552 行的数据帧上对这两种方法进行了基准测试：

```
system.time(
  resultsByLevel$subject <- sapply(resultsByLevel$variable, function(x) {
    s <- strsplit(x, ".", fixed=TRUE)[[1]]
    s[length(s)]
  })
  )

 user  system elapsed 
  3.722   0.000   3.594 
```

和

```
system.time(
  resultsByLevel$subject <- sapply(resultsByLevel$variable, function(x) {
    s <- strsplit(x, ".", fixed=TRUE)[[1]]
    tail(s, n=1)
  })
  )

   user  system elapsed 
 28.174   0.000  27.662 
```

因此，假设您正在使用向量，访问长度位置的速度要快得多。

* * *

## 回答 #7

> 赞同：12
> 
> 时间：2014-02-11T15:36:09.940

另一种方法是取反向向量的第一个元素：

```
rev(dat$vect1$vec2)[1] 
```

* * *

## 回答 #8

> 赞同：11
> 
> 时间：2015-01-16T20:35:49.843

我有另一种查找向量中最后一个元素的方法。说向量是`a`。

```
> a<-c(1:100,555)
> end(a)      #Gives indices of last and first positions
[1] 101   1
> a[end(a)[1]]   #Gives last element in a vector
[1] 555 
```

给你！

* * *

## 回答 #9

> 赞同：11
> 
> 时间：2016-06-07T18:42:49.653

包`data.table`内含`last`功能

```
library(data.table)
last(c(1:10))
# [1] 10 
```

* * *

## 回答 #10

> 赞同：8
> 
> 时间：2015-09-10T19:42:18.630

关于什么

```
> a <- c(1:100,555)
> a[NROW(a)]
[1] 555 
```

* * *

## 回答 #11

> 赞同：3
> 
> 时间：2017-05-03T12:51:58.810

xts 包提供了一个`last`功能：

```
library(xts)
a <- 1:100
last(a)
[1] 100 
```

# java - Ant无法删除Windows上的某些文件

> ID：77436
> 
> 赞同：23
> 
> 时间：2008-09-16T21:40:43.560
> 
> 标签：java, windows, ant, build-automation

我有一个创建目录、调用 javac 和所有常规内容的 ant 构建。我遇到的问题是，当我尝试清理（删除所有生成的东西）时，删除任务报告无法删除某些文件。当我尝试手动删除它们时，它工作得很好。这些文件显然没有被任何其他进程打开，但 ant 仍然无法删除它们。我能做些什么？

* * *

## 回答 #1

> 赞同：15
> 
> 时间：2008-09-17T08:47:56.063

我曾经遇到过这个问题。这是因为我试图删除的文件是另一个任务的**类路径的一部分。**

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2008-09-16T21:50:42.773

这取决于 ...

*   Ant 进程没有足够的权限来删除文件（通常是因为它们是由不同的用户创建的，可能是系统用户）。尝试使用 Run As 以管理用户身份运行 Ant 脚本。
*   当进程死亡或被杀死时，Windows 在清理文件锁方面真的很糟糕；因此，Windows 认为文件被一个已死（或被杀死）的进程锁定。在这种情况下，除了重新启动之外，您无能为力。
*   获得更好的工具来检查您的系统状态。我建议下载[SysInternals](http://technet.microsoft.com/en-us/sysinternals/default.aspx)工具并使用它们而不是默认的 Windows 等效工具。

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2012-08-20T06:16:11.973

使用 Ant Retry 任务对我有帮助。我刚刚将它包裹在删除任务周围。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T21:45:52.970

您不会说您的构建是否以当前登录的用户身份运行。如果没有，explorer.exe 或其他进程具有显示的目录这一​​事实也可能导致它被锁定。但是在同一个 explorer.exe 进程中删除它会成功。[从http://ccollomb.free.fr/unlocker/](http://ccollomb.free.fr/unlocker/)尝试 Unlocker ，查看哪些进程锁定了文件/目录。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-16T21:47:11.643

Ant 进程中是否存在保持文件（或目录）打开的内容？这将导致您可以在运行 ant 后删除它们，但不能在运行期间删除它们。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2014-05-28T10:50:05.907

我遇到了同样的问题。
我的机器上没有设置任何类路径或运行防病毒软件。
但是，我使用的 ANT 版本是 32 位的，而我安装的 JDK 是 64 位的。
我安装了 32 位 JDK，问题得到解决。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2012-03-05T12:47:22.433

Ant 1.8.0 之前的版本有一个错误，会导致删除操作期间出现随机错误。尝试使用 Ant 1.8.0 或更新版本。

您可以在此处查看错误详细信息[https://issues.apache.org/bugzilla/show_bug.cgi?id=45960](https://issues.apache.org/bugzilla/show_bug.cgi?id=45960)

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2014-09-03T10:50:42.047

就我而言，我的 ant clean 从 Eclipse 失败，无法删除构建文件。我不时看到这个。通常在重复尝试时会成功。这次没有。尝试从命令行运行 ant clean，失败无法删除“无法删除”。一定是 Eclipse 保留了问题文件，当我退出 Eclipse 时，cmd 行能够删除 OK。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2013-06-27T19:33:03.840

我最近经常遇到这个问题，而且是随机的。一次有效，下一次无效。我正在使用 NetBeans（以防万一），并且在 build.xml 中添加了许多额外的任务。我在 -post-jar 任务中遇到了这个问题。当我在文件上调用 unjar 然后删除时会发生这种情况。我怀疑 NB 正在尝试扫描 jar，这会导致它被锁定。

对我有用的是立即在 -post-jar 开头重命名 jar 并为其添加 .tmp 扩展名。然后我在临时文件上调用 unjar 。完成后，我将重命名为所需的 jar 名称。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2013-07-16T11:50:21.030

我也有同样的问题，并尝试手动删除构建目录。最后，我通过将项目的 .jar 工件重命名为与项目名称本身不同的名称来解决它。例如：我的项目是门户，我的 ant 构建脚本用于生成 portal.jar，其中 eclipse ant 无法删除此 portal.jar。当我更改我的 build.xml 以将我的 .jar 生成为 portalnew.jar 时，eclipse 下次能够删除这个 portalnew.jar。希望这可以帮助。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2014-12-02T09:34:11.093

您需要在 Windows 中手动删除它。它对我有用。（一般要删除的文件都是旧版本的jar。例如：如果存在httpcore.4.2.5.ja5r和httpcore.4.3.jar，会尝试删除4.2.5.jar）

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2017-07-26T06:41:31.057

我遇到了这个问题，因为蚂蚁试图删除的文件正被其他一些服务/进程使用。我停止了服务，然后 ant 构建脚本确实运行了。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2018-03-09T11:11:34.793

就我而言，我停止从任务管理器运行 Java 进程并重新运行 Ant 构建文件。该文件能够删除并且构建成功。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2018-11-07T11:04:13.617

自从我切换到 Microsoft Windows 10 后，我经常看到这样的问题。在删除文件之前立即重命名它为我解决了这个问题：

```
<rename src="file.name" dest="file.name.old"/>
<delete file="file.name.old" /> 
```

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2021-10-04T05:46:45.237

对我来说，我使用的是 mac，所以我在 ant cmd 之前尝试了 sudo，`sudo ant clean all`它确实工作得很好。

正如我所读到的，javac 将无权删除 JAR 文件，因此您可以使用 sudo 或找到替代方法。

# database - 数据库备份/恢复过程

> ID：77473
> 
> 赞同：7
> 
> 时间：2008-09-16T21:44:04.567
> 
> 标签：database, backup, restore

大型数据库或 sql server 上的数据库集合的备份和恢复过程对于灾难和恢复目的非常重要。但是，我还没有找到一个健壮的解决方案来保证整个过程尽可能高效、100% 可靠、易于维护和跨多台服务器进行配置。

Microsft 的维护计划似乎还不够。我使用过的最好的解决方案是我使用许多作业手动创建的，每个数据库在源服务器（备份）和目标服务器（恢复）上运行有许多步骤。这些作业使用存储过程来进行备份、复制和恢复。这每天运行一次（完全备份/恢复），每 5 分钟运行一次（事务日志传送）。

尽管我当前的流程可以正常工作并通过电子邮件报告任何作业失败，但我知道整个流程不是很可靠，并且如果不深入了解流程，非 DBA 无法在我们所有的服务器上轻松维护/配置。

我想知道其他人是否有相同的备份/恢复过程以及其他人如何克服这个问题。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-16T22:27:22.590

我已经使用了类似的步骤来让开发/测试/QA 数据库每晚都保持“零步”，以供开发人员和 QA 人员使用。

文档是关键——如果你想消除 Scott Hanselman 所说的“总线因素”（即系统的创建者会被总线击中并且一切都开始糟糕的危险）。

也就是说，对于正常的数据库备份和灾难恢复计划，我发现 SQL Server 维护计划运行良好。只要您包括： 1) 体面的文档 2) 例行测试。

我已经概述了一些方法来做到这一点（对于任何被这个问题吸引来寻找如何创建灾难恢复计划的例子的人）：
[SQL Server Backup Best Practices（免费教程/视频）](http://www.sqlservervideos.com/sqlserver-backups/sqlbackup-best-practices)

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-19T00:53:09.227

您问题的关键部分是由非 DBA 管理备份解决方案的能力。任何本机 SQL Server 答案（如备份脚本）都无法满足该需求，因为备份脚本需要 T-SQL 知识。

正因为如此，您想要寻找像 Mitch Wheat 提到的第三方解决方案。我为 Quest（LiteSpeed 的制造商）工作，所以我当然偏爱那个——它很容易向非 DBA 展示。在我离开上一家公司之前，我进行了十分钟的会议，向系统管理员和开发人员展示 LiteSpeed 控制台的工作原理，仅此而已。从那以后他们就没有打电话了。

另一种方法是使用与您商店的其他部分相同的备份软件。TSM、Veritas、Backup Exec 和 Microsoft DPM 都具有 SQL Server 代理，可让您的 Windows 管理员以不同程度的易用性管理备份过程。如果您真的希望非 DBA 来管理它，这可能是最简单的方法，尽管您牺牲了 SQL 特定备份工具为您提供的大量性能。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T21:55:54.960

即使在这个过程中，我也正在做同样的事情并且半定期地遇到各种问题。

您如何处理将文件从服务器 A 复制到服务器 B 和在服务器 B 上恢复事务备份之间的间隔。

每隔一段时间，事务备份就会比正常情况大，并且需要更长的时间来复制。然后，还原作业会收到一个操作系统错误，表明该文件正在使用中。

这没什么大不了的，因为该文件会在下次自动应用，但是通常有一个更优雅的解决方案并且专门解决这个问题会更好。

# svn - Git、Mercurial 和 Bazaar 的相对优势和劣势是什么？

> ID：77485
> 
> 赞同：140
> 
> 时间：2008-09-16T21:45:09.837
> 
> 标签：svn, git, version-control, mercurial, bazaar

这里的人们如何看待 Git、Mercurial 和 Bazaar 的相对优势和劣势？

在考虑它们中的每一个以及针对 SVN 和 Perforce 等版本控制系统时，应该考虑哪些问题？

在计划从 SVN 迁移到这些分布式版本控制系统之一时，您会考虑哪些因素？

* * *

## 回答 #1

> 赞同：147
> 
> 时间：2008-09-16T22:05:28.603

Git 速度非常快，可扩展性非常好，并且其概念非常透明。不利的一面是它的学习曲线相对陡峭。可以使用 Win32 端口，但不是一等公民。Git 将哈希作为版本号公开给用户；这提供了保证（因为单个哈希始终引用完全相同的内容；攻击者无法在不被发现的情况下修改历史记录），但对用户来说可能很麻烦。Git 具有跟踪文件内容的独特概念，即使这些内容在文件之间移动，并将文件视为第一级对象，但不跟踪目录。git 的另一个问题是它有很多操作（例如*rebase*) 这使得修改历史变得容易（在某种意义上——哈希引用的内容永远不会改变，但对该哈希的引用可能会丢失）；一些纯粹主义者（包括我自己）不太喜欢这样。

Bazaar 相当快（对于历史较浅的树来说非常快，但目前随着历史长度的增长很差），并且对于那些熟悉传统 SCM（CVS、SVN 等）的命令行界面的人来说很容易学习。Win32 被其开发团队认为是一流的目标。它具有针对不同组件的可插拔架构，并经常更换其存储格式；这使他们能够引入新功能（例如更好地支持与基于不同概念的修订控制系统的集成）并提高性能。Bazaar 团队认为目录跟踪和重命名支持一流的功能。虽然全局唯一的修订 ID 标识符可用于所有修订，但树本地 revnos（标准修订号，更类似于 svn 或其他更传统的 SCM 使用的那些）用于代替内容哈希来识别修订。Bazaar 支持“轻量级结账”，其中历史记录保存在远程服务器上，而不是复制到本地系统，并在需要时通过网络自动引用；目前，这在 DSCM 中是独一无二的。

两者都有某种形式的 SVN 集成可用；但是，bzr-svn 比 git-svn 功能强大得多，这主要是由于为此目的引入了后端格式修订。*[更新，截至 2014 年：第三方商业产品 SubGit 提供了 SVN 和 Git 之间的双向接口，其保真度与 bzr-svn 相当，并且更加精致；我**强烈**建议在预算和许可限制允许的情况下使用它而不是 git-svn]。*

我没有广泛使用 Mercurial，因此无法详细评论它——除了要注意它和 Git 一样，具有用于修订的内容哈希寻址；与 Git 一样，它不将目录视为一等对象（并且不能存储空目录）。然而，它比除 Git 之外的任何其他 DSCM 都快，并且比任何竞争对手都具有更好的 IDE 集成（尤其是 Eclipse）。鉴于其性能特征（仅略落后于 Git）及其卓越的跨平台和 IDE 支持，Mercurial 可能对拥有大量以 win32 为中心或受 IDE 约束的成员的团队具有吸引力。

从 SVN 迁移的一个问题是 SVN 的 GUI 前端和 IDE 集成比任何分布式 SCM 更成熟。此外，如果您目前大量使用 SVN 的预提交脚本自动化（即要求在提交可以继续之前通过单元测试），您可能希望使用类似于[PQM](https://launchpad.net/pqm)的工具来自动合并对您的共享分支的请求。

SVK 是一个 DSCM，它使用 Subversion 作为其后备存储，并且与以 SVN 为中心的工具有很好的集成。但是，它的性能和可扩展性特征比任何其他主要的 DSCM（甚至 Darcs）都要差得多，因此应该避免用于在历史长度或文件数量方面可能会变得很大的项目。

[关于作者：我在工作中使用 Git 和 Perforce，在我的个人项目中使用 Bazaar 并作为嵌入式库；我雇主组织的其他部分大量使用 Mercurial。在前世，我围绕 SVN 构建了大量自动化；在此之前，我有使用 GNU Arch、BitKeeper、CVS 等的经验。Git 一开始很令人反感——感觉就像 GNU Arch，因为它是一个概念繁重的环境，而不是为符合用户选择的工作流程而构建的工具包——但从那以后我已经很适应了它]。

* * *

## 回答 #2

> 赞同：19
> 
> 时间：2009-09-28T19:52:16.497

Ogre 3D 项目的 Steve Streeting 刚刚（2009 年 9 月 28 日）发表了一篇关于这个主题的博客文章，他在文章中[对 Git、Mercurial 和 Bazaar 进行了很好的比较](http://www.stevestreeting.com/2009/09/28/early-stage-gitmercurialbazaar-evaluation-thoughts/)。

最后，他发现了三者的优势和劣势，没有明显的赢家。从好的方面来说，他提供了一张很棒的桌子来帮助你决定选择哪一张。

![替代文字](https://i.stack.imgur.com/hlrmT.png)

它是一个简短的阅读，我强烈推荐它。

* * *

## 回答 #3

> 赞同：16
> 
> 时间：2009-01-12T22:38:36.677

* * *

> *这里的人们如何看待 Git、Mercurial 和 Bazaar 的相对优势和劣势？*

在我看来， **Git**的优势在于其简洁的底层设计和非常丰富的功能集。它还具有我认为对多分支存储库和管理分支繁重的工作流的最佳支持。它非常快并且存储库大小很小。

它有一些有用的功能，但需要一些努力才能习惯它们。其中包括工作区和存储库数据库之间的*可见*中间暂存 ara（索引），它允许在更复杂的情况下更好地合并解决、增量提交和脏树提交；*使用相似性启发式检测*重命名和副本，而不是使用某种文件 ID 来跟踪它们，这种方法效果很好，并且允许指责（注释），它可以跟踪跨文件的代码移动，而不仅仅是批发重命名。

它的缺点之一是 MS Windows 支持滞后且不完整。另一个明显的缺点是它没有像 Mercurial 这样的文档那么完善，并且比竞争对手更不友好，但它会发生变化。

在我看来， **Mercurial**的优势在于其良好的性能和较小的存储库大小，以及对 MS Windows 的良好支持。

在我看来，主要的缺点是本地分支（单个存储库中的多个分支）仍然是二等公民，并且以奇怪而复杂的方式实现标签。它处理文件重命名的方式也不是最理想的（但这种情况已经改变）。Mercurial 不支持章鱼合并（有两个以上的父母）。

根据我所听到和阅读的**Bazaar**的主要优势，它可以轻松支持集中式工作流（这也是缺点，集中式概念在不应该出现的地方可见），跟踪文件和目录的重命名。

它的主要缺点是具有长期非线性历史的大型存储库的性能和存储库大小（至少对于不太大的存储库，性能有所提高），默认范式是每个存储库一个牧场（尽管您可以将其设置为共享数据） ，和集中的概念（但这也是我所听到的变化）。

Git 是用 C、shell 脚本和 Perl 编写的，并且是可编写脚本的；Mercurial 是用 C（核心，用于性能）和 Python 编写的，并提供用于扩展的 API；Bazaar 是用 Python 编写的，并为扩展提供 API。

* * *

> *在考虑它们中的每一个以及针对 SVN 和 Perforce 等版本控制系统时，应该考虑哪些问题？*

Subversion (SVN)、Perforce 或 ClearCase 等版本控制系统是*集中式*版本控制系统。Git、Mercurial、Bazaar（还有 Darcs、Monotone 和 BitKeeper）是*分布式*版本控制系统。分布式版本控制系统允许更广泛的工作流程。他们允许使用“准备就绪时发布”。它们对分支和合并以及分支繁重的工作流有更好的支持。您无需信任具有提交访问权限的人就能以简单的方式从他们那里获得贡献。

* * *

> *在计划从 SVN 迁移到这些分布式版本控制系统之一时，您会考虑哪些因素？*

您可能要考虑的因素之一是对 SVN 的支持；Git 有 git-svn，Bazaar 有 bzr-svn，Mercurial 有 hgsubversion 扩展。

**免责声明：**我是 Git 用户和小时间贡献者，并观看（并参与）git 邮件列表。我仅从 Mercurial 和 Bazaar 的文档、关于 IRC 和邮件列表的各种讨论以及比较各种版本控制系统的博客文章和文章（其中一些列在 Git Wiki 上的[GitComparison](http://git.or.cz/gitwiki/GitComparison)页面上）中了解了 Mercurial 和 Bazaar。

* * *

## 回答 #4

> 赞同：8
> 
> 时间：2008-09-16T22:11:09.963

Mercurial 和 Bazaar 在表面上非常相似。它们都提供基本的分布式版本控制，如离线提交和合并多个分支，都是用 python 编写的，而且都比 git 慢。一旦您深入研究代码，就会有许多不同之处，但是对于您的日常日常任务，它们实际上是相同的，尽管 Mercurial 似乎有更多的动力。

Git 不适合初学者。它比 Mercurial 和 Bazaar 都快得多，并且是为管理 Linux 内核而编写的。它是三者中最快的，也是三者中最强大的，相差很大。Git 的日志和提交操作工具是无与伦比的。但是，它也是最复杂和最危险的使用方法。丢失提交或破坏存储库非常容易，尤其是如果您不了解 git 的内部工作原理。

* * *

## 回答 #5

> 赞同：7
> 
> 时间：2009-05-22T13:30:42.070

看看 Python 开发人员最近所做的比较：[http](http://wiki.python.org/moin/DvcsComparison) ://wiki.python.org/moin/DvcsComparison 。他们基于三个重要原因选择 Mercurial：

> 选择 Mercurial 的原因有以下三个：
> 
> *   根据一项小型调查，Python 开发人员对使用 Mercurial 比对 Bazaar 或 Git 更感兴趣。
> *   Mercurial 是用 Python 编写的，这与 Python 开发者“吃自己的狗粮”的趋势一致。
> *   Mercurial 比 bzr 快得多（它比 git 慢，尽管差异要小得多）。
> *   对于 SVN 用户来说，Mercurial 比 Bazaar 更容易学习。
> 
> （来自[http://www.python.org/dev/peps/pep-0374/](http://www.python.org/dev/peps/pep-0374/)）

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2008-09-17T03:13:55.913

Sun 对[git](http://opensolaris.org/os/community/tools/scm/git-eval.txt)、[Mercurial](http://opensolaris.org/os/community/tools/scm/mercurial-eval.html)和[Bazaar](http://opensolaris.org/os/community/tools/scm/bzr-eval/)进行了评估，作为替代 Sun Teamware VCS 用于 Solaris 代码库的候选者。我觉得很有趣。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2009-01-29T20:13:26.997

bazaar中一个非常重要的**缺失**的东西是cp。您不能像在 SVN 中那样让多个文件共享相同的历史记录，请参见[此处](https://lists.ubuntu.com/archives/bazaar/2007q3/029792.html)和[此处](https://bugs.launchpad.net/bzr/+bug/269095)的示例。如果你不打算使用 cp，bzr 是 svn 的一个很好的（而且非常易于使用）替代品。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2009-01-29T20:24:03.060

我使用 Bazaar 有一段时间了，我非常喜欢它，但它只是较小的项目，即便如此它也很慢。如此容易学习，但不是超级快。虽然它是非常x平台的。

我目前使用我非常喜欢的 Git，因为 1.6 版使它在使用的命令方面与其他 VCS 更加相似。

我认为我使用 DVCS 的经验的主要区别是：

1.  Git 拥有最活跃的社区，经常看到关于 Git 的文章
2.  [GitHub](http://github.com)真的很棒。Launchpad.net 还可以，但没有比 Github 带来的快感
3.  Git 的工作流工具数量非常多。它集成在所有地方。Bzr 有一些，但没有那么多或维护得很好。

总之，当我开始使用 DVCS 时，Bzr 很棒，但我现在对 Git 和 Github 非常满意。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-16T21:57:40.383

这是一个很大的问题，很大程度上取决于上下文，这将花费你很多时间来输入这些小文本框之一。此外，当用于大多数程序员通常做的事情时，所有这三个看起来都非常相似，因此即使理解这些差异也需要一些相当深奥的知识。

如果你能将这些工具的分析分解到你有更具体的问题的地步，你可能会得到更好的答案。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-09-16T22:20:56.053

恕我直言，Bazaar 比 git 更容易学习。Git 在 github.com 上有很好的支持。

我认为您应该尝试同时使用两者并确定最适合您的。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-09-16T22:29:24.380

> 这里的人们如何看待 Git、Mercurial 和 Bazaar 的相对优势和劣势？

这是一个非常开放的问题，接近于火焰诱饵。

Git 是最快的，但是这三个都足够快。Bazaar 是最灵活的（它对 SVN 存储库具有透明的读写支持）并且非常关心用户体验。Mercurial 处于中间位置。

这三个系统都有很多粉丝。我个人是集市迷。

> 在考虑它们中的每一个以及针对 SVN 和 Perforce 等版本控制系统时，应该考虑哪些问题？

前者是分布式系统。后者是集中式系统。此外，Perforce 是专有的，而所有其他的都是免费[的，就像在语音中一样](http://www.gnu.org/philosophy/free-sw.html)。

与您在其类别中提到的任何系统相比，集中式与分散式是一个更重要的选择。

> 在计划从 SVN 迁移到这些分布式版本控制系统之一时，您会考虑哪些因素？

首先，TortoiseSVN 缺乏好的替代品。尽管 Bazaar 正在开发他们自己的[Tortoise 变体](http://bazaar-vcs.org/TortoiseBzr)，但截至 2008 年 9 月还没有。

然后，培训关键人员使用去中心化系统将如何影响他们的工作。

最后，与系统的其他部分集成，例如问题跟踪器、夜间构建系统、自动化测试系统等。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2008-09-17T09:50:42.107

ddaa.myopenid.com 顺便提到了它，但我认为还是值得一提：Bazaar 可以读写远程 SVN 存储库。这意味着您可以在本地使用 Bazaar 作为概念验证，而团队的其他成员仍在使用 Subversion。

编辑：现在几乎所有的工具都有*某种*与 SVN 交互的方式，但我现在有个人经验，`git svn`效果**非常**好。我已经使用它几个月了，几乎没有打嗝。

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2008-09-18T10:17:20.737

您的主要问题将是这些是**分布式**SCM，因此需要对用户的思维方式进行一些改变。一旦人们习惯了这个想法，技术细节和使用模式就会到位，但不要低估最初的障碍，尤其是在公司环境中。请记住，所有问题都是人的问题。

* * *

## 回答 #14

> 赞同：1
> 
> 时间：2009-04-23T22:19:27.590

Linus Torvalds 在 git 上有很好的视频。他是 Git 的创建者，所以这就是他所宣传的，但在视频中他解释了分布式 SCM 是什么以及为什么它们比集中式 SCM 更好。有很多比较 git (mercurial 被认为是好的) 和 cvs/svn/perforce。观众也有关于迁移到分布式 SCM 的问题。

我发现这个材料很有启发性，我被卖给了分布式 SCM。但尽管 Linus 做出了努力，但我的选择是反复无常的。原因是 bitbucket.org，我发现它比 github 更好（更慷慨）。

在这里我要说一句警告：Linus 的风格相当激进，我认为他想搞笑但我没有笑。除此之外，如果您是分布式 SCM 的新手并考虑从 SVN 迁移，那么该视频非常棒。

[http://www.youtube.com/watch?v=4XpnKHJAok8](http://www.youtube.com/watch?v=4XpnKHJAok8)

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-09-16T22:15:41.730

分布式版本控制系统 (DVCS) 解决了与集中式 VCS 不同的问题。比较它们就像比较锤子和螺丝刀。

[集中式 VCS](http://en.wikipedia.org/wiki/Revision_control)系统的设计意图是存在一个受祝福的真正来源，因此是好的。所有开发人员都从该源工作（签出），然后添加（提交）他们的更改，然后这些更改变得类似 Blessed。CVS、Subversion、ClearCase、Perforce、VisualSourceSafe 和所有其他 CVCS 之间唯一真正的区别在于每个产品提供的工作流程、性能和集成。

[分布式 VCS](http://en.wikipedia.org/wiki/Distributed_revision_control)系统的设计意图是一个存储库与其他存储库一样好，并且从一个存储库合并到另一个存储库只是另一种通信形式。关于应该信任哪个存储库的任何语义值都是由进程从外部强加的，而不是由软件本身强加的。

使用一种类型或另一种类型的真正选择是组织性的——如果您的项目或组织想要集中控制，那么 DVCS 是不可能的。如果您的开发人员需要在全国/世界各地工作，而没有与中央存储库的安全宽带连接，那么 DVCS 可能是您的救星。如果你两者都需要，那你就完蛋了。

# c# - 带有位置的大型排序集合的 C# 数据类型？

> ID：77503
> 
> 赞同：4
> 
> 时间：2008-09-16T21:46:33.500
> 
> 标签：c#, comparison, types, sorted

我正在尝试比较 SQL 查询中的两个大型数据集。现在 SQL 查询是在外部完成的，每个数据集的结果都保存到自己的 csv 文件中。我的小 C# 控制台应用程序加载两个文本/csv 文件并比较它们的差异并将差异保存到文本文件中。

它是一个非常简单的应用程序，只需将第一个文件中的所有数据加载到一个数组列表中，并在从第二个 csv 文件中读取每一行时对数组列表执行 .compare() 操作。然后保存不匹配的记录。

该应用程序有效，但我想提高性能。我认为如果我可以利用两个文件都已排序的事实，我可以大大提高性能，但我不知道 C# 中的数据类型可以保持顺序并允许我选择特定位置。有一个基本数组，但我不知道每个列表中有多少项目。我可以拥有超过一百万条记录。是否有我应该查看的可用数据类型？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T21:56:47.970

如果两个 CSV 文件中的数据已经排序并且具有相同数量的记录，则可以完全跳过数据结构并进行就地分析。

```
StreamReader one = new StreamReader("C:\file1.csv");
StreamReader two = new StreamReader("C:\file2.csv");
String lineOne;
String lineTwo;

StreamWriter differences = new StreamWriter("Output.csv");
while (!one.EndOfStream)
{
    lineOne = one.ReadLine();
    lineTwo = two.ReadLine();
    // do your comparison.
    bool areDifferent = true;

    if (areDifferent)
        differences.WriteLine(lineOne + lineTwo);
}

one.Close();
two.Close();
differences.Close(); 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T21:54:19.427

System.Collections.Specialized.StringCollection 允许您添加一系列值，并使用 .IndexOf(string) 方法，允许您检索该项目的索引。

话虽如此，您可能只需要从文件流中加载几个 byte[] 并进行字节比较……甚至不必担心将这些内容加载到 StringCollection 或 string[] 等正式数据结构中；如果您所做的只是检查差异，并且您想要速度，我会认为字节差异在哪里。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T22:28:35.660

这是对 David Sokol 的代码的改编，可以处理不同数量的行，输出一个文件中的行而不是另一个文件中的行：

```
StreamReader one = new StreamReader("C:\file1.csv");
StreamReader two = new StreamReader("C:\file2.csv");
String lineOne;
String lineTwo;
StreamWriter differences = new StreamWriter("Output.csv");
lineOne = one.ReadLine();
lineTwo = two.ReadLine();
while (!one.EndOfStream || !two.EndOfStream)
{
  if(lineOne == lineTwo)
  {
    // lines match, read next line from each and continue
    lineOne = one.ReadLine();
    lineTwo = two.ReadLine();
    continue;
  }
  if(two.EndOfStream || lineOne < lineTwo)
  {
    differences.WriteLine(lineOne);
    lineOne = one.ReadLine();
  }
  if(one.EndOfStream || lineTwo < lineOne)
  {
    differences.WriteLine(lineTwo);
    lineTwo = two.ReadLine();
  }
} 
```

关于在我脑海中写下的代码的标准警告适用——您可能需要在一个特殊情况下用完行，而另一个仍然有行，但我认为这种基本方法应该可以满足您的需求。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T21:52:47.417

也许我误解了，但 ArrayList 将按照您添加它们的顺序维护其元素。这意味着您只能在一次通过中比较两个 ArrayList - 只需根据比较结果增加两个扫描索引。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T21:53:22.750

我的一个问题是您是否考虑过“外包”您的比较。有很多好的差异工具，你可以直接调用。如果没有一个可以让您指定两个文件并仅获取差异，我会感到惊讶。只是一个想法。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T22:13:31.097

我认为每个人都有这么多不同答案的原因是你没有很好地确定你的问题足以得到回答。首先，这取决于您要跟踪什么样的差异。您是否希望像在 WinDiff 中一样输出差异，其中第一个文件是“原始”文件，第二个文件是“修改过的”文件，以便您可以将更改列为 INSERT、UPDATE 或 DELETE？您是否有一个主键，可以让您将两行匹配为同一记录的不同版本（当主键以外的字段不同时）？或者这是某种和解，您只希望您的差异输出说“在文件 1 中而不是文件 2 中记录”之类的内容？

我认为这些问题的答案将帮助每个人为您的问题提供合适的答案。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T22:23:30.183

如果您有两个文件，如您的帖子中所述，每个文件都是一百万行，那么您可能会占用*大量*内存。一些性能问题可能是您正在从磁盘交换。如果您只是将文件 A 的第 1 行与文件 B 的第 1 行、第 2 行文件 A -> 第 2 行文件 B 等进行比较，我会推荐一种不会在内存中存储太多的技术。您可以读取先前评论者发布的两个文件流的注销，并在找到结果时“实时”写出结果。这不会在内存中显式存储任何内容。您还可以将每个文件的块转储到内存中，比如一次一千行，转储到类似列表的东西中。这可以进行微调以满足您的需求。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-18T14:05:53.090

要解决问题 #1，我建议考虑创建每行的哈希。这样您就可以使用字典快速轻松地比较哈希值。

要解决问题 #2，一个快速而肮脏的解决方案是使用 IDictionary。使用 itemId 作为您的第一个字符串类型，并将该行的其余部分作为您的第二个字符串类型。然后，您可以快速查找 itemId 是否存在并比较行。这当然假设.Net 2.0+

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T21:50:39.263

好吧，有几种方法可行。您可以编写自己的数据结构来执行此操作。或者您可以尝试使用 SortedList。您还可以在代码中返回 DataSet，然后在表上使用 .Select()。当然，您必须在两张桌子上都这样做。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T21:50:50.277

您可以轻松地使用 SortedList 进行快速查找。如果您正在加载的数据已经排序，则插入到 SortedList 中的速度应该不会很慢。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-16T21:52:24.110

如果您只是想查看 FileA 中的所有行是否都包含在 FileB 中，则可以将其读入并比较循环内的流。

文件 1 条目 1 条目 2 条目 3

文件 2 条目 1 条目 3

您可以使用两个计数器循环并查找遗漏，逐行浏览每个文件，看看是否得到了所需的内容。

# z80 - 您最喜欢的 ZX Spectrum 开发工具是什么？

> ID：77507
> 
> 赞同：27
> 
> 时间：2008-09-16T21:46:52.733
> 
> 标签：z80, sinclair, zxspectrum

你最喜欢的旧[ZX Spectrum](http://en.wikipedia.org/wiki/ZX_Spectrum)的汇编器、编译器、环境和解释器是什么？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-17T17:05:48.067

我一直使用[Roybot Assembler](http://www.worldofspectrum.org/infoseek.cgi?regexp=%5EComplete+Machine+Code+Package$&pub=%5ERoybot$&loadpics=1) - 它让您使用 BASIC 编辑器和 REM 语句输入您的程序。它带有一个不错的调试器/反汇编器，也可以让您单步执行机器代码。

Hisoft Gens and Mons 汇编器和反汇编器（又名 Devpak）可能相当流行。

对于高级编译，[Mira Modula-2](http://www.worldofspectrum.org/infoseekid.cgi?id=0012459)编译器非常好。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2009-08-06T12:13:14.350

用于编程/调试的 Hisoft Gens and Mons 汇编器和反汇编器。

艺术家/图形艺术工作室：
[http ://www.worldofspectrum.org/infoseekid.cgi?id=0007918](http://www.worldofspectrum.org/infoseekid.cgi?id=0007918)

音乐盒：
[http ://www.worldofspectrum.org/infoseekid.cgi?id=0008481](http://www.worldofspectrum.org/infoseekid.cgi?id=0008481)

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-12-23T08:51:15.597

[Zeus 汇编程序](http://en.wikipedia.org/wiki/Zeus_Assembler)，是最好的。

如果我能记住这些名字，我会在其中添加几本 Spectrum 书籍，仍然在家里。一个是 Ian Logan 和 Frank O'Hara 的 The Complete Spectrum ROM Disassembly (ISBN 0 86161 116 0)，它被评论和描述为好像它是源代码一样，这是一个很棒的逆向工程，包括建议的已知错误修复ROM 错误。如果当时只有闪存存在就好了。我还记住了一本名为 Z80 Workshop Manual 的小书，这是对处理器的一个很好的总结。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T22:18:14.627

只要用 BASIC 编程，命令就在那些橡胶键上。现在，如果只有 PC 可以在它们上具有带有 while、case、switch 等的关键图例:-)

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-17T18:45:00.353

**ZX ASM 3.0**

与 20 世纪末的其他汇编程序相比，它拥有最好的用户界面和良好的功能集。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-17T16:54:34.427

我曾经从杂志上输入十六进制表，然后用一个简短的基本应用程序将数据解压缩成汇编代码。很长一段时间以来，我都无法对它做出正面或反面，直到我发现我实际上根本没有编码！

然后，我在大学拥有的[CP/M](http://en.wikipedia.org/wiki/CP/M)迷你计算机系统上进行[Z80 组装。](http://en.wikipedia.org/wiki/Zilog_Z80#The_Z80_assembly_language)在那之后对 Speccy 进行编程就再也不一样了，我再也没有回去过！

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-17T17:21:28.620

我想到了 Devpac（一个蓝色的磁带），即使经过这么多年。

当然，它是#1。不过，我不会错过盒式磁带的装载。好问题！！！:D

[http://www.clive.nl/detail/22916/](http://www.clive.nl/detail/22916/)

我想我有 v.3。它看起来确实比这张照片更自制。但它*有效*并且没有一个错误。打败那个，当前的软件！

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2009-12-04T15:22:46.020

对于当代发展，[TommyGun](http://sourceforge.net/projects/tommygun/)是一个绝佳的选择。

它有一个内置的汇编器、地图编辑器、图形编辑器和其他好东西。它还支持多个 8 位平台。

它与出色的[ZX Spin](http://worldofspectrum.org/forums/showthread.php?t=27547)仿真器配合使用可以很好地进行调试。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2010-05-09T21:47:33.993

BASin、TommyGun、ConTEXT 和 Pasmo 交叉编译器。也适用于 ZXSpin 仿真器，

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-11-17T01:33:22.363

ZX-Asm v3.1 + 补丁 HiSoft-C v1.1 / figFORTH / BetaBasic 3.0

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-12-23T08:42:49.843

也有一些不错的基于 PC 的软件包。对于基于 Sinclair BASIC 的开发，适用于 Windows 的优秀 BASin 包为您提供了一个很好的语法荧光笔、运行时虚拟机、内置的字体编辑器和 UDG 等。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2009-04-27T12:57:56.860

Proxima Software 的汇编程序 Prometheus。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-27T13:57:48.413

在 GEN80 之外，HiSoft [Pascal](http://en.wikipedia.org/wiki/HiSoft_Systems)和Hisoft [C](http://en.wikipedia.org/wiki/HiSoft_Systems)给人留下了深刻的印象。 *适当*的高级语言，很酷。在我学习 Z80 之前，对 BASIC 的速度感到沮丧，我也喜欢[MCODER](http://en.wikipedia.org/wiki/ZX_Spectrum_software)，虽然在 ZX81 上比 ZX Spectrum 更喜欢。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2013-07-11T09:24:10.963

我正在使用 Z88DK，但我认为 SDCC 也可能感兴趣。

# c++ - 多线程调试器

> ID：77522
> 
> 赞同：3
> 
> 时间：2008-09-16T21:48:02.297
> 
> 标签：c++, c, gdb, debugging, pthreads

在使用多线程（pthread）进行调试时，GDB 会出现严重问题。*nix 上是否还有其他适用于 C/C++ 的优秀多线程调试器？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-09-16T22:01:41.700

在调试多线程应用程序时，我个人没有遇到任何 GDB 特定问题，因此详细说明您遇到的“问题”可能对您有所帮助。它将帮助我们更好地回答您。

过去在 linux 中调试多线程应用程序时，我使用过几种辅助工具，其中大部分都基于 GDB 而不是替代它。这些包括：

*   DDD [http://www.gnu.org/software/ddd/](http://www.gnu.org/software/ddd/)
*   日食[http://www.eclipse.org/](http://www.eclipse.org/)
*   本机 POSIX 线程库 (NTPL) 跟踪工具[http://nptltracetool.sourceforge.net/](http://nptltracetool.sourceforge.net/)

此外，如果您不熟悉在 Linux 中进行调试（即使您不是！），我强烈推荐您可以在此处找到题为“调试 Linux 应用程序”的论文：

[http://www.scribd.com/doc/3009706/Debugging-Linux-Applications](http://www.scribd.com/doc/3009706/Debugging-Linux-Applications)

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-09-16T22:10:02.290

[Allinea DDT](http://www.allinea.com/products/ddt) ... 用 C、C++ 和 Fortran 编写的标量、多线程和大规模并行应用程序的图形调试器。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-16T21:57:53.003

[TotalView](http://www.roguewave.com/products/totalview.aspx)是国家实验室用于大型集群的工具。我相信它也对线程并行性有一些很好的支持。它可能超出了您的价格范围，但您可以免费试用。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-16T21:53:24.590

从我的搜索中，我没有找到任何好的用于 *nix 的多线程调试器。GDB 似乎越来越好，上次我不得不在 FreeBSD (7.0-RELEASE) 上调试多线程应用程序时，它表现得相当好，让我找到了错误所在。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T21:53:26.150

我曾经寻找过一个 gdb 替代品，但不幸的是，我找到的每一个都是基于 gdb 的。我认为这是因为 gdb 与 gcc 有着错综复杂的联系，第三方调试器很难跟上 gcc 的每一个变化。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-17T02:17:43.503

Windows 的 AIX 调试器，让您调试多线程应用程序。

# windows-services - 如何在本地系统帐户下运行 CMD.exe？

> ID：77528
> 
> 赞同：165
> 
> 时间：2008-09-16T21:48:52.120
> 
> 标签：windows-services, user-accounts

我目前正在运行 Vista，我想手动完成与我的 Windows 服务相同的操作。由于 Windows 服务在本地系统帐户下运行，我想模拟这种相同的行为。基本上，我想在本地系统帐户下运行 CMD.EXE。

我在网上找到了建议使用 DOS 任务计划程序 AT 命令启动 CMD.exe 的信息，但我收到了一个 Vista 警告，“由于安全性增强，此任务将在除此之外的时间运行，但不会以交互方式运行。” 这是一个示例命令：

```
AT 12:00 /interactive cmd.exe 
```

另一种解决方案建议通过仅启动 CMD.exe 的服务控制 (sc.exe) 创建辅助 Windows 服务。

```
C:\sc create RunCMDAsLSA binpath= "cmd" type=own type=interact
C:\sc start RunCMDAsLSA 
```

在这种情况下，服务无法启动并导致以下错误消息：

```
FAILED 1053: The service did not respond to the start or control request in a timely fashion. 
```

第三个建议是通过计划任务启动 CMD.exe。尽管您可以在各种帐户下运行计划任务，但我不相信本地系统帐户是其中之一。

我也尝试过使用 Runas，但认为我遇到了与运行计划任务时相同的限制。

到目前为止，我的每一次尝试都以失败告终。有什么建议么？

* * *

## 回答 #1

> 赞同：254
> 
> 时间：2008-09-17T00:36:37.227

虽然我没有亲自测试过，但我有充分的理由相信上述 AT COMMAND 解决方案适用于 XP、2000 和 Server 2003。根据我和 Bryant 的测试，我们发现同样的方法不适用于 Vista或 Windows Server 2008——很可能是由于增加了安全性并且 /interactive 开关被弃用了。

但是，我遇到了这篇[文章](http://verbalprocessor.com/2007/12/05/running-a-cmd-prompt-as-local-system)，它演示了SysInternals [（](http://download.sysinternals.com/files/PSTools.zip) 2006 年 7 月被微软收购）的 PSTools 的使用。我通过以下命令启动了命令行，突然我像魔术一样在本地管理员帐户下运行[：](http://sysinternals.com/)

```
psexec -i -s cmd.exe 
```

PSTools 运行良好。这是一套轻量级的、有据可查的工具，可为我的问题提供适当的解决方案。

非常感谢那些提供帮助的人。

* * *

## 回答 #2

> 赞同：65
> 
> 时间：2013-06-07T01:17:01.513

1.  [从 Sysinternals 下载 psexec.exe](https://technet.microsoft.com/en-us/sysinternals/bb896649)。
2.  将它放在您的 C:\ 驱动器中。
3.  以标准或管理员用户身份登录并使用以下命令：`cd \`. 这会将您置于驱动器的根目录中，即 psexec 所在的位置。
4.  使用以下命令：`psexec -i -s cmd.exe`其中 -i 用于交互，-s 用于系统帐户。
5.  命令完成后，将启动一个 cmd shell。类型`whoami`；它会说“系统”
6.  打开任务管理器。杀死 explorer.exe。
7.  从提升的命令外壳类型`start explorer.exe`。
8.  当资源管理器启动时，请注意开始菜单栏中的名称“系统”。现在您可以删除 system32 目录中的一些文件，作为管理员您无法删除，或者作为管理员您必须努力更改权限才能删除这些文件。

尝试重命名或删除 Windows 任何受保护目录中的系统文件的用户应该知道，所有 Windows 文件都受 DACLS 保护，同时重命名文件时您必须更改所有者并替换拥有该文件的 TrustedInstaller 并使任何用户都喜欢作为文件所有者属于管理员组，然后尝试在更改权限后重命名它，它将起作用，并且当您使用内核特权运行 Windows 资源管理器时，出于安全原因，您在网络访问方面受到一定限制，这仍然是一个研究课题让我重新获得访问权

* * *

## 回答 #3

> 赞同：10
> 
> 时间：2008-09-16T21:56:26.940

[在这里](http://blogs.msdn.com/adioltean/articles/271063.aspx)找到了一个答案，似乎通过将 /k start 添加到 binPath 参数来解决问题。所以这会给你：

`sc create testsvc binpath= "cmd /K start" type= own type= interact`

但是，Ben 说这对他不起作用，当我在 Windows Server 2008 上尝试它时，它确实在本地系统下创建了 cmd.exe 进程，但它不是交互式的（我看不到窗口）。

我认为没有一种简单的方法可以按照您的要求进行操作，但是我想知道您为什么要这样做？您是否只是想查看运行服务时发生了什么？似乎您可以只使用日志记录来确定正在发生的事情，而不必将 exe 作为本地系统运行...

* * *

## 回答 #4

> 赞同：6
> 
> 时间：2015-05-30T07:06:24.853

## 使用 Secure Desktop 作为`cmd.exe`运行`system`

`CMD`我们可以通过附加调试器轻松地在 Windows XP/Vista/7/8.1中获取内核访问权限：

```
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\osk.exe" /v Debugger /t REG_SZ /d "C:\windows\system32\cmd.exe" 
```

1.  `CMD`以管理员身份运行

2.  然后在 Elevated 中使用此命令：

    ```
     CMD REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\osk.exe" /v Debugger /t REG_SZ /d "C:\windows\system32\cmd.exe" 
    ```

3.  然后运行`osk`（屏幕键盘）。如果您通过进程资源管理器检查，它仍然不会以系统完整性级别运行，但如果您可以在服务会话中使用 OSK，它将运行为`NT Authority\SYSTEM`

所以我想到你必须在 Secure Desktop 上运行它。

以管理员身份启动任何文件。当出现 UAC 提示时，只需按`Win`+`U`并开始`OSK`，它就会开始`CMD`。然后在提升的提示符中，键入`whoami`，您将获得`NT Authority\System`. 之后，您可以从系统命令 shell 启动 Explorer 并使用系统配置文件，但出于安全原因，您可以通过 SYSTEM 权限在网络上执行的操作有些受限。当我在一年前发现它时，我将在稍后添加更多解释。

## 简要说明这是如何发生的

`Cmd.exe`在不使用本地系统帐户下运行`PsExec`. 此方法运行之前发现的调试器陷阱技术，该技术有其自身的优点，可用于在调试器中捕获一些狡猾/恶意的蠕虫或恶意软件，并运行其他一些 exe 来临时阻止传播或损坏。在这里，此注册表项在 Windows 本机调试器中捕获屏幕键盘并运行 cmd.exe，但 cmd 仍将以登录用户权限运行，但是如果我们在 session0 中运行 cmd，我们可以获得系统 shell。所以我们在这里添加另一个想法，我们跨越安全桌面上的 cmd 记住安全桌面在系统帐户下的会话 0 中运行，我们得到系统外壳。因此，每当您以提升的方式运行任何内容时，您都必须在黑暗的非交互式桌面上回答 UAC 提示和 UAC 提示，一旦看到它，您必须按`Win`+`U`然后选择`OSK`您将`CMD.exe`在本地系统权限下运行。还有更多方法可以访问本地系统`CMD`

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2011-02-21T08:24:52.477

如果您以...的身份运行，则另一种方法是进程黑客（交互式对具有安全增强功能的人不起作用，但这无关紧要），并且当框打开时，将服务放入框类型并将系统放入用户框并放入 C :\Users\Windows\system32\cmd.exe 剩下的点击确定，然后你有一个带有 cmd 的窗口并以系统身份运行现在自己做其他步骤，因为我建议你知道它们

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2018-05-14T11:56:50.490

还有另一种方法。有一个名为 PowerRun 的程序允许运行提升的 cmd。即使拥有 TrustedInstaller 权限。它允许控制台和 GUI 命令。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2021-02-02T08:15:55.307

（评论）

我还不能发表评论，所以在这里发布......我刚刚尝试了上面的 OSK.EXE 调试技巧，但是当我将填充的“C:\windows\system32\cmd.exe”保存到已经创建的调试器密钥中时，regedit 立即关闭所以微软正在积极努力阻止本地方式来做到这一点。这真的很奇怪，因为其他事情不会触发这个。

使用任务调度程序确实会创建一个 SYSTEM CMD，但它位于系统环境中，并且未显示在人类用户配置文件中，因此现在它也已失效（尽管它是合乎逻辑的）。

目前在 Microsoft Windows [版本 10.0.20201.1000]

因此，在这一点上，必须是第三方软件来调解这一点，并且这些天微软正在更加积极地密封更多的技巧。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-16T21:56:56.703

如果您可以编写不需要交互的批处理文件，请尝试将该批处理文件作为服务运行，以完成需要完成的工作。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2018-06-15T19:09:12.967

我使用[*RunAsTi*](https://github.com/jschicht/RunAsTI)实用程序作为*TrustedInstaller*（高权限）运行。该实用程序甚至可以在 Windows 的恢复模式下使用（您通过执行`Shift`+进入的模式`Restart`），*psexec*实用程序在那里不起作用。但是您需要将您的`C:\Windows`and `C:\Windows\System32`（不是`X:\Windows`and `X:\Windows\System32`）路径添加到`PATH`环境变量中，否则*RunAsTi*将无法在恢复模式下工作，它只会打印：*AdjustTokenPrivileges for SeImpersonateName: Not all rights or groups referenced is assigned to the caller*。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2019-05-31T17:28:06.410

使用任务调度程序，使用 /add: /user: 和 /pass 的适当参数在 SYSTEM 下调度 CMDKEY 的运行：

无需安装任何东西。

# windows-server-2008 - 安装后在哪里输入 Windows Server 2008 密钥？

> ID：77531
> 
> 赞同：0
> 
> 时间：2008-09-16T21:49:01.933
> 
> 标签：windows-server-2008

当我安装 Windows Server 2008 时，我没有（激活）密钥。现在我有了它，我找不到在哪里输入它。有人知道吗？

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-09-16T21:50:43.007

转到控制面板\系统，然后在 Windows 激活下单击“更改产品密钥”。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T21:50:48.263

我知道在 Vista 中这是从系统控制面板完成的。我会在 Server 2008 中检查那里。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T21:53:55.590

托盘中可能有一个图标，或者它会在登录时提示您。我不记得提示您需要多长时间，或者是否需要任何时间。

尝试重新启动并登录。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2016-05-03T20:13:15.800

打开命令窗口。

类型 slui 4

跟随向导

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2016-06-15T14:22:15.380

右键单击**计算机**并选择**属性**。然后在*Windows 激活*部分下选择**更改产品密钥。**

 *# .net - wsdl.exe 错误：无法从命名空间“...”导入绑定“...”

> ID：77534
> 
> 赞同：34
> 
> 时间：2008-09-16T21:49:14.837
> 
> 标签：.net, soap, wsdl

在我创建的 WSDL 上运行 wsdl.exe 时，出现此错误：

> 错误：无法从命名空间“SomeNS”导入绑定“SomeBinding”。
> 
> *   无法导入操作“someOperation”。
> *   这些成员可能无法派生。

我正在使用文档文字样式，据我所知，我正在遵守所有规则。

总而言之，我有一个有效的 WSDL，但该工具不喜欢它。

我正在寻找的是是否有人对 wsdl.exe 工具有很多经验并且知道一些我不知道的秘密问题。

* * *

## 回答 #1

> 赞同：57
> 
> 时间：2009-01-23T14:05:24.403

我遇到了同样的错误信息。挖了一会，发现除了wsdl文件外，还可以提供xsd文件。因此，除了 .wsdl 之外，在 wsdl 命令的末尾还包含/导入了 .xsd 文件，如下所示：

> wsdl.exe myWebService.wsdl myXsd1.xsd myType1.xsd myXsd2.xsd ...

Wsdl 给出了一些警告，但它确实创建了一个好的服务接口。

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2010-11-24T17:51:02.227

有时您必须更改您的代码。消息部分名称不应该相同；）

```
<wsdl:message name="AnfrageRisikoAnfrageL">
    <wsdl:part name="parameters" element="his1_0:typeIn"/>
</wsdl:message>
<wsdl:message name="AnfrageRisikoAntwortL">
    <wsdl:part name="parameters" element="his1_0:typeOut"/>
</wsdl:message> 
```

对此：

```
<wsdl:message name="AnfrageRisikoAnfrageL">
    <wsdl:part name="in" element="his1_0:typeIn"/>
</wsdl:message>
<wsdl:message name="AnfrageRisikoAntwortL">
    <wsdl:part name="out" element="his1_0:typeOut"/>
</wsdl:message> 
```

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2015-11-20T12:16:59.337

在我的情况下，问题是不同的，[这里](http://webservices20.blogspot.com/2010/01/interoperability-gotcha-these-members.html)有很好的描述：

> 每当部件的名称是“参数”时，.Net 假定使用 doc/lit/wrapped 并相应地生成代理。如果即使使用了“参数”一词，wsdl 也不是 doc/lit/wrapped（如上一个示例所示），.Net 可能会给我们一些错误。哪个错误？你猜对了：“这些成员可能不是派生出来的”。现在我们可以理解错误的含义：.Net 尝试省略根元素，因为它认为使用了 doc/lit/wrapped。然而，这个元素不能被删除，因为它不是虚拟的——它应该由用户从几个派生类型中主动选择。

修复如下，对我来说非常有效：

> 修复它的方法是在文本编辑器中打开 wsdl 并将部件名称从**"parameters"**更改为**"parameters1"**。现在 .Net 将知道生成一个 doc/lit/bare 代理。这意味着一个新的包装类将作为根参数出现在代理中。虽然这可能是一个更乏味的 api，但这不会对有线格式产生任何影响，并且代理是完全可互操作的。

^(（我强调）)

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2014-12-02T15:20:22.933

@thehhv 解决方案是正确的。有一种解决方法不需要您`xsd`手动添加 s。

然后转到您的服务而不是`?wsdl`转到`?singleWsdl`（下面的屏幕截图）

![在此处输入图像描述](https://i.stack.imgur.com/PpDs0.png)

然后将页面保存为`.wsdl`文件（它会提供`.svc`所以改变它）

然后打开`Visual studio command prompt`你可以在（Win 7）开始 -> 所有程序 -> Visual Studio 2013 -> Visual Studio 工具 -> VS2013 x64 Native Tools 命令提示符（可能是类似的）
然后运行以下命令`Visual studio command prompt`（在哪里而不是C:\WebPricingService.wsdl 是您保存 wsdl 的位置，除非碰巧我们认为非常相似并选择相同的文件名和位置，这令人担忧）

```
wsdl.exe C:\WebPricingService.wsdl 
```

正如@thehhv 所说，它应该给您一些警告，但仍会在其中生成客户端`C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\amd64\WebPricingService.cs`（或将客户端放在您机器上的任何位置 - 检查控制台输出，其中读取“写入文件”）

![在此处输入图像描述](https://i.stack.imgur.com/h782L.png)

希望这可以节省您一些时间。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2017-06-26T16:48:33.760

万一有人撞到了这堵墙，这就是导致我的错误的原因：

我有一个操作：

```
<wsdl:operation name="FormatReport">
  <wsdl:documentation>Runs a report, which is returned as the response</wsdl:documentation>
  <wsdl:input message="FormatReportRequest" />
  <wsdl:output message="FormatReportResponse" />
</wsdl:operation> 
```

它需要一个输入：

```
<wsdl:message name="FormatReportRequest">
  <wsdl:part name="parameters" element="reporting:FormatReportInput" />
</wsdl:message> 
```

和另一个操作：

```
<wsdl:operation name="FormatReportAsync">
  <wsdl:documentation>Creates and submits an Async Report Job to be executed asynchronously by the Async Report Windows Service.</wsdl:documentation>
  <wsdl:input message="FormatReportAsyncRequest" />
  <wsdl:output message="FormatReportAsyncResponse" />
</wsdl:operation> 
```

接受输入：

```
 <wsdl:message name="FormatReportAsyncRequest">
    <wsdl:part name="parameters" element="reporting:FormatReportInputAsync" />
  </wsdl:message> 
```

输入元素是两种类型的实例：

```
<xsd:element name="FormatReportInput" type="reporting:FormatReportInputType"/>
<xsd:element name="FormatReportInputAsync" type="reporting:FormatReportAsyncInputType"/> 
```

这是关键 -`reporting:FormatReportAsyncInputType`类型扩展（派生自）`reporting:FormatReportInputType`类型。这似乎使工具混淆并导致“这些成员可能无法派生”。错误。您可以在接受的答案中解决以下建议。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2018-10-10T22:30:00.940

如果您使用 UPS Shipping wsdl 执行此操作，并且您希望在为不同区域（调试、开发、产品）等进行构建时将 dev 换成 prod url。您可以使用下面的命令从Ship.wsdl，然后在本例中覆盖 Ship.vb 文件中的值。

```
WSDL /Language:VB /out:"C:\wsdl\Ship.vb" "C:\wsdl\Ship.wsdl"  C:\wsdl\UPSSecurity.xsd  C:\wsdl\ShipWebServiceSchema.xsd  C:\wsdl\IFWS.xsd  C:\wsdl\common.xsd 
```

# c++ - 需要在 SCO6 上工作的 gcc/g++

> ID：77535
> 
> 赞同：1
> 
> 时间：2008-09-16T21:49:18.127
> 
> 标签：c++, c, gcc, gnu, sco-unix

有没有人找到让 gcc 在 SCO6 上构建/安装的方法？使用 2.95 和 4.3，我到了需要使用 (2.95) 或找到 (4.3) 汇编程序的地步，这就是它失败的地方。

如果有人知道这一点，我将不胜感激！

谢谢

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T22:13:10.440

您可能需要先安装 GNU binutils。它包含汇编程序。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-29T09:09:19.967

你可以在 SCO Skunkware CD 上找到这个：

[http://www.sco.com/skunkware/](http://www.sco.com/skunkware/)

# python - 'id' 在 Python 中是一个错误的变量名

> ID：77552
> 
> 赞同：179
> 
> 时间：2008-09-16T21:50:58.653
> 
> 标签：python

`id`为什么在 Python中命名变量是不好的？

* * *

## 回答 #1

> 赞同：168
> 
> 时间：2008-09-16T21:55:59.703

`id()`是一个基本的内置：

> `id`模块 内置函数的帮助`__builtin__`：
> 
> ```
> id(...)
> 
>     id(object) -> integer
> 
>     Return the identity of an object.  This is guaranteed to be unique among
>     simultaneously existing objects.  (Hint: it's the object's memory
>     address.) 
> ```

通常，即使允许，在任何语言中使用使关键字或内置函数黯然失色的变量名都是一个坏主意。

* * *

## 回答 #2

> 赞同：84
> 
> 时间：2015-01-22T14:24:12.917

在**PEP 8 - Style Guide for Python Code**中，以下指南出现在[描述性：命名样式](https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles)部分：

> *   `single_trailing_underscore_`: 按照惯例使用以避免与 Python 关键字冲突，例如
>     
>     
>     
>     `Tkinter.Toplevel(master, class_='ClassName')`

因此，为了回答这个问题，应用此指南的一个示例是：

```
id_ = 42 
```

在变量名中包含尾随下划线可以明确意图（对于那些熟悉 PEP 8 中的指导的人）。

* * *

## 回答 #3

> 赞同：60
> 
> 时间：2008-09-17T02:13:34.310

[`id`](https://docs.python.org/library/functions.html#id)是一个提供对象标识的内置函数（在 CPython 中也是它的内存地址）。如果你命名你的函数之一`id`，你将不得不说[`builtins.id`](https://docs.python.org/library/builtins.html)得到原始的（或`__builtins__.id`在 CPython 中）。全局重命名`id`除了一个小脚本之外的任何东西都令人困惑。

但是，只要使用是本地的，重用内置名称作为变量并不是那么糟糕。Python 有*很多*内置函数，它们 (1) 有通用名称，(2) 无论如何你都不会使用太多。使用这些作为局部变量或作为对象的成员是可以的，因为从上下文中很明显你在做什么：

例子：

```
def numbered(filename):
    with open(filename) as file:
        for i, input in enumerate(file):
            print("%s:\t%s" % (i, input), end='') 
```

一些具有诱人名称的内置插件：

*   `id`
*   `file`
*   `list`,`dict`
*   `map`
*   `all`,`any`
*   `complex`,`int`
*   `dir`
*   `input`
*   `slice`
*   `buffer`
*   `sum`
*   `min`,`max`
*   `object`

* * *

## 回答 #4

> 赞同：55
> 
> 时间：2008-09-16T22:27:26.380

在这里我可能会说一些不受欢迎的东西：`id()`是一个相当专业的内置函数，在业务逻辑中很少使用。因此，我认为将它用作紧凑且编写良好的函数中的变量名没有问题，很明显 id 并不意味着内置函数。

* * *

## 回答 #5

> 赞同：6
> 
> 时间：2020-07-18T20:08:08.077

其他人提到这很令人困惑，但我想详细说明**原因**。这是一个基于真实故事的示例。基本上，我编写了一个带`id`参数的类，但后来尝试使用内置函数`id`。

```
class Employee:
    def __init__(self, name, id):
        """Create employee, with their name and badge id."""
        self.name = name
        self.id = id
        # ... lots more code, making you forget about the parameter names
        print('Created', type(self).__name__, repr(name), 'at', hex(id(self)))

tay = Employee('Taylor Swift', 1985) 
```

预期输出：

```
Created Employee 'Taylor Swift' at 0x7efde30ae910 
```

实际输出：

```
Traceback (most recent call last):
  File "company.py", line 9, in <module>
    tay = Employee('Taylor Swift', 1985)
  File "company.py", line 7, in __init__
    print('Created', type(self).__name__, repr(name), 'at', hex(id(self)))
TypeError: 'int' object is not callable 
```

> *嗯？我在哪里尝试调用 int？这些都是内置的...*

如果我将它命名为`badge_id`或`id_`，我就不会遇到这个问题。

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2008-09-16T21:54:56.630

在内置函数之后命名任何变量是不好的。原因之一是因为它可能会让不知道名称被覆盖的读者感到困惑。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-16T21:55:32.417

`id`是 Python 中的内置函数。分配一个值`id`将覆盖该函数。最好添加一个前缀，如 in`some_id`或以不同的大写形式使用，如 in `ID`。

内置函数接受一个参数并返回一个整数，表示您传递的对象的内存地址（在 CPython 中）。

```
>>> id(1)
9787760
>>> x = 1
>>> id(x)
9787760 
```

* * *

## 回答 #8

> 赞同：-2
> 
> 时间：2008-09-16T21:52:12.580

因为它是内置函数的名称。

* * *

## 回答 #9

> 赞同：-6
> 
> 时间：2008-09-16T23:47:16.003

因为 python 是一种动态语言，所以给变量和函数同名通常不是一个好主意。id() 是 python 中的一个函数，所以建议不要使用名为 id 的变量。请记住，这适用于您可能使用的所有函数......变量不应与函数具有相同的名称。

# php - 如何使用 PHP File api 写入原始字节？

> ID：77558
> 
> 赞同：2
> 
> 时间：2008-09-16T21:51:45.640
> 
> 标签：php, file-io

我想将原始字节/字节流写入文件中的某个位置。这是我目前拥有的：

```
$fpr = fopen($out, 'r+');
fseek($fpr, 1); //seek to second byte
fwrite($fpr, 0x63); 
fclose($fpr); 
```

这当前从字节偏移量 1 开始写入“99”的实际字符串值。IE，它写入字节“9”和“9”。我只想写实际的一字节值 0x63，它恰好代表数字 99。

谢谢你的时间。

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-16T21:54:15.040

`fwrite()`需要字符串。`chr(0x63)`如果您想将一个`0x63`字节写入文件，请尝试。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-16T21:57:03.037

这是因为 fwrite() 需要一个字符串作为它的第二个参数。尝试这样做：

```
fwrite($fpr, chr(0x63)); 
```

chr(0x63) 返回一个字符串，其中一个字符的 ASCII 值为 0x63。（所以它会将数字 0x63 写入文件。）

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T21:54:51.670

您正在尝试将 int 传递给接受字符串的函数，因此它正在为您转换为字符串。

这将写出你想要的：

```
fwrite($fpr, "\x63"); 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2012-01-22T21:47:49.820

如果您真的想将二进制文件写入文件，我建议将该`pack()`方法与文件 API 一起使用。

有关示例，[请参见此问题。](https://stackoverflow.com/questions/5719803/what-is-the-realtime-use-of-php-pack-and-unpack-function)

# testing - 黑盒回归测试的测试框架

> ID：77582
> 
> 赞同：3
> 
> 时间：2008-09-16T21:54:04.793
> 
> 标签：testing, embedded, regression-testing

我正在寻找一种用于回归测试我们正在构建的设备套件的工具。

当前的概念是您为工具创建一个输入文件 (text/csv)，指定对被测系统的输入。然后，该工具从系统捕获输出并将输入和输出记录到输出文件中。

输出与原始输入文件的格式相同，可用作工具后续运行的输入，测量的输出与前一次运行的值匹配。

两次运行的结果不会完全匹配，存在一些时间差异，这取决于电池的状态，或者取决于设备的其他内部状态。

我们必须编写自己的接口来将命令从工具传递到设备并捕获设备的输出。

这是一项相对简单的任务，但我正在寻找现有的工具/包/库，以避免重新发明轮子/从中吸取教训。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T22:05:43.097

[我最近在 git ( http://git.or.cz/](http://git.or.cz/) )之上构建了一个这样的系统。基本上，编写一个程序来获取所有输入文件，将它们发送到服务器，读回输出，并将其写入一组输出文件。第一次运行后，将输出文件提交到 git。

对于未来的运行，您的成功取决于运行完成后 git 存储库是否干净：

```
test 0 == $(git diff data/output/ | wc -l) 
```

作为奖励，您可以使用所有 git 工具来比较差异，并在结果证明差异是改进时提交它们，以便未来的运行将通过。在分支之间合并时也很有效。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-17T16:12:25.993

我不确定是否会有一个完全适合您需求的软件包。您需要考虑以下几点：

1.  如何将数据传递给设备以及如何将其收集回来。这是非常特定于应用程序的，但通常不错的选择是旧的'n'good 串行端口（RS232），对于任何编程语言都存在简单的交互。
2.  如何运行测试。单元测试框架绝对可以在这里为您提供帮助。现有框架实现了许多基本功能——选择要运行的测试、选择报告的详细级别（对于最初的详细调试和稍后的生产阶段PASS/FAIL 分析非常重要）。我在测试嵌入式设备时使用 Perl 和 Python 的测试框架有很好的经验。
3.  您还必须决定如何进行比较。正如您正确指出的那样，结果将不相等。这就是您的领域知识的来源。通常，它只是使用适用于您的领域的误差范围来实现。当然，您将无法使用基本`diff`工具，而必须编写智能脚本。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T22:02:14.350

您可以使用任何测试框架。困难的部分是编写从测试系统发送/检索数据的工具，而不是实际的字符串比较。

你的测试看起来像这样：

```
x = read_input_file(ifilename);
y1 = read_expected_data(ofilename);
send_input_file_to_server();
y2 = read_output_from_server();
checkequal(y1, y2) 
```

# eclipse-plugin - 是否有用于调试 Jython 的集成 Eclipse 插件？

> ID：77587
> 
> 赞同：2
> 
> 时间：2008-09-16T21:54:17.397
> 
> 标签：eclipse-plugin, debugging, jython

[JyDT](http://www.redrobinsoftware.net/jydt/)是一个很好的 Jython Eclipse 插件。

但是，它不允许在 Debug 透视图中进行 Jython 调试。

Jython 提供了一个命令行调试器 (Pdb)，但它在 Eclipse 之外运行。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T21:56:33.523

[Pydev](http://pydev.sourceforge.net/)对我来说效果很好。

# java - Getting java and flash to talk to each other

> ID：77598
> 
> 赞同：5
> 
> 时间：2008-09-16T21:54:53.510
> 
> 标签：java, flash

I have an application written in java, and I want to add a flash front end to it. The flash front end will run on the same computer as the java app in the stand alone flash player. I need two way communication between the two parts, and have no idea how to even start going about this. I suppose I could open a socket between the two programs, but I feel that there must be an easier way. Is there a nice part of the api in actionscript 3.0 that will allow me to access java methods directly, or will I have to resort to sockets? I am relatively new to flash, by the way, so any good guides would be much appreciated!

Thanks

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-09-16T21:57:33.833

[AMF](http://en.wikipedia.org/wiki/Action_Message_Format) is a messaging protocol commonly used to talk between flash and a backend system. There're several Java implementations, but I haven't used any of them so can't tell you which is best.

*   [Blaze DS](http://labs.adobe.com/technologies/blazeds/)
*   [Red5](http://www.osflash.org/red5)
*   [Granite DS](http://www.graniteds.org/)

Flash can also talk plain old XML, SOAP or REST to the backend, so depending on your codebase that might be easier.

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-17T10:41:38.160

There is also **[OpenAMF](http://sourceforge.net/projects/openamf/)**. It is *very* mature, stable, simple and lightweight relative to Blaze, Red5 and Granite.

**BUT**, it is also dated (AMF0 protocol only) and the project is no longer active. Lots of people are still using it out in the wild. And the documentation is borderline non-existent.

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-15T11:19:03.913

Granite DS is a good solution, it will allow you to set up services to communicate not only to POJO's but to EJB3 session beans also. It comes with a GAS code generator for converting your java beans into as3 equivalents and also data push to the client using the gravity side project.

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T22:49:36.000

MERAPI is a bridge framework for communication between Java and Flash.

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-23T11:09:34.460

I agree on Granite DS. It was easy to setup and get going.

I have used it to talk directly with a EJB3 bean communicating with thrift generated objects.

# .net - 性能测试

> ID：77603
> 
> 赞同：2
> 
> 时间：2008-09-16T21:55:16.677
> 
> 标签：.net, nunit, vmware, regression-testing

我们正在使用 VMWare 和 NUnit 开发自动化回归测试。我们已将测试划分为多个步骤，现在我希望查看每个步骤的性能回归。像 NUnit 那样简单地为测试计时似乎并不可靠。我计算了大约 15% 的接受系数，但我们的步骤有时可能会超过 35%。在这种依赖资源的测试环境中，是否有任何一致的测试性能的方法？“智能”计时系统是我唯一的选择吗？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T22:10:23.600

对于这种性能测试，没有系统可以为您提供简单的通过/失败结果。在现实生活中，改变你的系统可能会让一些事情变得更快而另一些事情变得更慢，所以通常不是在“更好”和“不是更好”之间做出选择，而是在不同种类的更好之间做出选择。（当然，你想避免情况更糟的情况。）

我过去为此所做的只是随着时间的推移保持统计数据。每次运行测试时，将结果连同版本号和测试时间一起放到 SQL 数据库中。然后，您可以随时随地绘制它们（最好是在一个小的 Web 小程序中，以便团队中的每个人都可以查看它们），并查看您的绩效是上升还是下降，或者自特定修订以来绩效是否一直在下降。

不过，这里的关键是它需要是一个*图表*。这样人眼就可以看到它并找到趋势。你可以花一整周时间想出一个人工智能算法来对数据进行数字分析，但它永远不会超过人类的模式识别能力。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T21:57:49.493

您可能会查看 Ants Profiler 等工具提供的功能，因为它确实提供了方法执行/运行时间，但我不确定它在重复测试方面提供了什么。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T21:58:26.467

关于性能测试，我一直对使用 vmware 或其他虚拟化进程持怀疑态度。我们过去处理这个问题的方式是让部分构建在静态机器上安装最新版本并运行测试。您应该会在虚拟化之外看到更一致的结果。

# c# - 泛型有什么好处，为什么要使用它们？

> ID：77632
> 
> 赞同：92
> 
> 时间：2008-09-16T21:57:43.817
> 
> 标签：c#, generics, types

我想我会把这个垒球提供给任何想把它打出公园的人。什么是泛型，泛型的优点是什么，为什么，在哪里，如何使用它们？请保持相当基本。谢谢。

* * *

## 回答 #1

> 赞同：131
> 
> 时间：2008-09-16T22:04:16.267

*   允许您编写代码/使用类型安全的库方法，即保证 List<string> 是字符串列表。
*   由于使用了泛型，编译器可以对代码执行编译时检查以确保类型安全，即您是否尝试将 int 放入该字符串列表中？使用 ArrayList 会导致它是一个不太透明的运行时错误。
*   比使用对象更快，因为它可以避免装箱/拆箱（.net 必须将[值类型转换为引用类型，反之亦然](https://stackoverflow.com/questions/5057267/what-is-the-difference-between-a-reference-type-and-value-type-in-c)）或从对象转换为所需的引用类型。
*   允许您编写适用于具有相同基础行为的许多类型的代码，即 Dictionary<string, int> 使用与 Dictionary<DateTime, double> 相同的基础代码；使用泛型，框架团队只需要编写一段代码就可以实现上述两种结果。

* * *

## 回答 #2

> 赞同：55
> 
> 时间：2009-06-04T23:56:26.140

我真的很讨厌重复自己。我讨厌比我必须更频繁地输入相同的东西。我不喜欢多次重复有细微差别的事情。

而不是创建：

```
class MyObjectList  {
   MyObject get(int index) {...}
}
class MyOtherObjectList  {
   MyOtherObject get(int index) {...}
}
class AnotherObjectList  {
   AnotherObject get(int index) {...}
} 
```

我可以构建一个可重用的类...（在您出于某种原因不想使用原始集合的情况下）

```
class MyList<T> {
   T get(int index) { ... }
} 
```

我现在的效率提高了 3 倍，而且我只需要维护一份副本。为什么不想维护更少的代码？

对于必须与其他类交互的非集合类（例如 a`Callable<T>`或 a ）也是如此。`Reference<T>`你真的想扩展`Callable<T>`和 `Future<T>`其他所有相关的类来创建类型安全的版本吗？

我不。

* * *

## 回答 #3

> 赞同：22
> 
> 时间：2009-06-05T00:24:44.413

**不需要类型转换是 Java 泛型的最大优势之一**，因为它将在编译时执行类型检查。这将减少在运行时抛出 s 的可能性`ClassCastException`，并且可以产生更健壮的代码。

但我怀疑你完全意识到这一点。

> 每次看到泛型都让我头疼。我发现 Java 最好的部分是它的简单性和最小的语法，泛型并不简单，并且添加了大量的新语法。

起初，我也没有看到泛型的好处。我从 1.4 语法开始学习 Java（尽管当时 Java 5 已经出来了），当我遇到泛型时，我觉得要写更多的代码，我真的不明白它的好处。

**现代 IDE 使使用泛型编写代码变得更加容易。**

大多数现代的、体面的 IDE 都足够聪明，可以帮助使用泛型编写代码，尤其是代码完成。

这是一个`Map<String, Integer>`用`HashMap`. 我必须输入的代码是：

```
Map<String, Integer> m = new HashMap<String, Integer>(); 
```

事实上，为了制作一个新的`HashMap`. 然而，实际上，在 Eclipse 知道我需要什么之前，我只需要输入这么多：

`Map<String, Integer> m = new Ha` `Ctrl`+`Space`

没错，我确实需要`HashMap`从候选列表中进行选择，但基本上 IDE 知道要添加什么，包括泛型类型。使用正确的工具，使用泛型并不算太糟糕。

此外，由于类型是已知的，当从泛型集合中检索元素时，IDE 将表现得好像该对象已经是其声明类型的对象——不需要强制转换让 IDE 知道对象的类型是。

**泛型的一个关键优势来自于它与 Java 5 新特性的良好配合。**这是一个将整数放入 a`Set`并计算其总数的示例：

```
Set<Integer> set = new HashSet<Integer>();
set.add(10);
set.add(42);

int total = 0;
for (int i : set) {
  total += i;
} 
```

在那段代码中，存在三个新的 Java 5 特性：

*   [泛型](http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html)
*   [自动装箱和拆箱](http://java.sun.com/j2se/1.5.0/docs/guide/language/autoboxing.html)
*   [对于每个循环](http://java.sun.com/j2se/1.5.0/docs/guide/language/foreach.html)

首先，泛型和基元的自动装箱允许以下行：

```
set.add(10);
set.add(42); 
```

整数`10`被自动装箱为`Integer`值为 的`10`。（同样适用`42`）。然后将`Integer`其扔进`Set`已知持有`Integer`s 的 中。尝试抛出 a`String`会导致编译错误。

接下来，for for-each 循环采用所有这三个：

```
for (int i : set) {
  total += i;
} 
```

首先，`Set`包含`Integer`s 用于 for-each 循环。每个元素都被声明为 an`int`并且是允许的，因为`Integer`被拆箱回原语`int`。并且这种拆箱发生的事实是众所周知的，因为泛型用于指定`Integer`在`Set`.

泛型可以成为结合 Java 5 中引入的新特性的粘合剂，它只是让编码更简单、更安全。而且大多数时候 IDE 足够聪明，可以帮助你提出好的建议，所以一般来说，它不会多打字。

坦率地说，从示例中可以看出`Set`，我觉得利用 Java 5 的特性可以使代码更加简洁和健壮。

**编辑 - 没有泛型的示例**

下面是上面`Set`例子的说明，没有使用泛型。这是可能的，但并不完全令人愉快：

```
Set set = new HashSet();
set.add(10);
set.add(42);

int total = 0;
for (Object o : set) {
  total += (Integer)o;
} 
```

*（注意：上面的代码会在编译时产生未经检查的转换警告。）*

使用非泛型集合时，输入到集合中的类型是 type 的对象`Object`。因此，在此示例中，a`Object`是被`add`编入集合的内容。

```
set.add(10);
set.add(42); 
```

在上面的几行中，自动装箱正在发挥作用——原始`int`值`10`并被自动装箱`42`到`Integer`对象中，这些对象被添加到`Set`. 但是，请记住，`Integer`对象是作为`Object`s 处理的，因为没有类型信息可以帮助编译器知道`Set`应该期望什么类型。

```
for (Object o : set) { 
```

这是至关重要的部分。for-each 循环起作用的原因是因为它`Set`实现了[`Iterable`](http://java.sun.com/javase/6/docs/api/java/lang/Iterable.html)接口，该接口返回`Iterator`带有类型信息（如果存在）的信息。( `Iterator<T>`，即。)

但是，由于没有类型信息，因此`Set`将返回 an `Iterator`，它将返回`Set`as中的值`Object`，这就是为什么在 for-each 循环中检索的元素*必须*是 type 的原因`Object`。

现在`Object`从 中检索到`Set`，需要`Integer`手动将其强制转换为 a 以执行添加：

```
 total += (Integer)o; 
```

在这里，从 an`Object`到 an执行类型转换`Integer`。在这种情况下，我们知道这将始终有效，但是手动类型转换总是让我觉得它是脆弱的代码，如果在其他地方进行微小的更改可能会损坏。（我觉得每个类型转换都是`ClassCastException`等待发生，但我离题了......）

现在`Integer`已将 拆箱`int`并允许对`int`变量执行加法运算`total`。

我希望我能说明 Java 5 的新特性可以与非泛型代码一起使用，但它不像使用泛型编写代码那样干净和直接。而且，在我看来，要充分利用 Java 5 中的新特性，应该研究泛型，如果至少允许编译时检查以防止无效类型转换在运行时抛出异常。

* * *

## 回答 #4

> 赞同：15
> 
> 时间：2009-06-04T23:43:14.543

如果您在 1.5 发布之前搜索 Java 错误数据库，您会发现`NullPointerException`比`ClassCastException`. 因此，寻找错误似乎不是一个很棒的功能，或者至少是在经过一些冒烟测试后仍然存在的错误。

对我来说，泛型的巨大优势在于它们**在代码**中记录了重要的类型信息。如果我不想在代码中记录类型信息，那么我会使用动态类型语言，或者至少是一种具有更多隐式类型推断的语言。

将对象的集合保留为自身并不是一种糟糕的风格（但常见的风格是有效地忽略封装）。这取决于你在做什么。使用泛型（在编译时或之前）将集合传递给“算法”稍微容易一些。

* * *

## 回答 #5

> 赞同：11
> 
> 时间：2009-06-05T00:39:52.823

Java 中的泛型促进了[参数多态性](http://en.wikipedia.org/wiki/Polymorphism_(computer_science))。通过类型参数，您可以将参数传递给类型。就像一个方法`String foo(String s)`模拟一些行为一样，不仅仅是一个特定的字符串，而是任何字符串`s`，所以一个类型`List<T>`模拟一些行为，不仅仅是一个特定的类型，而是*任何类型*。`List<T>`说*对于任何 type `T`，都有一个 type 的`List`元素是`T`s*。实际上也是`List`一个*类型构造函数*。它将一个类型作为参数并构造另一个类型作为结果。

以下是我每天使用的几个泛型类型的示例。首先，一个非常有用的通用接口：

```
public interface F<A, B> {
  public B f(A a);
} 
```

这个接口表示，*对于某些两种类型，`A`和`B`，有一个函数（称为`f`），它接受一个`A`并返回一个`B`。*当你实现这个接口时，`A`可以`B`是你想要的任何类型，只要你提供一个函数`f`，接受前者并返回后者。这是接口的示例实现：

```
F<Integer, String> intToString = new F<Integer, String>() {
  public String f(int i) {
    return String.valueOf(i);
  }
} 
```

在泛型之前，多态性是通过使用关键字进行*子类化来实现的。*`extends`使用泛型，我们实际上可以取消子类化并使用参数多态性。例如，考虑一个用于计算任何类型的哈希码的参数化（通用）类。我们将使用这样的泛型类，而不是覆盖 Object.hashCode()：

```
public final class Hash<A> {
  private final F<A, Integer> hashFunction;

  public Hash(final F<A, Integer> f) {
    this.hashFunction = f;
  }

  public int hash(A a) {
    return hashFunction.f(a);
  }
} 
```

这比使用继承要灵活得多，因为我们可以保持使用组合和参数多态的主题，而不会锁定脆弱的层次结构。

Java 的泛型虽然并不完美。例如，您可以抽象类型，但不能抽象类型构造函数。也就是说，您可以说“对于任何类型 T”，但您不能说“对于采用类型参数 A 的任何类型 T”。

[我在这里写了一篇关于 Java 泛型的这些限制的文章。](http://apocalisp.wordpress.com/2008/10/23/heterogeneous-lists-and-the-limits-of-the-java-type-system/)

泛型的一个巨大胜利是它们可以让你避免子类化。子类化往往会导致难以扩展的脆弱的类层次结构，以及如果不查看整个层次结构就难以单独理解的类。

在泛型之前，您可能拥有像`Widget`扩展了`FooWidget`、、`BarWidget`和这样的类`BazWidget`，使用泛型，您可以拥有一个泛型类，该类`Widget<A>`采用`Foo`,`Bar`或`Baz`在其构造函数中为您提供`Widget<Foo>`,`Widget<Bar>`和`Widget<Baz>`.

* * *

## 回答 #6

> 赞同：8
> 
> 时间：2008-09-16T22:00:42.110

泛型避免了装箱和拆箱对性能的影响。基本上，看看 ArrayList 与 List<T>。两者都做相同的核心事情，但 List<T> 会快很多，因为您不必对对象进行装箱/装箱。

* * *

## 回答 #7

> 赞同：7
> 
> 时间：2008-09-17T04:03:39.100

泛型的最大好处是代码重用。假设您有很多业务对象，并且您将为每个实体编写非常相似的代码来执行相同的操作。（IE Linq to SQL 操作）。

使用泛型，您可以创建一个类，该类将能够在给定从给定基类继承的任何类型或实现给定接口的情况下进行操作，如下所示：

```
public interface IEntity
{

}

public class Employee : IEntity
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public int EmployeeID { get; set; }
}

public class Company : IEntity
{
    public string Name { get; set; }
    public string TaxID { get; set }
}

public class DataService<ENTITY, DATACONTEXT>
    where ENTITY : class, IEntity, new()
    where DATACONTEXT : DataContext, new()
{

    public void Create(List<ENTITY> entities)
    {
        using (DATACONTEXT db = new DATACONTEXT())
        {
            Table<ENTITY> table = db.GetTable<ENTITY>();

            foreach (ENTITY entity in entities)
                table.InsertOnSubmit (entity);

            db.SubmitChanges();
        }
    }
}

public class MyTest
{
    public void DoSomething()
    {
        var dataService = new DataService<Employee, MyDataContext>();
        dataService.Create(new Employee { FirstName = "Bob", LastName = "Smith", EmployeeID = 5 });
        var otherDataService = new DataService<Company, MyDataContext>();
            otherDataService.Create(new Company { Name = "ACME", TaxID = "123-111-2233" });

    }
} 
```

注意给定上述 DoSomething 方法中不同类型的相同服务的重用。真优雅！

在你的工作中使用泛型还有很多其他重要的理由，这是我最喜欢的。

* * *

## 回答 #8

> 赞同：5
> 
> 时间：2008-09-16T22:02:46.660

我只是喜欢它们，因为它们为您提供了一种快速定义自定义类型的方法（无论如何我都使用它们）。

因此，例如，无需定义由字符串和整数组成的结构，然后必须实现一整套对象和方法来了解如何访问这些结构的数组等等，您只需制作一个 Dictionary

```
Dictionary<int, string> dictionary = new Dictionary<int, string>(); 
```

编译器/IDE 完成了其余的繁重工作。尤其是 Dictionary 允许您使用第一种类型作为键（无重复值）。

* * *

## 回答 #9

> 赞同：5
> 
> 时间：2009-06-04T23:39:34.380

*   类型化的集合——即使你不想使用它们，你也可能不得不从其他库、其他来源处理它们。

*   类创建中的通用类型：

    public class Foo < T> { public T get()...

*   避免铸造 - 我一直不喜欢这样的事情

    new Comparator { public int compareTo(Object o){ if (o instanceof classIcareAbout)...

您实际上是在检查一个只应该存在的条件，因为接口是用对象表示的。

我对泛型的最初反应与你的相似——“太杂乱，太复杂”。我的经验是，在使用它们一段时间后，你会习惯它们，没有它们的代码感觉不太明确，而且不太舒服。除此之外，Java 世界的其余部分都在使用它们，所以您最终将不得不使用该程序，对吧？

* * *

## 回答 #10

> 赞同：5
> 
> 时间：2009-06-04T23:46:31.963

举一个很好的例子。想象一下你有一个名为 Foo 的类

```
public class Foo
{
   public string Bar() { return "Bar"; }
} 
```

**示例 1** 现在您想要一个 Foo 对象的集合。您有两个选项，LIst 或 ArrayList，它们都以类似的方式工作。

```
Arraylist al = new ArrayList();
List<Foo> fl = new List<Foo>();

//code to add Foos
al.Add(new Foo());
f1.Add(new Foo()); 
```

在上面的代码中，如果我尝试添加一个 FireTruck 类而不是 Foo，ArrayList 会添加它，但是 Foo 的 Generic List 会导致抛出异常。

**例二。**

现在您有了两个数组列表，并且您想在每个列表上调用 Bar() 函数。由于 hte ArrayList 中充满了对象，因此您必须先转换它们，然后才能调用 bar。但是由于 Foo 的通用列表只能包含 Foos，因此您可以直接在这些上调用 Bar()。

```
foreach(object o in al)
{
    Foo f = (Foo)o;
    f.Bar();
}

foreach(Foo f in fl)
{
   f.Bar();
} 
```

* * *

## 回答 #11

> 赞同：4
> 
> 时间：2009-06-05T00:33:29.340

您是否曾经编写过方法（或类），其中方法/类的关键概念没有紧密绑定到参数/实例变量的特定数据类型（想想链表、最大/最小函数、二进制搜索， ETC。）。

你有没有希望你可以重用算法/代码而不诉诸剪切-粘贴重用或损害强类型（例如，我想要一个`List`字符串，而不是`List`我*希望*是字符串的东西！）？

这就是为什么您应该***使用***泛型（或更好的东西）。

* * *

## 回答 #12

> 赞同：3
> 
> 时间：2009-06-05T00:24:18.220

不要忘记泛型不仅仅被类使用，它们也可以被方法使用。例如，采用以下代码段：

```
private <T extends Throwable> T logAndReturn(T t) {
    logThrowable(t); // some logging method that takes a Throwable
    return t;
} 
```

它很简单，但可以非常优雅地使用。好消息是该方法返回它给出的任何内容。当您处理需要重新抛出给调用者的异常时，这会有所帮助：

```
 ...
} catch (MyException e) {
    throw logAndReturn(e);
} 
```

关键是通过方法传递它不会丢失类型。您可以抛出正确类型的异常，而不仅仅是 a `Throwable`，这将是您在没有泛型的情况下所能做的。

这只是泛型方法的一种用途的简单示例。使用泛型方法可以做很多其他巧妙的事情。在我看来，最酷的是使用泛型进行类型推断。举个例子（取自 Josh Bloch 的 Effective Java 2nd Edition）：

```
...
Map<String, Integer> myMap = createHashMap();
...
public <K, V> Map<K, V> createHashMap() {
    return new HashMap<K, V>();
} 
```

这并没有多大作用，但是当泛型类型很长（或嵌套；即`Map<String, List<String>>`）时，它确实减少了一些混乱。

* * *

## 回答 #13

> 赞同：2
> 
> 时间：2008-09-16T22:04:31.740

正如 Mitchel 所指出的，主要优势是无需定义多个类的强类型。

这样，您可以执行以下操作：

```
List<SomeCustomClass> blah = new List<SomeCustomClass>();
blah[0].SomeCustomFunction(); 
```

如果没有泛型，您必须将 blah[0] 转换为正确的类型才能访问其功能。

* * *

## 回答 #14

> 赞同：2
> 
> 时间：2008-09-16T22:26:10.283

jvm 无论如何都会强制转换......它隐式地创建将泛型类型视为“对象”的代码，并创建对所需实例化的强制转换。Java 泛型只是语法糖。

* * *

## 回答 #15

> 赞同：2
> 
> 时间：2008-09-17T02:28:06.757

我知道这是一个 C# 问题，但[泛型](http://en.wikipedia.org/wiki/Generic_programming)也用于其他语言，它们的用途/目标非常相似。

Java 集合从 Java 1.5 开始使用[泛型。](http://en.wikipedia.org/wiki/Generics_in_Java)因此，使用它们的好地方是当您创建自己的类似集合的对象时。

我几乎在任何地方都能看到的一个例子是 Pair 类，它包含两个对象，但需要以通用方式处理这些对象。

```
class Pair<F, S> {
    public final F first;
    public final S second;

    public Pair(F f, S s)
    { 
        first = f;
        second = s;   
    }
} 
```

每当您使用这个 Pair 类时，您都可以指定您希望它处理哪种类型的对象，并且任何类型转换问题都将在编译时出现，而不是在运行时出现。

泛型也可以使用关键字“super”和“extends”定义其边界。例如，如果你想处理一个泛型类型，但你想确保它扩展了一个名为 Foo 的类（它有一个 setTitle 方法）：

```
public class FooManager <F extends Foo>{
    public void setTitle(F foo, String title) {
        foo.setTitle(title);
    }
} 
```

虽然它本身不是很有趣，但知道每当您处理 FooManager 时，您知道它将处理 MyClass 类型，并且 MyClass 扩展了 Foo 是很有用的。

* * *

## 回答 #16

> 赞同：2
> 
> 时间：2009-06-04T23:49:51.427

来自 Sun Java 文档，以回应“我为什么要使用泛型？”：

“泛型为您提供了一种将集合的类型传达给编译器的方法，以便对其进行检查。一旦编译器知道集合的元素类型，编译器就可以检查您是否一致地使用了该集合并可以插入对从集合中取出的值进行正确的强制转换...使用泛型的代码更清晰、更安全....**编译器可以在编译时验证在运行时没有违反类型约束**[强调我的]。因为程序编译时没有警告，我们可以肯定地说它不会在运行时抛出 ClassCastException。使用泛型的净效果，尤其是在大型程序中，**提高了可读性和鲁棒性**。[强调我的]“

* * *

## 回答 #17

> 赞同：1
> 
> 时间：2008-09-16T21:59:30.677

泛型允许您创建强类型的对象，但您不必定义特定类型。我认为最有用的例子是 List 和类似的类。

使用通用列表，您可以拥有任何您想要的列表列表，并且您始终可以引用强类型，您不必转换或像使用数组或标准列表那样做任何事情。

* * *

## 回答 #18

> 赞同：1
> 
> 时间：2008-09-16T22:00:44.107

泛型允许您对应该能够容纳任何对象的对象和数据结构使用强类型。在从通用结构（装箱/拆箱）中检索对象时，它还消除了繁琐且昂贵的类型转换。

一个同时使用两者的例子是链表。如果链表类只能使用对象 Foo，它会有什么好处？要实现可以处理任何类型对象的链表，如果您希望列表仅包含一种类型的对象，则链表和假设节点内部类中的节点必须是通用的。

* * *

## 回答 #19

> 赞同：1
> 
> 时间：2008-09-16T22:01:49.687

如果您的集合包含值类型，则它们在插入集合时不需要对对象进行装箱/取消装箱，因此您的性能会显着提高。像 resharper 这样的很酷的插件可以为你生成更多的代码，比如 foreach 循环。

* * *

## 回答 #20

> 赞同：1
> 
> 时间：2008-09-16T22:29:00.013

使用泛型（尤其是集合/列表）的另一个优点是您可以获得编译时类型检查。这在使用通用列表而不是对象列表时非常有用。

* * *

## 回答 #21

> 赞同：1
> 
> 时间：2008-09-16T22:30:18.077

最重要的一个原因是它们提供**了类型安全**

```
List<Customer> custCollection = new List<Customer>; 
```

相反，

```
object[] custCollection = new object[] { cust1, cust2 }; 
```

作为一个简单的例子。

* * *

## 回答 #22

> 赞同：1
> 
> 时间：2008-09-16T22:32:08.727

总之，泛型允许您更精确地指定您打算做什么（更强的类型）。

这对您有几个好处：

*   因为编译器更了解你想要做什么，它允许你省略很多类型转换，因为它已经知道类型是兼容的。

*   这还可以让您更早地获得有关程序正确性的反馈。以前在运行时会失败的事情（例如，因为无法将对象转换为所需的类型），现在在编译时会失败，您可以在测试部门提交神秘的错误报告之前修复错误。

*   编译器可以做更多的优化，比如避免装箱等。

* * *

## 回答 #23

> 赞同：1
> 
> 时间：2008-09-17T01:50:54.113

需要添加/扩展的几件事（从 .NET 的角度来看）：

泛型类型允许您创建基于角色的类和接口。这已经在更基本的术语中说过了，但是我发现您开始使用以与类型无关的方式实现的类来设计代码 - 这会产生高度可重用的代码。

方法上的通用参数可以做同样的事情，但它们也有助于将“告诉不要问”原则应用于强制转换，即“给我我想要的，如果你不能，你告诉我为什么”。

* * *

## 回答 #24

> 赞同：1
> 
> 时间：2009-06-04T23:42:37.040

例如，我在使用 SpringORM 和 Hibernate 实现的 GenericDao 中使用它们，看起来像这样

```
public abstract class GenericDaoHibernateImpl<T> 
    extends HibernateDaoSupport {

    private Class<T> type;

    public GenericDaoHibernateImpl(Class<T> clazz) {
        type = clazz;
    }

    public void update(T object) {
        getHibernateTemplate().update(object);
    }

    @SuppressWarnings("unchecked")
    public Integer count() {
    return ((Integer) getHibernateTemplate().execute(
        new HibernateCallback() {
            public Object doInHibernate(Session session) {
                    // Code in Hibernate for getting the count
                }
        }));
    }
  .
  .
  .
} 
```

通过使用泛型，我对这个 DAO 的实现强制开发人员只通过子类化 GenericDao 来传递它们为它们设计的实体

```
public class UserDaoHibernateImpl extends GenericDaoHibernateImpl<User> {
    public UserDaoHibernateImpl() {
        super(User.class);     // This is for giving Hibernate a .class
                               // work with, as generics disappear at runtime
    }

    // Entity specific methods here
} 
```

*我的小框架更健壮（具有过滤、延迟加载、搜索等功能）。我只是在这里简化了给你一个例子*

我和史蒂夫和你一样，一开始说*“太乱太复杂”*，但现在我看到了它的优点

* * *

## 回答 #25

> 赞同：1
> 
> 时间：2018-06-29T14:21:02.057

已经提到了诸如“类型安全”和“无强制转换”之类的明显好处，所以也许我可以谈谈其他一些“好处”，我希望它会有所帮助。

首先，泛型是一个独立于语言的概念，IMO，如果您同时考虑常规（运行时）多态性，它可能更有意义。

例如，我们从面向对象设计中知道的多态性有一个运行时概念，其中调用者对象在运行时随着程序执行的进行而被计算出来，并根据运行时类型相应地调用相关方法。在泛型中，这个想法有点相似，但一切都发生在编译时。这是什么意思以及你如何使用它？

（让我们坚持使用泛型方法以保持紧凑）这意味着您仍然可以在不同的类上使用相同的方法（就像您之前在多态类中所做的那样）但是这次它们是由编译器自动生成的，取决于类型集在编译时。你在编译时给你的类型参数化你的方法。**因此，与其像在运行时多态性（方法覆盖）中那样为每个类型**从头编写方法，不如让编译器在编译期间完成工作。这有一个明显的优势，因为您不需要推断系统中可能使用的所有可能类型，这使得它在不更改代码的情况下更具可扩展性。

类的工作方式几乎相同。您对类型进行参数化，代码由编译器生成。

一旦您了解了“编译时间”的概念，您就可以使用“有界”类型并限制可以通过类/方法作为参数化类型传递的内容。因此，您可以控制要传递的内容，这是一个强大的东西，尤其是您有一个被其他人使用的框架。

```
public interface Foo<T extends MyObject> extends Hoo<T>{
    ...
} 
```

现在没有人可以设置除了 MyObject 之外的东西。

此外，您可以对方法参数“强制”类型约束，这意味着您可以确保两个方法参数都依赖于相同的类型。

```
public <T extends MyObject> foo(T t1, T t2){
    ...
} 
```

希望所有这些都有意义。

* * *

## 回答 #26

> 赞同：0
> 
> 时间：2008-09-17T02:36:25.940

我曾经就这个话题发表过演讲。[您可以在http://www.adventuresinsoftware.com/generics/](http://www.adventuresinsoftware.com/generics/)找到我的幻灯片、代码和录音。

* * *

## 回答 #27

> 赞同：0
> 
> 时间：2009-06-04T23:43:14.497

对集合使用泛型非常简单明了。即使您在其他任何地方都使用它，从收藏中获得的收益对我来说也是一种胜利。

```
List<Stuff> stuffList = getStuff();
for(Stuff stuff : stuffList) {
    stuff.do();
} 
```

对比

```
List stuffList = getStuff();
Iterator i = stuffList.iterator();
while(i.hasNext()) {
    Stuff stuff = (Stuff)i.next();
    stuff.do();
} 
```

或者

```
List stuffList = getStuff();
for(int i = 0; i < stuffList.size(); i++) {
    Stuff stuff = (Stuff)stuffList.get(i);
    stuff.do();
} 
```

仅此一项就值得仿制药的边际“成本”，而且您不必成为仿制药大师即可使用它并获得价值。

* * *

## 回答 #28

> 赞同：0
> 
> 时间：2009-06-05T00:00:57.630

泛型还使您能够创建更多可重用的对象/方法，同时仍提供特定于类型的支持。在某些情况下，您还会获得很多性能。我不知道 Java 泛型的完整规范，但在 .NET 中，我可以指定对 Type 参数的约束，例如实现接口、构造函数和派生。

* * *

## 回答 #29

> 赞同：0
> 
> 时间：2020-10-30T21:53:52.720

1.  使程序员能够实现泛型算法 - 通过使用泛型，程序员可以实现适用于不同类型集合的泛型算法，可以自定义，并且是类型安全的并且更易于阅读。

2.  Stronger type checks at compile time - A Java compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find.

3.  Elimination of casts.

# asp.net - SWFAddress 深层链接和 C# 库？

> ID：77637
> 
> 赞同：1
> 
> 时间：2008-09-16T21:58:03.037
> 
> 标签：asp.net, flash

是否有用于与 SWFAddress 深层链接 URL 字符串交互的 C# 类（读取深层链接参数、构建 SWFAddress URL 等）？计划自己写一个，否则；但我想确保我没有先重新发明轮子。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T19:01:57.993

如果您尝试在服务器端读取那些深层链接 URL（我假设您是），请知道这是不可能的。

这些深度链接系统使用 URL 的片段部分（哈希 ( `#`) 符号之后的部分）来指定浏览器 URL 中 Flash 应用程序的特定部分，并且在发出请求时，浏览器不会将片段发送到 Web 服务器——它们只是为了让浏览器能够自行移动到页面的某个部分。

因此，为了访问完整的深度链接 URL，您必须编写客户端解决方案（例如使用 Javascript 或 AS3）。

# exception - 构造函数什么时候抛出异常合适？

> ID：77639
> 
> 赞同：244
> 
> 时间：2008-09-16T21:58:08.013
> 
> 标签：exception, language-agnostic, constructor

构造函数什么时候抛出异常合适？（或者在 Objective C 的情况下：init'er 什么时候返回 nil 是正确的？）

在我看来，如果对象不完整，构造函数应该失败——因此拒绝创建对象。即，构造函数应该与其调用者签订合同，以提供可以有意义地调用哪些方法的功能和工作对象？这合理吗？

* * *

## 回答 #1

> 赞同：330
> 
> 时间：2008-09-16T22:03:59.713

构造函数的工作是使对象进入可用状态。基本上有两种思想流派。

一组赞成两阶段建设。构造函数只是将对象带入休眠状态，在这种状态下它拒绝做任何工作。还有一个额外的函数可以进行实际的初始化。

我从来不明白这种方法背后的原因。我坚定地支持一阶段构造，其中对象在构造后完全初始化并可用。

如果无法完全初始化对象，一阶段构造函数应该抛出。如果对象不能被初始化，就一定不允许它存在，所以构造函数必须抛出。

* * *

## 回答 #2

> 赞同：71
> 
> 时间：2008-09-16T22:11:36.513

[Eric Lippert 说](https://blogs.msdn.microsoft.com/ericlippert/2008/09/10/vexing-exceptions/)有 4 种例外。

*   致命异常不是您的错，您无法阻止它们，也无法明智地清除它们。
*   愚蠢的异常是您自己的错误，您可以阻止它们，因此它们是您代码中的错误。
*   令人烦恼的异常是不幸的设计决策的结果。令人烦恼的异常是在完全非异常的情况下抛出的，因此必须一直被捕获和处理。
*   最后，外生异常似乎有点像令人烦恼的异常，只是它们不是不幸的设计选择的结果。相反，它们是杂乱的外部现实影响你美丽、清晰的程序逻辑的结果。

你的构造函数不应该自己抛出一个致命的异常，但是它执行的代码可能会导致一个致命的异常。诸如“内存不足”之类的事情不是您可以控制的，但是如果它发生在构造函数中，嘿，它就会发生。

愚蠢的异常绝不应该出现在您的任何代码中，因此它们是正确的。

构造函数不应该抛出令人烦恼的异常（例如`Int32.Parse()`），因为它们没有非异常情况。

最后，应该避免外生异常，但是如果你在构造函数中做一些依赖于外部环境（如网络或文件系统）的事情，那么抛出异常是合适的。

参考链接：[https ://blogs.msdn.microsoft.com/ericlippert/2008/09/10/vexing-exceptions/](https://blogs.msdn.microsoft.com/ericlippert/2008/09/10/vexing-exceptions/)

* * *

## 回答 #3

> 赞同：36
> 
> 时间：2008-09-17T12:07:01.497

将对象初始化与构造分离通常**不会**获得任何好处。RAII 是正确的，对构造函数的成功调用应该导致完全初始化的活动对象或者应该失败，并且任何代码路径中任何点的**所有**失败都应该总是抛出异常。使用单独的 init() 方法除了在某种程度上增加了复杂性之外，您什么也得不到。ctor 合约应该是它返回一个功能有效的对象，或者它自己清理并抛出。

考虑一下，如果你实现一个单独的 init 方法，你**仍然**必须调用它。它仍然有可能抛出异常，它们仍然必须被处理，并且它们实际上总是必须在构造函数之后立即调用，除非现在你有 4 个可能的对象状态而不是 2 个（IE、构造、初始化、未初始化、并且失败与有效且不存在）。

无论如何，我在 25 年的 OO 开发案例中遇到过，似乎单独的 init 方法可以“解决一些问题”是设计缺陷。如果您现在不需要一个对象，那么您现在不应该构造它，如果您现在确实需要它，那么您需要初始化它。KISS 应该始终是遵循的原则，以及任何接口的行为、状态和 API 应该反映对象做什么而不是如何做的简单概念，客户端代码甚至不应该知道对象有任何种类需要初始化的内部状态，因此 init after 模式违反了这一原则。

* * *

## 回答 #4

> 赞同：9
> 
> 时间：2017-03-20T20:18:18.237

据我所知，没有人提出一个相当明显的解决方案，它体现了一级和二级结构的最佳效果。

**注意：**此答案假定 C#，但原则可以应用于大多数语言。

首先，两者的好处：

## 一级

一阶段构造通过防止对象以无效状态存在来使我们受益，从而防止各种错误的状态管理以及随之而来的所有错误。然而，它让我们中的一些人感到奇怪，因为我们不希望我们的构造函数抛出异常，有时这就是我们需要在初始化参数无效时做的事情。

```
public class Person
{
    public string Name { get; }
    public DateTime DateOfBirth { get; }

    public Person(string name, DateTime dateOfBirth)
    {
        if (string.IsNullOrWhitespace(name))
        {
            throw new ArgumentException(nameof(name));
        }

        if (dateOfBirth > DateTime.UtcNow) // side note: bad use of DateTime.UtcNow
        {
            throw new ArgumentOutOfRangeException(nameof(dateOfBirth));
        }

        this.Name = name;
        this.DateOfBirth = dateOfBirth;
    }
} 
```

## 两阶段通过验证方法

通过允许在构造函数之外执行验证，两阶段构造使我们受益，因此避免了在构造函数中引发异常的需要。然而，它给我们留下了“无效”的实例，这意味着我们必须为实例跟踪和管理状态，或者我们在堆分配后立即将其丢弃。它引出了一个问题：为什么我们要在一个我们甚至没有最终使用的对象上执行堆分配，从而进行内存收集？

```
public class Person
{
    public string Name { get; }
    public DateTime DateOfBirth { get; }

    public Person(string name, DateTime dateOfBirth)
    {
        this.Name = name;
        this.DateOfBirth = dateOfBirth;
    }

    public void Validate()
    {
        if (string.IsNullOrWhitespace(Name))
        {
            throw new ArgumentException(nameof(Name));
        }

        if (DateOfBirth > DateTime.UtcNow) // side note: bad use of DateTime.UtcNow
        {
            throw new ArgumentOutOfRangeException(nameof(DateOfBirth));
        }
    }
} 
```

## 通过私有构造函数的单阶段

那么我们如何才能让构造函数不发生异常，并防止自己对将立即丢弃的对象执行堆分配呢？这是非常基本的：我们将构造函数设为私有，并通过指定用于执行实例化的静态方法创建实例，因此只有***在***验证之后才会进行堆分配。

```
public class Person
{
    public string Name { get; }
    public DateTime DateOfBirth { get; }

    private Person(string name, DateTime dateOfBirth)
    {
        this.Name = name;
        this.DateOfBirth = dateOfBirth;
    }

    public static Person Create(
        string name,
        DateTime dateOfBirth)
    {
        if (string.IsNullOrWhitespace(Name))
        {
            throw new ArgumentException(nameof(name));
        }

        if (dateOfBirth > DateTime.UtcNow) // side note: bad use of DateTime.UtcNow
        {
            throw new ArgumentOutOfRangeException(nameof(DateOfBirth));
        }

        return new Person(name, dateOfBirth);
    }
} 
```

## 通过私有构造函数进行异步单阶段

除了前面提到的验证和防止堆分配的好处之外，之前的方法还为我们提供了另一个不错的优势：异步支持。这在处理多阶段身份验证时会派上用场，例如当您需要在使用 API 之前检索不记名令牌时。这样，您就不会得到一个无效的“已注销”API 客户端，相反，如果您在尝试执行请求时收到授权错误，您可以简单地重新创建 API 客户端。

```
public class RestApiClient
{
    public RestApiClient(HttpClient httpClient)
    {
        this.httpClient = new httpClient;
    }

    public async Task<RestApiClient> Create(string username, string password)
    {
        if (username == null)
        {
            throw new ArgumentNullException(nameof(username));
        }

        if (password == null)
        {
            throw new ArgumentNullException(nameof(password));
        }

        var basicAuthBytes = Encoding.ASCII.GetBytes($"{username}:{password}");
        var basicAuthValue = Convert.ToBase64String(basicAuthBytes);

        var authenticationHttpClient = new HttpClient
        {
            BaseUri = new Uri("https://auth.example.io"),
            DefaultRequestHeaders = {
                Authentication = new AuthenticationHeaderValue("Basic", basicAuthValue)
            }
        };

        using (authenticationHttpClient)
        {
            var response = await httpClient.GetAsync("login");
            var content = response.Content.ReadAsStringAsync();
            var authToken = content;
            var restApiHttpClient = new HttpClient
            {
                BaseUri = new Uri("https://api.example.io"), // notice this differs from the auth uri
                DefaultRequestHeaders = {
                    Authentication = new AuthenticationHeaderValue("Bearer", authToken)
                }
            };

            return new RestApiClient(restApiHttpClient);
        }
    }
} 
```

根据我的经验，这种方法的缺点很少。

通常，使用这种方法意味着您不能再将类用作 DTO，因为在没有公共默认构造函数的情况下反序列化到对象是困难的，充其量。但是，如果您将对象用作 DTO，则不应真正验证对象本身，而是在尝试使用对象时使对象上的值无效，因为从技术上讲，这些值并不是“无效”的到 DTO。

这也意味着当您需要允许 IOC 容器创建对象时，您最终将创建工厂方法或类，否则容器将不知道如何实例化对象。然而，在很多情况下，工厂方法最终成为`Create`方法本身之一。

* * *

## 回答 #5

> 赞同：7
> 
> 时间：2008-09-16T22:01:49.563

由于部分创建的类可能导致的所有麻烦，我会说永远不会。

如果您需要在构造过程中验证某些内容，请将构造函数设为私有并定义一个公共静态工厂方法。如果某些内容无效，该方法可以抛出。但是如果一切都检查了，它会调用构造函数，保证不会抛出。

* * *

## 回答 #6

> 赞同：6
> 
> 时间：2008-09-16T22:30:04.520

当构造函数无法完成所述对象的构造时，它应该抛出异常。

例如，如果构造函数应该分配 1024 KB 的 ram，但它没有这样做，它应该抛出一个异常，这样构造函数的调用者就知道该对象还没有准备好使用并且有错误需要修复的地方。

半初始化半死的对象只会导致问题和问题，因为调用者确实无法知道。我宁愿让我的构造函数在出现问题时抛出错误，而不是依赖编程来运行对返回 true 或 false 的 isOK() 函数的调用。

* * *

## 回答 #7

> 赞同：5
> 
> 时间：2008-09-16T22:03:29.700

它总是很狡猾，尤其是当你在构造函数中分配资源时；根据您的语言，不会调用析构函数，因此您需要手动清理。这取决于对象的生命周期在您的语言中是如何开始的。

我真正做到的唯一一次是当某处存在安全问题时，这意味着不应该创建对象，而不是不能创建对象。

* * *

## 回答 #8

> 赞同：5
> 
> 时间：2008-09-16T22:06:07.197

构造函数抛出异常是合理的，只要它正确地清理自己。如果您遵循[RAII](http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)范式（资源获取即初始化），那么构造函数做有意义的工作**是很常见的；**如果不能完全初始化，编写良好的构造函数将依次清理自身。

* * *

## 回答 #9

> 赞同：3
> 
> 时间：2008-09-16T22:04:55.623

请参阅 C++ FAQ 第[17.2](http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.2)和[17.4](http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.4)节。

一般来说，我发现如果编写构造函数以便它们不会失败，那么代码更容易移植和维护结果，并且可能失败的代码被放置在一个单独的方法中，该方法返回错误代码并使对象处于惰性状态.

* * *

## 回答 #10

> 赞同：3
> 
> 时间：2008-12-23T17:28:59.623

如果您正在编写 UI 控件（ASPX、WinForms、WPF...），则应避免在构造函数中引发异常，因为设计器（Visual Studio）在创建控件时无法处理它们。了解您的控件生命周期（控件事件）并尽可能使用延迟初始化。

* * *

## 回答 #11

> 赞同：3
> 
> 时间：2011-02-15T16:13:25.220

请注意，如果您在初始化程序中抛出异常，如果任何代码使用该`[[[MyObj alloc] init] autorelease]`模式，您最终会泄漏，因为异常将跳过自动释放。

看到这个问题：

[在 init 中引发异常时如何防止泄漏？](https://stackoverflow.com/questions/5005852/how-do-you-prevent-leaks-when-raising-an-exception-in-init)

* * *

## 回答 #12

> 赞同：2
> 
> 时间：2008-09-16T22:08:23.323

如果您无法创建有效对象，您绝对应该从构造函数中抛出异常。这使您可以在类中提供适当的不变量。

在实践中，您可能必须非常小心。请记住，在 C++ 中，不会调用析构函数，因此如果在分配资源后抛出异常，则需要非常小心地正确处理！

[此页面](http://www.gotw.ca/gotw/066.htm)对 C++ 中的情况进行了彻底的讨论。

* * *

## 回答 #13

> 赞同：2
> 
> 时间：2008-09-16T22:38:11.113

如果您无法在构造函数中初始化对象，则抛出异常，例如非法参数。

作为一般经验法则，应始终尽快抛出异常，因为当问题的根源更接近发出错误信号的方法时，它会使调试更容易。

* * *

## 回答 #14

> 赞同：1
> 
> 时间：2008-09-16T22:06:25.120

是的，如果构造函数未能构建其内部部分之一，则可以选择由其负责抛出（并以某种语言声明）[显式异常](https://stackoverflow.com/questions/27578/when-to-choose-checked-and-unchecked-exceptions)，并在构造函数文档中适当地注明。

这不是唯一的选择：它可以完成构造函数并构建一个对象，但方法“isCoherent()”返回 false，以便能够发出不连贯状态的信号（在某些情况下可能更可取，以便避免由于异常导致执行工作流的残酷中断）
警告：正如 EricSchaefer 在他的评论中所说，这可能会给单元测试带来一些复杂性（由于触发条件，抛出会增加函数的[圈复杂度](http://en.wikipedia.org/wiki/Cyclomatic_complexity)它）

如果由于调用者而失败（如调用者提供的空参数，被调用的构造函数需要一个非空参数），构造函数无论如何都会抛出未经检查的运行时异常。

* * *

## 回答 #15

> 赞同：1
> 
> 时间：2008-09-16T22:08:10.967

在构造过程中抛出异常是使代码更复杂的好方法。看似简单的事情突然变得困难了。例如，假设您有一个堆栈。你如何弹出堆栈并返回顶部值？好吧，如果堆栈中的对象可以在它们的构造函数中抛出（构造临时返回给调用者），你不能保证你不会丢失数据（递减堆栈指针，使用 value in 的复制构造函数构造返回值堆栈，它会抛出，现在有一个堆栈刚刚丢失了一个项目）！这就是为什么 std::stack::pop 不返回值，而你必须调用 std::stack::top 的原因。

这个问题[在这里](http://books.google.com/books?id=mT7E5gDuW_4C&pg=PA39&lpg=PA39&dq=exception+safe+stack+pop&source=web&ots=AXUQyXfWkW&sig=0c3POTY82SsQ5-zNUWTzSNIoRu0&hl=en&sa=X&oi=book_result&resnum=3&ct=result#PPA32,M1)有很好的描述，检查第 10 条，编写异常安全代码。

* * *

## 回答 #16

> 赞同：1
> 
> 时间：2008-09-16T22:10:24.317

OO 中通常的约定是对象方法确实起作用。

因此，作为推论，永远不要从构造函数/初始化中返回僵尸对象。

僵尸不起作用，可能缺少内部组件。只是等待发生的空指针异常。

很多年前，我第一次在 Objective C 中制作僵尸。

像所有经验法则一样，有一个“例外”。

完全有可能一个*特定的接口*可能有一个合同，说存在一个允许异常的“初始化”方法。实现此接口的对象可能无法正确响应除属性设置器之外的任何调用，直到调用了 initialize。我在引导过程中将它用于 OO 操作系统中的设备驱动程序，它是可行的。

通常，您不想要僵尸对象。在 Smalltalk 之类的语言中，使用**become**时会变得有点杂乱无章，但过度使用*become*也是不好的风格。*成为让一个对象就地变为另一个对象，因此不需要信封包装器（高级 C++）或策略模式（GOF）。*

* * *

## 回答 #17

> 赞同：1
> 
> 时间：2008-09-16T22:18:01.553

我无法解决 Objective-C 中的最佳实践，但在 C++ 中，构造函数抛出异常是可以的。特别是因为没有其他方法可以确保在不调用 isOK() 方法的情况下报告构造中遇到的异常情况。

函数 try 块特性是专门为支持构造函数成员初始化中的失败而设计的（尽管它也可以用于常规函数）。这是修改或丰富将抛出的异常信息的唯一方法。但是由于其最初的设计目的（在构造函数中使用），它不允许异常被空的 catch() 子句吞噬。

* * *

## 回答 #18

> 赞同：1
> 
> 时间：2018-02-28T15:38:06.580

我不确定任何答案是否完全与语言无关。某些语言处理异常和内存管理的方式不同。

我之前在编码标准下工作过，要求从不使用异常，并且只在初始化程序上使用错误代码，因为开发人员已经被处理异常的语言所困扰。没有垃圾收集的语言将处理堆和堆栈非常不同，这可能对非 RAII 对象很重要。尽管团队决定保持一致很重要，但他们默认知道是否需要在构造函数之后调用初始化程序。所有方法（包括构造函数）也应该详细记录它们可以抛出的异常，以便调用者知道如何处理它们。

我通常赞成单阶段构造，因为很容易忘记初始化对象，但也有很多例外。

*   您对异常的语言支持不是很好。
*   你有一个紧迫的设计理由仍然使用`new`和`delete`
*   您的初始化是处理器密集型的，应该与创建对象的线程异步运行。
*   您正在创建一个 DLL，该 DLL 可能会在其与使用不同语言的应用程序的接口之外引发异常。在这种情况下，可能不是不抛出异常的问题，而是确保它们在公共接口之前被捕获。（您可以在 C# 中捕获 C++ 异常，但需要跳过一些障碍。）
*   静态构造函数 (C#)

* * *

## 回答 #19

> 赞同：1
> 
> 时间：2018-07-11T04:31:51.370

OP 的问题有一个“与语言无关”的标签……对于所有语言/情况，这个问题不能以同样的方式安全地回答。

以下 C# 示例的类层次结构抛出类 B 的构造函数，`IDisposeable.Dispose`在退出 main时跳过对类 A 的立即调用，跳过`using`对 A 类资源的显式处置。

例如，如果 A 类创建了一个`Socket`连接到网络资源的 at 结构，那么在`using`块之后可能仍然是这种情况（一个相对隐藏的异常）。

```
class A : IDisposable
{
    public A()
    {
        Console.WriteLine("Initialize A's resources.");
    }

    public void Dispose()
    {
        Console.WriteLine("Dispose A's resources.");
    }
}

class B : A, IDisposable
{
    public B()
    {
        Console.WriteLine("Initialize B's resources.");
        throw new Exception("B construction failure: B can cleanup anything before throwing so this is not a worry.");
    }

    public new void Dispose()
    {
        Console.WriteLine("Dispose B's resources.");
        base.Dispose();
    }
}
class C : B, IDisposable
{
    public C()
    {
        Console.WriteLine("Initialize C's resources. Not called because B throws during construction. C's resources not a worry.");
    }

    public new void Dispose()
    {
        Console.WriteLine("Dispose C's resources.");
        base.Dispose();
    }
}

class Program
{
    static void Main(string[] args)
    {
        try
        {
            using (C c = new C())
            {
            }
        }
        catch
        {           
        }

        // Resource's allocated by c's "A" not explicitly disposed.
    }
} 
```

* * *

## 回答 #20

> 赞同：0
> 
> 时间：2008-09-16T22:10:16.937

严格来说，从 Java 的角度来看，任何时候你用非法值初始化一个构造函数，它都应该抛出一个异常。这样它就不会在糟糕的状态下构建。

* * *

## 回答 #21

> 赞同：0
> 
> 时间：2008-09-16T22:10:22.867

对我来说，这是一个有点哲学的设计决定。

从 ctor 时间开始，拥有只要它们存在就有效的实例是非常好的。对于许多不平凡的情况，如果无法进行内存/资源分配，这可能需要从 ctor 抛出异常。

其他一些方法是 init() 方法，它本身就有一些问题。其中之一是确保 init() 实际被调用。

一个变体使用惰性方法在第一次调用访问器/修改器时自动调用 init()，但这要求任何潜在的调用者都必须担心对象是否有效。（与“它存在，因此它是有效的哲学”相反）。

我也看到了各种提议的设计模式来处理这个问题。例如能够通过 ctor 创建一个初始对象，但必须调用 init() 来获得一个包含访问器/突变器的初始化对象。

每种方法都有其起伏；我已经成功地使用了所有这些。如果您没有从创建即用型对象开始制作它们，那么我建议使用大量断言或异常以确保用户不会在 init() 之前进行交互。

**附录**

我是从 C++ 程序员的角度写的。我还假设您正确使用 RAII 习惯用法来处理引发异常时释放的资源。

* * *

## 回答 #22

> 赞同：0
> 
> 时间：2008-09-17T17:11:05.150

使用工厂或工厂方法创建所有对象，可以避免无效对象，而不会从构造函数中抛出异常。如果创建方法能够创建一个对象，则创建方法应返回所请求的对象，否则返回 null。您在处理类用户的构造错误时失去了一点灵活性，因为返回 null 并不能告诉您创建对象时出了什么问题。但它也避免了每次请求对象时增加多个异常处理程序的复杂性，以及捕获不应处理的异常的风险。

* * *

## 回答 #23

> 赞同：0
> 
> 时间：2017-10-12T08:41:25.423

我见过的关于异常的最佳建议是，当且仅当替代方案是未能满足后置条件或保持不变量时才抛出异常。

该建议用基于您应该已经做出的设计决策（不变和后置条件）的技术性、精确性问题取代了不清楚的主观决定（这是一个*好主意）。*

构造函数只是该建议的一个特殊情况，但不是特殊情况。那么问题就变成了，一个类应该有哪些不变量？提倡在构造后调用单独的初始化方法，是建议该类具有两种或多种*操作模式*，构造后具有未*就绪*模式，并且在初始化后进入至少一种*就绪模式。*这是一个额外的复杂性，但如果该类无论如何都有多种操作模式，则可以接受。如果该类没有操作模式，那么很难看出这种复杂性是多么值得。

请注意，将设置推送到单独的初始化方法中并不能避免引发异常。您的构造函数可能抛出的异常现在将由初始化方法抛出。如果为未初始化的对象调用类的所有有用方法，则它们都必须抛出异常。

另请注意，避免构造函数抛出异常的可能性很麻烦，而且在许多标准库中在许多情况下*是不可能的。*这是因为这些库的设计者认为从构造函数中抛出异常是个好主意。特别是，任何尝试获取不可共享或有限资源（例如分配内存）的操作都可能失败，并且该失败通常在 OO 语言和库中通过抛出异常来指示。

# browser - 最佳实践：如何处理浏览器和网站导航的并发性

> ID：77645
> 
> 赞同：0
> 
> 时间：2008-09-16T21:58:28.573
> 
> 标签：browser, navigation, struts

对于每个 Web 开发人员来说，这是一个众所周知的问题。至于我试图找到解决这个问题的好方法 - 没有（或者至少我找不到）。

### *让我们假设以下内容：*

***用户的行为不像他预期的那样。***我正在从事的实际项目使用 Web 门户中的导航。但是如果用户使用浏览器的后退按钮，整个事情就会变得危险[？]，结果并不总是可以预测的。

我们使用了 struts 框架并将 back-url 存储到表单中——在某些地方，我们需要一个 back-url——这已经从这个表单的 back-url 中呈现出来。因为该信息只有一个字段，因此不可能返回多个步骤。

当您更改“struts-flow”时——这可能会导致使用**不同的表单**——这些信息将会丢失。

如果用户敢在您的 web 应用程序中的某处放置**书签**- 此信息可能从未设置过，结果将再次变得不可预测或不够灵活！

**我的“解决方案”**：

我将用户访问的每个导航相关页面存储到**类似堆栈的**存储中到**session**中。这意味着收集并存储导航路径以供以后导航。

在 webapp 中涉及反向导航的任何页面上，我使用了一个自制标签，它将堆栈内容呈现到 url 中。

**就是这样**。当单击此反向 URL 时，堆栈已被用户单击的反向 URL 中的内容填充（一旦呈现反向链接，它将保存堆栈中的所有信息）。

这很清楚，因为单击链接是一个清晰的状态，Web 开发人员确切地知道此时用户“在”哪里 - 绝对独立于用户之前所做的任何事情（例如多次点击浏览器后退按钮次）。然后导航堆栈建立在这个新状态之上。

**简历：** 很明显，这不是最好的解决方案。但它允许在堆栈上存储额外的信息，如页面参数和其他一些有用的东西（可能的进一步开发）。

**那么，您对这个问题的解决方案是什么？**

干杯，

法力

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T22:13:33.293

堆栈解决方案听起来很有趣，但如果用户选择在不同选项卡上“并行”导航或使用书签，它可能会中断。

恐怕我真的不明白为什么你必须为每个用户保留所有这些状态：理想情况下，网络应该遵循[REST 原则](http://en.wikipedia.org/wiki/REST)并且完全无状态。因此，单个 URL 应该标识单个资源，而不必保留每个用户的导航历史记录。

如果您的 Web 应用程序严重依赖 AJAX，您可以尝试实现类似 GMail 的东西（诚然，这并不容易......），其中界面中的每个更改都会反映在页面 URL 的更改中。因此，每个页面都由当前 URL 标识，用户可以同时导航或像往常一样使用后退按钮。

# c# - .NET WebBrowser 控件中的阻止对话框

> ID：77659
> 
> 赞同：19
> 
> 时间：2008-09-16T22:00:27.820
> 
> 标签：c#, .net, winforms, activex, mshtml

我有一个 .NET **2.0** WebBrowser 控件，用于在没有用户交互的情况下导航某些页面（不要问......长篇大论）。由于此应用程序的无用户特性，我已将 WebBrowser 控件的 ScriptErrorsSuppressed 属性设置为 true，VS 2005 中包含的文档将 [...]“隐藏其所有源自底层 ActiveX 控件的对话框，不仅仅是脚本错误。” 但是，[MSDN 文章](http://msdn.microsoft.com/en-us/library/system.windows.forms.webbrowser.scripterrorssuppressed(VS.80).aspx)没有提到这一点。我已经设法取消了 NewWindow 事件，它可以防止弹出窗口，所以已经处理好了。

任何人都有使用其中之一并成功阻止**所有**对话框、脚本错误等的经验吗？

**编辑**

这不是 IE 的独立实例，而是位于 Windows 窗体应用程序上的 WebBrowser 控件的实例。**任何人都对此控件或底层控件AxSHDocVW**有任何经验吗？

**再次编辑**

对不起，我忘了提这个...我试图阻止**JavaScript alert()**，只有一个 OK 按钮。也许我可以转换为 IHTMLDocument2 对象并以这种方式访问​​脚本，我已经使用了一点 MSHTML，有人知道吗？

* * *

## 回答 #1

> 赞同：13
> 
> 时间：2008-10-30T19:53:46.730

要获得一种简单的方法来注入那条神奇的 javascript 行，请阅读[如何将 javascript 注入 webbrowser 控件](https://stackoverflow.com/questions/153748/webbrowser-control-from-net-how-to-inject-javascript)。

或者只是使用这个完整的代码：

```
private void InjectAlertBlocker() {
    HtmlElement head = webBrowser1.Document.GetElementsByTagName("head")[0];
    HtmlElement scriptEl = webBrowser1.Document.CreateElement("script");
    string alertBlocker = "window.alert = function () { }";
    scriptEl.SetAttribute("text", alertBlocker);
    head.AppendChild(scriptEl);
} 
```

* * *

## 回答 #2

> 赞同：7
> 
> 时间：2008-09-19T12:58:18.073

这绝对是 hacky，但是如果您使用 WebBrowser 控件进行任何工作，您会发现自己在做很多 hacky 的事情。

这是我所知道的最简单的方法。您需要注入 JavaScript 来覆盖警报函数......类似于注入此 JavaScript 函数的内容：

```
window.alert = function () { } 
```

有*很多方法可以做到这一点*，但很有可能做到这一点。一种可能性是挂钩[DWebBrowserEvents2](http://msdn.microsoft.com/en-us/library/aa768283.aspx)接口的实现。完成此操作后，您可以插入 NavigateComplete、DownloadComplete 或 DocumentComplete（或者，正如我们所做的那样，它们的一些变体），然后调用您已实现的 InjectJavaScript 方法来执行此覆盖 window.alert方法。

就像我说的，hacky，但它有效:)

如果需要，我可以详细说明。

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-09-21T02:25:53.770

您可能需要自定义一些东西，看看`IDocHostUIHandler`，然后查看一些其他相关的接口。您可以拥有相当多的控制权，甚至可以自定义对话框显示/用户界面（我不记得哪个界面可以做到这一点）。我很确定你可以做你想做的事，但它确实需要在内部进行处理`MSHTML`并能够实现各种`COM`接口。

其他一些想法：http: [//msdn.microsoft.com/en-us/library/aa770041.aspx](http://msdn.microsoft.com/en-us/library/aa770041.aspx)

```
IHostDialogHelper
IDocHostShowUI 
```

这些可能是您正在考虑实施的事情。

* * *

## 回答 #4

> 赞同：6
> 
> 时间：2012-03-21T20:07:58.463

防弹警报拦截器：

```
Browser.Navigated +=
    new WebBrowserNavigatedEventHandler(
        (object sender, WebBrowserNavigatedEventArgs args) => {
            Action<HtmlDocument> blockAlerts = (HtmlDocument d) => {
                HtmlElement h = d.GetElementsByTagName("head")[0];
                HtmlElement s = d.CreateElement("script");
                IHTMLScriptElement e = (IHTMLScriptElement)s.DomElement;
                e.text = "window.alert=function(){};";
                h.AppendChild(s);
            };
            WebBrowser b = sender as WebBrowser;
            blockAlerts(b.Document);
            for (int i = 0; i < b.Document.Window.Frames.Count; i++)
                try { blockAlerts(b.Document.Window.Frames[i].Document); }
                catch (Exception) { };
        }
    ); 
```

此示例假定您在命名空间中添加了*Microsoft.mshtml*引用“ *using mshtml;* ”，并且*Browser*是您的*WebBrowser*实例。

为什么是防弹的？首先，它**处理框架内的脚本**。然后，当文档中存在特殊的*“杀手框架”时，它***不会崩溃。**“*杀手框架”*是在尝试将其用作 HtmlWindow 对象时引发异常的框架。Document.Window.Frames 上使用的任何“foreach”都会导致异常，因此必须将更安全的“for”循环与 try / catch 块一起使用。

 **也许它不是最易读的代码，但它适用于现实生活中格式错误的页面。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2011-10-26T13:10:59.853

```
webBrowser1.ScriptErrorsSuppressed = true; 
```

只需将其添加到您的入门级功能即可。经过大量研究后，我遇到了这种方法，并且触摸木头直到现在它才起作用。干杯！！

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2013-02-03T06:00:14.027

window.showModelessDialog 和 window.showModalDialog 可以通过实现 INewWindowManager 接口来阻止，另外下面的代码显示了如何通过实现 IDocHostShowUI 来阻止警报对话框

```
public class MyBrowser : WebBrowser
{

    [PermissionSetAttribute(SecurityAction.LinkDemand, Name = "FullTrust")]
    public MyBrowser()
    {
    }

    protected override WebBrowserSiteBase CreateWebBrowserSiteBase()
    {
        var manager = new NewWindowManagerWebBrowserSite(this);
        return manager;
    }

    protected class NewWindowManagerWebBrowserSite : WebBrowserSite, IServiceProvider, IDocHostShowUI
    {
        private readonly NewWindowManager _manager;

        public NewWindowManagerWebBrowserSite(WebBrowser host)
            : base(host)
        {
            _manager = new NewWindowManager();
        }

        public int ShowMessage(IntPtr hwnd, string lpstrText, string lpstrCaption, int dwType, string lpstrHelpFile, int dwHelpContext, out int lpResult)
        {
            lpResult = 0;
            return Constants.S_OK; //  S_OK Host displayed its UI. MSHTML does not display its message box.
        }

        // Only files of types .chm and .htm are supported as help files.
        public int ShowHelp(IntPtr hwnd, string pszHelpFile, uint uCommand, uint dwData, POINT ptMouse, object pDispatchObjectHit)
        {
            return Constants.S_OK; //  S_OK Host displayed its UI. MSHTML does not display its message box.
        }

        #region Implementation of IServiceProvider

        public int QueryService(ref Guid guidService, ref Guid riid, out IntPtr ppvObject)
        {
            if ((guidService == Constants.IID_INewWindowManager && riid == Constants.IID_INewWindowManager))
            {
                ppvObject = Marshal.GetComInterfaceForObject(_manager, typeof(INewWindowManager));
                if (ppvObject != IntPtr.Zero)
                {
                    return Constants.S_OK;
                }
            }
            ppvObject = IntPtr.Zero;
            return Constants.E_NOINTERFACE;
        }

        #endregion
    }
 }

[ComVisible(true)]
[Guid("01AFBFE2-CA97-4F72-A0BF-E157038E4118")]
public class NewWindowManager : INewWindowManager
{
    public int EvaluateNewWindow(string pszUrl, string pszName,
        string pszUrlContext, string pszFeatures, bool fReplace, uint dwFlags, uint dwUserActionTime)
    {

        // use E_FAIL to be the same as CoInternetSetFeatureEnabled with FEATURE_WEBOC_POPUPMANAGEMENT
        //int hr = MyBrowser.Constants.E_FAIL; 
        int hr = MyBrowser.Constants.S_FALSE; //Block
        //int hr = MyBrowser.Constants.S_OK; //Allow all
        return hr;
    }
} 
```

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2011-04-25T16:23:05.630

`InjectAlertBlocker`绝对正确的代码是

```
private void InjectAlertBlocker() {
    HtmlElement head = webBrowser1.Document.GetElementsByTagName("head")[0];
    HtmlElement scriptEl = webBrowser1.Document.CreateElement("script");
    IHTMLScriptElement element = (IHTMLScriptElement)scriptEl.DomElement;
    string alertBlocker = "window.alert = function () { }";
    element.text = alertBlocker;
    head.AppendChild(scriptEl);
} 
```

需要添加的参考是

1.  添加对 的引用`MSHTML`，这在引用下可能被称为“ **Microsoft HTML 对象库**” `COM`。

2.  添加`using mshtml;`到您的命名空间。

3.  获取对脚本元素的引用`IHTMLElement`：

然后您可以将`Navigated`webbrowser 的事件用作：

```
private void InjectAlertBlocker()
{
    HtmlElement head = webBrowser1.Document.GetElementsByTagName("head")[0];
    HtmlElement scriptEl = webBrowser1.Document.CreateElement("script");
    IHTMLScriptElement element = (IHTMLScriptElement)scriptEl.DomElement;
    string alertBlocker = "window.alert = function () { }";
    element.text = alertBlocker;
    head.AppendChild(scriptEl);
}

private void webDest_Navigated(object sender, WebBrowserNavigatedEventArgs e)
{
    InjectAlertBlocker();
} 
```

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-19T01:08:10.817

您是否正在尝试实现网络机器人？我在使用托管 IE 控件方面几乎没有经验，但我确实完成了一些尝试使用 IE 控件的 Win32 项目。禁用弹出窗口应该通过控件的事件处理程序完成，但我发现您还需要更改 IE 选项中的“禁用脚本调试 xxxx”（或者您可以修改代码中的注册表）为cjheath 已经指出。但是，我还发现需要执行额外的步骤来检查任何可下载内容的导航 url，以防止那些打开/保存对话框。但是我不知道如何处理流文件，因为我无法通过单独查看 url 来跳过它们，最后我转向了 Indy 库，为我节省了处理 IE 的所有麻烦。最后，我记得微软确实在网上提到过 IE 并非旨在用作 OLE 控件。根据我自己的经验，每次控件导航到新页面时都会为程序引入内存泄漏！

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-12-01T10:46:14.587

我设法通过创建一个扩展`WebBroswer`类并覆盖该`OnNavigated`方法来注入上面的代码。

这似乎工作得很好：

```
class WebBrowserEx : WebBrowser
{
  public WebBrowserEx ()
  {
  }

  protected override void OnNavigated( WebBrowserNavigatedEventArgs e )
  {
       HtmlElement he = this.Document.GetElementsByTagName( "head" )[0];
       HtmlElement se = this.Document.CreateElement( "script" );
       mshtml.IHTMLScriptElement element = (mshtml.IHTMLScriptElement)se.DomElement;
       string alertBlocker = "window.alert = function () { }";
       element.text = alertBlocker;
       he.AppendChild( se );
       base.OnNavigated( e );
  }
} 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2012-02-23T11:20:35.140

我遇到了更大的问题：加载一个用于打印的网页，它显示烦人的打印对话框。InjectBlocker 是唯一有效的方法，但相当不可靠。在某些情况下（我认为这是因为 WebBrowser 控件使用 IE 引擎，这取决于安装的 IE 版本）打印对话框仍然出现。这是一个主要问题，该解决方案适用于安装了 IE9 的 Win7，但安装了 IE8 的 WinXP 无论如何都会显示对话框。

我相信解决方案是在控件呈现页面之前修改源代码并删除打印 javascript。但是我尝试了： webbrowser 控件的 DocumentText 属性，它不起作用。当我修改源时，该属性不是只读的，但它没有效果。

我为我的问题找到的解决方案是 Exec 脚本：

```
string alertBlocker = "window.print = function emptyMethod() { }; window.alert = function emptyMethod() { }; window.open = function emptyMethod() { };";    
this.Document.InvokeScript("execScript", new Object[] { alertBlocker, "JavaScript" }); 
```

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2016-01-27T17:29:26.850

只需从浏览器控件属性：scriptErrorSupressed=true

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2016-03-28T08:09:29.333

最简单的方法是： 在：Webbrowser Control 你有程序（标准）`BeforeScriptExecute`

（参数`BeforeScriptExecute`为`pdispwindow`）

添加这个：

```
pdispwindow.execscript("window.alert = function () { }") 
```

这样，在页面窗口上的任何脚本执行之前，警报都会被注入的代码抑制。

# sql-server - SQL Server 兼容模式

> ID：77664
> 
> 赞同：6
> 
> 时间：2008-09-16T22:00:46.977
> 
> 标签：sql-server, upgrade, compatibility

我们目前正在以兼容模式 8 运行服务器，我想对其进行更新。

*   只是进入并改变它的含义是什么？
*   什么情况可能会破裂？
*   在我执行之前，是否有任何东西可以检查数据是否会存活？
*   我可以在不执行还原且不丢失数据的情况下回滚到模式 8 吗？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T22:08:35.600

如果您要从 80 到 90，则差异很小。从 65 到 70+ 可能会造成严重影响（NULL 的存储方式不同）。

影响 - 您的 SP 可能返回与您预期不同的结果 那里的任何东西都不应该影响事物。
从 80 到 90 并返回只需几秒钟。是的，你可以来回移动。

[http://msdn.microsoft.com/en-us/library/bb510680.aspx](http://msdn.microsoft.com/en-us/library/bb510680.aspx)

一些陷阱： http: [//mapamdug.blogspot.com/2006/03/sql-server-2005-gotcha-1.html](http://mapamdug.blogspot.com/2006/03/sql-server-2005-gotcha-1.html)

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T22:12:28.773

1.  兼容模式不影响存储。这只是一面旗帜。数据或查询不会发生任何变化。只有查询执行会受到影响。
2.  什么都没有——或者很多东西。您是否使用了 2000 年标记为过时且可能被删除的语法？在查询中提供提示时是否使用了括号？您是否使用了查询执行提示？如果是，最好先修改数据库，删除过时的语法，放回括号并挖掘 BOL 以找出哪些提示会减慢您在新引擎上的微调查询。
3.  不会。但数据会继续存在。事实上，如果您能够在 server2005 上运行您的数据库，即使在模式 8 下，您已经在使用新的数据格式。
4.  是的，您可以回滚。它没有改变，它只是设置了一个标志，上面写着“我的查询是兼容的”。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T22:04:19.760

兼容模式禁用了较新版本的功能，我个人并没有真正使用过很多有问题的数据库，关键是我们环境中的问题是移动到9之后，您无法再使用企业管理器查看数据库。

备份/恢复是一个不错的选择，我也相信您可以毫无问题地将其翻转回来。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-17T13:25:45.550

（我确实说过，只有当您从 6.5 迁移时，`char()`当 NULL - 70 和更高版本使用整个字段时，它不会在字段中存储任何内容，这可能会导致大规模的大小变化。）

VBStreets 在他的观点上是正确的——当然在第 3 点上——当你在 2005 年第一次运行数据库时，它转换了数据结构。如果您进行备份，则无论兼容性级别如何，都无法在以前的版本上恢复它。

# c# - C# .Net 2.0 是否有基于规范的测试框架？

> ID：77683
> 
> 赞同：4
> 
> 时间：2008-09-16T22:02:12.417
> 
> 标签：c#, .net, testing, automated-tests

例如，[Reducio](http://reductiotest.org/)（用于 Java/Scala）和[QuickCheck](http://www.cs.chalmers.se/~rjmh/QuickCheck/)（用于 Haskell）。我正在考虑的那种框架将为内置数据类型提供“生成器”，并允许程序员定义新的生成器。然后，程序员将定义一个断言某些属性的测试方法，将适当类型的变量作为参数。然后，该框架为参数生成一堆随机数据，并对该方法运行数百次测试。

例如，如果我实现了一个 Vector 类，并且它有一个 add() 方法，我可能想检查我的加法是否通勤。所以我会写一些类似的东西（用伪代码）：

```
boolean testAddCommutes(Vector v1, Vector v2) {
    return v1.add(v2).equals(v2.add(v1));
} 
```

我可以在两个特定向量上运行 testAddCommutes() 以查看该添加是否通勤。但是我没有编写一些 testAddCommutes 调用，而是编写了一个生成任意向量的过程。鉴于此，框架可以在数百个不同的输入上运行 testAddCommutes。

这会为任何人敲响警钟吗？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2009-10-09T09:42:08.037

有 FsCheck，它是从 QuickCheck 到 F# 以及 C# 的一个端口，尽管大部分文档似乎是针对 f# 的。我自己也一直在探索这些想法。见： http: [//kilfour.wordpress.com/2009/08/02/testing-tool-tour-quicknet-preview/](http://kilfour.wordpress.com/2009/08/02/testing-tool-tour-quicknet-preview/)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-17T01:58:40.133

我也可能理解不正确，但[PEX](http://www.codeplex.com/Pex)可能对你有用。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2009-10-16T22:12:33.320

详细说明我之前的评论，用于测试伪代码示例的 QN 代码如下所示：

```
新的测试运行(1, 1000)
    .AddTransition(new MetaTransition<Input<Vector, Vector>, Vector>
    {
        名称=“矢量添加”，
        生成器 = DoubleVectorGenerator，
        执行 = 输入 => input.paramOne.Add(input.paramTwo)
    }
    .注册属性（
        （输入，输出）=>
            新的 Qn 属性（
                “是交流的”，
                () => QnAssert.IsTrue(输出 == input.paramTwo.Add(input.paramOne) )
            )
        )
    )
    。核实（）
    .RethrowLastFailureifAny()
    .ReportPropertiesTested(new ConsoleReporter());

```

其中 DoubleVectorGenerator 是一个用户定义的类，提供 Input<Vector, Vector> 类型的值。

* * *

## 回答 #4

> 赞同：-1
> 
> 时间：2008-09-16T22:04:47.950

我可能没有正确理解您，但请检查一下...

[http://www.ayende.com/projects/rhino-mocks.aspx](http://www.ayende.com/projects/rhino-mocks.aspx)

# java - Java Applet - 部分签名？

> ID：77686
> 
> 赞同：0
> 
> 时间：2008-09-16T22:02:23.523
> 
> 标签：java, security, applet, signed-applet

是否可以只签署小程序的一部分？即，有一个小程序不会弹出关于被签名的安全警告，但是如果使用了某些特定的功能（需要特权），那么使用签名的 jar？

据我所知，即使您在执行时根本不请求特权，一些（也许是大多数）浏览器也会弹出签名小程序的警告。如果可能的话，我宁愿避免这种情况。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T23:09:44.610

尝试将您的代码拆分为一个未签名的 jar 和一个签名的 jar。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-18T15:00:16.410

理论上你可以（签名+未签名的jar），但实际上它会导致你的代码将被视为未签名。访问决策应该由线程做出，而不是直接调用者。如果线程在堆栈中包含从未签名代码的对象进行的调用，则整个调用应被视为未签名。如果您解决此问题，您会发现一个错误。

换句话说……**不**。

如果我不好奇，请问您为什么要部分签署您的代码？

* * *

## 回答 #3

> 赞同：-1
> 
> 时间：2008-09-16T22:39:59.987

给我的印象是 Sun 不鼓励创建 Applet 并鼓励使用 Java Web Start。我认为签署小程序的这个问题是问题的一部分。请参阅 Sun 的此文档：[Java Web start FAQ](http://java.sun.com/j2se/1.5.0/docs/guide/javaws/developersguide/faq.html)。

我还没有尝试过，但是您能否将需要登录的功能分割到单独的 jar 中，这些 jar 仅在用户需要这些 jar 中的功能时才需要权限检查？

# drupal - 如何快速主题化视图？

> ID：77694
> 
> 赞同：85
> 
> 时间：2008-09-16T22:02:57.703
> 
> 标签：drupal, drupal-views, cck, drupal-theming

我用 CCK 和 View 2 模块定义了一个视图。我想快速定义一个特定于此视图的模板。有这方面的教程或信息吗？我需要修改哪些文件？

* * *

**这是我的发现：（已编辑）**

实际上，有两种方法可以给视图设置主题：“**字段**”方式和“**节点**”方式。在“编辑视图”中，您可以选择“ `Row style: Node`”或“ `Row style: Fields`”。

*   使用“**节点**”方式，您可以创建一个**node-contentname.tpl.php**，它将为视图中的每个节点调用。您可以使用 $field_name[0]['value'] 访问您的 cck 字段值。（edit2）您可以使用**node-view-viewname.tpl.php**，它只会为从此视图显示的每个节点调用。
*   使用“**字段**”方式，您可以为每个要单独设置主题的字段添加 views-view-field--viewname--field-name-value.tpl.php。

感谢之前的回复，我使用了以下工具：

*   在“基本设置”块中，“主题：信息”可以查看您可以修改的所有不同模板。
*   [开发模块](http://drupal.org/project/devel)的“主题开发者”可以快速找到字段变量名。
*   [查看 2 个文档](http://views-help.doc.logrus.com/)，尤其是[“使用主题”](http://views-help.doc.logrus.com/help/views/using-theme)页面。

* * *

## 回答 #1

> 赞同：52
> 
> 时间：2008-09-16T22:55:11.370

事实上，有两种方法可以为视图设置主题：“**字段**”方式和“**节点**”方式。在“编辑视图”中，您可以选择“ `Row style: Node`”或“ `Row style: Fields`”。

*   使用“**节点**”方式，您可以创建一个 node-contentname.tpl.php，它将为视图中的每个节点调用。您可以使用 $field_name[0]['value'] 访问您的 cck 字段值
*   使用“**字段**”方式，您可以为每个要单独设置主题的字段添加 views-view-field--viewname--field-name-value.tpl.php。

感谢之前的回复，我使用了以下工具：

*   在“基本设置”块中，“主题：信息”可以查看您可以修改的所有不同模板。
*   [开发模块](http://drupal.org/project/devel)的“主题开发者”可以快速找到字段变量名。
*   [查看 2 个文档](http://views-help.doc.logrus.com/)，尤其是[“使用主题”](http://views-help.doc.logrus.com/help/views/using-theme)页面。

* * *

## 回答 #2

> 赞同：22
> 
> 时间：2008-09-16T23:27:29.420

在 Views 2.0 中查找可以为视图创建和修改的模板文件的一种快速方法是：

1.  编辑视图
2.  选择样式（例如页面、块、默认）
3.  在“基本设置”块中，单击“主题：信息”以查看您可以修改的所有不同模板。

* * *

## 回答 #3

> 赞同：16
> 
> 时间：2008-09-17T00:20:09.153

[Devel 模块](http://drupal.org/project/devel)的“主题开发者”功能可以方便地查看 Drupal 在主题化时正在寻找哪些模板文件。有关示例，请参见该页面上的屏幕截图。

* * *

## 回答 #4

> 赞同：10
> 
> 时间：2010-07-28T04:12:24.190

您还应该查看[语义视图](http://drupal.org/project/semanticviews)。对于简单的 Views 主题，它*真的很*方便。

* * *

## 回答 #5

> 赞同：7
> 
> 时间：2011-03-24T14:14:47.397

一个提示：

您可能会有许多需要类似格式的视图。为每个视图创建模板并复制它们会造成代码分支的噩梦——如果您被要求更改站点的整体外观和感觉（意味着更改以这种特定方式格式化的每个视图的显示），您必须返回并分别编辑其中的每一个。

有时我不使用视图界面为视图选择新模板，而是简单地将一些代码分支插入到单个视图文件中。例如，对于`views-view-fields.tpl.php`我有一个站点：

```
if($view->name == 'articleList' || $view->name == 'frontList' 
|| $view->name == 'archiveList') {
/* field formatting code */
} else {
/* the default code running here */
} 
```

然后，这会以我只希望这一系列 Views = articleList、frontList 和 archiveList 的方式修改字段，而对于使用此模板的其他视图，则运行通常在此模板中找到的代码。如果客户问，“嘿，你能让那些显示档案的页面和首页上的列表看起来更像 (...)”，这只是我打开和编辑这个文件的问题，而不是三个不同的文件。维护变得更加快捷和友好。

* * *

## 回答 #6

> 赞同：6
> 
> 时间：2009-10-21T00:50:41.233

对我来说**block-views-myViewName-myBlockId.tpl.php**有效

* * *

## 回答 #7

> 赞同：4
> 
> 时间：2009-08-08T10:22:10.787

我的快捷方式选项。

1.  转到**/views/theme/文件夹中的****theme.inc**文件。**`YOUR_MODULE_DIR`**

2.  在**`_views_theme_functions`**函数中打印**$themes**变量或在函数的最后一行放置断点以查看变量的内容。

只需转换**`views_view`**为**views-view**和 __ to -- 并添加您的模板扩展名以获得所需的文件名。

例如，如果**$themes**数组的元素是**`views_view__test_view__block`** （`test_view`您的视图的名称在哪里），那么模板文件的名称将是**views-view--test_view--block.tpl.php**。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2010-02-21T16:48:26.843

在我看来，决定使用哪个模板文件对视图进行主题化的最简单方法是： 1) 点击 admin/build/views/edit/ViewName -> Basic Settings -> Theme

单击此按钮将列出所有可能的模板文件。突出显示（粗体中的文件名）文件指示正在使用哪个模板文件来做主题视图的哪个部分。在相关视图模板文件 RESCAN.. 中合并所需的更改后，现在您应该能够看到更改后的模板文件突出显示。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2011-09-01T10:11:35.573

如果您想通过大量拖放操作进行快速 Drupal 开发，请使用 Display Suite 模块 def. 是你应该使用的东西：http: [//drupal.org/project/ds](http://drupal.org/project/ds)

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2017-01-24T04:19:20.157

在我看来，有两种方法可以做到：

程序化方式：

1.  转到编辑视图。
2.  选择页面/块样式。
3.  转到“基本设置”并单击“主题：信息”以查看您可以修改的所有不同模板。
4.  添加您想要主题的 html 并在需要的地方打印视图的变量

配置更新：![使用显示套件](https://i.stack.imgur.com/CvhW1.png)显示套件为我们提供了一个选项，可以将您的标签放置在行内或上方，甚至添加以隐藏它们。也可以为每个视图元素添加自定义类。高级选项包括：

*   出口品
*   在后端或代码中添加您自己的自定义字段
*   在您的主题中添加自定义布局（仅限 D7）
*   更改标签、添加样式或覆盖字段设置（语义字段）。
*   与视图和面板完全集成
*   通过安装 Field Group 扩展布局的功能
*   对象缓存 (D6) 或实体缓存 (D7) 集成的最佳性能

# perl - 如何设置本地 CPAN 镜像？

> ID：77695
> 
> 赞同：8
> 
> 时间：2008-09-16T22:02:59.670
> 
> 标签：perl, cpan, administration

设置和维护本地 CPAN 镜像需要什么？我应该注意哪些脚本和最佳实践？

* * *

## 回答 #1

> 赞同：25
> 
> 时间：2008-09-16T22:16:14.800

[CPAN::Mini](http://search.cpan.org/perldoc?CPAN::Mini)是要走的路。在本地镜像 CPAN 后，您需要使用如下“文件：” URL 将 CPAN.pm 或 CPANPLUS 中的镜像 URL 设置为本地目录：

```
file:///path/to/my/cpan/mirror 
```

如果您希望您的镜像拥有 CPAN 发行版的开发版本的副本，您可以使用[CPAN::Mini::Devel](http://search.cpan.org/perldoc?CPAN::Mini::Devel)。

更新：

“[我需要什么来镜像 CPAN？”](http://www.cpan.org/misc/cpan-faq.html#How_mirror_CPAN) 另一个答案中给出的常见问题解答是用于镜像*所有*CPAN，通常是提供另一个公共镜像。这包括旧的、过时的发行版。CPAN::Mini 只是镜像最新版本。这要小得多，对于大多数用户来说，通常是人们用于本地或断开连接（笔记本电脑）访问 CPAN 的方式。

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2008-09-20T21:18:51.417

除了其他答案，请查看 Leon 的[CPAN::Mini::Webserver](http://search.cpan.org/dist/CPAN-Mini-Webserver)，它为您提供了本地 CPAN 副本的[CPAN 搜索界面。](http://search.cpan.org)

如果您想做更多花哨的事情，请参阅我的[“MyCPAN”](http://www.slideshare.net/brian_d_foy/mycpan-lapm-september-2007)演讲。[例如，您可以使用CPAN::Mini::Inject](http://search.cpan.org/dist/CPAN-Mini-Inject)将您自己的私有模块注入您的私有 CPAN 。

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-09-16T22:45:37.367

CPAN::Mini 很好。默认情况下，它只保留最新版本的发行版，而不像 CPAN 那样保留每个版本。

您还可以安装 CPAN::Mini::Webserver，它为您提供本地 cpan 镜像的 Web 界面 - 如果您处于离线状态但仍想使用 perl，则非常方便。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T22:04:57.747

试试[CPAN::Mini](http://search.cpan.org/perldoc/CPAN::Mini)。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-17T13:11:25.227

运行 CPAN 镜像最可能的情况是，您的 50 台机器的网络都可以从本地更新，而不是访问网络 50 次。

我认为以传统方式使用 CPAN 是一种使服务器网络保持最新的糟糕方法。

我运行一个 RedHat 机器网络。我将所有打算在生产中使用的 CPAN 模块打包到 RPM 中（主要使用 RPM::Specfile 中的 cpanflute2 工具）并以这种方式部署它们，从而确保正确的依赖跟踪，而您实际上并没有以任何理智的方式从 CPAN 本身获得。

# fogbugz - 托管 Fogbugz 中的 BugzScout

> ID：77697
> 
> 赞同：4
> 
> 时间：2008-09-16T22:03:27.187
> 
> 标签：fogbugz, fogbugz-on-demand, bugzscout

是否可以在 Fogcreek 托管的 Fogbugz 版本中使用 BugzScout？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-09-16T22:06:34.373

是的你可以！

[该文档](http://fogbugz.stackexchange.com/questions/315/bugzscout-to-capture-errors)位于 FogBugz 知识交流处。FogBugz 的为您的服务器版本附带的示例代码可在[此处](http://support.fogcreek.com/default.asp?W741)下载。

# java - 为什么 Java 不提供运算符重载？

> ID：77718
> 
> 赞同：451
> 
> 时间：2008-09-16T22:04:40.070
> 
> 标签：java, operator-overloading

从 C++ 到 Java，显而易见的未解决问题是为什么 Java 不包含运算符重载？

不是`Complex a, b, c; a = b + c;`比 简单得多`Complex a, b, c; a = b.add(c);`吗？

是否有一个已知的原因，不允许运算符重载的有效*参数*？原因是随意的，还是被时间遗忘了？

* * *

## 回答 #1

> 赞同：865
> 
> 时间：2008-10-12T00:20:32.840

有很多帖子抱怨运算符重载。

我觉得我必须澄清“操作员重载”的概念，为这个概念提供另一种观点。

# 代码混淆？

这种说法是谬误。

## 在所有语言中都可以进行混淆...

在 C 或 Java 中通过函数/方法混淆代码就像在 C++ 中通过运算符重载一样容易：

```
// C++
T operator + (const T & a, const T & b) // add ?
{
   T c ;
   c.value = a.value - b.value ; // subtract !!!
   return c ;
}

// Java
static T add (T a, T b) // add ?
{
   T c = new T() ;
   c.value = a.value - b.value ; // subtract !!!
   return c ;
}

/* C */
T add (T a, T b) /* add ? */
{
   T c ;
   c.value = a.value - b.value ; /* subtract !!! */
   return c ;
} 
```

## ...即使在 Java 的标准接口中

再举一个例子，让我们看看Java中的[`Cloneable`接口：](http://download.oracle.com/javase/7/docs/api/java/lang/Cloneable.html)

您应该克隆实现此接口的对象。但你可以撒谎。并创建一个不同的对象。事实上，这个接口太弱了，你可以完全返回另一种类型的对象，只是为了好玩：

```
class MySincereHandShake implements Cloneable
{
    public Object clone()
    {
       return new MyVengefulKickInYourHead() ;
    }
} 
```

由于`Cloneable`接口可以被滥用/混淆，是否应该以 C++ 运算符重载的相同理由禁止它？

我们可以重载`toString()`一个`MyComplexNumber`类的方法，让它返回一天中的字符串化时间。是否也应该`toString()`禁止超载？我们可以破坏`MyComplexNumber.equals`让它返回一个随机值，修改操作数......等等等等......

**在 Java 中，就像在 C++ 或任何语言中一样，程序员在编写代码时必须尊重最低限度的语义。这意味着实现一个`add`添加的函数，`Cloneable`一个克隆的实现方法，一个`++`操作符而不是增量。**

# 到底有什么好混淆的？

既然我们知道即使通过原始的 Java 方法也可以破坏代码，我们可以问问自己，C++ 中运算符重载的真正用途是什么？

## 清晰自然的符号：方法与运算符重载？

我们将在下面针对不同的情况比较 Java 和 C++ 中的“相同”代码，以了解哪种编码风格更清晰。

### 自然比较：

```
// C++ comparison for built-ins and user-defined types
bool    isEqual          = A == B ;
bool    isNotEqual       = A != B ;
bool    isLesser         = A <  B ;
bool    isLesserOrEqual  = A <= B ;

// Java comparison for user-defined types
boolean isEqual          = A.equals(B) ;
boolean isNotEqual       = ! A.equals(B) ;
boolean isLesser         = A.comparesTo(B) < 0 ;
boolean isLesserOrEqual  = A.comparesTo(B) <= 0 ; 
```

请注意，A 和 B 可以是 C++ 中的任何类型，只要提供了运算符重载。在 Java 中，当 A 和 B 不是基元时，代码会变得非常混乱，即使对于类似基元的对象（BigInteger 等）也是如此......

### 自然数组/容器访问器和下标：

```
// C++ container accessors, more natural
value        = myArray[25] ;         // subscript operator
value        = myVector[25] ;        // subscript operator
value        = myString[25] ;        // subscript operator
value        = myMap["25"] ;         // subscript operator
myArray[25]  = value ;               // subscript operator
myVector[25] = value ;               // subscript operator
myString[25] = value ;               // subscript operator
myMap["25"]  = value ;               // subscript operator

// Java container accessors, each one has its special notation
value        = myArray[25] ;         // subscript operator
value        = myVector.get(25) ;    // method get
value        = myString.charAt(25) ; // method charAt
value        = myMap.get("25") ;     // method get
myArray[25]  = value ;               // subscript operator
myVector.set(25, value) ;            // method set
myMap.put("25", value) ;             // method put 
```

在 Java 中，我们看到每个容器都做同样的事情（通过索引或标识符访问其内容），我们有不同的方式来做这件事，这令人困惑。

在 C++ 中，由于运算符重载，每个容器使用相同的方式访问其内容。

### 自然的高级类型操作

下面的示例使用了一个对象，该对象是使用在 Google 上找到的“ [Java Matrix object](https://encrypted.google.com/search?q=Java+Matrix+object) ”和“ [C++ Matrix object](https://encrypted.google.com/search?q=c%2B%2B+Matrix+object)`Matrix` ”的第一个链接找到的：

```
// C++ YMatrix matrix implementation on CodeProject
// http://www.codeproject.com/KB/architecture/ymatrix.aspx
// A, B, C, D, E, F are Matrix objects;
E =  A * (B / 2) ;
E += (A - B) * (C + D) ;
F =  E ;                  // deep copy of the matrix

// Java JAMA matrix implementation (seriously...)
// http://math.nist.gov/javanumerics/jama/doc/
// A, B, C, D, E, F are Matrix objects;
E = A.times(B.times(0.5)) ;
E.plusEquals(A.minus(B).times(C.plus(D))) ;
F = E.copy() ;            // deep copy of the matrix 
```

这不仅限于矩阵。Java的`BigInteger`和`BigDecimal`类具有同样令人困惑的冗长，而它们在 C++ 中的等价物与内置类型一样清晰。

### 自然迭代器：

```
// C++ Random Access iterators
++it ;                  // move to the next item
--it ;                  // move to the previous item
it += 5 ;               // move to the next 5th item (random access)
value = *it ;           // gets the value of the current item
*it = 3.1415 ;          // sets the value 3.1415 to the current item
(*it).foo() ;           // call method foo() of the current item

// Java ListIterator<E> "bi-directional" iterators
value = it.next() ;     // move to the next item & return the value
value = it.previous() ; // move to the previous item & return the value
it.set(3.1415) ;        // sets the value 3.1415 to the current item 
```

### 自然函子：

```
// C++ Functors
myFunctorObject("Hello World", 42) ;

// Java Functors ???
myFunctorObject.execute("Hello World", 42) ; 
```

### 文本连接：

```
// C++ stream handling (with the << operator)
                    stringStream   << "Hello " << 25 << " World" ;
                    fileStream     << "Hello " << 25 << " World" ;
                    outputStream   << "Hello " << 25 << " World" ;
                    networkStream  << "Hello " << 25 << " World" ;
anythingThatOverloadsShiftOperator << "Hello " << 25 << " World" ;

// Java concatenation
myStringBuffer.append("Hello ").append(25).append(" World") ; 
```

好的，在 Java 中你也可以使用`MyString = "Hello " + 25 + " World" ;`……但是，等一下：这是运算符重载，不是吗？不是骗人？？？

:-D

## 通用代码？

相同的通用代码修改操作数应该可用于内置/原语（在 Java 中没有接口）、标准对象（可能没有正确的接口）和用户定义的对象。

例如，计算任意类型的两个值的平均值：

```
// C++ primitive/advanced types
template<typename T>
T getAverage(const T & p_lhs, const T & p_rhs)
{
   return (p_lhs + p_rhs) / 2 ;
}

int     intValue     = getAverage(25, 42) ;
double  doubleValue  = getAverage(25.25, 42.42) ;
complex complexValue = getAverage(cA, cB) ; // cA, cB are complex
Matrix  matrixValue  = getAverage(mA, mB) ; // mA, mB are Matrix

// Java primitive/advanced types
// It won't really work in Java, even with generics. Sorry. 
```

# 讨论运算符重载

既然我们已经看到了使用运算符重载的 C++ 代码与 Java 中的相同代码之间的公平比较，我们现在可以将“运算符重载”作为一个概念来讨论。

## 算子重载在计算机出现之前就存在

**即使在计算机科学之外，也存在运算符重载：例如，在数学中，运算符如`+`、`-`、`*`等是重载的。**

实际上， 、 、 等的含义`+`会`-`根据`*`操作数的类型（数值、向量、量子波函数、矩阵等）而变化。

作为我们科学课程的一部分，我们大多数人都根据操作数的类型学习了运算符的多种含义。那么，我们是否发现它们令人困惑？

## 运算符重载取决于其操作数

这是运算符重载中最重要的部分：就像在数学或物理学中一样，运算取决于其操作数的类型。

所以，知道了操作数的类型，你就会知道操作的效果。

## 甚至 C 和 Java 也有（硬编码的）运算符重载

在 C 中，运算符的实际行为将根据其操作数而改变。例如，两个整数相加不同于两个双精度数相加，甚至是一个整数和一个双精度数相加。甚至还有整个指针算术域（不进行强制转换，您可以向指针添加一个整数，但不能添加两个指针......）。

在 Java 中，没有指针算术，但有人仍然发现没有`+`运算符的字符串连接是荒谬的，足以证明“运算符重载是邪恶的”信条中的异常是合理的。

只是您，作为 C（出于历史原因）或 Java（出于*个人原因*，见下文）编码器，您无法提供自己的。

## 在 C++ 中，运算符重载不是可选的...

在 C++ 中，内置类型的运算符重载是不可能的（这是一件好事），但*用户定义的*类型可以具有*用户定义的*运算符重载。

如前所述，在 C++ 中，与 Java 相反，与内置类型相比，用户类型不被视为该语言的二等公民。因此，如果内置类型有运算符，那么用户类型也应该能够拥有它们。

事实是，就像 Java 的`toString()`, `clone()`,`equals()`方法一样（*即类标准*），C++ 运算符重载是 C++ 的重要组成部分，以至于它变得与原始 C 运算符或前面提到的 Java 方法一样自然。

结合模板编程，运算符重载成为众所周知的设计模式。事实上，如果不使用重载运算符以及为您自己的类重载运算符，您将无法在 STL 中走得太远。

## ...但它不应该被滥用

运算符重载应努力尊重运算符的语义。不要在`+`运算符中减去（如“不要在`add`函数中减去”或“在`clone`方法中返回废话”）。

强制重载可能非常危险，因为它们会导致歧义。因此，它们确实应该保留用于定义明确的案例。至于`&&`和，除非您真的知道自己在做什么，否则永远不要使它们超载，因为您将失去本机运算符并享受`||`的短路评估。`&&``||`

# 所以......好吧......那为什么在Java中不可能呢？

因为詹姆斯·高斯林是这么说的：

> 我忽略了运算符重载作为一个**相当个人的选择**，因为我看到太多人在 C++ 中滥用它。
> 
> *詹姆斯·高斯林。资料来源：[http ://www.gotw.ca/publications/c_family_interview.htm](http://www.gotw.ca/publications/c_family_interview.htm)*

请将上面的 Gosling 的文字与下面的 Stroustrup 的文字进行比较：

> 许多 C++ 设计决策的根源在于我不喜欢强迫人们以某种​​特定方式做事 [...] 通常，我很想禁止我个人不喜欢的功能，我没有这样做，因为**我认为我没有把我的意见强加给别人的权利**。
> 
> *比亚内·斯特劳斯特鲁普。来源：C++ 的设计与演进（1.3 一般背景）*

## 运算符重载对 Java 有好处吗？

一些对象将极大地受益于运算符重载（具体或数字类型，如 BigDecimal、复数、矩阵、容器、迭代器、比较器、解析器等）。

在 C++ 中，由于 Stroustrup 的谦逊，您可以从中受益。在 Java 中，您只是因为 Gosling 的*个人选择*而被搞砸了。

## 它可以添加到Java中吗？

现在不在 Java 中添加运算符重载的原因可能是内部政治、对该功能的过敏、对开发人员的不信任（你知道，那些似乎困扰 Java 团队的破坏者......）、与以前的 JVM 的兼容性，是时候编写正确的规范等了。

所以不要屏住呼吸等待这个功能......

## 但是他们在 C# 中做到了！！！

是的...

虽然这远不是​​两种语言之间的唯一区别，但这种语言总是能让我感到开心。

显然，C# 的人，他们的*“每个原语都是 a `struct`，a`struct`派生自 Object”*，第一次尝试就做对了。

## 他们用[其他语言](https://en.wikipedia.org/wiki/Operator_overloading)做！

尽管所有 FUD 都反对使用定义的运算符重载，但以下语言支持它：[Kotlin](https://kotlinlang.org/docs/reference/operator-overloading.html)，[Scala](https://stackoverflow.com/q/1991240)，[Dart](https://www.dartlang.org/articles/idiomatic-dart/#operators)，[Python](https://docs.python.org/3/reference/datamodel.html#special-method-names)，[F#](https://msdn.microsoft.com/en-us/library/dd233204.aspx)，[C#](https://msdn.microsoft.com/en-us/library/aa288467.aspx)，[D](http://dlang.org/operatoroverloading.html)，[Algol 68](http://www.cap-lore.com/Languages/A68Ops.html)，[Smalltalk](http://logos.cs.uic.edu/476/resources/SmallTalk/cs476_Smalltalk/Smalltalk.htm)，[Groovy](http://www.groovy-lang.org/operators.html#Operator-Overloading)，[Perl 6](http://design.perl6.org/S06.html#Operator_overloading)， C++ ，[Ruby](https://stackoverflow.com/a/3331974)，[Haskell](https://stackoverflow.com/questions/16241556)，[MATLAB](https://fr.mathworks.com/help/matlab/matlab_oop/implementing-operators-for-your-class.html)，[Eiffel](http://se.ethz.ch/~meyer/publications/online/eiffel/basic.html)，[Lua](http://lua-users.org/wiki/MetamethodsTutorial)，[Clojure](https://stackoverflow.com/a/1535235)，[Fortran 90](http://research.physics.illinois.edu/ElectronicStructure/498-s97/comp_info/overload.html)，[Swift](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID42)，[Ada](http://archive.adaic.com/standards/83lrm/html/lrm-06-07.html)，[Delphi 2005](http://edn.embarcadero.com/article/34324) ...

这么多语言，有这么多不同（有时甚至是对立的）哲学，但他们都同意这一点。

深思熟虑...

* * *

## 回答 #2

> 赞同：44
> 
> 时间：2008-09-16T22:46:57.613

James Gosling 将 Java 的设计比作如下：

> “搬家有一个原则，当你从一间公寓搬到另一间公寓时。一个有趣的实验是把你的公寓收拾好，把所有东西都装在盒子里，然后搬到下一个公寓，直到你需要它时才打开任何东西。所以你”正在做你的第一顿饭，你从盒子里拿出一些东西。然后大约一个月后，你已经用它来弄清楚你生活中真正需要的东西，然后你把剩下的东西——忘记你有多喜欢它或者它有多酷——然后你就把它扔掉。这让你的生活变得非常简单，你可以在各种设计问题中使用这个原则：不要仅仅因为它们而做事'很酷，或者只是因为它们很有趣。

您可以在[此处阅读引用的上下文](http://www.gotw.ca/publications/c_family_interview.htm)

基本上，运算符重载非常适合模拟某种点、货币或复数的类。但在那之后，您开始快速用完示例。

另一个因素是开发人员滥用 C++ 中的功能重载运算符，如“&&”、“||”、强制转换运算符，当然还有“new”。将其与按值传递和异常相结合所产生的复杂性在[Exceptional C++](https://rads.stackoverflow.com/amzn/click/com/0201615622)一书中得到了很好的介绍。

* * *

## 回答 #3

> 赞同：23
> 
> 时间：2008-09-17T13:01:50.693

查看 Boost.Units：[链接文本](http://www.boost.org/doc/libs/1_36_0/doc/html/boost_units.html)

它通过运算符重载提供零开销维度分析。这能清楚多少？

```
quantity<force>     F = 2.0*newton;
quantity<length>    dx = 2.0*meter;
quantity<energy>    E = F * dx;
std::cout << "Energy = " << E << endl; 
```

实际上会输出正确的“Energy = 4 J”。

* * *

## 回答 #4

> 赞同：14
> 
> 时间：2008-09-16T22:11:51.787

Java 设计者认为运算符重载带来的麻烦多于其价值。就那么简单。

在每个对象变量实际上都是引用的语言中，运算符重载会带来额外的危险，即非常不合逻辑 - 至少对 C++ 程序员而言。将这种情况与 C# 的 == 运算符重载和`Object.Equals`和`Object.ReferenceEquals`（或其他任何名称）进行比较。

* * *

## 回答 #5

> 赞同：13
> 
> 时间：2008-09-16T22:31:07.760

假设您想覆盖由 引用的对象的先前值`a`，则必须调用成员函数。

```
Complex a, b, c;
// ...
a = b.add(c); 
```

在 C++ 中，此表达式告诉编译器在堆栈上创建三 (3) 个对象，执行加法，并将结果值从临时对象*复制*到现有对象`a`中。

但是，在Java中，`operator=`引用类型不进行值复制，用户只能创建新的引用类型，而不能创建值类型。因此，对于名为 的用户定义类型`Complex`，赋值意味着复制对现有值的引用。

改为考虑：

```
b.set(1, 0); // initialize to real number '1'
a = b; 
b.set(2, 0);
assert( !a.equals(b) ); // this assertion will fail 
```

在 C++ 中，这会复制值，因此比较结果会不相等。在 Java 中，`operator=`执行引用复制，因此`a`和`b`现在引用相同的值。结果，比较将产生“相等”，因为对象将与自身比较相等。

副本和引用之间的区别只会增加运算符重载的混乱。正如@Sebastian 提到的，Java 和 C# 都必须分别处理值和引用相等——`operator+`可能会处理值和对象，但`operator=`已经实现处理引用。

在 C++ 中，您一次应该只处理一种比较，这样可以减少混乱。例如， on`Complex`和`operator=`都`operator==`在处理值——分别复制值和比较值。

* * *

## 回答 #6

> 赞同：9
> 
> 时间：2008-09-16T22:24:52.720

[Groovy](http://groovy.codehaus.org/)具有运算符重载，并在 JVM 中运行。如果您不介意性能下降（每天都会变小）。它是基于方法名称的自动的。例如，'+' 调用 'plus(argument)' 方法。

* * *

## 回答 #7

> 赞同：6
> 
> 时间：2008-09-16T22:10:27.857

我认为这可能是一种有意识的设计选择，它迫使开发人员创建名称清楚地传达其意图的函数。在 C++ 中，开发人员会使用通常与给定运算符的普遍接受的性质无关的功能来重载运算符，从而几乎不可能在不查看运算符定义的情况下确定一段代码的作用。

* * *

## 回答 #8

> 赞同：5
> 
> 时间：2008-09-16T22:06:22.063

好吧，您真的可以在操作员超载的情况下将自己开枪打死。就像人们用指针犯愚蠢的错误一样，所以决定把剪刀拿走。

至少我认为这是原因。反正我是站在你这边的。:)

* * *

## 回答 #9

> 赞同：5
> 
> 时间：2010-03-24T02:35:48.633

有人说Java中的运算符重载会导致混淆。那些人有没有停下来看一些 Java 代码做一些基本的数学运算，比如使用 BigDecimal 将财务价值增加一个百分比？....这种练习的冗长变成了它自己的混淆证明。具有讽刺意味的是，将运算符重载添加到 Java 将允许我们创建自己的 Currency 类，这将使此类数学代码优雅而简单（不那么模糊）。

* * *

## 回答 #10

> 赞同：5
> 
> 时间：2011-11-24T02:05:37.327

从技术上讲，每种编程语言都存在运算符重载，可以处理不同类型的数字，例如整数和实数。解释：术语重载意味着一个函数只有几个实现。在大多数编程语言中，为运算符 + 提供了不同的实现，一种用于整数，一种用于实数，这称为运算符重载。

现在，很多人觉得奇怪的是Java有运算符重载，用于将字符串加在一起的运算符+，从数学的角度来看这确实很奇怪，但从编程语言的开发人员的角度来看，添加内置运算符重载并没有错用于运算符 + 用于其他类，例如字符串。但是，大多数人都同意，一旦为 + 为 String 添加了内置重载，那么为开发人员提供此功能通常是一个好主意。

A 完全不同意运算符重载混淆代码的谬误，因为这是由开发人员决定的。这种想法太天真了，老实说，它已经变老了。

+1 用于在 Java 8 中添加运算符重载。

* * *

## 回答 #11

> 赞同：4
> 
> 时间：2009-09-11T21:46:50.707

说运算符重载导致运算符与运算逻辑不匹配的类型的逻辑错误，就像什么都没说。如果函数名不适合操作逻辑，也会出现同样类型的错误——那么解决办法是什么：放弃函数使用的能力！？这是一个可笑的答案——“不适合操作逻辑”，每个参数名称、每个类、函数或任何可能在逻辑上不合适的东西。我认为这个选项应该在受人尊敬的编程语言中可用，并且那些认为它不安全的人 - 嘿，不，他们说你必须使用它。让我们以 C# 为例。他们放弃了指针，但是嘿 - 有“不安全代码”声明 - 随意编程，风险自负。

* * *

## 回答 #12

> 赞同：2
> 
> 时间：2008-09-16T22:12:42.610

假设 Java 作为实现语言，那么 a、b 和 c 都将是对具有初始值为 null 的 Complex 类型的引用。还假设 Complex 与提到的[BigInteger](http://java.sun.com/j2se/1.5.0/docs/api/java/math/BigInteger.html)和类似的不可变[BigDecimal](http://java.sun.com/j2se/1.5.0/docs/api/java/math/BigDecimal.html)一样是不可变的，我认为您的意思如下，因为您将引用分配给通过添加 b 和 c 返回的 Complex，而不是将此引用与 a 进行比较。

> 不是：
> 
> ```
> Complex a, b, c; a = b + c; 
> ```
> 
> *比*：
> 
> ```
> Complex a, b, c; a = b.add(c); 
> ```

* * *

## 回答 #13

> 赞同：2
> 
> 时间：2008-09-16T22:57:47.930

有时拥有运算符重载、友元类和多重继承会很好。

但是我仍然认为这是一个很好的决定。如果 Java 有运算符重载，那么如果不查看源代码，我们将永远无法确定运算符的含义。目前这是没有必要的。而且我认为您使用方法而不是运算符重载的示例也很有可读性。如果你想让事情更清楚，你总是可以在毛茸茸的陈述上方添加评论。

```
// a = b + c
Complex a, b, c; a = b.add(c); 
```

* * *

## 回答 #14

> 赞同：2
> 
> 时间：2018-08-06T20:59:20.827

**Java 运算符重载的本机支持的替代方案**

由于 Java 没有运算符重载，因此您可以考虑以下一些替代方案：

1.  使用另一种语言。[Groovy](https://en.wikipedia.org/wiki/Apache_Groovy)和[Scala](https://en.wikipedia.org/wiki/Scala_(programming_language))都具有运算符重载，并且基于 Java。
2.  使用[java-oo](https://github.com/amelentev/java-oo)，一个在 Java 中启用运算符重载的插件。请注意，它不是独立于平台的。此外，它还有很多问题，并且与最新版本的 Java（即 Java 10）不兼容。（[原始 StackOverflow 源](https://stackoverflow.com/questions/1686699/operator-overloading-in-java/1686714)）
3.  使用[JNI](https://en.wikipedia.org/wiki/Java_Native_Interface)、Java Native Interface 或替代方案。这允许您编写用于 Java 的 C 或 C++（也许是其他？）方法。当然，这也不是独立于平台的。

如果有人知道其他人，请发表评论，我会将其添加到此列表中。

* * *

## 回答 #15

> 赞同：1
> 
> 时间：2020-11-18T07:53:10.810

我认为，当重载允许使用标准符号而不将所有内容构建到语言中时，做出决策的人只是忘记了复杂的值、矩阵代数、集合论和其他情况。无论如何，只有面向数学的软件才能真正受益于这些功能。一个通用的客户应用程序几乎从不需要它们。

当程序员定义一些特定于程序的运算符时，他们关于不必要的混淆的论点显然是有效的，而它可能是函数。函数的名称在清晰可见时提供了它所做的提示。运算符是一个没有可读名称的函数。

Java 通常是基于这样的理念设计的，即一些额外的冗长并不坏，因为它使代码更具可读性。做同样事情的构造只是需要更少的代码来输入，过去被称为“语法糖”。这与 Python 哲学非常不同，例如，即使为第二位读者提供的上下文更少，也总是认为越短越好。

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2018-01-29T13:07:13.630

这不是一个禁止它的好理由，而是一个实际的理由：

人们并不总是负责任地使用它。看看 Python 库 scapy 中的这个例子：

```
>>> IP()
<IP |>
>>> IP()/TCP()
<IP frag=0 proto=TCP |<TCP |>>
>>> Ether()/IP()/TCP()
<Ether type=0x800 |<IP frag=0 proto=TCP |<TCP |>>>
>>> IP()/TCP()/"GET / HTTP/1.0\r\n\r\n"
<IP frag=0 proto=TCP |<TCP |<Raw load='GET / HTTP/1.0\r\n\r\n' |>>>
>>> Ether()/IP()/IP()/UDP()
<Ether type=0x800 |<IP frag=0 proto=IP |<IP frag=0 proto=UDP |<UDP |>>>>
>>> IP(proto=55)/TCP()
<IP frag=0 proto=55 |<TCP |>> 
```

这是解释：

> / 运算符已被用作两层之间的组合运算符。这样做时，下层可以根据上层重载其一个或多个默认字段。（你仍然可以给出你想要的值）。字符串可以用作原始层。

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2020-01-03T20:02:31.777

虽然 Java 语言不直接支持运算符重载，但您可以在任何 Java 项目中使用[Manifold 编译器插件来启用它。](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading)它支持 Java 8 - 17（当前的 Java 版本），并在 IntelliJ IDEA 中得到完全支持。

# xml - Xml 或 Sqlite，何时为数据库删除 Xml？

> ID：77726
> 
> 赞同：52
> 
> 时间：2008-09-16T22:05:27.073
> 
> 标签：xml, database

我真的很喜欢 Xml 来保存数据，但是 sqlite/database 什么时候会成为更好的选择？例如，当 xml 有超过*x 个*项目或大于*y* MB 时？

我正在编写一个 rss 阅读器，我相信我在使用 xml 而不是 sqlite 数据库来存储*所有*提要项的缓存时做出了错误的选择。有些提要一个月后的 xml 文件约为 1mb，另一些提要有超过 700 项，而大多数只有约 30 项，几个月后大小约为*50kb*。

我目前没有计划实施上限，因为我喜欢能够搜索所有内容。

所以，我的问题是：

1.  sqlite/数据库的开销何时比使用 xml 更合理？
2.  当有**很多小文件时，****少数几个大的 xml 文件**是否足以满足数据库的要求，尽管即使是小的文件也会随着时间的推移而增长？（很久*很久*）

 *****更新**（更多信息）

每次在 GUI 中选择一个提要时，我都会从该提要 xml 文件中重新加载所有项目。

我还需要修改已读/未读状态，当我遍历 xml 中的所有节点以查找该项目然后将其设置为已读/未读时，这似乎真的很糟糕。

* * *

## 回答 #1

> 赞同：40
> 
> 时间：2008-09-17T01:25:55.843

伙计，我有这方面的经验。我在一个项目中工作，我们最初使用 XML 存储所有数据，然后转移到 sqlite。每种技术都有很多优点和缺点，但导致转换的是性能。这是我们观察到的。

对于小型数据库（几兆或更小），XML 速度更快，也更容易处理。我们的数据自然采用树格式，这使得 XML 更具吸引力，而 XPATH 允许我们在一条简单的行中执行许多查询，而不必遍历祖先树。

我们在 Win32 环境中编程，并使用标准的 Microsoft DOM 库。我们会将所有数据加载到内存中，将其解析为 dom 树，然后在内存中的副本上搜索、添加、修改。我们会定期保存数据，并且需要轮换副本，以防机器在写入过程中崩溃。

我们还需要使用 C++ 树映射手动建立一些“索引”。当然，这对于 sql 来说是微不足道的。

请注意，文件系统上的数据大小比“内存中”的 dom 树小 2-4 倍。

当数据达到 10M-100M 大小时，我们开始遇到真正的问题。有趣的是，在所有数据大小下，XML 处理都比 sqlite 快得多（因为它在内存中，而不是在硬盘上）！问题实际上是双重的——首先，加载时间真的开始变长。在数据进入内存并构建地图之前，我们需要等待一分钟左右。当然，一旦加载程序非常快。第二个问题是所有这些内存一直被占用。即使我们运行得非常快，只有几百兆的系统在其他应用程序中也会无响应。

我们实际上正在研究使用基于文件系统的 xml 数据库。有几个开源版本的 xml 数据库，我们试过了。我从来没有尝试过使用商业 xml 数据库，所以我不能对它们发表评论。不幸的是，我们根本无法让 xml 数据库正常工作。即使是用数百兆 xml 填充数据库的行为也需要几个小时......也许我们使用不正确。另一个问题是这些数据库非常重量级。他们需要 java 并且拥有完整的客户端服务器架构。我们放弃了这个想法。

然后我们找到了sqlite。它解决了我们的问题，但要付出代价。当我们最初插入 sqlite 时，内存和加载时间问题就消失了。不幸的是，由于现在所有处理都在硬盘驱动器上完成，后台处理负载大大增加。虽然早些时候我们甚至没有注意到 CPU 负载，但现在处理器使用率上升了。我们需要优化代码，并且仍然需要在内存中保留一些数据。我们还需要将许多简单的 XPATH 查询重写为复杂的多查询算法。

所以这里是我们学到的总结。

1.  对于树数据，使用 XPATH 更容易查询和修改 XML。

2.  对于小型数据集（小于 10M），XML 在性能上击败了 sqlite。

3.  对于大型数据集（大于 10M-100M），XML 加载时间和内存使用成为一个大问题，以至于一些计算机变得无法使用。

4.  我们无法获得任何开源 xml 数据库来解决与大型数据集相关的问题。

5.  SQLITE 没有 XML dom 的内存问题，但它处理数据的速度通常较慢（它在硬盘驱动器上，而不是在内存中）。（注意，sqlite 表可以存储在内存中，也许这样可以让它更快......我们没有尝试这个，因为我们想从内存中获取数据。）

6.  在表中存储和查询树数据并不令人愉快。但是，管理事务和索引部分弥补了这一点。

* * *

## 回答 #2

> 赞同：21
> 
> 时间：2008-09-16T22:40:04.573

我基本上同意[Mitchel](https://stackoverflow.com/questions/77726/xml-or-sqlite-when-to-drop-xml-for-a-database#77750)的观点，这可能是非常具体的，具体取决于您要使用 XML/sqlite 做什么。对于您的情况（缓存），在我看来，使用 sqlite（或其他嵌入式数据库）更有意义。

首先，我真的不认为 sqlite 需要比 XML 更多的开销。我的意思是开发时间开销和运行时开销。唯一的问题是您依赖于 sqlite 库。但是由于无论如何您都需要一些 XML 库，所以这并不重要（我假设项目是 C/C++ 中的）。

**sqlite 相对于 xml 的优势：**

*   一切都在一个文件中，
*   随着缓存变大，性能损失低于 XML，
*   您可以将提要元数据与缓存本身（其他表）分开，但可以以相同的方式访问，
*   对于大多数人来说，SQL 可能比 XPath 更容易使用。

**sqlite的缺点：**

*   访问同一数据库的多个进程可能会出现问题（可能不是您的情况），
*   你至少应该知道基本的 SQL。除非缓存中有数十万个项目，否则我认为您不需要对其进行太多优化，
*   从安全的角度来看（SQL 注入），它可能在某种程度上更危险。另一方面，您不是在编写 Web 应用程序，所以这不应该发生。

这两种解决方案的其他事情可能都差不多。

总结一下，分别回答你的问题：

1.  您不会知道，除非您使用两个后端测试您的特定应用程序。否则它总是只是一个猜测。对两个缓存的基本支持对代码来说应该不是问题。然后进行基准测试和比较。

2.  由于 XML 文件的组织方式，sqlite 搜索应该总是更快（除非在某些极端情况下它并不重要，因为它非常快）。无论如何，加速 XML 中的搜索都需要索引数据库，在您的情况下，这意味着缓存用于缓存，这不是一个特别好的主意。但是使用 sqlite，您可以将索引作为数据库的一部分。

* * *

## 回答 #3

> 赞同：16
> 
> 时间：2008-09-16T22:26:07.133

不要忘记您有一个触手可及的出色数据库：文件系统！

许多程序员忘记了一个像样的目录文件结构是/具有：

1.  它快得像地狱
2.  它是便携式的
3.  它的运行时占用空间很小

人们正在谈论将 XML 文件拆分为多个 XML 文件...我会考虑将您的 XML 拆分为多个目录和多个纯文本文件。

搏一搏。速度快得令人耳目一新。

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2008-09-16T22:22:41.947

1.  将 XML 用于应用程序应该知道的数据 - 配置、日志记录等等。
2.  将数据库（oracle、SQL server 等）用于用户直接或间接交互的数据 - 真实数据
3.  如果用户数据更像是一个序列化的集合，则使用 SQLite——比如巨大的文件列表及其内容或电子邮件项目的集合等。SQLite 擅长于此。

取决于数据的种类和大小。

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2008-09-16T22:09:43.630

我不会使用 XML 来存储 RSS 项目。提要阅读器在接收数据时会不断更新。

使用 XML，您需要先从文件中加载数据，解析它，然后存储它以便于搜索/检索/更新。好像是数据库...

另外，如果您的应用程序崩溃了怎么办？如果使用 XML，XML 文件中的数据与内存中的数据是什么状态。至少使用 SQLite，您可以获得原子性，因此您可以放心，您的应用程序将以与上次数据库写入时相同的状态开始。

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2008-09-16T22:09:45.847

当您需要将数据从应用程序移动到其他地方或在应用程序之间共享信息时，XML 最适合用作交换格式。数据库应该是几乎任何规模的应用程序的首选存储方法。

* * *

## 回答 #7

> 赞同：5
> 
> 时间：2008-09-17T01:15:02.203

什么时候应该使用 XML 而不是数据库来实现数据持久性？几乎从不。XML 是一种数据传输语言。解析速度慢，查询麻烦。解析 XML（不要分解它！）并将生成的数据转换为域对象。然后持久化域对象。持久性数据库的一个主要优势是 SQL，这意味着非结构化查询以及对常用工具和优化技术的访问。

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2008-09-16T22:07:11.580

对我来说，这实际上取决于您对它们做什么，有多少用户/进程需要同时访问它们等。

我一直在处理大型 XML 文件，但它们是单个进程、导入样式项、多用户或性能并不是真正需要的。

所以真的是一种平衡。

* * *

## 回答 #9

> 赞同：3
> 
> 时间：2008-09-17T22:30:32.840

我已经切换到 SQLite，知道它在数据库中我感觉*好多了。*

这样做还有很多其他好处：

*   添加新项目非常简单
*   按多列排序
*   删除具有唯一索引的重复项

我创建了 2 个视图，一个用于未读项目，一个用于所有项目，不确定这是否是视图的最佳用途，但我真的很想尝试使用它们。

**我还使用StopWatch**类对 xml 与 sqlite 进行了基准测试，并且 sqlite 更快，**尽管可能只是我解析 xml 文件的方式不是最快的方法**。

1.  **小# 项和大小（25 项，30kb）**
    *   ~1.5 毫秒 sqlite
    *   ~8.0 毫秒 xml
2.  **大量项目（700 个项目，350kb）**
    *   ~20 毫秒 sqlite
    *   ~25 毫秒 xml
3.  **大文件大小（850 项，1024kb）**
    *   ~45 毫秒 sqlite
    *   ~60 毫秒 xml

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-09-16T22:23:58.573

如果您需要扩展，请使用数据库。

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2008-09-16T22:38:33.453

XML 非常适合存储不完全结构化的数据，并且您通常希望与另一个应用程序交换它。我更喜欢使用 SQL 数据库存储数据。XML 容易出错，因为数据本身的拼写错误或遗漏可能会导致细微的错误。一些开源应用程序框架使用太多的xml文件来进行配置、数据等，我更喜欢在SQL中拥有它。

由于您要求经验法则，我会说如果您要设置一次而不是访问/搜索太多，请使用基于 XML 的应用程序数据、配置等。对于主动搜索和更新，最好使用 SQL。

例如，Web 服务器将应用程序数据存储在 XML 文件中，而您实际上并不需要执行复杂的搜索、更新文件。Web 服务器启动，读取 xml 文件，仅此而已。所以 XML 在这里是完美的。假设您使用像 Struts 这样的框架。您需要使用 XML，并且一旦开发和部署了应用程序，操作配置就不会发生太大变化。同样，XML 文件是一个好方法。现在，如果您的 Struts 开发的应用程序允许广泛的搜索和更新、删除，那么 SQL 是最佳方式。

当然，您肯定会在您的组织中遇到一两个开发人员，他们只会高呼 XML 或 SQL，并宣称 XML 或 SQL 是唯一的出路。提防这些人，并为您的应用程序做“感觉”正确的事情。不要只遵循“技术宗教”。

想想你需要多久更新一次数据，多久需要搜索一次数据。然后，您将获得关于使用什么的答案——XML 或 SQL。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2008-09-16T22:15:59.047

我同意@Bradley。

XML 非常慢，并且作为一种存储格式并不是特别有用。何苦？您会使用文本编辑器手动编辑数据吗？如果是这样，与 YAML 之类的格式相比，XML*仍然*不是一种非常方便的格式。使用 SQlite 之类的东西，查询更容易编写，并且有一个定义明确的 API 用于输入和输出数据。

如果您需要在程序之间发送数据，XML 很好。但是以效率的名义，您可能应该在发送时生成 XML，并在接收时将其解析为“真实数据”。

以上所有意味着您关于“何时证明数据库的开销是合理的”的问题有点没有实际意义。XML 总是比 SQlite 有更高的开销。（像 MSSQL 这样的完整数据库更重，尤其是在管理开销方面，但这是一个完全不同的问题。）

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2008-09-16T22:53:30.703

XML 可以存储为文本和二进制文件格式。

如果您的主要目标是让计算机有效地读取/写入文件格式，您应该使用二进制文件格式。

数据库是一种易于使用的存储和维护数据的方式。它们不是存储二进制文件格式数据的最快方式。

可以加快速度的是使用内存数据库/数据库类型。Sqlite 有这个选项。

这听起来像是为您做这件事的最佳方式。

* * *

## 回答 #14

> 赞同：1
> 
> 时间：2008-09-16T22:53:44.697

我的意见是，只要您不需要纯文本文件格式，就应该使用 SQLite（或其他合适的嵌入式数据库）。请注意，这是一个很大的例外。有很多场景需要纯文本文件格式，或者受益于纯文本文件格式。

就开销而言，SQLite 编译为带有正常标志的 250 k 之类的东西。许多 XML 解析库都比 SQLite 大。使用 XML 不会获得并发收益。SQLite 二进制文件格式将支持更高效的写入（主要是因为您不能追加到格式良好的 XML 文件的末尾）。甚至读取数据，我认为其中大部分是相当随机的访问，使用 SQLite 会更快。

最重要的是，您可以获得 SQL 的好处，例如事务和索引。

编辑：忘了提。SQLite 的一个好处（与许多数据库相反）是它允许在任何列中的任何行中使用任何类型。基本上，使用 SQLite，您可以在数据类型方面获得与使用 XML 相同的自由。这也意味着您不必担心对文本列进行限制。

* * *

## 回答 #15

> 赞同：1
> 
> 时间：2008-09-17T19:27:52.233

您应该注意，许多大型关系数据库（Oracle 和 SQLServer）都有 XML 数据类型来在数据库中存储数据，并在 SQL 语句中使用 XPath 来访问该数据。

此外，还有一些原生 XML 数据库，它们的工作方式与 SQLite 非常相似，因为它们是一个二进制文件，其中包含一组文档（可能大致是一个表），然后您可以在单个文档或整个集合上使用 XPath/XQuery。因此，使用 XML 数据库，您可以将日期数据作为单独的 XML 文档存储在集合中……因此，在处理今天的数据时，您只需要使用该文档即可。但是编写一个 XQuery 来找出那个人的文档集合的历史数据。光滑。

我使用过 Berkeley XMLDB（现在由 Oracle 提供支持）。如果您在 google 上搜索“Native XML Database”，还有其他的。我没有看到以这种方式存储/检索数据的性能问题。

XQuery 是一种不同的野兽（但非常值得学习），但是您可以只使用当前使用的 XPath，只需稍加修改即可。

* * *

## 回答 #16

> 赞同：1
> 
> 时间：2008-09-17T19:48:01.437

数据库非常适合作为程序的一部分。如果查询数据是您业务逻辑的一部分。XML 是最好的文件格式，特别是如果您的数据格式是：

1、分层
2、未来可能以你无法猜测的方式发生变化
3、数据的寿命将比程序长

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2008-09-16T22:09:10.857

我说这不是数据大小的问题，而是数据类型的问题。如果您的数据是*结构化*的，请使用关系数据库。如果您的数据是*半结构化的*，请使用 XML 或 - 如果数据量确实增长得太大 - 使用 XML 数据库。

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2008-09-16T22:12:47.400

如果您的搜索与分贝一起使用。您可以将 xml 文件拆分为目录以方便查找，但管理开销很容易变得相当沉重。您还可以获得更多的不仅仅是使用 sql 数据库的性能......

# python - 用于 Python 的 iBATIS？

> ID：77731
> 
> 赞同：5
> 
> 时间：2008-09-16T22:05:58.697
> 
> 标签：python, orm, ibatis

在我目前的演出中，我们通过 Java 使用 iBATIS 来 CRUD 我们的数据库。我喜欢该工具的抽象特性，尤其是在使用遗留数据库时，因为它不会将自己的语法强加给您。

**我正在寻找这个库的 Python 模拟**，因为该网站只有 Java/.NET/Ruby 版本可用。如果不需要，我不想切换到 Jython。

是否还有其他类似于 iBATIS 功能的 Python 项目？

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-09-16T22:53:33.713

iBatis 将 SQL DML（或 SQL 的定义）隔离在 XML 文件中。它特别关注 SQL 和其他地方定义的某些对象模型之间的映射。

SQL Alchemy 可以做到这一点——但它并不是一个非常完整的解决方案。与 iBatis 一样，您只能拥有 SQL 表定义以及表和 Python 类定义之间的映射。

更完整的是有一个类定义，它*也是*SQL 数据库定义。如果类定义生成 SQL 表 DDL 以及查询和处理 DML，那就更完整了。

我在 SQLAlchemy 和 Django ORM 之间切换。SQLAlchemy 可以以类似 iBatis 的方式使用。但我更喜欢让对象设计成为中心，让 SQL 实现由工具集从对象派生而来。

我将 SQLAlchemy 用于大型、批量、独立的项目。数据库加载、模式转换、DW 报告等运行良好。在这些项目中，重点是数据的关系视图，而不是对象模型。例如，生成的 SQL 可以移动到 PL/SQL 存储过程中。

我将 Django 用于 Web 应用程序，利用其内置的 ORM 功能。您可以通过一些工作将 Django ORM 与 Django 环境的其余部分隔离开来。您可以[提供全局设置](http://docs.djangoproject.com/en/dev/topics/settings/#using-settings-without-setting-django-settings-module)以将您的应用绑定到特定数据库，而无需使用单独的设置模块。

Django 包含许多可以管理 SQL 实现的常见关系（外键、多对多、一对一）。它为附加的数据库生成键和索引定义。

如果您的问题主要是面向对象的，并且数据库用于持久性，那么 Django 几乎透明的 ORM 层具有优势。

如果您的问题主要与 SQL 处理中心有关，那么在 SQLAlchemy 中查看生成的 SQL 的能力具有优势。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T22:17:30.790

也许 SQLAlchemy SQL 表达式支持是合适的。请参阅[文档](http://docs.sqlalchemy.org/en/latest/core/expression_api.html)。

# windows - 如何更改 windows 命令提示符中的文本颜色

> ID：77744
> 
> 赞同：13
> 
> 时间：2008-09-16T22:06:36.963
> 
> 标签：windows, ruby, command-line, colors

我有一个命令行程序，它将日志记录输出到屏幕。

我希望错误行以红色显示。我可以输出一些特殊的字符代码来将文本颜色切换为红色，然后将其切换回白色吗？

我正在使用 ruby​​，但我想这在任何其他语言中都是一样的。

就像是：

```
red = "\0123" # character code
white = "\0223"

print "#{red} ERROR: IT BROKE #{white}"
print "other stuff" 
```

* * *

## 回答 #1

> 赞同：27
> 
> 时间：2008-09-17T00:49:42.123

在 Windows 上，您可以通过三种方式轻松完成：

```
require 'win32console'
puts "\e[31mHello, World!\e[0m" 
```

现在你可以用一个叫做的小方法来扩展 String`red`

```
 require 'win32console'
 class String
   def red
     "\e[31m#{self}\e[0m"
   end
 end

 puts "Hello, World!".red 
```

您也可以像这样扩展 String 以获得更多颜色：

```
require 'win32console'

class String
  { :reset          =>  0,
    :bold           =>  1,
    :dark           =>  2,
    :underline      =>  4,
    :blink          =>  5,
    :negative       =>  7,
    :black          => 30,
    :red            => 31,
    :green          => 32,
    :yellow         => 33,
    :blue           => 34,
    :magenta        => 35,
    :cyan           => 36,
    :white          => 37,
  }.each do |key, value|
    define_method key do
      "\e[#{value}m" + self + "\e[0m"
    end
  end
end

puts "Hello, World!".red 
```

或者，如果您可以安装 gem：

```
gem install term-ansicolor 
```

在你的程序中：

```
require 'win32console'
require 'term/ansicolor'

class String
  include Term::ANSIColor
end

puts "Hello, World!".red
puts "Hello, World!".blue
puts "Annoy me!".blink.yellow.bold 
```

有关更多信息和可能的用法，请参阅 term/ansicolor 的文档。

* * *

## 回答 #2

> 赞同：7
> 
> 时间：2008-09-16T22:21:08.363

您需要访问[Win32 控制台 API](https://docs.microsoft.com/en-us/windows/console/console-functions)。不幸的是，我不知道你如何从 Ruby 中做到这一点。在 Perl 中，我会使用[Win32::Console](http://search.cpan.org/perldoc?Win32::Console)模块。Windows 控制台不响应 ANSI 转义码。

根据artur02提到的[关于着色Ruby输出的文章](http://kpumuk.info/ruby-on-rails/colorizing-console-ruby-script-output/)，您需要安装并加载win32console gem。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-16T22:17:48.650

你可以在这里阅读一篇很好的插图文章： http: [//kpumuk.info/ruby-on-rails/colorizing-console-ruby-script-output/](http://kpumuk.info/ruby-on-rails/colorizing-console-ruby-script-output/)

我认为设置控制台文本颜色是非常特定于语言的。这是来自 MSDN 的 C# 示例：

```
for (int x = 0; x < colorNames.Length; x++)
{
  Console.Write("{0,2}: ", x);
  Console.BackgroundColor = ConsoleColor.Black;
  Console.ForegroundColor = (ConsoleColor)Enum.Parse(typeof(ConsoleColor), colorNames[x]);
  Console.Write("This is foreground color {0}.", colorNames[x]);
  Console.ResetColor();
  Console.WriteLine();
} 
```

**Console.ForegroundColor**是设置文本颜色的属性。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-16T22:29:16.033

您可以使用 ANSI 转义序列，但这不会在现代版本的 Windows 下做您想要的。维基百科有一篇内容丰富的文章：

[http://en.wikipedia.org/wiki/ANSI_escape_code](http://en.wikipedia.org/wiki/ANSI_escape_code)

因此，您最初问题的答案几乎肯定是“不”。但是，您可以在不编写转义序列的情况下更改前景色，例如通过调用 Win32 API 函数。我不知道如何在 Ruby 中做这种事情，但其他人似乎已经做到了：

[http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/241925](http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/241925)

我想你想用 4 表示深红色或 12 表示亮红色，用 7 恢复默认颜色。

希望这可以帮助！

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-16T22:33:17.850

关于 ANSI 转义码：

> 32 位字符模式（子系统：控制台）Windows 应用程序不会将 ANSI 转义序列写入控制台
> 
> 他们必须解释转义码操作并改为调用本机控制台 API

谢谢微软:-(

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-16T22:35:09.390

`color [background][foreground]`

其中颜色定义如下：

```
0 = Black    8 = Gray
1 = Blue     9 = Light Blue
2 = Green    A = Light Green
3 = Aqua     B = Light Aqua
4 = Red      C = Light Red
5 = Purple   D = Light Purple
6 = Yellow   E = Light Yellow
7 = White    F = Bright White 
```

例如，要将背景更改为蓝色并将前景更改为灰色，您可以键入：

`color 18`

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2015-07-31T09:42:52.950

我编写了一个小型跨平台 gem，它可以在 Windows 或 POSIX 系统上无缝运行，在 MRI 和 JRuby 下都可以处理。

它没有依赖关系，在 POSIX 系统上使用 ANSI 代码，在 Windows 上使用 FFI (JRuby) 或 Fiddler (MRI)。

要使用它，只需：

```
gem install color-console 
```

ColorConsole 提供了使用 Console.write 和 Console.puts 函数以不同颜色输出文本行的方法。

```
require 'color-console'

Console.puts "Some text"                    # Outputs text using the current  console colours
Console.puts "Some other text", :red        # Outputs red text with the current background
Console.puts "Yet more text", nil, :blue    # Outputs text using the current foreground and a blue background

# The following lines output BlueRedGreen on a single line, each word in the appropriate color
Console.write "Blue ", :blue
Console.write "Red ", :red
Console.write "Green", :green 
```

访问项目主页[https://github.com/agardiner/color-console](https://github.com/agardiner/color-console)了解更多详情。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-16T22:11:12.800

据我所知，命令行是不可能的，它只是一种颜色......

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T22:12:12.847

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Console_Test
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.ForegroundColor = ConsoleColor.DarkRed;
            Console.WriteLine("Hello World");
            Console.ReadKey();
        }
    }
} 
```

您可以使用简单的 C# 程序更改颜色，[http](http://powerof2games.com/node/31) ://powerof2games.com/node/31描述了如何包装控制台输出以实现效果。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T22:12:23.343

您需要[ANSI 转义码](http://en.wikipedia.org/wiki/ANSI_escape_code)。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-16T22:14:34.197

许多旧的 ANSI[颜色代码](http://pueblo.sourceforge.net/doc/manual/ansi_color_codes.html)都可以使用。红色前景的代码类似于 Escape-[31m. 转义是字符 27，因此是“\033[31m”或“\x1B[31m”，具体取决于您的转义方案。

[39m 是返回默认颜色的代码。

也可以一次指定多个代码来同时设置前景色和背景色。

您可能需要加载 ANSI.sys，请参阅[此页面](http://academic.evergreen.edu/projects/biophysics/technotes/program/ansi_esc.htm#notes)。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-09-16T22:18:21.740

用于输出到命令行的标准 C/C++ 规范没有指定任何更改控制台窗口颜色的功能。也就是说，Win32 中有很多函数可以做这样的事情。

更改 Win32 控制台颜色的最简单方法是通过 iostream.h 中的系统命令。该函数调用 DOS 命令。要更改颜色，我们将使用它来调用颜色命令。例如，`system("Color F1");`将使控制台在白色上变成深蓝色。

DOS 颜色

该命令可用的颜色是十六种 DOS 颜色，每种颜色都用一个十六进制数字表示。第一个是背景，第二个是前景。

```
0 = Black    8 = Gray
1 = Blue     9 = Light Blue
2 = Green    A = Light Green
3 = Aqua     B = Light Aqua
4 = Red      C = Light Red
5 = Purple   D = Light Purple
6 = Yellow   E = Light Yellow
7 = White    F = Bright White 
```

只是这一点点颜色使控制台程序在视觉上更令人愉悦。但是，颜色命令会改变整个控制台的颜色。要控制单个单元格，我们需要使用 windows.h 中的函数。

做你需要使用的`SetConsoleAttribute`功能

[http://msdn.microsoft.com/en-us/library/ms686047.aspx](http://http://msdn.microsoft.com/en-us/library/ms686047.aspx)

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-16T22:24:12.647

最终你需要调用[SetConsoleTextAttribute](http://msdn.microsoft.com/en-us/library/ms686047.aspx)。[您可以从GetStdHandle](http://msdn.microsoft.com/en-us/library/ms683231(VS.85).aspx)获取控制台屏幕缓冲区句柄。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-09-17T00:20:56.170

多年来，我一直在使用一个名为 baretail (google it) 的免费 Windows tail 程序，它可以让您执行 Windows 应用版本的 unix tail 命令。它使您可以根据定义的任何关键字对线条进行着色。作为一种解决方案，它的好处在于它不依赖于特定的语言或设置等，你只需定义你的配色方案，它就像 donkey kong 一样。在我个人排名前 10 位的免费软件帮手中！

# ruby-on-rails - Mongrel 以 100% CPU / EBADF 挂起（错误的文件描述符）

> ID：77748
> 
> 赞同：1
> 
> 时间：2008-09-16T22:07:06.617
> 
> 标签：ruby-on-rails, ruby, mongrel, rmagick

我们有一个服务器，有 10 个正在运行的 mongrel_cluster 实例，它们前面有 apache，并且不时有一个或一些挂起。在数据库中没有看到任何活动（我们正在使用 activerecord 会话）。带有innodb 表的Mysql。show innodb status 显示没有锁。show processlist 什么也不显示。

服务器是linux debian 4.0

Ruby 是：ruby 1.8.6 (2008-03-03 patchlevel 114) [i486-linux]

Rails 是：Rails 1.1.2（是的，很旧）

我们正在使用本机 mysql 连接器（gem install mysql）

“strace -p PID”在循环中为挂起的杂种进程提供以下内容：

```
gettimeofday({1219834026, 235289}, NULL) = 0
select(4, [3], [0], [], {0, 905241})    = -1 EBADF (Bad file descriptor)
gettimeofday({1219834026, 235477}, NULL) = 0
select(4, [3], [0], [], {0, 905053})    = -1 EBADF (Bad file descriptor)
gettimeofday({1219834026, 235654}, NULL) = 0
select(4, [3], [0], [], {0, 904875})    = -1 EBADF (Bad file descriptor)
gettimeofday({1219834026, 235829}, NULL) = 0
select(4, [3], [0], [], {0, 904700})    = -1 EBADF (Bad file descriptor)
gettimeofday({1219834026, 236017}, NULL) = 0
select(4, [3], [0], [], {0, 904513})    = -1 EBADF (Bad file descriptor)
gettimeofday({1219834026, 236192}, NULL) = 0
select(4, [3], [0], [], {0, 904338})    = -1 EBADF (Bad file descriptor)
gettimeofday({1219834026, 236367}, NULL) = 0
... 
```

使用lsof发现进程使用了​​67个文件描述符（lsof -p PID |wc -l）

有没有其他方法可以调试它，以便例如确定哪个文件描述符是“坏的”？还有其他信息或建议吗？还有人看到这个吗？

该站点被充分使用，但并不过分，平均负载通常在 0.3 左右。

* * *

一些额外的信息。我安装了 mongrelproctitle 来显示挂起的进程在做什么，似乎它们挂在一种方法上，该方法使用 file_column / 数据库中的图像 / rmagick 来显示图像以调整图像大小并使图像变为灰度。

问题不在这里，但这是一个怀疑。以下内容有明显问题吗？如果订单不包含图像，则该方法显示静态图像，否则图像会根据订单调整大小。缓存的东西是为了让图像每次都在浏览器中更新。图像被插入到带有普通图像标签的页面中。

代码：

```
 def preview_image
    @order = session[:order]
    if @order.image.nil?
      @headers['Pragma'] = 'no-cache'
      @headers['Cache-Control'] = 'no-cache, must-revalidate'
      send_data(EMPTY_PIC.to_blob, :filename => "img.jpg", :type =>
"image/jpeg", :disposition => "inline")
       else
      @pic = Image.read(@order.image)[0]
      if (@order.crop)
       @pic.crop!(@order.crop[:x1].to_i, @order.crop[:y1].to_i,
@order.crop[:width].to_i, @order.crop[:height].to_i, true)
      end
      @pic.resize!(103,130)
      @pic = @pic.quantize(256, Magick::GRAYColorspace)
      @headers['Pragma'] = 'no-cache'
      @headers['Cache-Control'] = 'no-cache, must-revalidate'
      send_data(@pic.to_blob, :filename => "img.jpg", :type =>
"image/jpeg", :disposition => "inline")
    end
  end 
```

如果有人能在其中找到任何问题，这是 lsof 输出。不知道它在这条消息中的格式...

```
lsof: WARNING: can't stat() ext3 file system /dev/.static/dev
      Output information may be incomplete.
COMMAND     PID    USER   FD   TYPE     DEVICE      SIZE     NODE NAME
mongrel_r 11628 username  cwd    DIR        9,2      4096  1870688 
/home/domains/example.com/usernameOrder/releases/20080831121802
mongrel_r 11628 username  rtd    DIR        9,1      4096        2 /
mongrel_r 11628 username  txt    REG        9,1      3564   167172 
/usr/bin/ruby1.8
mongrel_r 11628 username  mem    REG        0,0                  0 
[heap] (stat: No such file or directory)
mongrel_r 11628 username  DEL    REG        0,8           15560245 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560242 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560602 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560601 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560684 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560683 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560685 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560568 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560607 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560569 
/dev/zero
mongrel_r 11628 username  mem    REG        9,1   1933648   456972 
/usr/lib/libmysqlclient.so.15.0.0
mongrel_r 11628 username  DEL    REG        0,8           15442414 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560546 
/dev/zero
mongrel_r 11628 username  mem    REG        9,1     67408   457393 
/lib/i686/cmov/libresolv-2.7.so
mongrel_r 11628 username  mem    REG        9,1     17884   457386 
/lib/i686/cmov/libnss_dns-2.7.so
mongrel_r 11628 username  DEL    REG        0,8           15560541 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560246 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560693 
/dev/zero
mongrel_r 11628 username  DEL    REG        0,8           15560608 
/dev/zero
mongrel_r 11628 username  mem    REG        9,1     25700   164963 
/usr/lib/gconv/gconv-modules.cache
mongrel_r 11628 username  mem    REG        9,1     83708   457384 
/lib/i686/cmov/libnsl-2.7.so
mongrel_r 11628 username  mem    REG        9,1    140602   506903 
/var/lib/gems/1.8/gems/mysql-2.7/lib/mysql.so
mongrel_r 11628 username  mem    REG        9,1   1282816   180935 
...
mongrel_r 11628 username    1w   REG        9,2    462923  1575329 
/home/domains/example.com/usernameOrder/shared/log/mongrel.8001.log
mongrel_r 11628 username    2w   REG        9,2    462923  1575329 
/home/domains/example.com/usernameOrder/shared/log/mongrel.8001.log
mongrel_r 11628 username    3u  IPv4   15442350                TCP 
localhost:8001 (LISTEN)
mongrel_r 11628 username    4w   REG        9,2 118943548  1575355 
/home/domains/example.com/usernameOrder/shared/log/production.log
mongrel_r 11628 username    5u   REG        9,1    145306   234226 
/tmp/mongrel.11628.0 (deleted)
mongrel_r 11628 username    7u  unix 0xc3c12480           15442417 
socket
mongrel_r 11628 username   11u   REG        9,1        50   234180 
/tmp/CGI.11628.2
mongrel_r 11628 username   12u   REG        9,1     26228   234227 
/tmp/CGI.11628.3 
```

我已经安装了monit来监控服务器。由于 PID 文件问题，还没有自动重启，但也许我会得到支持删除陈旧 PID 文件的最新版本。
实际解决问题会很好，因为如果服务器需要一直重新启动（每天约 10 次），有人会断开连接等

发生这种情况时，mongrel-processes 不会占用任何大量内存，并且机器甚至没有交换，所以它可能不是内存泄漏。

```
 total       used       free     shared    buffers     cached
Mem:       4152796    4083000      69796          0     616624    2613364
-/+ buffers/cache:     853012    3299784
Swap:      1999992         52    1999940 
```

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-17T01:32:50.820

考虑使用[ImageScience](http://seattlerb.rubyforge.org/ImageScience.html)，已知 RMagick 会泄漏大量内存并锁定。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T22:40:25.523

Deploying Rails Applications (A Step by Step Guide) 一书中的第 6.3 章有一个很好的部分，介绍了在 Linux 上安装和配置监控实用程序 Monit 并使用它来监控你的杂种。当它们失败时，它可以重新启动你的杂种。

由于磁盘上存在重复的 PID 文件，旧版本的 Mongrel 无法重新启动。较新的版本支持 --clean 选项，该选项将删除剩余的 PID 文件（如果存在）。因此，您必须将 Mongrel 升级到支持 --clean 的版本才能解决过时的 PID 文件问题，仅 Monit 无法做到这一点。

# java - 使用 Java 读取 Windows EventLog 的方法

> ID：77813
> 
> 赞同：3
> 
> 时间：2008-09-16T22:12:52.673
> 
> 标签：java, java-native-interface, event-log

有人对如何在不使用 JNI 的情况下读取 Windows EventLog 有任何指示吗？或者，如果您*必须*使用 JNI，是否有任何好的开源库可以做到这一点？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2010-09-30T15:30:55.103

JNA 3.2.8 具有所有事件日志记录功能的实现和 Java 迭代器。读[这个](http://code.dblock.org/ShowPost.aspx?id=125)。

```
EventLogIterator iter = new EventLogIterator("Application");         
while(iter.hasNext()) { 
    EventLogRecord record = iter.next(); 
    System.out.println(record.getRecordId() 
            + ": Event ID: " + record.getEventId() 
            + ", Event Type: " + record.getType() 
            + ", Event Source: " + record.getSource()); 
} 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T22:37:20.290

[http://bloggingabout.net/blogs/wellink/archive/2005/04/08/3289.aspx](http://bloggingabout.net/blogs/wellink/archive/2005/04/08/3289.aspx) 和 [http://www.j-interop.org/](http://www.j-interop.org/)

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T22:43:21.880

您可能需要考虑将[J/Invoke](http://www.jinvoke.com/)或[JNA（Java Native Access）](https://github.com/twall/jna/)作为广受批评的 JNI 的替代方案。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T22:39:57.380

您需要使用[JNI](http://en.wikipedia.org/wiki/Java_Native_Interface)。

# c++ - 类的C++运行时知识

> ID：77817
> 
> 赞同：2
> 
> 时间：2008-09-16T22:13:07.977
> 
> 标签：c++, class, runtime

我有多个类都派生自一个基类，现在某些派生类将不会根据平台进行编译。我有一个类允许我返回基类的对象，但是现在派生类的所有名称都已被硬编码。

有没有办法确定哪些类已经编译，最好是在运行时，这样我就可以删除链接，而是提供动态可加载的库。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-16T22:26:00.130

您在寻找 C++ 运行时类注册吗？我找到了这个[链接](http://meat.net/2006/03/cpp-runtime-class-registration/)（[备份](http://web.archive.org/web/20100618122920/http://meat.net/2006/03/cpp-runtime-class-registration/)）。

这可能会完成您想要的，我不确定动态加载的模块以及您是否可以使用相同的方法注册它们。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T22:16:55.923

我不知道你真正想要完成什么，但你可以在每个派生类的实现文件中放置一个单例构造函数，将名称与指向工厂的指针一起添加到列表中。然后该列表始终是最新的，并且可以创建所有已编译的类。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T22:17:10.370

通常，在 C++ 中依赖运行时类型信息是一个坏主意。你所描述的似乎是工厂模式。您可能需要考虑为每个平台创建一个特殊的工厂子类，它只知道该平台上存在的类。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T22:16:15.160

这听起来像是一个使用“编译时多态性”或模板策略参数的地方。

参见 Andrei Alexandrescu 的 Modern C++ Design 和他基于本书的[Loki实现。](http://sourceforge.net/projects/loki-lib/)另请参阅维基百科的[Loki](http://en.wikipedia.org/wiki/Loki_(C%2B%2B))页面。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T22:16:22.960

在运行时获取类信息有一些讨厌的、特定于编译器的技巧。相信我，你不想打开那罐虫子。

在我看来，唯一认真的方法是对每个派生类使用条件编译。在#ifdef 块中，定义一个包含正在编译的类名的*新常量。*然后，名称仍然是硬编码的，但都在一个中心位置。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T22:28:51.823

派生类的名称必须用 C++ 硬编码。没有其他方法可以使用它们。因此，不仅无法自动检测已编译的类，而且如果存在该信息，也无法使用该信息。

如果您可以根据名称在运行时指定类，例如：

std::string foo = "Derived1"; 基础 * 对象 = 新的“foo”；// 或任何你喜欢的符号 - 在 C++ 中不起作用

那么判断“Derived1”是否已编译的能力将很有用。由于您必须直接指定类，例如：

基础 * 对象 = 新的 Derived1；// 在 C++ 中工作

所有检查都在编译时完成。

* * *

## 回答 #7

> 赞同：-1
> 
> 时间：2008-09-16T22:15:01.327

如果每个类都有自己的动态库，只需检查该库是否存在。

# php - PHP：$_SESSION - 在 $_SESSION 变量中存储临时使用的数据的优缺点是什么

> ID：77826
> 
> 赞同：32
> 
> 时间：2008-09-16T22:13:48.037
> 
> 标签：php, session, scope

我最近开始经常做的一件事是在任务开始时**检索一些数据****并将其存储在 $_SESSION['myDataForTheTask']**中。

现在这样做似乎很方便，但我对使用这种方法的性能、安全风险或类似情况一无所知。它是由具有更多专业知识的程序员经常做的事情，还是更像是业余的事情？

**例如：**

```
if (!isset($_SESSION['dataentry']))
{
    $query_taskinfo = "SELECT participationcode, modulearray, wavenum FROM mng_wave WHERE wave_id=" . mysql_real_escape_string($_GET['wave_id']);
    $result_taskinfo = $db->query($query_taskinfo);
    $row_taskinfo = $result_taskinfo->fetch_row();

        $dataentry = array("pcode" => $row_taskinfo[0], "modules" => $row_taskinfo[1], "data_id" => 0, "wavenum" => $row_taskinfo[2], "prequest" => FALSE, "highlight" => array());

        $_SESSION['dataentry'] = $dataentry;
} 
```

* * *

## 回答 #1

> 赞同：20
> 
> 时间：2008-09-16T22:26:16.180

会话变量实际上是使访问者在网站上的整个时间都可用这些变量的唯一方法之一（并且可能是最有效的），用户没有真正的方法来编辑它们（除了您的漏洞利用代码，或在 PHP 解释器中），因此它们相当安全。

这是一种存储用户可以更改的设置的好方法，因为您可以在会话开始时从数据库中读取一次设置，并且它可用于整个会话，您只需在设置时进行进一步的数据库调用已更改，当然，正如您在代码中显示的那样，找出设置是否已经存在或是否需要从数据库中提取它们是微不足道的。

我想不出任何其他安全存储临时变量的方法（因为 cookie 很容易被修改，这在大多数情况下是不可取的）所以 $_SESSION 将是要走的路

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-09-16T22:24:43.173

我一直使用会话变量来为用户存储信息。我没有看到任何性能问题。会话数据是基于 cookie（或*PHPSESSID*，如果您关闭了 cookie）。我不认为它比任何其他基于 cookie 的身份验证更具安全风险，并且可能比将实际数据存储在用户 cookie 中更安全。

只是让您知道，您的 SQL 语句确实存在安全问题：

```
SELECT participationcode, modulearray, wavenum FROM mng_wave WHERE wave_id=".$_GET['wave_id']; 
```

您**永远不应该，我永远不重复**，获取用户提供的数据并使用它来运行 SQL 语句，而无需先对其进行清理。我会将它用引号括起来并添加函数`mysql_real_escape_string()`。这将保护您免受大多数攻击。所以你的行看起来像：

```
$query_taskinfo = "SELECT participationcode, modulearray, wavenum FROM mng_wave WHERE wave_id='".mysql_real_escape_string($_GET['wave_id'])."'"; 
```

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-10-13T05:53:08.160

$_SESSION 机制正在使用 cookie。

如果是 Firefox（也许是新的 IE，我没有检查自己），这意味着**session 是在打开的 tabs 之间共享的**。默认情况下，这不是您所期望的。这意味着会话不再是“特定于单个窗口/用户的东西”。

例如，如果您打开了两个选项卡来访问您的站点，而不是使用第一个选项卡以 root 身份登录，您将获得另一个选项卡的 root 权限。

这真的很不方便，特别是如果您编写电子邮件客户端或其他东西（如电子商店）。在这种情况下，您将不得不手动管理会话或在 URL 中引入不断重新生成的密钥或执行其他操作。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T22:19:31.673

在决定将临时数据存储在何处时，您需要考虑几个因素。会话存储非常适合特定于单个用户的数据。如果您发现默认的基于文件的会话存储处理程序效率低下，您可以实现其他东西，可能使用数据库或 memcache 类型的后端。有关更多信息，请参阅[session_set_save_handler](http://us.php.net/manual/en/function.session-set-save-handler.php)。

我发现在用户会话中存储公共数据是一种不好的做法。有更好的地方可以存储多个用户经常访问的数据，并且通过将这些数据存储在会话中，您将为需要这些数据的每个用户复制数据。在您的示例中，您可能会为此波数据（基于 wave_id）设置不同类型的存储引擎，该引擎不专门与用户会话相关联。这样，您只需将数据拉下一次，然后将其存储在多个用户可以访问数据而无需再次拉取的地方。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-16T22:21:10.827

如果您在自己的服务器上运行，或者在没有人可以窥探服务器上的文件/内存的环境中运行，则会话数据是安全的。它们存储在服务器上，只是发送给客户端的标识 cookie。当然，问题是其他人是否可以抢走 cookie 并冒充其他人。使用 HTTPS 并确保不将会话 ID 放在 URL 中应该可以使您的用户免受大多数这些问题的影响。（如果你不小心的话，XSS 可能仍会被用来抓取 cookie，请参阅[Jeef Atwoods 的帖子](http://www.codinghorror.com/blog/archives/001167.html)。）

至于在会话变量中存储什么，如果您想在另一个页面上再次引用它，请将您的数据放在那里，例如购物篮，但如果它只是用于产生此结果的临时数据，请不要放在那里页面，例如当前查看的帖子的标签列表。会话用于每个用户的持久数据。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-16T22:47:31.263

另一种改进输入验证的方法是转换 _GET['wave_id'] 变量：

```
$query_taskinfo = "SELECT participationcode, modulearray, wavenum FROM mng_wave WHERE wave_id=".(int)$_GET['wave_id']." LIMIT 1"; 
```

我假设 wave_id 是一个整数，并且只有一个答案。

将要

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2009-04-20T11:20:38.193

使用会话的其他一些缺点：

1.  `$_SESSION`*数据将在session.gc_maxlifetime*秒不活动后过期。
2.  您必须记住调用`session_start()`将使用会话数据的每个脚本。
3.  通过在多个服务器上进行负载平衡来扩展网站可能是一个问题，因为每次都需要将用户定向到同一台服务器。用“Sticky Sessions”解决这个问题。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-16T22:16:34.630

$_SESSION 项目存储在会话中，默认情况下，会话保存在磁盘上。无需像您那样创建自己的数组并将其填充到“dataentry”数组条目中。您可以只使用 $_SESSION['pcode']、$_SESSION['modules'] 等。

就像我说的，会话存储在磁盘上，指向会话的指针存储在 cookie 中。因此，用户不能轻易获得会话数据。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-16T22:20:49.020

IMO，在会话中存储东西是完全可以接受的。这是使数据持久化的好方法。在许多情况下，它也比将所有内容存储在 cookie 中更安全。这里有几个问题：

*   有人可能会劫持会话，因此如果您要使用它来跟踪用户授权，请小心。阅读[此](http://en.wikipedia.org/wiki/Session_hijacking)内容以获取更多信息。
*   保存数据可能是一种非常懒惰的方式。不要只是将所有内容都扔到会话中，以便您以后不必查询它。
*   如果您要在会话中存储对象，则需要在下一个请求启动会话之前包含它们的类文件，或者您需要配置一个自动加载器。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-09-16T22:25:58.537

Zend Framework 有一个有用的会话数据管理库，它有助于过期和安全（用于验证码之类的东西）。他们还对会话进行了有用的解释。请参阅[http://framework.zend.com/manual/en/zend.session.html](http://framework.zend.com/manual/en/zend.session.html)

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-09-17T00:03:11.050

我发现会话非常有用，但有几点需要注意：

1) PHP 可能会将您的会话存储在 tmp 文件夹或您服务器上其他用户可以访问的其他目录中。您可以通过转到 php.ini 文件来更改存储会话的目录。

2) 如果您正在建立一个需要非常严格的安全性的高价值系统，您可能希望在将数据发送到会话之前对其进行加密，然后对其进行解密以使用它。注意：这可能会产生过多的开销，具体取决于您的流量/服务器容量。

3) 我发现 session_destroy(); 不会立即删除会话，您仍然需要等待 PHP 垃圾收集器清理会话。您可以在 php.ini 文件中更改垃圾收集器的运行频率。但似乎仍然不是很可靠，更多信息[http://www.captain.at/howto-php-sessions.php](http://www.captain.at/howto-php-sessions.php)

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2009-03-11T13:05:00.493

您可能想考虑一下这有多 REST-ful？

即参见“ [A Brief Introduction to REST](http://www.infoq.com/articles/rest-introduction) ”中的“无状态通信”段落...

> “REST 要求状态要么转换为资源状态，要么保留在客户端上。换句话说，服务器不应该为任何与其通信的客户端保留某种通信状态，而不是单个请求。”

[（或REST](http://en.wikipedia.org/wiki/REST)维基百科上的任何其他链接）

所以在你的情况下，'wave_id' 是一个合理的 GET 资源，但你真的想将它存储在 SESSION 中吗？[memcached](http://www.danga.com/memcached/)肯定是您缓存对象资源的解决方案吗？

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-16T22:17:00.137

我使用这种方法相当多，我认为它没有任何问题。与 cookie 不同，数据不存储在客户端，这通常是一个大错误。

就像任何事情一样，请注意始终清理用户输入，特别是如果您将用户输入放入 $_SESSION 变量，然后在 SQL 查询中使用该变量。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-09-16T22:23:04.753

这是相当常见的事情，并且会话通常比连续的数据库命中要快。它们也相当安全，因为 PHP 开发人员一直在努力防止会话劫持。

唯一的问题是您需要记住在发生变化时重建会话条目。并且，如果拥有会话的用户以外的用户更改了任何会导致需要刷新此密钥的更改，则没有简单的方法来通知系统刷新此会话密钥。可能没什么大不了的，但您应该注意一些事情。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2009-04-29T16:15:33.687

$_SESSION 在安全性方面非常有用，因为它是一种在用户活跃在您的页面上时存储信息的服务器端方式，因此很难破解，除非您的实际 php 文件或服务器存在被利用的弱点。一个非常好的实现是存储一个变量以确认用户已登录，并且仅在确认用户已登录时才允许采取行动。

# asp.net - 如何使任何 aspx 网页的任意部分可用作 Ajax 弹出窗口

> ID：77833
> 
> 赞同：0
> 
> 时间：2008-09-16T22:15:30.373
> 
> 标签：asp.net, asp.net-ajax

我想知道是否有人能想到一种好的技术来使 aspx 页面的任意部分（例如，指定 DIV 标记中的内容）能够被调用并显示在 ajax 模式弹出窗口中？（因此，只会显示页面的某个部分）

例如：
1）您有一个包含许多实体（客户、产品、商店等）的大型应用程序
2）每个实体都有一个 EntityDetails aspx 页面

现在，从显示许多不同类型实体的发票屏幕说，我希望能够将鼠标悬停（或单击一个小图标）一个实体，并弹出一个小工具提示样式的模态 ajax 窗口，显示的内容将是相应的 EntityDetails aspx 页面的一部分，该页面被指定为可用于呈现为弹出窗口。显然，标识特定实体的相应 aspx 参数也必须从页面传递。

所以要做到这一点，**我认为请求的页面必须在服务器的内存中呈现**，然后必须将innerhtml从指定的div中拉出，并返回到调用页面，然后在弹出的 ajax 窗口中显示此 html。因此，除非有一种我缺少的更简单的方法来做到这一点，否则如何在服务器上完成此渲染？

以前有没有人见过这样做，是否有任何预先存在的框架或任何东西可以做到这一点？

更复杂的是，是否可以使用已经嵌入现有页面中的现有 asp.net 表单机制来编辑弹出表单并将其保存回服务器（如果调用表单已经具有 asp.net 表单。 ...我认为每页只允许使用一种形式，对吗？）

当然，通过简单的 javascript 弹出窗口或新窗口打开 EntityDetails 表单并不是我想要的。而且我不想在我希望显示的每个页面上嵌入详细信息表单……可以想象，应用程序中的每个表单都可以调用任何其他表单作为弹出窗口。

谢谢！

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T22:17:26.093

您很可能使用一组用户控件和 AJAX 控件工具包中提供的 ModalPopupExtender 来执行此操作。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T22:18:16.560

如果您使用用户控件进行编辑，我认为您可以使用[Greybox](http://www.orangoo.com/labs/GreyBox/)来完成。将用户控件名称（和其他参数）传递给您以灰色框显示的页面，然后动态加载执行编辑的用户控件。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T22:54:14.587

我不能投票，但用户控制将是一种方式。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2010-03-12T17:57:21.933

[http://api.jquery.com/load/](http://api.jquery.com/load/) [http://css.dzone.com/articles/jquery-load-data-from-other-pa](http://css.dzone.com/articles/jquery-load-data-from-other-pa)

# unit-testing - 如何解决此错误：“找不到类 PHPUnit_Extensions_SeleniumTestCase”

> ID：77835
> 
> 赞同：12
> 
> 时间：2008-09-16T22:15:46.627
> 
> 标签：unit-testing, selenium, phpunit, cruisecontrol, phpundercontrol

我正在尝试使用 phpunit 运行 SeleniumTestCase，但我无法使用 phpunit.bat 脚本运行它。

我的目标是在 CruiseControl 和 phpUnderControl 中使用 phpunit 和 Selenium RC。这是测试的样子：

```
require_once 'PHPUnit/Extensions/SeleniumTestCase.php';

class WebTest extends PHPUnit_Extensions_SeleniumTestCase
{
    protected function setUp()
    {
        $this->setBrowser('*firefox');
        $this->setBrowserUrl('http://www.example.com/');
    }

    public function testTitle()
    {
        $this->open('http://www.example.com/');
        $this->assertTitleEquals('Example Web Page');
    }
} 
```

我还在 include_path 中安装了 PEAR，并使用 Selenium 扩展安装了 PHPUnit。我用 pear 安装程序安装了这些，所以我想这不是问题。

任何帮助将不胜感激。

谢谢，雷米

* * *

## 回答 #1

> 赞同：16
> 
> 时间：2010-12-15T23:39:45.737

希望这是一个比这里给出的答案更明确的答案（这并没有解决我的问题）。如果您收到此错误，请检查您的 PEAR 文件夹并查看“SeleniumTestCase.php”文件是否确实存在：

```
/PEAR/PHPUnit/Extensions/SeleniumTestCase.php 
```

如果不是，最简单的方法是使用 PEAR 卸载并重新安装 PHPUnit ...

```
pear uninstall phpunit/PHPUnit

pear uninstall phpunit/PHPUnit_Selenium

pear install phpunit/PHPUnit 
```

完成上述操作并仅进行一次安装后，PHPUnit_Selenium 也自动安装了，我不确定这是否是典型的，所以有些人可能不得不这样做......

```
pear install phpunit/PHPUnit_Selenium 
```

如果需要，请参阅[http://www.phpunit.de/manual/3.5/en/installation.html](http://www.phpunit.de/manual/3.5/en/installation.html)了解 PEAR 频道信息...

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2009-01-23T11:04:18.543

这是交易：

如果你有“Class PHPUnit_Extensions_SeleniumTestCase could not be found in (testcase file name)”的问题，你必须做以下两件事：

***1\. 将测试用例文件重命名为它包含的类的名称*** ***2\. 您应该从包含测试的文件夹中启动 phpunit。***

这应该可以解决您的问题。

安德鲁

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T22:30:11.150

查看php手册中require_once条目中的评论之一。

[http://ie.php.net/manual/en/function.require-once.php#62838](http://ie.php.net/manual/en/function.require-once.php#62838)

“require_once（和 include_once 相关的）很慢

此外，如果您计划使用单元测试和模拟对象（即在您要测试的类中包含真实类之前包括模拟类），它将无法正常工作，因为 require() 加载的是文件而不是类。”

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2010-01-27T10:50:06.657

我发现 PHPUnit 教程中的以下示例正在运行，而我编写的测试中出现了相同的错误。解决方案是一个惊喜。确保您的类位于`<?php .. ?>`块内，而不是`<? .. ?>`脚本中的块内。

```
<?php
require_once 'PHPUnit/Framework.php';

class StackTest extends PHPUnit_Framework_TestCase
{
    public function testPushAndPop()
    {
        $stack = array();
        $this->assertEquals(0, count($stack));

        array_push($stack, 'foo');
        $this->assertEquals('foo', $stack[count($stack)-1]);
        $this->assertEquals(1, count($stack));

        $this->assertEquals('foo', array_pop($stack));
        $this->assertEquals(0, count($stack));
    }
}
?> 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T22:43:06.687

我刚刚将我的测试所在的文件重命名为“WebTest.php”（它包含的类的名称），现在测试运行良好。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2009-02-26T14:30:05.453

不要假设 pear 安装没有问题。

我已经通过 pear 安装了 phpunit，但是尽管它说当我查看文件夹内部时安装正常，但我有所有这些以 .tmp 开头的文件，例如 PHPUnit/Util/.tmpErrorHandler.php，所以当我运行第一个测试时很自然时间它给了我与上面相同的错误。在检查该文件确实不存在后，我手动将 PHPUnit 安装到与 pear 相同的文件夹，唉，一切都很好。我在 Mac/豹。

关于 Selenim RC 不要忘记通过在终端运行 java -jar /path/to/file/selenium-server.jar 来启动它

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2014-10-01T15:53:52.323

尝试：

```
class WebTest extends \PHPUnit_Extensions_Selenium2TestCase 
```

它可能是命名空间问题，就像对我一样。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2012-01-30T05:31:18.833

这是我解决这个问题的方法：

1.  确保安装了 php 的 curl 扩展，例如 ubuntu`sudo apt-get install php5-curl`
2.  进入`sudo pear install phpunit/PHPUnit_Selenium`

之后，您应该安装丢失的文件

快乐的编码...

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2014-02-05T03:32:03.317

当它失败时，它并不总是打印出最详细的错误消息。

永远记得在运行测试之前也启动 Selenium。

java -jar selenium-server-standalone-2.39.0.jar

这是一个为我自己工作的代码示例。[http://www.siteconsortium.com/h/p1.php?id=php002](http://www.siteconsortium.com/h/p1.php?id=php002)。显然，编写测试套件和启动测试用例有很多不同的方法，但我首先使用 set_class_path 来摆脱类问题。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2009-01-08T17:03:01.577

好吧，当我使用内联命令时：如果从 PhPunit 目录启动测试我有错误，而当从测试目录启动它时我没有错误...

但我仍然没有任何对 selenium 服务器的访问权限......我是否必须先启动它。

如果是，奇怪的是我们没有为 PhPUnit 指定任何句柄......

# math - 如何在平截头体上剪裁线段？

> ID：77836
> 
> 赞同：5
> 
> 时间：2008-09-16T22:15:57.720
> 
> 标签：math, clipping

给定两个向量**A**和**B**，它们形成线段**L** = AB。此外，给定一个由其左、右、下、上、近和远平面定义的视锥**F。**

我如何剪辑**L**反对**F**？

也就是说，测试一个交叉点*以及*该交叉点在 L 上的哪个位置？（请记住，如果一条线段在拐角处与两侧相交，则它可以与平截头体有**多个交点。）**

如果可能，请提供代码示例（首选 C++ 或 Python）。

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-16T22:21:31.997

我现在不想为此编写代码，但如果我正确理解“截锥体”，以下应该可以工作。

1.  与所有给定平面相交线
2.  如果你有两个路口，你就完成了。
3.  如果您只有一个交点，请计算前平面并相交。
4.  如果您仍然只有一个交点，请计算背板并相交。

但我可能完全误解了。在这种情况下，请详细说明:)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-18T07:17:40.607

除了上面所说的下士 Touchy 所说的，您还需要[知道如何将线段与平面相交](http://local.wasp.uwa.edu.au/~pbourke/geometry/planeline/)。在该页面的描述中， u 表示您的线的参数定义中的参数。首先，使用描述的 2 种方法之一计算 u。如果 u 的值在 0.0 到 1.0 的范围内，则平面会剪裁线段上某处的线。将 u 插回您的直线方程可以为您提供该交点发生的点。

另一种方法是找到每个点到平面的有[向距离](http://mathworld.wolfram.com/Point-PlaneDistance.html)。如果一个点的距离为正而另一个为负，则它们位于平面的相对两侧。然后，您知道哪个点在您的截锥体之外（基于您的平面法线指向的方式）。使用这种方法，通过基于有向距离的比率进行线性插值，可以更快地找到交点。例如，如果一个点的距离是 +12 而另一个是 -12，那么您知道平面将线段切成两半，并且您的 u 参数是 0.5。

希望这可以帮助。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2016-01-23T06:50:55.453

首先[从您的视图矩阵中提取平面](https://stackoverflow.com/a/34960913/432509)。

然后使用您的点将向量和最小值/最大值定义为 (0, 1)，然后遍历平面并将它们与线段相交，更新最小值/最大值，如果`min > max`.

这是一个纯 Python 函数的示例，没有外部依赖。

```
def clip_segment_v3_plane_n(p1, p2, planes):
    """
    - p1, p2: pair of 3d vectors defining a line segment.
    - planes: a sequence of (4 floats): `(x, y, z, d)`.

    Returns 2 vector triplets (the clipped segment)
    or (None, None) then segment is entirely outside.
    """
    dp = sub_v3v3(p2, p1)

    p1_fac = 0.0
    p2_fac = 1.0

    for p in planes:
        div = dot_v3v3(p, dp)
        if div != 0.0:
            t = -plane_point_side_v3(p, p1)
            if div > 0.0:  # clip p1 lower bounds
                if t >= div:
                    return None, None
                if t > 0.0:
                    fac = (t / div)
                    if fac > p1_fac:
                        p1_fac = fac
                        if p1_fac > p2_fac:
                            return None, None
            elif div < 0.0:  # clip p2 upper bounds
                if t > 0.0:
                    return None, None
                if t > div:
                    fac = (t / div)
                    if fac < p2_fac:
                        p2_fac = fac
                        if p1_fac > p2_fac:
                            return None, None

    p1_clip = add_v3v3(p1, mul_v3_fl(dp, p1_fac))
    p2_clip = add_v3v3(p1, mul_v3_fl(dp, p2_fac))

    return p1_clip, p2_clip

# inline math library
def add_v3v3(v0, v1):
    return (
        v0[0] + v1[0],
        v0[1] + v1[1],
        v0[2] + v1[2],
        )

def sub_v3v3(v0, v1):
    return (
        v0[0] - v1[0],
        v0[1] - v1[1],
        v0[2] - v1[2],
        )

def dot_v3v3(v0, v1):
    return (
        (v0[0] * v1[0]) +
        (v0[1] * v1[1]) +
        (v0[2] * v1[2])
        )

def mul_v3_fl(v0, f):
    return (
        v0[0] * f,
        v0[1] * f,
        v0[2] * f,
        )

def plane_point_side_v3(p, v):
    return dot_v3v3(p, v) + p[3] 
```

# php - 使用 PHP 填写 PDF 表单

> ID：77873
> 
> 赞同：48
> 
> 时间：2008-09-16T22:19:08.913
> 
> 标签：php, pdf

是否有 PHP 库可用于填写 PDF 表单，然后将它们保存（展平）为 PDF 文件？

* * *

## 回答 #1

> 赞同：48
> 
> 时间：2008-09-16T23:21:41.260

这里提到的库和框架都不错，但如果你只想填写一个表格并将其展平，我推荐名为 pdftk (PDF Toolkit) 的命令行工具。

见[https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/](https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/)

可以从php调用命令行，命令为

`pdftk` *formfile.pdf* `fill_form` *fieldinfo.fdf* `output` *outputfile.pdf* `flatten`

您需要找到 FDF 文件的格式，以生成填写字段的信息。这是一个很好的链接：

[http://www.tgreer.com/fdfServe.html](http://www.tgreer.com/fdfServe.html)

[编辑：上面的链接似乎失效了。这里有更多信息...]

pdftk 命令可以从 PDF 格式文件生成 FDF 文件。然后，您可以使用生成的 FDF 文件作为示例。表单域是 FDF 文件的一部分，看起来像

```
...
<< /T(f1-1) /V(text of field) >>
<< /T(f1-2) /V(text of another field) >>
... 
```

您还可以查看[php-pdftk](https://github.com/mikehaertl/php-pdftk)，这是一个特定于 PHP 的库。我没有使用它，但评论者 Álvaro（下）推荐它。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2012-10-07T19:23:46.720

对已接受的答案大加 1，如果您遇到 fdf 文件的编码问题，还有一点提示。如果您生成 fields.fdf 并在运行时

```
file -bi fields.fdf 
```

你得到

```
application/octet-stream; charset=binary 
```

那么您很可能遇到了 UTF-16 字符集问题。尝试通过以下方式转换 ftf

```
cat fields.fdf | sed -e's/\x00//g' | sed -e's/\xFE\xFF//g' > better.fdf 
```

然后我可以编辑 better.fdf 文件并将其导入我的 PDF 表单。

希望这可以为某人节省一些谷歌

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-18T00:49:54.737

我在使用提交给使用 fpdf 并将表单字段作为获取变量传递的 php 脚本的表单方面取得了很大的成功（可能不是一个很好的最佳实践，但它确实有效）。

```
 <?php
require('fpdf.php');
$pdf=new PDF();
$pdf->AddPage();
$pdf->SetY(30);
$pdf->SetX(100);
$pdf->MultiCell(10,4,$_POST['content'],0,'J');
$pdf->Output();
?> 
```

你可以有这样的东西。

```
 <form action="fooPDF.php" method="post">
     <p>PDF CONTENT: <textarea name="content" ></textarea></p>
     <p><input type="submit" /></p>
    </form> 
```

这个骨架示例应该可以帮助您入门。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2009-07-03T09:30:07.960

用 php 生成 fdf 文件：见[http://www.php.net/manual/en/book.fdf.php](http://www.php.net/manual/en/book.fdf.php)

然后使用 pdftk 将其填充到 pdf 中（见上文）

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2012-05-20T14:00:05.230

为了：

*   比 XFDF 更简单的输入格式
*   真正的 UTF-8（俄语）支持
*   完整的php使用示例

随意检查我的[PdfFormFillerUTF-8](https://sourceforge.net/projects/pdfformfiller2/)。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-16T22:28:20.857

看起来这已经被[覆盖了](https://stackoverflow.com/questions/7364/pdf-editing-in-php)。点击查看使用 Zend Framework PDF 库的相关代码。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-16T22:29:58.670

我们在工作中使用[PDFLib](http://www.pdflib.com/)。付费版不是很贵，而且有一个更有限的开源版，如果你买不起付费版的话。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-22T00:55:08.987

我编写了一个 Perl 库[CAM::PDF](http://search.cpan.org/dist/CAM-PDF/)，它带有一个可以解决这个问题的[命令行界面。](http://search.cpan.org/dist/CAM-PDF/bin/fillpdffields.pl)几年前我尝试使用 FDF 解决方案，但发现它太复杂了，这就是我首先编写 CAM::PDF 的原因。我的库使用一些启发式方法将表单替换为所需的文本，因此它并不完美。但它在大多数情况下都有效，而且快速、免费且使用起来非常简单。

# multithreading - 解释 Windows Minidump 中的堆栈

> ID：77887
> 
> 赞同：9
> 
> 时间：2008-09-16T22:21:27.240
> 
> 标签：multithreading, windbg, stack-trace

作为一个刚刚开始学习复杂的计算机调试的人，对于我的生活，我无法理解如何阅读 Windbg 中转储的堆栈文本。我不知道从哪里开始如何解释它们或如何去做。任何人都可以为这个可怜的灵魂提供方向吗？

即（实际上我手头上唯一的垃圾场）

```
>b69dd8f0 bfa1e255 016d2fc0 89efc000 00000040 nv4_disp+0x48b94

b69dd8f4 016d2fc0 89efc000 00000040 00000006 nv4_disp+0x49255

b69dd8f8 89efc000 00000040 00000006 bfa1dcc0 0x16d2fc0

b69dd8fc 00000000 00000006 bfa1dcc0 e1e71018 0x89efc000
```

我知道问题与 Nvidia 显示驱动程序有关，但我想知道的是如何实际读取堆栈（例如，什么是 b69dd8f4？）:-[

* * *

## 回答 #1

> 赞同：18
> 
> 时间：2008-09-16T22:49:30.493

首先，您需要配置正确的符号。这些符号将允许您将内存地址与函数名称相匹配。为此，您必须在您的机器中创建一个本地文件夹，您将在其中存储符号的本地缓存（例如：C:\symbols）。然后您需要指定符号服务器路径。为此，只需转到：文件 > 符号文件路径并键入：

```
SRV*c:\symbols*http://msdl.microsoft.com/download/symbols 
```

[您可以在此处](http://www.microsoft.com/whdc/devtools/debugging/debugstart.mspx#a)找到有关如何正确配置符号的更多信息。

正确配置符号服务器后，您可以从以下位置打开小型转储：文件 > 打开故障转储。

打开 minidump 后，它将在命令行左侧显示生成转储时正在执行的线程。如果你想看看这个线程正在执行什么类型：

```
kpn 200 
```

第一次执行它可能需要一些时间，因为它必须第一次下载必要的公共 Microsoft 相关符号。下载所有符号后，您将获得如下信息：

```
01 MODULE!CLASS.FUNCTIONNAME1(...)
02 MODULE!CLASS.FUNCTIONNAME2(...)
03 MODULE!CLASS.FUNCTIONNAME3(...)
04 MODULE!CLASS.FUNCTIONNAME4(...) 
```

在哪里：

*   **THE FIRST NUMBER** : 表示帧号
*   **MODULE** : 包含代码的 DLL
*   **CLASS**：（仅在 C++ 代码上）将向您显示包含代码的类
*   **FUNCTIONAME**：被调用的方法。如果您有正确的符号，您还将看到参数。

您可能还会看到类似

```
01 MODULE!+989823 
```

这表明您没有此 DLL 的正确符号，因此您只能看到方法偏移量。

那么，什么是调用栈？

想象一下你有这样的代码：

```
void main()
{
  method1();
}

void method1()
{
  method2();
}

int method2()
{
  return 20/0;
} 
```

在这段代码中，method2 基本上会抛出一个异常，因为我们试图除以 0，这将导致进程崩溃。如果我们在发生这种情况时得到一个小型转储，我们将看到以下调用堆栈：

```
01 MYDLL!method2()
02 MYDLL!method1()
03 MYDLL!main() 
```

您可以从此调用堆栈中跟踪“main”调用“method1”，然后调用“method2”并且它失败了。

在你的情况下，你有这个调用堆栈（我猜这是运行“kb”命令的结果）

```
b69dd8f0 bfa1e255 016d2fc0 89efc000 00000040 nv4_disp+0x48b94
b69dd8f4 016d2fc0 89efc000 00000040 00000006 nv4_disp+0x49255
b69dd8f8 89efc000 00000040 00000006 bfa1dcc0 0x16d2fc0
b69dd8fc 00000000 00000006 bfa1dcc0 e1e71018 0x89efc000 
```

第一列表示子帧指针，第二列表示正在执行的方法的返回地址，接下来的三列显示传递给方法的前 3 个参数，最后一部分是 DLL 名称（nv4_disp）以及正在执行的方法的偏移量（+0x48b94）。由于您没有符号，因此您无法看到方法名称。我怀疑 NVIDIA 是否提供对其符号的公开访问，所以我猜你无法从这里获得太多信息。

我建议你运行“kpn 200”。这将向您显示完整的调用堆栈，您可能会看到导致此崩溃的方法的来源（如果它是 Microsoft DLL，您应该在我提供的步骤中使用正确的符号）。

至少您知道它与 NVIDIA 错误有关 ;-) 尝试将此驱动程序的 DLL 升级到最新版本。

如果您想了解有关 WinDBG 调试的更多信息，我推荐以下链接：

*   [如果坏了，你应该修复它](http://blogs.msdn.com/tess/default.aspx)
*   [TechNet 网络广播：Windows 挂起和故障转储分析](http://www.microsoft.com/events/EventDetails.aspx?CMTYSvcSource=MSCOMMedia&Params=~CMTYDataSvcParams%5E~arg+Name%3D%22ID%22+Value%3D%221032298076%22%2F%5E~arg+Name%3D%22ProviderID%22+Value%3D%22A6B43178-497C-4225-BA42-DF595171F04C%22%2F%5E~arg+Name%3D%22lang%22+Value%3D%22en%22%2F%5E~arg+Name%3D%22cr%22+Value%3D%22US%22%2F%5E~sParams%5E~%2FsParams%5E~%2FCMTYDataSvcParams%5E)
*   [Delicious.com WinDBG 上的热门链接](http://delicious.com/popular/windbg)

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T22:46:39.893

此处提供了有关解释堆栈跟踪的非常好的教程：

[http://www.codeproject.com/KB/debug/cdbntsd2.aspx](http://www.codeproject.com/KB/debug/cdbntsd2.aspx)

然而，即使有这样的教程，在没有可用/加载的正确符号的情况下解释堆栈转储也可能非常困难（或几乎不可能）。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T22:27:04.010

包含您尝试阅读的堆栈示例可能会有所帮助。一个好的提示是确保堆栈中显示的所有模块都有正确的调试符号。这包括操作系统中模块的符号，微软已经公开了他们的符号服务器。

# delphi - 在 Delphi 中，如何从防火墙 API 中的 LocalPolicy.CurrentProfile.GloballyOpenPorts 获取枚举器

> ID：77890
> 
> 赞同：2
> 
> 时间：2008-09-16T22:21:38.190
> 
> 标签：delphi, firewall

我正在编写一些代码，以查看**WinXP**和**Vista**的防火墙例外列表中是否存在针对我们客户端软件使用的特定端口的漏洞。

我可以看到我可以使用`NetFwMgr.LocalPolicy.CurrentProfile.GloballyOpenPorts`来获取当前开放端口异常的列表。但我不知道如何将枚举列表放入我可以在我的 Delphi 程序中使用的东西中。

下面列出了我的最新尝试。当我使用`port_list.Item`. 我知道那是错误的，这主要是我的一厢情愿。任何帮助，将不胜感激。

```
function TFirewallUtility.IsPortInExceptionList(iPortNumber: integer): boolean;
var
  i, h: integer;
  port_list, port: OleVariant;
begin
  Result := False;
  port_list := mxFirewallManager.LocalPolicy.CurrentProfile.GloballyOpenPorts;
  for i := 0 to port_list.Count - 1 do
  begin
    port := port_list.Item[i];
    if (port.PortNumber = iPortNumber) then
    begin
      Result := True;
      break;
    end;
  end;
end; 
```

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T21:32:54.420

好的，我想我已经弄清楚了。

我必须创建 hnetcfg.dll 的类型库文件。我刚开始时就这样做了，但从那时起我就学到了很多关于防火墙对象的知识。那时它不起作用，但它现在起作用了。您可以从 Component|Import Component 创建自己的文件。然后按照向导。

包装代码使用了我通常不喜欢做的异常，但我不知道如何判断正在返回接口的接口是否实际上正在返回我可以处理的数据......所以这将是一个如果有人能指出我正确的方向，则改进。

现在是代码，感谢 Jim 的回复。

```
constructor TFirewallUtility.Create;
begin
  inherited Create;
  CoInitialize(nil);
  mxCurrentFirewallProfile := INetFwMgr(CreateOLEObject('HNetCfg.FwMgr')).LocalPolicy.CurrentProfile;
end;

function TFirewallUtility.IsPortInExceptionList(iPortNumber: integer): boolean;
begin
  try
    Result := mxCurrentFirewallProfile.GloballyOpenPorts.Item(iPortNumber, NET_FW_IP_PROTOCOL_TCP).Port = iPortNumber;
  except
    Result := False;
  end;
end;

function TFirewallUtility.IsPortEnabled(iPortNumber: integer): boolean;
begin
  try
    Result := mxCurrentFirewallProfile.GloballyOpenPorts.Item(iPortNumber, NET_FW_IP_PROTOCOL_TCP).Enabled;
  except
    Result := False;
  end;
end;

procedure TFirewallUtility.SetPortEnabled(iPortNumber: integer; sPortName: string; xProtocol: TFirewallPortProtocol);
begin
  try
   mxCurrentFirewallProfile.GloballyOpenPorts.Item(iPortNumber, CFirewallPortProtocalConsts[xProtocol]).Enabled := True;
  except
    HaltIf(True, 'xFirewallManager.TFirewallUtility.IsPortEnabled: Port not in exception list.');
  end;
end;

procedure TFirewallUtility.AddPortToFirewall(sPortName: string; iPortNumber: Cardinal; xProtocol: TFirewallPortProtocol);
var
  port: INetFwOpenPort;
begin
  port := INetFwOpenPort(CreateOLEObject('HNetCfg.FWOpenPort'));
  port.Name := sPortName;
  port.Protocol := CFirewallPortProtocalConsts[xProtocol];
  port.Port := iPortNumber;
  port.Scope := NET_FW_SCOPE_ALL;
  port.Enabled := true;
  mxCurrentFirewallProfile.GloballyOpenPorts.Add(port);
end; 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2009-10-23T12:58:19.223

您可以像这样遍历枚举：

```
type
  IEnumVariant = interface(IUnknown)
  ['{00020404-0000-0000-C000-000000000046}']
    function Next(celt: LongWord; var rgvar : OleVariant;
                 pceltFetched: PLongWord): HResult; stdcall;
    function Skip(celt: LongWord): HResult; stdcall;
    function Reset: HResult; stdcall;
    function Clone(out Enum : IEnumVariant) : HResult; stdcall;
  end;

var
  Enum : IEnumVariant;
  Port : OleVariant;
  Count : Integer;
...
Count := 1;
IUnknown (Profile.GloballyOpenPorts._NewEnum).QueryInterface (IEnumVariant, Enum);
Enum.Reset;
while (Enum.Next (1, FirewallPort, @Count) = S_OK) do
  begin
  if (FirewallPort.Port = Port) then
    Exit (True)
  end; 
```

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T22:53:26.100

在不设置要测试的应用程序的情况下，我将建议以下内容。让我知道它是否有效。

我在[这里查看了 C# 示例](http://blogs.msdn.com/joncole/archive/2005/12/06/managed-classes-to-view-manipulate-the-windows-firewall.aspx)，看起来您需要执行以下操作：

```
Result := False;
port_enum := mxFirewallManager.LocalPolicy.CurrentProfile.GloballyOpenPorts._NewEnum;
while port_enum.MoveNext <> Null do // try assigned if that doesn't work
begin
  port = e.Current as INetFwOpenPort;
  if (port.PortNumber = iPortNumber) then
  begin
    Result := True;
    break;
  end;
end; 
```

不确定这是否会编译，但**_NewEnum**、**MoveNext**和**Current**是您要使用的成员。

# html - 那里正在使用哪些电子邮件客户端？

> ID：77891
> 
> 赞同：6
> 
> 时间：2008-09-16T22:21:47.270
> 
> 标签：html, email, outlook, statistics

这不是“完全”一个编程问题，但它是高度相关的。我们正在编写一个为客户发送电子邮件邀请的应用程序（不，这不是垃圾邮件）。他们的设计师给了我们一个 HTML 和 CSS 模板供我们使用，这很好。问题是它在 Outlook 2007 中看起来像垃圾，因为 Microsoft 决定使用 Word（所有东西！）作为[Outlook 2007 中 HTML 的呈现引擎](http://msdn.microsoft.com/en-us/library/aa338201.aspx)。我希望客户了解他们应该设计一个“兼容”的外观，并且希望能够显示一些关于正在使用哪些电子邮件客户端的统计数据，即 Outlook 2007 的使用量正在增长。

有没有人浏览过任何白皮书、网站、研究，甚至接近提供对此的看法？我不期望人口普查水平的准确性，但相当可信的东西会很好。谢谢你的帮助。

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-09-16T22:29:57.890

我对此普遍认为的最佳实践的理解是为最小公分母编码。有很多电子邮件客户端在野外使用足够多，但在呈现“现代”HTML 方面并不出色。

首先，旨在将您的邮件作为 2 部分的多部分 mime 消息发送。一个 HTML 部分和一个纯文本部分。

其次，尽可能避免使用 CSS 或定位的 div。使用基于表格的布局和内联样式。最好尽可能多地在 HTML 中指定样式。

尝试将图像保留为内联 IMG 标签，或仅作为表格/行/单元格背景属性。

电子邮件世界远没有浏览器世界那么新，更重要的是，它远比浏览器世界更加多样化。如果您遵循这些简单的规则，那么您的生活将比采用更高级的方法并反复调整它以使您的内容在足够多的普通客户端上令人满意地呈现要容易得多。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T23:45:57.393

如果没有一般统计数据，请自行收集。

查看[http://fingerprintapp.com/email-client-stats](http://fingerprintapp.com/email-client-stats)以获取现成的统计数据收集工具，并查看[http://www.mattbrindley.com/fingerprint-email-client-usage-1/](http://www.mattbrindley.com/fingerprint-email-client-usage-1/)以获取 write-起来吧。Matt Brindley 也提供了这颗宝石：“*到目前为止，只有 Outlook 像我们预期的那样受欢迎，iPhone 对我们自己的列表来说是一个显着的惊喜，Lotus Notes 也出人意料地出现了。* ”

当然，提供 text/html 和 text/plain mime 类型，以便读者可以选择查看哪个版本，并保持您的 html 非常基本，直到您的统计数据表明您可以变得更高级。

如果指纹的费用是不可能的，您可以收集自己的统计数据。在您的 HTML 中包含超链接。当您的 CGI 应用程序接收到来自这些超链接的请求时，它可以将 HTTP_USER_AGENT 保存在数据库中以供您进行统计分析。这种方法并不完全可靠，因为有些读者会坚持纯文本，有些人永远不会点击任何超链接，有些电子邮件客户端不会在用户代理请求标头中包含有用的信息，但它可能会为您提供足够的信息来继续。

Sitepoint 是一个备受推崇的 W3 信息来源，有一篇文章[http://www.sitepoint.com/article/code-html-email-newsletters/](http://www.sitepoint.com/article/code-html-email-newsletters/)，其中 Tom Slavin 指出：

1.  使用 HTML 表格来控制设计布局和一些演示。您可能习惯于为您的网页使用纯 CSS 布局，但这种方法在电子邮件环境中是行不通的。

2.  使用内联 CSS 来控制电子邮件中的其他演示元素，例如背景颜色和字体。

Slavin 还推荐来自 Campaign Monitor 和 MailChimp 的模板来帮助您入门。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-16T22:48:33.337

原始市场份额数据对您帮助不大。在设计 HTML 电子邮件时，唯一重要的是您的特定目标人群使用什么客户端。这取决于地理区域、行业、B2B/B2C——在实践中差异很大。在某些行业（新闻业...），您甚至不得不考虑使用 Lotus Notes 等客户端的大量用户，Lotus Notes 以支持 HTML 而臭名昭著，只是名义上支持 HTML（不寒而栗）。

Outlook 2007 肯定不能再被忽视，特别是如果您发送到企业地址，但在新 PC 上使用 Vista 时，私人帐户也有明显的存在。

Return Path 确实有按行业划分的数据。

然而，在实践中，一个好的方法是遵循“保存”指南，以最低公分母风格。Outlook 2007 并不是唯一有问题的客户端——Gmail 也因缺乏对其他一些设计元素的支持而臭名昭著。您会发现数量惊人的网页设计师确实在 HTML 电子邮件设计方面做副业（有需求，它有助于支付租金）。如果您刚开始，Campaign Monitor（电子邮件营销提供商）拥有丰富的优质资源。您可以从他们的[2008 电子邮件设计指南](http://www.campaignmonitor.com/blog/archives/2008/05/2008_email_design_guidelines.html)开始。他们也是[电子邮件标准项目](http://www.email-standards.org/)背后的成员之一。

哦，我个人将 Thunderbird 与 IMAP、Gmail 和 RoundCube 一起使用。

（免责声明/全面披露：我实际上是在为Campaing Monitor 的竞争对手工作。）

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-16T22:24:54.750

你应该看看[ReturnPath](https://returnpath.com/) - 他们有点专攻那个。

您可能需要考虑的客户（Outlook 除外）：

*   [美国在线](https://aol.com)
*   [谷](https://gmail.com)歌（谷歌）
*   [雅虎邮箱](https://ymail.com)（雅虎）
*   [Hotmail](https://hotmail.com) / [Live](https://live.com) / [MSN](https://msn.com) / [Outlook](https://outlook.com)（微软）
*   Lotus Notes (IBM)
*   [雷鸟](https://thunderbird.net)(Mozilla)

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T23:25:26.010

我有outlook和gmail，还有黑莓曲线...

该曲线在处理纯文本/文本电子邮件以外的任何内容时都非常糟糕。请在顶部附近有一个链接以在网站上查看电子邮件，并考虑发送多部分电子邮件，该电子邮件还包含针对不支持 HTML 等的客户的纯文本部分。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T22:26:34.497

如果您希望吸引许多商业客户，请记住其中很大一部分将使用 MS Office 和 Exchange Server，因此也使用 Outlook。如果您更针对家庭用户，他们中的大多数人将使用一些网络邮件或使用常规 HTML 引擎的邮件客户端，例如 Windows Mail、Thunderbird、Opera Mail、Mac OS X Mail.app。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T22:32:48.757

我使用 KMail，你也应该看看 Thunderbird、Outlook、Evolution、Lotus 和 Opera Mail。

还要记住，许多人使用网络邮件，例如 GMail、Hotmail、Yahoo Mail 等。出于安全原因，一些网络邮件（和邮件客户端）仅以纯文本形式工作。

我个人认为纯文本电子邮件是最好的，出于安全原因，许多人宁愿不允许 HTML 邮件，因此无论如何都会查看格式错误的纯文本邮件，无论您发送什么，所以在我看来它会更好只使用纯文本。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-16T22:41:16.333

Gmail - 个人邮件

Lotus Notes - 被迫将其用于公司邮件:(

Lotus Notes 无法正确呈现任何 HTML 消息（我们运行的是 6.5），并且仅部分支持 CSS。最好的 HTML 消息是简单的基于表格的布局。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T22:53:52.870

在工作中，我们有 3 x KMail 和 4 x mac OSX' 邮件。
进一步的 webmail 作为 Firefox、Camino、Safari 中的故障转移（邮件服务器上的 squirrelmail）。我们把这些话放在邮件里，其余的放在附件里。

单词（纯文本消息）可以简单地复制/粘贴、转发等，而不会出现格式问题。

单独的附件允许用户选择查看、下载、保存等。

这是使用邮件的最通用方式。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T23:06:16.913

我前段时间遇到过这个问题。大多数客户端（包括网络）阻止 HTML！我们刚刚创建了电子邮件的网络版本并将其添加到电子邮件的页脚“如果您无法查看消息，请单击此处（链接到网络版本）。这只是因为有些人认为它不安全显示图片 ;-) 所以更好的方式让它们打开并阅读漂亮的 html 电子邮件

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-16T23:32:43.043

我运行 M2（Opera 的内置邮件客户端）并始终将其设置为邮件正文“首选纯文本”。我还打开了“阻止外部元素”。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-09-16T23:53:18.640

另外，我认为如果您同时发送 text/plain 和 text/html，Gmail 用户（网络邮件 UI）别无选择，只能查看 text/html 版本。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2010-10-20T18:32:58.497

我看到这份报告/数据清楚地表明 Outlook 2007 越来越受欢迎并呈上升趋势。目前，该站点报告了以下前 4 位客户（当然是 100% 的百分比），但 Outlook 2007 也呈上升趋势。希望这可以帮助。

[http://www.campaignmonitor.com/stats/email-clients/#most_popular](http://www.campaignmonitor.com/stats/email-clients/#most_popular)

27.77% Outlook 2000、2003、Express / 16.23% Hotmail / 14.14% Yahoo! 邮件 / 8.94% Outlook 2007

* * *

## 回答 #14

> 赞同：-1
> 
> 时间：2008-09-16T22:27:12.187

我正在使用 gmail

# asp.net - 如何将 aspx webform 上的所有控件转换为只读等效项

> ID：77900
> 
> 赞同：5
> 
> 时间：2008-09-16T22:23:10.963
> 
> 标签：asp.net

有没有人写过可以将aspx页面上的所有控件转换为只读版本的函数？例如，如果 UserDetails.aspx 用于编辑和保存用户信息，如果有不适当权限的人进入该页面，我想将其呈现为只读。因此，大多数控件将被转换为标签，并从可编辑的原始控件中加载相应的数据。

我认为这可能是一个相当简单的例程，即：

```
Dim ctlParent As Control = Me.txtTest.Parent  
Dim ctlOLD As TextBox = Me.txtTest  
Dim ctlNEW As Label = New Label  
ctlNEW.Width = ctlOLD.Width  
ctlNEW.Text = ctlOLD.Text  
ctlParent.Controls.Remove(ctlOLD)  
ctlParent.Controls.Add(ctlNEW) 
```

...确实是文本框所需要的全部 --> 标签转换，但我希望有人可能知道现有的功能，因为在某些控件和情况下可能存在一些陷阱。

更新：
- 只是将 ReadOnly 属性设置为 true 不是一个可行的解决方案，因为它看起来像这样变灰看起来很愚蠢。- 避免手动创建辅助视图是这一点的全部重点，因此我试图避免使用一种巧妙的方式来显示使用标签手动构建的用户界面的只读版本。

谢谢！！

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-20T07:51:23.190

斯科特米切尔不久前发表了一篇很好的文章。

[http://aspnet.4guysfromrolla.com/articles/012506-1.aspx](http://aspnet.4guysfromrolla.com/articles/012506-1.aspx)

我过去曾使用这种方法来推测“只读”字段上的 css 以使它们看起来和工作起来完全像一个标签，即使它们实际上是文本框。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T22:29:06.143

您可以使用多视图并且只有一个显示视图和一个编辑视图..然后将您的任务分配为：

```
lblWhatever.Text = txtWhatever.Text = whateverOriginatingSource;
lblSomethingElse.Text = txtSomethingElse.Text = somethingElseOriginatingSource;

myViews.SelectedIndex = myConditionOrVariableThatDeterminesEditable ? 0 : 1; 
```

然后根据权限交换视图。

不是最优雅的，但可能适合您的情况。

也许我应该详细说明一下.. 消除伪（不确定我是否选择了 selectedindex yada yada 对.. 但你明白了）。

```
<asp:Multiview ID="myViews" SelectedIndex="1">
    <asp:View ID="EditView">
        <asp:TextBox ID="txtWhatever" /><br />
        <asp:TextBox ID="txtSomethingElse" />
    </asp:View>
    <asp:View ID="DisplayView">
        <asp:Label ID="lblWhatever" /><br />
        <asp:Label ID="lblSomethingElse" />
    </asp:View>
</asp:Multiview> 
```

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-19T17:12:28.457

Use a DetailsView. It does exactly what you want based on the current mode of the page.

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T22:53:22.670

如何创建自己的控件库，如果 ReadOnly 为 true，则呈现方式不同。就像是：

```
MyTextBox : TextBox {
   public override void RenderControl(HtmlTextWriter writer) {
      if (this.ReadOnly) {
          writer.WriteBeginTag("label");
          writer.Write(this.Value);
          writer.WriteEndTag();
      }
   }
} 
```

有一种方法可以使用 web.config 将所有 asp:TextBox 实例替换为您自己的控件，而无需编辑 my:TextBox - 但我无法找到参考 ATM。

否则，我可能只是编写一个 jQuery 片段来完成它。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T22:53:30.623

我不知道任何现有的功能，但自己处理控件并不难。您需要担心的最重要的事情是控件树中的非 ASP.NET 控件。（例如。）

您可以将控件设置为适当的类型并仅检查 null，然后正确处理每个控件。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T23:03:45.297

如果没有编写自己的控件，恐怕您不想走的路线（制作第二个仅标签页面）可能是一条非常好的路线，因为您不希望有人运行可以编辑的 Firebug动态 HTML 只需关闭您现有的任何控件并使用该页面，就好像他们有权更新它一样。

# ssl - 使用密码保护的 SSL 密钥在 Apache 2 上由 logrotate 导致的失败

> ID：77914
> 
> 赞同：3
> 
> 时间：2008-09-16T22:26:08.723
> 
> 标签：ssl, crash, apache2, logrotate, passphrase

我在 Debian 上安装了 Apache 2，并安装了 mod_ssl。服务器私钥受启动时需要输入的密码保护。错误和访问日志每周都会进行 logrotate。我发现 Apache 在 logrotate 运行后不久崩溃并出现与密码相关的错误。

我知道 logrotate 在归档日志后会向 Apache 触发 SIGHUP，我怀疑这会导致重新加载以及随后无法获取服务器密钥的密码。

好吧，我的理论说得够多了，问题来了：

是否有一种“最佳实践”方式来配置 Apache 以允许其 SSL 服务器密钥受密码保护（而不将该密码存储在某处的文件中），以便在运行 logrotate 时不会崩溃？

在服务器启动时要求用户输入很好，但不需要重新启动或重新加载。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T22:33:50.953

您可以使用不需要叹气的[Cronolog](http://cronolog.org/)。这是一个例子：

```
CustomLog "| /usr/sbin/cronolog /pathtologs/%Y_%m/sitename.com-%Y%m%d.log" combined 
```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2009-01-07T17:03:43.773

您还可以使用以下命令关闭密码：

```
openssl rsa -in example.tld.key -out example.tld.key 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T22:28:06.583

一种选择是使用 Apache 提供的日志轮换工具。它的配置与系统 logrotate 略有不同，但由于它与管道一起使用，因此可以在不重新启动 Apache 的情况下移动文件。

# lisp - 如何使用 ltk 显示图像？

> ID：77934
> 
> 赞同：4
> 
> 时间：2008-09-16T22:28:50.620
> 
> 标签：lisp, tcl, tk, sbcl, ltk

我已经编写了代码来读取 Windows 位图，现在想用 ltk 显示它。我怎样才能构造一个合适的对象？ltk中有这样的功能吗？如果不是，我怎么能直接连接到 tk？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-19T18:17:33.110

自从我使用 LTK 做任何事情以来已经有一段时间了，但是使用 LTK 显示图像的最简单方法如下：

```
(defpackage #:ltk-image-example
  (:use #:cl #:ltk))

(in-package #:ltk-image-example)

(defun image-example ()
  (with-ltk ()
    (let ((image (make-image)))
      (image-load image "testimage.gif")
      (let ((canvas (make-instance 'canvas)))
        (create-image canvas 0 0 :image image)
        (configure canvas :width 800)
        (configure canvas :height 640)
        (pack canvas))))) 
```

不幸的是，默认情况下您可以对图像执行的操作相当有限，您只能使用 gif 或 ppm 图像 - 但[ppm 文件格式](http://en.wikipedia.org/wiki/Portable_pixmap)非常简单，您可以轻松地从位图创建 ppm 图像。但是，您说要操作显示的图像，并查看定义图像对象的代码：

```
(defclass photo-image(tkobject)
  ((data :accessor data :initform nil :initarg :data)
   )
  )

(defmethod widget-path ((photo photo-image))
  (name photo))

(defmethod initialize-instance :after ((p photo-image)
                                       &key width height format grayscale data)
  (check-type data (or null string))
  (setf (name p) (create-name))
  (format-wish "image create photo ~A~@[ -width ~a~]~@[ -height ~a~]~@[ -format \"~a\"~]~@[ -grayscale~*~]~@[ -data ~s~]"
               (name p) width height format grayscale data))

(defun make-image ()
  (let* ((name (create-name))
     (i (make-instance 'photo-image :name name)))
    ;(create i)
    i))

(defgeneric image-load (p filename))
(defmethod image-load((p photo-image) filename)
  ;(format t "loading file ~a~&" filename)
  (send-wish (format nil "~A read {~A} -shrink" (name p) filename))
  p) 
```

看起来图像的实际数据是由 Tcl/Tk 解释器存储的，并且无法从 lisp 中访问。如果您想访问它，您可能需要使用**format-wish**和**send-wish**编写自己的函数。

当然，您可以简单地在画布对象上单独渲染每个像素，但我认为这样做不会获得很好的性能，一旦您尝试在其上显示数千种不同的东西，画布小部件就会变得有点慢它。所以总结一下——如果你不关心实时做任何事情，你可以在每次想要显示时将位图保存为 .ppm 图像，然后使用上面的代码简单地加载它——这将是最简单的。否则，您可以尝试从 tk 本身访问数据（在将其作为 ppm 图像加载一次之后），最后如果这些都不起作用，您可以切换到另一个工具包。大多数像样的 lisp GUI 工具包都是用于 linux 的，所以如果你使用的是 windows，你可能会不走运。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-17T01:28:36.773

Tk 本身不支持 Windows 位图文件。但是，“Img”扩展在几乎所有平台上都可以免费使用。您不需要读取数据，您可以直接从磁盘上的文件创建图像。在普通的 tcl/tk 中，您的代码可能看起来像这样：

```
package require Img
set image [image create photo -file /path/to/image.bmp]
label .l -image $image
pack .l 
```

更多信息可以在[http://wiki.tcl.tk/6165找到](http://wiki.tcl.tk/6165)

# python - 计算 3D（或 nD）质心的最佳方法是什么？

> ID：77936
> 
> 赞同：26
> 
> 时间：2008-09-16T22:28:58.703
> 
> 标签：python, math, 3d, geometry

作为工作项目的一部分，我必须计算 3D 空间中一组点的质心。现在我正在以一种看似简单但幼稚的方式来做这件事——通过取每组点的平均值，如下所示：

```
centroid = average(x), average(y), average(z) 
```

其中`x`,`y`和`z`是浮点数数组。我似乎记得有一种方法可以获得更准确的质心，但我还没有找到一个简单的算法来做到这一点。有人有什么想法或建议吗？我为此使用 Python，但我可以改编其他语言的示例。

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2016-06-13T01:56:07.663

与这里的常见说法相反，有不同的方法来定义（和计算）点云的中心。您已经提出了第一个也是最常见的解决方案，我**不会**争辩这有什么问题：

`centroid = average(x), average(y), average(z)`

这里的“问题”是它会根据你的点分布“扭曲”你的中心点。例如，如果您假设所有点都在立方体或其他几何形状内，但它们中的大多数恰好位于上半部分，那么您的中心点也会朝那个方向移动。

作为替代方案，您可以在每个维度中使用数学中间值（极值的平均值）来避免这种情况：

`middle = middle(x), middle(y), middle(z)`

当您不太关心点的数量时，您可以使用它，但更关心全局边界框，因为这就是所有这些 - 围绕您的点的边界框的中心。

最后，您还可以`median`在每个维度中使用（中间的元素）：

`median = median(x), median(y), median(z)`

现在，这将与实际相反`middle`，实际上可以帮助您忽略点云中的异常值并**根据**点的分布找到中心点。

找到“好”中心点的更稳健的方法可能是忽略每个维度中的顶部和底部 10%，然后计算`average`or `median`。如您所见，您可以用不同的方式定义中心点。下面我将向您展示 2 个 2D 点云的示例，并考虑到这些建议。

深蓝点是平均（平均）质心。中位数显示为绿色。中间显示为红色。在第二张图片中，您将看到我之前所说的：绿点“更接近”点云最密集的部分，而红点离它更远，考虑到最极端的边界。点云。

[![在此处输入图像描述](https://i.stack.imgur.com/8qSQA.png)](https://i.stack.imgur.com/8qSQA.png) [![在此处输入图像描述](https://i.stack.imgur.com/iZSSi.png)](https://i.stack.imgur.com/iZSSi.png)

* * *

## 回答 #2

> 赞同：12
> 
> 时间：2008-09-16T22:33:06.447

不，这是点集合质心的唯一公式。参见维基百科：[http ://en.wikipedia.org/wiki/Centroid](http://en.wikipedia.org/wiki/Centroid)

* * *

## 回答 #3

> 赞同：12
> 
> 时间：2008-09-17T22:35:44.137

您含糊地提到“一种获得更准确质心的方法”。也许您正在谈论不受异常值影响的质心。例如，美国的*平均*家庭收入可能非常高，因为少数*非常*富有的人扭曲了平均水平；他们是“异常值”。出于这个原因，统计学家改用中*位数*。获得中位数的一种方法是对值进行排序，然后在列表的中间选择值。

也许您正在寻找类似的东西，但对于 2D 或 3D 点。问题是，在 2D 及更高版本中，您无法排序。没有自然规律。然而，有一些方法可以消除异常值。

一种方法是找到点的[凸包](http://en.wikipedia.org/wiki/Convex_hull)。凸包的所有点都在点集的“外部”。如果你这样做，并扔掉船体上的点，你将扔掉异常值，剩下的点将给出一个更具“代表性”的质心。你甚至可以多次重复这个过程，结果就像剥洋葱一样。实际上，它被称为“凸壳剥落”。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T22:40:36.960

您可以使用提高准确度求和 - Kahan 求和 - 这就是您的想法吗？

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-17T17:48:20.647

可能更有效：如果您要多次计算，则可以通过保留两个常设变量来加快速度

```
N  # number of points
sums = dict(x=0,y=0,z=0)  # sums of the locations for each point 
```

然后在创建或销毁点时更改 N 和总和。这会将计算的时间从 O(N) 更改为 O(1)，但每次创建、移动或销毁一个点时都会花费更多的工作。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T22:34:34.057

“更准确的质心”我相信质心是按照您计算它的方式定义的，因此不可能有“更准确的质心”。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T22:42:12.850

是的，这是正确的公式。

如果您有大量点，您可以利用问题的对称性（无论是圆柱、球面还是镜面）。否则，您可以从统计数据中借用并平均随机数的点，而只会出现一些错误。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2021-03-11T06:19:48.830

如果您的**n 维**向量在列表**[[a0, a1, ..., an],[b0, b1, ..., bn],[c0, c1, ..., cn]]**中，只需转换要数组的列表，然后像这样计算质心：

```
import numpy as np

vectors = np.array(Listv)
centroid = np.mean(vectors, axis=0) 
```

* * *

## 回答 #9

> 赞同：-1
> 
> 时间：2008-09-16T22:33:34.277

你说对了。您正在计算的是质心或平均向量。

# perl - 引用 undef 值时如何让 Perl 停止？

> ID：77954
> 
> 赞同：15
> 
> 时间：2008-09-16T22:30:07.437
> 
> 标签：perl, warnings, undef

当您引用 undef 值时，如何让 Perl 停止并给出堆栈跟踪，而不仅仅是警告？似乎这`use strict;`还不够。

* * *

## 回答 #1

> 赞同：20
> 
> 时间：2008-09-16T22:32:25.853

```
use warnings FATAL => 'uninitialized';

use Carp ();
$SIG{__DIE__} = \&Carp::confess; 
```

第一行使警告致命。当您的程序终止时，接下来的两个会导致堆栈跟踪。

* * *

## 回答 #2

> 赞同：15
> 
> 时间：2008-09-16T23:11:35.137

`%SIG`而不是其他人提出的乱七八糟的摆弄，只是和完成。`use [Carp::Always](http://search.cpan.org/perldoc?Carp::Always)`

请注意，您可以将模块注入脚本而无需修改源代码，只需使用`perl -MCarp::Always`;运行它即可。此外，您可以将`PERL5OPT`环境变量设置`-MCarp::Always`为在不更改脚本调用的情况下加载它。（见[`perldoc perlrun`](http://p3rl.org/run)。）

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-16T22:32:04.047

包括这个：

```
use Carp (); 
```

然后在源文件的顶部包含以下行*之一：*

```
local $SIG{__WARN__} = \&Carp::confess;
local $SIG{__WARN__} = \&Carp::cluck; 
```

该`confess`行将给出堆栈跟踪，并且该`cluck`行更加简洁。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-16T22:32:31.893

引用 undef 值本身不是问题，但如果您的代码期望它不是 undef 值，它可能会导致警告。（特别是如果您尝试将该变量用作对象引用）。您可以在代码中添加一些内容，例如：

```
use Carp qw();

[....]

Carp::confess '$variableName is undef' unless defined $variableName;

[....] 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T22:33:12.937

使这些警告致命的一种方法是为**WARN**虚拟信号安装信号处理程序：

```
$SIG{__WARN__} = sub { die "Undef value: @_" if $_[0] =~ /undefined/ }; 
```

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2011-05-03T17:10:31.193

您必须手动执行此操作。上面的“答案”不起作用！只需测试一下：

```
use strict;
use warnings FATAL => 'uninitialized';
use Carp ();
$SIG{__DIE__} = \&Carp::confess;

my $x = undef; # it would be enough to say my $x;
if (!$x->{test}) {
print "no warnings, no errors\n";
} 
```

您将看到取消引用不会导致任何错误消息或警告。我知道没有办法让 Perl 自动检测使用 undef 作为无效引用。我怀疑这是设计使然，因此自动生存可以无缝地工作。

# visual-studio - Visual Studio 不断添加空行

> ID：77957
> 
> 赞同：1
> 
> 时间：2008-09-16T22:30:19.150
> 
> 标签：visual-studio, visual-studio-2008

我将 Visual Studio 2008 用于 ASP .Net 应用程序，每当我保存、切换到设计模式并返回代码视图、切换到拆分模式或在文件之间切换时，Visual Studio 都会不断向我的 aspx 文件添加空行。在我保存之前，我将拥有：

```
 </ContentTemplate></asp:UpdatePanel>
                    </ContentTemplate>
                </ajax:TabPanel>
            </ajax:TabContainer> 
```

然后，它会神奇地变成：

```
 </ContentTemplate></asp:UpdatePanel>

</ContentTemplate>

</ajax:TabPanel>
                    </ajax:TabContainer> 
```

我知道这主要是一个美学问题，但它还在每个选项卡容器中添加了 17 行无内容（并使文件滚动时间更长），这很烦人。我检查过我没有放错引号，文件前面没有错位的标签，有什么想法吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-17T00:11:09.330

我唯一一次看到 Visual Studio 做类似的事情是当相关的 XML/HTML 无效时，例如您在某处缺少结束标记。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T23:58:09.020

我不能说我曾经在任何 Visual Studio 中体验过这个，但是试试这个

**Ctrl-E、D**命令会自动重新格式化文件。（假设C#开发环境）

**Ctrl-K, Ctrl-D**用于 Web 开发环境

如果文档保持原样，间距不正确，那么自动格式就是问题所在。简单地禁用**选项**->**文本编辑器**-> **HTML** ->格式中的自动**格式**

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2010-07-12T04:47:02.077

由于未知的原因，选项卡容器似乎在设计环境中临时呈现长字符串，这似乎导致使用默认设置插入空行。关闭标签包装，似乎对我有用。

工具/选项/

[显示所有设置]

文本编辑器/HTML

超过指定长度时包装标签

如果有兴趣。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2019-06-19T11:16:27.410

我有同样的问题，这里以前的答案都没有解决它；但我在这里找到了解决方案：[https](https://github.com/Microsoft/vscode/issues/12076) ://github.com/Microsoft/vscode/issues/12076 。转到**.editor.config**文件并设置**insert_final_newline = false**（或简单地删除该行）。

# asp.net - 在会话变量中放入什么

> ID：77960
> 
> 赞同：7
> 
> 时间：2008-09-16T22:30:45.890
> 
> 标签：asp.net, asp-classic

我最近遇到了一个 ASP 1.1 Web 应用程序，它在会话变量中放置了一大堆东西——包括所有 DB 数据对象，甚至是 DB 连接对象。它最终变得巨大。当 Web 会话超时（用户使用完应用程序后四个小时）时，有时他们的数据库事务会回滚。我假设这是因为当 IIS 终止会话时数据库连接没有正确关闭。

无论如何，我的问题是会话变量中应该包含什么？显然有些东西需要在那里。用户在主屏幕上选择他们想要编辑的计划，因此计划 ID 进入会话变量。通过将有关用户（及其经理等）的所有详细信息以及他们正在编辑的计划存储在会话变量中来尝试减少数据库的负载是否更好，或者我应该尝试最小化会话变量中的内容和在 Page_Load 事件中查询数据库以获取我需要的所有内容？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-09-16T22:34:07.317

这很难回答，因为它是特定于应用程序的，但这里有一些我使用的指南：

1.  在会话中尽可能少地放置。
2.  只应在给定访问期间持续的用户特定选择是一个不错的选择
3.  通常，在用户访问您的站点期间需要可被多个页面访问的变量（以避免将它们从一个页面传递到另一个页面）也可以放入会话中。

根据您对应用程序的介绍，我可能会从数据库中选择您的数据，并尝试找到将这些查询的影响降至最低而不是加载会话的方法。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-09-16T22:35:07.657

不要**将**数据库连接信息放在会话中。

至于缓存，如果可能的话，我会避免使用会话进行缓存——你会遇到其他人更改用户正在使用的数据的问题，而且你不能在用户之间共享缓存的数据。使用 ASP.NET 缓存或其他一些缓存实用程序（如 Memcached 或 Velocity）。

至于会话中的内容，适用于用户打开到您网站的**所有**浏览器窗口的任何内容（登录、安全设置等）都应该在会话中**。**诸如正在查看/编辑什么对象之类的事情实际上应该是在屏幕之间传递的 GET/POST 变量，因此用户可以使用多个浏览器窗口来处理您的应用程序（除非您想阻止这种情况）。

 *** * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-16T22:34:17.347

[**不要**将 UI 对象放在会话中。](http://blogs.msdn.com/tess/archive/2008/05/28/asp-net-memory-thou-shalt-not-store-ui-objects-in-cache-or-session-scope.aspx)

除此之外，我会说它会有所不同。如果您不使用进程中会话，太多的会话会减慢您的速度，因为您将序列化很多 + 提供程序的速度。应该谨慎使用缓存和会话。不要仅仅因为您可以或方便而参加会议。坐下来分析是否有意义。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-16T22:41:58.937

理想情况下，ASP 中的会话应该存储您可以逃脱的最少数据量。存储对保持系统资源打开（尤其是数据库连接）的任何对象的引用是一个明确的可伸缩性杀手。此外，在大多数情况下，将未提交的数据存储在会话变量中只是一个坏主意。总的来说，听起来当前的实现正在滥用会话对象来尝试在所谓的无状态环境中模拟有状态的应用程序。

尽管受到了很多诟病，但通过隐藏字段自动管理状态的 ASP.NET 模型应该真正消除了在会话变量中保留任何内容的大部分需要。

我的经验法则是，应用程序需要的可扩展性（就用户/点击数而言）越多，使用会话状态的机会就越少。但是，有一个权衡。对于用户重复访问相同数据并且每次使用站点通常具有相当长的会话的 Web 应用程序，一些缓存（如果需要在会话对象中）实际上可以通过减少数据库服务器上的负载来帮助可伸缩性。这里的想法是，与后端 DB 相比，耕种表示层更便宜且更简单。当然，无论如何，这个建议应该适度接受，并不适用于所有情况，但对于一个相当简单的内部 CRUD 应用程序，它应该很好地为您服务。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T22:35:08.237

之前就 PHP 会话提出了一个[非常相似的问题。](https://stackoverflow.com/questions/77826/php-session-what-are-the-pros-and-cons-of-storing-temporarily-used-data-in-the)基本上，会话是存储用户特定数据的好地方，您需要在多个页面加载时访问这些数据。会话不是存储数据库连接引用的好地方；您最好使用某种连接池软件或在每次页面加载时打开/关闭您的连接。至于在会话中缓存数据，这取决于会话数据的存储方式、您需要多少安全性以及数据是否特定于用户。更好的选择是使用其他东西来缓存数据。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T22:36:04.630

在会话中存储导航提示很棘手。同一个用户可以打开多个窗口，然后更改以令人困惑的方式传播。*绝对*不应该存储数据库连接。ASP.NET 为您维护连接池，无需求助于您自己的巫术。如果您需要短期缓存内容并且数据集大小相对较小，请查看 ViewState 作为一个可能的选项（以在页面大小上加载更多批量为代价）

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T22:36:10.073

答：仅与一位用户相关的数据。IE：一个用户名，一个用户ID。**最多**代表一个用户的对象。有时，与 URL 相关的数据（例如将某人带到哪里）或错误消息堆栈对于推送到会话中很有用。

如果您想在不同用户之间共享内容，请使用应用程序商店或缓存。他们远超一流。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-16T22:40:24.167

斯蒂芬，
您是否为一家以“I”开头的公司工作，该公司的网站以“BC”开头？这听起来和我刚开始在 .net 中开发时所做的完全一样（当时我年轻而愚蠢）——我在会话和应用程序中塞满了我能想到的一切。不用说，那是双重的不利因素。
一般来说，尽可能避开会话。当然，不可序列化的对象不应该存储在那里（数据库连接等），但即使是大的、可序列化的对象也不应该是。你只是不想要开销。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-24T06:26:37.987

我总是在会话中保留很少的信息。会话使用昂贵的服务器内存资源。在会话中保存太多值会增加服务器的负载，最终站点的性能会下降。当您使用负载平衡服务器时，会话的使用可能会遇到问题。所以我所做的是使用最少的会话或不使用会话，如果信息不是很关键，则使用 cookie，更多地使用隐藏字段和数​​据库会话。

# cocoa - Cocoa 对话框中的 Esc 和 Enter 键

> ID：77982
> 
> 赞同：6
> 
> 时间：2008-09-16T22:33:25.493
> 
> 标签：cocoa, interface-builder

当用户按 Esc 或 Enter 键时，如何关闭 Cocoa 应用程序中的对话框？我有确定按钮，是否可以将其设为默认按钮？

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-09-16T22:49:23.770

如果您使用[`NSAlert`](http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/Classes/NSAlert_Class/Reference/Reference.html)类或`NSRunAlertPanel`函数族或函数族呈现警报面板`NSBeginAlertSheet`，您将自动获得对默认和取消按钮的支持。

如果您正在呈现需要确定/取消按钮的工作表，并且您没有使用上述任何按钮，您应该能够使用属性检查器在 Interface Builder 中为您的按钮分配适当的键盘等效项。（只需突出显示**Key Equiv.**区域并按下您想要相当于按下该按钮的键。）

如果您正在呈现一个既不是警报也不是文档/窗口模式表的对话框 - 不要。:) Document-modal alerts 不像 Mac，不应该用于偏好窗口之类的东西。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2020-04-17T07:52:57.653

只需在 IB 中的“等效键”属性中为您想要的按钮分配“escapeKey”或“cancelKey”，它就可以正常工作。此外，如果您分配该键，按钮将获得不同的突出显示。

# linux - 在终端重绘屏幕

> ID：77990
> 
> 赞同：8
> 
> 时间：2008-09-16T22:34:03.043
> 
> 标签：linux, terminal

一些程序如何编辑终端上显示的内容（随机选择一个例子，程序'sl'）？我在这里考虑的是Linux终端，我不知道它也可能发生在其他操作系统中。我一直认为，一旦显示了一些文本，它就会留在那里。如何在不重绘整个屏幕的情况下更改它？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2010-02-08T15:22:10.200

Depending on the terminal you send control seuqences. Common sequences are for example esc[;H to send the cursor to a specific position (e.g. on Ansi, Xterm, Linux, VT100). However, this will vary with the type or terminal the user has ... curses (in conjunction with the terminfo files) will wrap that information for you.

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-09-16T22:40:04.043

试试这个 shellscript

```
#!/bin/bash
i=1
while [ true ]
    do
            echo -e -n "\r $i"
            i=$((i+1))
    done 
```

-n 选项可防止换行...而 \r 是否回车...您一次又一次地写入同一行 - 没有滚动或类似的东西

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-16T22:37:57.620

如果您使用回车符 ('\r') 而不是换行符 ('\n') 终止发送到终端的行，它会将光标移动到当前行的开头，从而允许程序打印更多文本在它之前打印的之上。我偶尔将它用于长任务的进度消息。

如果您需要进行更多的终端编辑，请使用[ncurses](http://www.gnu.org/software/ncurses/ncurses.html)或其变体。

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2008-09-16T22:41:08.907

许多应用程序使用[curses](http://en.wikipedia.org/wiki/Curses_(programming_library))库，或一些绑定到它的语言。

对于单行重写，例如更新进度信息，通常由转义序列“\r”指定的特殊字符“[回车](http://en.wikipedia.org/wiki/Carriage_return)”可以将光标返回到当前行的开头，从而允许后续输出覆盖原来的内容以前写在那里。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-16T22:35:37.470

有些字符可以发送到终端，使光标向后移动。然后可以覆盖文本。

[这里](http://ascii-table.com/ansi-escape-sequences-vt-100.php)有一个清单。注意“移动光标的东西”行。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-16T22:40:20.970

下士 Touchy 已经回答了这是如何在最低级别完成的。为了更容易开发，[curses 库](http://www.manpagez.com/man/3/ncurses/)提供了比简单地将字符发送到终端更高级别的控制。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-16T22:41:14.570

NCurses 是一个跨平台库，可让您在智能终端上绘制用户界面。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-16T22:38:52.983

为了建立@Corporal Touchy 的答案，有一些库可以为您处理其中的一些功能，例如[curses/ncurses](http://en.wikipedia.org/wiki/Curses_(programming_library))

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T22:44:56.543

我同意danio，ncurses是要走的路。这是一个很好的教程：

[http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/](http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/)

# windows - 对于 IE7 中显示的基于 Web 的程序，如何禁用右上角的 Windows 的“X”关闭按钮？

> ID：77993
> 
> 赞同：1
> 
> 时间：2008-09-16T22:34:16.350
> 
> 标签：windows, internet-explorer

我们正在使用我们学校的软件程序来参加 IEP（个性化教育计划）。为学生输入目标时，会为用户提供保存和关闭按钮。关闭适用于不希望保存他们刚刚选择的目标的用户。但是，我们的用户有时希望通过单击右上角的 X 退出屏幕并关闭窗口。不幸的是，这会以某种方式破坏数据，并且用户以后很难输入目标。软件公司告诉我们要教育我们的员工不要点击 X，并且没有办法禁用它。该软件是基于网络的，我们学校已经标准化了IE7。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T22:39:38.600

如果它是基于 Web 的，那么您可能只是在 Internet Explorer 中运行网页。如果是这样的话，我会推荐[IE 的 kiosk mode](http://samanathon.com/internet-explorer-7s-kiosk-mode/)。

如果您需要更重量级的东西，[Public Web Browser](http://www.teamsoftwaresolutions.com)是一个不错且便宜的选择，我有很好的经验。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T22:40:01.080

没有办法禁用窗口上的关闭按钮（你能想象！？永远不会消失的广告弹出窗口！哎呀！）。

但是，您可以抓住它并做一些有用的事情（例如单击表单上的“关闭”按钮）。见：http: [//blogs.x2line.com/al/archive/2004/09/15/561.aspx](http://blogs.x2line.com/al/archive/2004/09/15/561.aspx)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T22:38:47.133

许多浏览器都有全屏模式（Firefox 中的 F11），它们占据了整个屏幕空间，隐藏了任何其他 UI 元素，包括顶部栏（至少对于 Windows，不知道 *nix）。这是一个非常简单的解决方案，但是 afaik 通常无法禁用 Windows 的 [x]，您必须找到一个不使用默认 Windows 外观并且不实现它自己的 [x] 的浏览器角落。

# c++ - C++ 中的自定义事件？

> ID：77996
> 
> 赞同：9
> 
> 时间：2008-09-16T22:34:20.453
> 
> 标签：c++, design-patterns

是否可以在 C++ 中创建自定义事件？例如，假设我有变量 X 和变量 Y。每当 X 发生变化时，我想执行一个将 Y 设置为 3X 的函数。有没有办法创建这样的触发器/事件？（触发器在某些数据库中很常见）

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-09-16T22:52:42.140

这基本上是观察者模式的一个实例（正如其他人提到并链接的那样）。但是，您可以使用模板魔法来使其在语法上更具可调色性。考虑类似...

```
template <typename T>
class Observable
{
  T underlying;

public:
  Observable<T>& operator=(const T &rhs) {
   underlying = rhs;
   fireObservers();

   return *this;
  }
  operator T() { return underlying; }

  void addObserver(ObsType obs) { ... }
  void fireObservers() { /* Pass every event handler a const & to this instance /* }
}; 
```

然后你可以写...

```
Observable<int> x;
x.registerObserver(...);

x = 5;
int y = x; 
```

你用什么方法来编写你的观察者回调函数完全取决于你；我建议[http://www.boost.org](http://www.boost.org)的功能或功能模块（您也可以使用简单的仿函数）。我还提醒您要小心这种类型的运算符重载。虽然它可以使某些编码风格更清晰，但鲁莽地使用类似的渲染

似乎LikeAnIntToMe = 10;

一个*非常*昂贵的操作，很可能会爆炸，并导致未来几年的调试噩梦。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-17T01:13:41.037

[Boost 信号](http://www.boost.org/doc/libs/1_36_0/doc/html/signals.html)是您在执行观察者模式（又名发布-订阅）时可能遇到的另一个常用库。买家在这里要小心，我听说它的性能很糟糕。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T22:36:51.397

认为您应该阅读一些有关[设计模式](http://en.wikipedia.org/wiki/Design_pattern_(computer_science))的知识，特别是[观察者模式](http://en.wikipedia.org/wiki/Observer_pattern)。

[奇趣科技](http://trolltech.com/)的Qt实现了一个很好的解决方案，他们称之为[Signals and Slots](http://www.youtube.com/watch?v=yPhbgrApNx0)。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-16T22:37:40.397

使用观察者模式

[代码项目示例](http://www.codeproject.com/KB/cpp/CppEvents.aspx)

[维基页面](http://en.wikipedia.org/wiki/Observer_pattern)

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T22:38:26.043

据我所知，您不能使用默认变量来执行此操作，但是如果您编写了一个采用回调函数的类，您可以让其他类注册它们希望收到任何更改的通知。********`**