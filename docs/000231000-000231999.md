# StackOverflow 问答 000231000-000231999

# css - CSS 定位问题 - Tables vs. Absolute vs. DL

> ID：231023
> 
> 赞同：5
> 
> 时间：2008-10-23T19:06:25.603
> 
> 标签：css, styling

我想在不使用绝对定位或表格的情况下使用 CSS 在中心对齐标签/值对（参见屏幕截图）。在那个屏幕截图中，我将值（即 4,500 美元/周）定位为绝对值，然后将标签直接浮动到它上面。但是绝对在 IE 中效果不佳，而且我听说这不是一个好的技术。

但是我怎样才能达到这种效果，其中标签都是正确的，没有绝对的？

[替代文字 http://www.amherstparents.org/files/shot.jpg](http://www.amherstparents.org/files/shot.jpg)

* * *

## 回答 #1

> 赞同：13
> 
> 时间：2008-10-23T19:08:58.330

如果您要显示表格数据，那么使用表格并不丢人。

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2008-10-23T20:16:21.393

我很困惑，关于这些数据的表格是什么？记录在哪里？不同字段的行并不能真正组成传统意义上的表格。（也没有破解它每行有两条记录）

如果我们接受这个想法，那么桌子的左半边和右半边有什么区别？如果有的话，列标题会是什么？

我更喜欢定义列表建议，它绝对比表格更合适。如果所有的 DT 和 DD 都是 float:left 和 width:25%，并且按照以下顺序排列，则不需要两列：成本、宠物、睡眠、吸烟等...因此您可以使用 1 个定义列表，因为它真的应该是。

尽管您可能需要在每个其他 DT 上使用 clear:left ，以防这些元素的内容包含两行。

```
<style>
    dl
    {
        float:left;
        width:100%;
    }
    dt,
    dd
    {
        float:left;
        width:24%;
        margin:0;
        padding:0;
    }
    dt
    {
        text-align:right;
        padding-right:.33em;
    }
    dd
    {
        text-align:left;
    }
</style>
<dl>
    <dt>Cost:</dt>
    <dd>$4,500/wk</dd>
    <dt>Pets:</dt>
    <dd>No</dd>
    <dt>Sleeps:</dt>
    <dd>1</dd>
    <dt>Smoking:</dt>
    <dd>No</dd>
</dl> 
```

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-23T19:09:31.387

使用带有 CSS [text-align](http://www.w3schools.com/CSS/pr_text_text-align.asp)属性的固定宽度 div。不要忘记将您的 div 向左浮动。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-10-23T19:15:04.667

假设您正在使用 DL、DT 和 DD：

```
<dl>
<dt>Cost:</dt>
<dd>$4,500/wk</dd>
<dt>Sleeps:</dt>
<dd>1</dd>
</dl> 
```

您可以使用以下近似 CSS（未经测试）：

```
dl { width: 200px; }
dt { width: 100px; text-align: right; float: left; clear: both; }
dd { width: 100px; margin: 0; float: left; } 
```

编辑：正如 Chris Marasti-Georg 指出的那样：

> 此外，如果您想要 2 列，请使用 2 个定义列表，并将它们浮动

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-10-23T19:20:11.397

@jon 是对的，如果它的表格数据，您可以使用表格。但是，如果您真的不想使用表格，我认为这就是您想要的：

**CSS**

```
.label {
  min-width: 20%;
  text-align: right;
  float: left;
} 
```

**HTML**

```
<div class="pair">
  <div class="label">Cost</div>
  <div class="value">$4,500/wk</div>
</div>
<div class="pair">
  <div class="label">Sleeps</div>
  <div class="value">1</div>
</div>
<div class="pair">
  <div class="label">Bedrooms</div>
  <div class="value">9</div>
</div> 
```

**编辑**@Chris Marasti-Georg 指出定义列表在这里更合适。我同意，但我想我想表明任何块级元素都可以轻松完成相同的操作，并且在定义列表的默认样式中没有任何内容需要实现此目标。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-10-23T19:42:39.150

扩展 Rahul 的帖子：

**CSS**

```
#list { width: 450px; }
#left { float: left; background: lightgreen; }
#right { float: right; background: lightblue; }
dl { width: 225px; }
dt { width: 100px; text-align: right; float: left; clear: both; }
dd { width: 100px; margin: 0; float: left; padding-left: 5px; } 
```

**HTML**

```
<div id="list">
    <dl id="left">
        <dt>Cost:</dt>
        <dd>$4,500/wk</dd>
        <dt>Sleeps:</dt>
        <dd>1</dd>
        <dt>Bedrooms:</dt>
        <dd>9</dd>
        <dt>Baths:</dt>
        <dd>6</dd>
    </dl>
    <dl id="right">
        <dt>Pets:</dt>
        <dd>No</dd>
        <dt>Smoking:</dt>
        <dd>No</dd>
        <dt>Pool:</dt>
        <dd>No</dd>
        <dt>Waterfront:</dt>
        <dd>No</dd>
    </dl>
</div> 
```

我在 FF 3.0.1、IE6 和 IE7 下对此进行了测试。背景颜色只是为了帮助您可视化列的开始和结束位置。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-23T19:30:26.837

如何使用表格来布局表格，然后使用 CSS 将该表格放置在页面上您想要的任何位置？

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-23T19:44:17.477

关于使用表实现这一点的快速说明，有几个结构可以使这很容易访问。其中最简单的方法是使用 TH 作为标签，使用 TD 作为值。 [这个网站](http://www.usability.com.au/resources/tables.cfm)有一个很好的讨论，并且更深入地研究了单元格标题等内容。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-24T07:52:01.767

我一直将定义列表视为用于项目的*定义*，而不是用于键/值对。（9 不是“卧室”的定义）。然而，这种特殊的结构（键/值对列表）多年来一直引起争论，因为没有适当地反映它的本地语义标记。

如果您不知道定义是什么，请选择 DL。或者去找一张桌子。如果标题/单元格范围设置正确，则具有行中键/值对的表是完全有效的。我最近一直在这样做，它似乎是语义上最准确的表示。

# c# - 去除标签的xml文档，删除换行符并添加自定义换行符

> ID：231027
> 
> 赞同：2
> 
> 时间：2008-10-23T19:07:23.933
> 
> 标签：c#, regex

我向 xml Web 服务发出请求，然后得到响应。这个响应，作为一个流，然后被保存到一个字符串中。问题是，响应中充满了标签、CDATA 等（如您所料）。正如预期的那样，也没有换行符。

我想获取这个代表一个 xml 文档的字符串，并去掉它的所有标签，但保留实际值，并且确保每条记录都在一行中，所以：

```
<Record>
  <name>adam</name>
  <telephoneno>000</telephonenumber>
</Record>
<Record>
  <name>mike</name>
  <telephoneno>001</telephonenumber>
</Record> 
```

将转化为：

```
adam 000
mike 001 
```

标题是一个简单的问题，但我怎么能做到这一点？我已经尝试过数据表和数据集，但我认为它们对实现我想要做的事情没有很大的支持。

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-23T19:12:13.457

这正是 XSLT 的用途！它将 XML 文件转换为不同的输出。在您的情况下，您可以使用相对简单的 XSL 转换来输出列表。

这可能会做到：

记录.xml：

```
<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="style.xsl"?>
<Records>
  <Record>
    <name>adam</name>
    <telephonenumber>000</telephonenumber>
  </Record>
  <Record>
    <name>mike</name>
    <telephonenumber>001</telephonenumber>
  </Record>
</Records> 
```

样式.xsl

```
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
  <xsl:output method="text" omit-xml-declaration="yes" indent="no"/>
  <xsl:template match="Record">
    <xsl:value-of select="name"/><xsl:text> </xsl:text><xsl:value-of select="telephonenumber"/>
  </xsl:template>
</xsl:stylesheet> 
```

我用[这个工具](http://www.netcrucible.com/xslt/xslt-tool.htm)对其进行了测试，它可以工作。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T19:15:53.883

Michael Haren 的 XSLT 响应是最好的答案。

但或者，如果您实际上并不希望将响应作为 XML，您可以从 Web 服务返回您想要的任何内容（前提是它是您的，而不是第三方服务）。

没有规定 Web 服务必须返回 XML。只要确保提供适当的 MIME-Type。

# php - 如何在 html 输入标签的 value 元素中包含 php 变量？

> ID：231029
> 
> 赞同：3
> 
> 时间：2008-10-23T19:07:46.240
> 
> 标签：php, html

我正在尝试将数据库表中的值包含在输入字段的值元素中。
这就是我所拥有的，但它不起作用：

```
?><input type="text" size="10" value="<?= date("Y-m-d", 
strtotime($rowupd['upcoming_event_featured_date'])) ?>" name="upcoming_event_featured_date" 
id="keys"/><?php 
```

我以前这样做过，但我通常这样打印出来：

```
print '<input type="text" size="10" value="'.date("Y-m-d", 
strtotime($rowupd['upcoming_event_featured_date'])).'" name="upcoming_event_featured_date" 
id="keys"/>'; 
```

在不使用的情况下这样做的适当方法是什么`print ''`？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-23T19:21:26.930

始终使用完整的 PHP 标签是个好主意，因为如果您移动到不同的服务器或者您的配置更改为不允许短标签，这将防止您的应用程序崩溃。

```
?>
<input type="text" size="10" value="<?php
echo(date("Y-m-d", strtotime($rowupd['upcoming_event_featured_date'])));
?>"name="upcoming_event_featured_date" id="keys"/><?php 
```

另外，请注意您缺少`;`PHP 代码末尾的 。

您可能会发现将整个内容也保留在 PHP 中会更好，并且只`echo()`保留 HTML，因为这样您就不必在 PHP 和 HTML 解析之间来回切换。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-24T19:14:16.713

正如其他一些回复所提到的，请确保`short_open_tag`在您的 php.ini 中启用。这使您可以使用`<?=`语法。很多人建议不要使用短标签，因为并非所有服务器都允许使用它们，但如果您确定不会将其移至另一台服务器，我认为这很好。

Besides that, I don't know of any technical reason to choose one way over the other. Code readability should be your main focus. For example, you might want to set your value to a variable before outputting it:

```
$featured_date = date("Y-m-d",strtotime($rowupd['featured_date']));

?><input type="text" value="<?=$featured_date?>" name="featured_date" /><?php 
```

In fact, I'd try to do as little processing as possible while you're in the middle of a block of HTML. Things will be a lot cleaner if you define all your variables at the beginning of the script, then output all of the HTML, inserting the variables as needed. You're almost getting into templating at that point, but without needing the overhead of a template engine.

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T19:11:39.183

您可以使用[short_open_tag](http://us.php.net/manual/en/ini.core.php#ini.short-open-tag) ini 指令打开 <?= 打印快捷方式。

如果这不可用，您必须使用 print 或 echo 来完成此操作。

你可以试试：

```
ini_set('short_open_tag', true); 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T19:15:13.107

你可以做

```
[...] ?><input 
    type="text" 
    size="10" 
    value="<?php echo date("Y-m-d", strtotime($rowupd['upcoming_event_featured_date'])) ?>" 
    name="upcoming_event_featured_date" 
    id="keys"/>
<?php [...] 
```

如果您没有`short_open_tag`在 PHP 配置中启用。

# visual-studio-2008 - Visual Studio 2008 中未显示属性页

> ID：231034
> 
> 赞同：4
> 
> 时间：2008-10-23T19:09:44.053
> 
> 标签：visual-studio-2008

我正在使用 Visual Studio 2008 Team Development Edition，我的项目属性页面不会显示。我右键单击项目名称并选择“属性”，但没有像往常一样显示任何页面。此外，当我双击 Settings.settings 时，不会显示正常的设置 GUI。我只在 Settings.settings 文件中看到 XML。请帮忙。谢谢。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2009-03-19T14:31:55.407

似乎卸载加载项是导致我的问题的原因。重新安装 Visual Studio 似乎没有帮助，所以我采取了极端措施并重新格式化了我的机器。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2010-11-10T08:49:36.503

打开命令行并将目录更改为您的 Visual Studio 安装目录。

运行 devenv /setup

这基本上是将您的 Visual Studio 重置为原始安装状态并重置已安装的软件包。

在此处找到解决方案：[Visual Studio 2008 中的属性窗口为空白](http://codingsmarter.com/post/2008/05/14/Property-Window-is-Blank-in-Visual-Studio-2008.aspx)

MSDN 条目在这里：[/setup (devenv.exe](http://msdn.microsoft.com/en-us/library/ex6a2fad%28VS.80%29.aspx)

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2013-11-23T06:34:39.140

重新安装系统后，我也遇到了这个问题。这是我导致这个问题的方式。

1.  在解决方案资源管理器中，右键单击解决方案项，然后选择“卸载项目”

2.  再次右键单击，然后选择“重新加载项目”。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2014-12-20T12:51:38.160

```
devenv.exe /resetskippkgs 
```

为我工作。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-23T19:12:17.840

不做任何事情时可以显示属性页面。

尝试去查看 - > 属性窗口，看看它是否显示。或者试试键盘快捷键 CTRL-W, P

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2009-02-22T08:03:01.783

你在使用多台显示器吗？或者你在某个时候，不再是？

我注意到有时会在错误的监视器上打开“项目属性”窗口。所以也许它确实打开了它，但处于旧位置。

要对此进行测试，请打开 VS，打开您的解决方案，右键单击您的项目并选择属性。现在按 [Alt+Space]、[M]、[右箭头]，然后移动鼠标。窗口应该移动到您当前的监视器。

还有一个 Window->Reset Window Layout 菜单，您可以尝试，但它似乎不会影响 Project Properties 窗口。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2012-10-12T13:18:06.427

看看这篇文章：[尝试查看项目属性时 Visual Studio 2008 中的“未指定错误”](https://stackoverflow.com/questions/1527224/unspecified-error-in-visual-studio-2008-when-trying-to-view-project-properties)

您可能需要为 Visual Studio 2008 安装 x64 组件。它们可以在安装盘中找到。添加功能 -> C++

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2012-10-31T23:17:23.133

可能回复的有点晚了。我的“属性页 Shift+F4”显示为灰色，但 F4 本身似乎打开了我想要的属性对话框。奇怪的。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2018-04-09T02:19:17.710

F4 调出缺少的属性窗口。我发现它隐藏在 Microsoft 文档中。至少它适用于我的 vb 2008。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2022-02-10T15:07:57.390

检查您是否打开了解决方案，或者它可能从文件资源管理器指向您的本地文件夹。

# java - java.lang.String 是否有内存高效的替代品？

> ID：231051
> 
> 赞同：36
> 
> 时间：2008-10-23T19:13:37.227
> 
> 标签：java, string, optimization, memory, performance

在阅读了这篇测量几种对象类型的内存消耗的[老文章](http://www.javaworld.com/javaworld/javatips/jw-javatip130.html?page=2)`String`后，我惊讶地发现在 Java 中使用了多少内存：

```
length: 0, {class java.lang.String} size = 40 bytes
length: 7, {class java.lang.String} size = 56 bytes 
```

虽然这篇文章有一些技巧可以最大限度地减少这种情况，但我并不觉得它们完全令人满意。`char[]`用于存储数据似乎很浪费。大多数西方语言的明显改进是使用`byte[]`UTF-8 之类的编码，因为您只需要一个字节来存储最常见的字符，而不是两个字节。

当然可以使用`String.getBytes("UTF-8")`and `new String(bytes, "UTF-8")`。甚至 String 实例本身的开销也会消失。但是在那里你失去了非常方便的方法，比如`equals()`, `hashCode()`, `length()`, ...

据我所知，Sun 拥有字符串表示的[专利](http://www.freepatentsonline.com/6751790.html)。`byte[]`

> **用于在 Java 编程环境中有效表示字符串对象的框架**
> ......可以实现这些技术以在适当时将 Java 字符串对象创建为单字节字符数组......

但我没能找到该专利的 API。

我为什么在乎？
在大多数情况下，我没有。但我处理的应用程序具有巨大的缓存，包含大量字符串，这将受益于更有效地使用内存。

有人知道这样的API吗？或者是否有另一种方法可以使字符串的内存占用保持较小，即使以 CPU 性能或丑陋的 API 为代价？

请不要重复上述文章中的建议：

*   自己的变体`String.intern()`（可能与`SoftReferences`）
*   存储单个`char[]`并利用当前`String.subString(.)`实现来避免数据复制（讨厌）

**更新**

我运行了有关 Sun 当前 JVM (1.6.0_10) 的文章中的代码。它产生了与 2002 年相同的结果。

* * *

## 回答 #1

> 赞同：25
> 
> 时间：2010-12-09T20:00:57.827

# 借助 JVM 的一点帮助...

***警告：**此解决方案现在在较新的 Java SE 版本中已过时。请参阅下面的其他临时解决方案。*

如果您使用 HotSpot JVM，自 Java 6 更新 21 起，您可以使用此命令行选项：

```
-XX:+UseCompressedStrings 
```

[JVM 选项](http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html)页面显示：

> 对可以表示为纯 ASCII 的字符串使用 byte[]。（在 Java 6 Update 21 Performance Release 中引入）

**更新**：此功能在更高版本中被破坏，并且应该在 Java SE 6u25 中再次修复，如[6u25 b03 发行说明所述（但是我们在](http://download.java.net/jdk6/6u25/promoted/b03/changes/JDK6u25.b03.list.html)[6u25 最终发行说明](http://www.oracle.com/technetwork/java/javase/2col/6u25bugfixes-356453.html)中没有看到它）。出于安全原因，[错误报告 7016213](http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7016213)不可见。因此，请谨慎使用并先检查。与任何`-XX`选项一样，它被认为是实验性的，并且可能会在没有太多通知的情况下进行更改，因此在生产服务器的启动脚本中不使用它可能并不总是最好的。

**2013-03 更新** *（感谢[Aleksey Maximus](https://stackoverflow.com/users/1073844/aleksey-maximus)的评论）*：请参阅此[相关问题](https://stackoverflow.com/questions/8833385/is-support-for-compressed-strings-being-dropped)及其[接受的答案](https://stackoverflow.com/a/10289995/453590)。该选项现在似乎已失效。这在错误[7129417](http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7129417)报告中得到了进一步证实。

# 目的证明手段

***警告：（**丑陋的）特定需求的解决方案*

*这有点开箱和低级，但既然你问......不要打信使！*

## 您自己的打火机字符串表示

如果 ASCII 可以满足您的需求，那么您为什么不推出自己的实现呢？

正如你所提到的，你可以`byte[]`代替`char[]`内部。但这还不是全部。

要做到更轻量级，而不是将字节数组包装在一个类中，为什么不简单地使用一个帮助类，其中包含对您传递的这些字节数组进行操作的大部分静态方法？当然，它会感觉很 C-ish，但它会起作用，并且会为您节省与对象相关的**巨大**开销。`String`

当然，它会错过一些不错的功能……除非你重新实现它们。如果您真的需要它们，那么没有太多选择。多亏了 OpenJDK 和许多其他优秀的项目，您可以很好地推出自己的仅对参数`LiteStrings`进行操作的 fugly 类`byte[]`。每次需要调用函数时，您都会想冲个澡，但您会节省大量内存。

我建议让它与`String`类的契约非常相似，并提供有意义的适配器和构建器来转换 from 和 to `String`，您可能还希望有适配器 to 和 from `StringBuffer`and `StringBuilder`，以及您可能需要的其他东西的一些镜像实现. 绝对是一些工作，但可能是值得的（请参阅“让它计数！”部分下方的一点）。

## 即时压缩/解压

您可以很好地压缩内存中的字符串，并在需要时即时解压缩它们。毕竟，您只需要在访问它们时能够阅读它们，对吗？

当然，如此暴力将意味着：

*   更复杂（因此不易维护）的代码，
*   处理能力更强，
*   压缩需要相对较长的字符串才能相关（或通过实现您自己的存储系统将多个字符串压缩为一个，以使压缩更有效）。

## 两者都做

对于完全头痛，当然你可以做所有这些：

*   C-ish 助手类，
*   字节数组，
*   即时压缩存储。

*一定要开源。:)*

# 让它计数！

*顺便说一句，请参阅N. Mitchell 和 G. Sevitsky关于**构建内存高效的 Java 应用程序的精彩演示：[** [2008 版](http://domino.research.ibm.com/comm/research_people.nsf/pages/sevitsky.pubs.html/$FILE/oopsla08%20memory-efficient%20java%20slides.pdf)]，[ [2009 版](http://www.cs.virginia.edu/kim/publicity/pldi09tutorials/memory-efficient-java-tutorial.pdf)]。*

从这个演示文稿中，我们看到一个**8 字符的字符串**在 32 位系统上占用了 64 个字节（64 位系统为 96 个字节！！），其中大部分是由于 JVM 开销造成的。从这篇[文章中](http://www.javamex.com/tutorials/memory/array_memory_usage.shtml)我们看到，一个**8 字节的数组“只”吃掉 24 个字节**：12 个字节的标头，8 x 1 个字节 + 4 个对齐字节）。

如果你真的操纵了很多这样的东西，听起来这可能是值得的（并且可能会加快一些事情，因为你会花更少的时间分配内存，但不要引用我的话并对其进行基准测试；另外它会很大程度上取决于您的实施）。

* * *

## 回答 #2

> 赞同：21
> 
> 时间：2008-10-24T05:27:08.707

在 Terracotta，我们在某些情况下会在大字符串通过网络发送时对其进行压缩，实际上将它们压缩到需要解压缩为止。为此，我们将 char[] 转换为 byte[]，压缩 byte[]，然后将 byte[] 编码回原始的 char[]。对于哈希和长度等某些操作，我们可以在不解码压缩字符串的情况下回答这些问题。对于像大型 XML 字符串这样的数据，您可以通过这种方式获得大量压缩。

在网络上移动压缩数据无疑是一个胜利。保持压缩取决于用例。当然，我们有一些旋钮可以将其关闭并更改压缩打开的长度等。

这一切都是通过 java.lang.String 上的字节码检测完成的，我们发现这是非常微妙的，因为在启动时使用了早期的 String，但如果你遵循一些指导方针，它是稳定的。

* * *

## 回答 #3

> 赞同：10
> 
> 时间：2008-10-23T21:32:25.030

文章指出两点：

1.  字符数组以 8 字节为单位增加。
2.  char[] 和 String 对象之间的大小差异很大。

开销是由于包括一个 char[] 对象引用和三个整数：一个偏移量、一个长度和用于存储字符串哈希码的空间，以及简单地作为一个对象的标准开销。

与 String.intern() 略有不同，或者 String.substring() 使用的字符数组对所有字符串使用单个 char[]，这意味着您不需要将对象引用存储在包装器类字符串对象中。您仍然需要偏移量，并且您对总共可以拥有多少个字符引入了（大）限制。

如果您使用特殊的字符串结尾标记，您将不再需要长度。这节省了四个字节的长度，但花费了两个字节的标记，加上额外的时间、复杂性和缓冲区溢出风险。

如果您不经常需要它，那么不存储散列的时空权衡可能会对您有所帮助。

对于我使用过的应用程序，我需要对大量字符串进行超快速和内存高效的处理，我能够将数据保留为其编码形式，并使用字节数组。我的输出编码与输入编码相同，我不需要将字节解码为字符，也不需要再次编码回字节以进行输出。

此外，我可以将输入数据留在最初读入的字节数组中——一个内存映射文件。

我的对象由一个 int 偏移量（适合我的情况的限制）、一个 int 长度和一个 int 哈希码组成。

java.lang.String 是我想要做的熟悉的锤子，但不是完成这项工作的最佳工具。

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2008-10-23T20:54:57.837

内部 UTF-8 编码有其优点（例如您指出的较小的内存占用），但它也有缺点。

例如，确定 UTF-8 编码字符串的字符长度（而不是字节长度）是一个 O(n) 操作。在 java 字符串中，确定字符长度的成本是 O(1)，而生成 UTF-8 表示的成本是 O(n)。

这一切都与优先事项有关。

数据结构设计通常可以看作是速度和空间之间的权衡。在这种情况下，我认为 Java 字符串 API 的设计者基于以下标准做出了选择：

*   String 类必须支持所有可能的 Unicode 字符。

*   尽管 unicode 定义了 1 字节、2 字节和 4 字节变体，但 4 字节字符（实际上）非常罕见，因此可以将它们表示为代理对。这就是 java 使用 2 字节 char 原语的原因。

*   当人们调用length()、indexOf() 和charAt() 方法时，他们感兴趣的是字符位置，而不是字节位置。为了创建这些方法的快速实现，有必要避免内部 UTF-8 编码。

*   像 C++ 这样的语言通过定义三种不同的字符类型并迫使程序员在它们之间进行选择，使程序员的生活变得更加复杂。大多数程序员开始使用简单的 ASCII 字符串，但是当他们最终需要支持国际字符时，修改代码以使用多字节字符的过程非常痛苦。我认为 Java 设计者做出了一个很好的折衷选择，即所有字符串都由 2 字节字符组成。

* * *

## 回答 #5

> 赞同：7
> 
> 时间：2008-10-23T19:56:16.410

我认为您应该非常谨慎地基于 2002 年的 javaworld.com 文章中的任何想法和/或假设。从那时起的六年里，编译器和 JVM 发生了很多很多的变化。至少，首先针对现代 JVM 测试您的假设和解决方案，以确保该解决方案甚至值得付出努力。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-10-23T20:51:58.777

Java 选择 UTF-16 是为了兼顾速度和存储大小。处理 UTF-8 数据比处理 UTF-16 数据更 PITA（例如，当试图在字节数组中找到字符 X 的位置时，如果每个字符都可以有一个，你将如何快速完成，两个、三个甚至最多六个字节？有没有想过？逐字节检查字符串并不是很快，你明白吗？）。当然 UTF-32 最容易处理，但会浪费两倍的存储空间。自 Unicode 早期以来，情况发生了变化。现在某些字符需要 4 个字节，即使使用 UTF-16。正确处理这些会使 UTF-16 几乎与 UTF-8 一样糟糕。

无论如何，请放心，如果您实现一个带有使用 UTF-8 的内部存储的 String 类，您可能会赢得一些内存，但您会失去许多字符串方法的处理速度。此外，您的论点是一种过于有限的观点。您的论点不适用于日本人，因为 UTF-8 中的日语字符不会比 UTF-16 中的小（实际上它们在 UTF-8 中占用 3 个字节，而在 UTF-16 中只有两个字节） . 我不明白为什么像今天这样一个互联网无处不在的全球化世界中的程序员仍然谈论“西方语言”，好像这就是全部，好像只有西方世界有计算机，其余的都生活在洞穴。任何应用程序迟早都会被它无法有效处理非西方字符的事实所困扰。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-10-23T19:19:36.263

只需使用 gzip 将它们全部压缩即可。:) 开个玩笑……但我见过奇怪的东西，它会以显着的 CPU 开销为您提供更小的数据。

我知道的唯一其他 String 实现是 Javolution 类中的那些。不过，我认为它们的内存效率并不高：

[http://www.javolution.com/api/javolution/text/Text.html](http://www.javolution.com/api/javolution/text/Text.html)
[http://www.javolution.com/api/javolution/text/TextBuilder.html](http://www.javolution.com/api/javolution/text/TextBuilder.html)

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2010-07-24T07:51:34.870

今天（2010 年），您添加到服务器的每 GB 成本约为 80 英镑或 120 美元。在你重新设计 String 之前，你应该问问自己这真的值得。

如果您要节省 GB 的内存，也许。十 GB，绝对是。如果您想节省 10 秒的 MB，您可能会花费比其价值更多的时间。

您如何压缩字符串实际上取决于您的使用模式。有很多重复的字符串吗？（使用对象池）是否有很多长字符串？（使用压缩/编码）

您可能需要更小的字符串的另一个原因是减少缓存的使用。即使是最大的 CPU 也有大约 8 MB - 12 MB 的缓存。这可能是更宝贵的资源，不容易增加。在这种情况下，我建议你看看字符串的替代品，但你必须记住它在英镑或美元上与它所花费的时间有多大的不同。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2010-07-24T03:44:18.063

我目前正在实现如下压缩方法（我正在开发一个需要在内存中存储大量文档以便我们可以进行文档到文档计算的应用程序）：

*   将字符串拆分为 4 个字符的“单词”（如果您需要所有 Unicode）并将这些字节存储在`long`使用掩码/位移位的方法中。如果您不需要完整的 Unicode 集而只需要 255 个 ASCII 字符，则可以将 8 个字符放入每个`long`. 添加`(char) 0`到字符串的末尾，直到长度除以 4（或 8）。
*   覆盖散列集实现（如 Trove's `TLongHashSet`）并将每个“单词”添加到该集合中，编译集合中`long`最终位置的内部索引数组（确保在集合重新散列时也更新索引）
*   使用二维`int`数组存储这些索引（因此第一个维度是每个压缩字符串，第二个维度是哈希集中的每个“单词”索引），并将`int`该数组中的单个索引返回给调用者（您必须拥有单词数组，以便您可以全局更新上面提到的 rehash 上的索引）

优点：

*   恒定时间压缩/解压缩
*   长度为*n*的字符串表示为长度为*n*`int` /4 的数组，单词集的额外开销随着遇到的唯一“单词”越来越少而渐近增长*`long`*
**   用户将返回一个`int`字符串“ID”，该字符串既方便又小巧，可以存储在他们的对象中*

 *缺点：

*   有点 hacky，因为它涉及位移，弄乱哈希集的内部等。（[Bill K](https://stackoverflow.com/users/12943/bill-k)不会批准）
*   当您不期望有很多重复的字符串时效果很好。检查库中是否已经存在字符串非常昂贵。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-10-23T20:37:45.217

有创建一个对象（至少是一个调度表）的开销，它使用每个字母 2 个字节这一事实的开销，还有一些额外变量的开销，这些变量是为了实际提高速度和内存使用而创建的。很多情况。

如果您打算使用 OO 编程，这就是拥有清晰、可用、可维护的代码的成本。

除了显而易见的答案（如果内存使用如此重要，您可能应该使用 C），您可以使用 BCD 字节数组中的内部表示来实现自己的字符串。

这听起来真的很有趣，我可能只是为了好玩:)

Java 数组每项占用 2 个字节。BCD 编码的数字每个字母 IIRC 占用 6 位，使您的字符串显着更小。及时会有一点转换成本，但真的不算太糟糕。真正的大问题是您必须转换为字符串才能对其进行任何操作。

您仍然需要担心对象实例的开销......但是通过修改您的设计而不是试图消除实例来解决这个问题会更好。

最后一个注释。我完全反对部署这样的东西，除非你有 3 件事：

*   以最易读的方式完成的实现
*   测试结果和要求显示该实施如何不满足要求
*   关于“改进的”实现如何满足要求的测试结果。

如果没有这三个方面，我会拒绝开发人员提供给我的任何优化解决方案。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2011-12-01T22:51:43.500

UseCompressedStrings 编译器选项似乎是最简单的方法。如果您仅将字符串用于存储，而不进行任何等于/子字符串/拆分操作，那么类似 CompactCharSequence 类的东西可以工作：

[http://www.javamex.com/tutorials/memory/ascii_charsequence.shtml](http://www.javamex.com/tutorials/memory/ascii_charsequence.shtml)

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-10-26T04:00:27.203

请记住，有许多类型的压缩。使用霍夫曼编码是一种很好的通用方法 - 但它相对 CPU 密集。对于几年前我工作的 B+Tree 实现，我们知道键可能有共同的前导字符，因此我们为 B+Tree 中的每个页面实现了前导字符压缩算法。代码很简单，非常非常快，内存使用量是我们开始时的 1/3。在我们的例子中，这样做的真正原因是为了节省磁盘空间，并减少花费在磁盘上的时间 -> RAM 传输（而 1/3 的节省对有效的磁盘性能产生了巨大的影响）。

我提出这个问题的原因是自定义 String 实现在这里不会有太大帮助。我们之所以能够获得我们所做的收益，是因为我们工作了字符串所在的*容器层。*

相比之下，尝试在 String 对象中到处优化几个字节可能不值得。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-10-23T19:17:13.180

出于好奇，节省的几个字节真的值得吗？

通常，出于性能原因，我建议放弃字符串，转而使用 StringBuffer（请记住，字符串是不可变的）。

你是否真的从字符串引用中耗尽了你的堆？

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-10-23T20:09:16.787

我相信字符串在一段时间内占用的内存较少，因为 Java 工程师已经实现了享元设计模式以尽可能多地共享。事实上，我相信具有相同值的字符串指向内存中的相同对象。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-10-23T20:26:07.300

您说不要重复文章中提出的推出自己的实习计划的建议，但`String.intern`它本身有什么问题？这篇文章包含以下一次性评论：

> 避免使用 String.intern() 方法的原因有很多。一是很少有现代 JVM 可以实习大量数据。

但是即使 2002 年的内存使用数据在 6 年后仍然保持不变，如果在 JVM 可以实习的数据量方面没有取得任何进展，我也会感到惊讶。

这不仅仅是一个修辞问题——我很想知道是否有充分的理由避免它。对于高度多线程的使用，它是否效率低下？它是否填满了堆的一些特殊的 JVM 特定区域？你真的有数百兆字节的唯一字符串吗（所以实习无论如何都没用）？

# wpf - 使用 WPF 验证规则和禁用“保存”按钮

> ID：231052
> 
> 赞同：30
> 
> 时间：2008-10-23T19:13:54.670
> 
> 标签：wpf, validation, validationrules

我有一个页面，其中一些文本框在单击“保存”按钮之前不能为空。

```
<TextBox...

                <TextBox.Text>
                    <Binding Path ="LastName" UpdateSourceTrigger="PropertyChanged">

                        <Binding.ValidationRules>
                            <local:StringRequiredValidationRule />
                        </Binding.ValidationRules>                              
                    </Binding>
                </TextBox.Text> 
```

我的规则有效，我的文本框周围有一个红色边框，直到我输入一个值。我现在想将此验证规则添加到我的其他文本框中。

如何在页面没有验证错误之前禁用“保存”按钮？我不确定要检查什么。

* * *

## 回答 #1

> 赞同：19
> 
> 时间：2012-01-23T17:24:16.047

这是您需要的完整示例。

[http://codeblitz.wordpress.com/2009/05/08/wpf-validation-made-easy-with-idataerrorinfo/](http://codeblitz.wordpress.com/2009/05/08/wpf-validation-made-easy-with-idataerrorinfo/)

[https://skydrive.live.com/?cid=2c6600f1c1d5e3be&id=2C6600F1C1D5E3BE%21203](https://skydrive.live.com/?cid=2c6600f1c1d5e3be&id=2C6600F1C1D5E3BE%21203)

![在此处输入图像描述](https://i.stack.imgur.com/wRAT1.jpg)

* * *

## 回答 #2

> 赞同：17
> 
> 时间：2009-04-30T17:44:10.577

在视图的代码隐藏中，您可以像这样连接 Validation.ErrorEvent；

```
this.AddHandler(Validation.ErrorEvent,new RoutedEventHandler(OnErrorEvent)); 
```

进而

```
private int errorCount;
private void OnErrorEvent(object sender, RoutedEventArgs e)
{
    var validationEventArgs = e as ValidationErrorEventArgs;
    if (validationEventArgs  == null)
        throw new Exception("Unexpected event args");
    switch(validationEventArgs.Action)
    {
        case ValidationErrorEventAction.Added:
            {
                errorCount++; break;
            }
        case ValidationErrorEventAction.Removed:
            {
                errorCount--; break;
            }
        default:
            {
                throw new Exception("Unknown action");
            }
    }
    Save.IsEnabled = errorCount == 0;
} 
```

这假设您将收到删除通知（如果您在无效元素中删除违规元素，则不会发生这种情况）。

* * *

## 回答 #3

> 赞同：8
> 
> 时间：2008-10-24T05:22:40.883

您想使用[Validation.HasError](http://msdn.microsoft.com/en-us/library/system.windows.controls.validation.haserror.aspx)附加属性。

同样，Josh Smith 对[Binding to (Validation.Errors)[0] without Creating Debug Spew 进行](http://joshsmithonwpf.wordpress.com/2008/10/08/binding-to-validationerrors0-without-creating-debug-spew/)了有趣的阅读。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2011-09-22T09:21:53.090

```
int count = 0;

private void LayoutRoot_BindingValidationError(object sender, ValidationErrorEventArgs e)
{
    if (e.Action == ValidationErrorEventAction.Added)
    {
        button1.IsEnabled = false;
        count++;
    }
    if (e.Action == ValidationErrorEventAction.Removed)
    {                
        count--;
        if (count == 0) button1.IsEnabled = true;
    }
} 
```

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2011-11-16T19:50:20.750

这是一个辅助方法，它跟踪依赖对象（及其所有子对象）上的验证错误并调用委托以通知更改。它还跟踪删除有验证错误的孩子。

```
 public static void AddErrorHandler(DependencyObject element, Action<bool> setHasValidationErrors)
        {
            var errors = new List<Tuple<object, ValidationError>>();

            RoutedEventHandler sourceUnloaded = null;

            sourceUnloaded = (sender, args) =>
                {
                    if (sender is FrameworkElement)
                        ((FrameworkElement) sender).Unloaded -= sourceUnloaded;
                    else
                        ((FrameworkContentElement) sender).Unloaded -= sourceUnloaded;

                    foreach (var error in errors.Where(err => err.Item1 == sender).ToArray())
                        errors.Remove(error);

                    setHasValidationErrors(errors.Any());
                };

            EventHandler<ValidationErrorEventArgs> errorHandler = (_, args) =>
                {
                    if (args.Action == ValidationErrorEventAction.Added)
                    {
                        errors.Add(new Tuple<object, ValidationError>(args.OriginalSource, args.Error));

                        if (args.OriginalSource is FrameworkElement)
                            ((FrameworkElement)args.OriginalSource).Unloaded += sourceUnloaded;
                        else if (args.OriginalSource is FrameworkContentElement)
                            ((FrameworkContentElement)args.OriginalSource).Unloaded += sourceUnloaded;
                    }
                    else
                    {
                        var error = errors
                            .FirstOrDefault(err => err.Item1 == args.OriginalSource && err.Item2 == args.Error);

                        if (error != null) 
                            errors.Remove(error);
                    }

                    setHasValidationErrors(errors.Any());
                };

            System.Windows.Controls.Validation.AddErrorHandler(element, errorHandler);
        } 
```

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2012-12-25T11:36:08.273

这就是你需要从后面的代码中检查 HasError 控件属性

并在保存按钮中执行此代码单击

```
 BindingExpression bexp = this.TextBox1.GetBindingExpression(TextBox.TextProperty);
bexp.UpdateSource(); // this to refresh the binding and see if any error exist 
bool hasError = bexp.HasError;  // this is boolean property indique if there is error 

MessageBox.Show(hasError.ToString()); 
```

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2019-07-23T08:44:09.523

因为它仍然丢失，所以如果链接消失，这里是对开发人员答案的改编：

XAML：

```
<TextBox.Text Validation.Error="handleValidationError">
    <Binding Path ="LastName" 
             UpdateSourceTrigger="PropertyChanged"
             NotifyOnValidationError="True">
        <Binding.ValidationRules>
            <local:StringRequiredValidationRule />
        </Binding.ValidationRules>                              
    </Binding>
</TextBox.Text>
<Button IsEnabled="{Binding HasNoValidationErrors}"/> 
```

代码隐藏/C#：

```
private int _numberOfValidationErrors;
public bool HasNoValidationErrors => _numberOfValidationErrors = 0;

private void handleValidationError(object sender, ValidationErrorEventArgs e)
{
    if (e.Action == ValidationErrorEventAction.Added)
        _numberOfValidationErrors++;
    else
        _numberOfValidationErrors--;
} 
```

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2014-10-21T11:14:10.933

只需从 System.ComponentModel.IDataErrorInfo 继承您的 ViewModel 以进行验证，并从 INotifyPropertyChanged 继承您的 ViewModel 以通知按钮

制作属性：

```
 public bool IsValid
    {
        get
        {
            if (this.FloorPlanName.IsEmpty())
                return false;
            return true;
        }
    } 
```

在 xaml 中，将其连接到按钮

```
<Button Margin="4,0,0,0" Style="{StaticResource McVMStdButton_Ok}" Click="btnDialogOk_Click" IsEnabled="{Binding IsValid}"/> 
```

在 IDataErrorInfo 覆盖中，通知按钮

```
public string this[string columnName]{
        get
        {
            switch (columnName)
            {
                case "FloorPlanName":
                    if (this.FloorPlanName.IsEmpty())
                    {
                        OnPropertyChanged("IsValid");
                        return "Floor plan name cant be empty";
                    }
                    break;
            }
        }
} 
```

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2016-01-22T18:42:44.953

我已经尝试了上述几种解决方案；但是，它们都不适合我。

### 我的简单问题

我有一个简单的输入窗口，它向用户请求 URI，如果该`TextBox`值无效，则应禁用`Uri`该按钮。`Okay`

### 我的简单解决方案

这对我有用：

```
CommandBindings.Add(new CommandBinding(AppCommands.Okay,
            (sender, args) => DialogResult = true,
            (sender, args) => args.CanExecute = !(bool) _uriTextBoxControl.GetValue(Validation.HasErrorProperty))); 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2020-01-16T14:20:12.197

这个网站有你正在寻找的代码： [https ://www.wpfsharp.com/2012/02/03/how-to-disable-a-button-on-textbox-validationerrors-in-wpf/](https://www.wpfsharp.com/2012/02/03/how-to-disable-a-button-on-textbox-validationerrors-in-wpf/)

对于后代，如果您在输入字段上使用 ValidationRule 覆盖，则按钮代码应如下所示：

```
<Button Content="<NameThisButton>" Click="<MethodToCallOnClick>" >
                <Button.Style>
                    <Style TargetType="{x:Type Button}">
                        <Setter Property="IsEnabled" Value="false" />
                        <Style.Triggers>
                            <MultiDataTrigger>
                                <MultiDataTrigger.Conditions>                                    
                                    <Condition Binding="{Binding ElementName=<TextBoxName>, Path=(Validation.HasError)}" Value="false" />
                                    <Condition Binding="{Binding ElementName=<TextBoxName>, Path=(Validation.HasError)}" Value="false" />
                                </MultiDataTrigger.Conditions>
                                <Setter Property="IsEnabled" Value="true" />
                            </MultiDataTrigger>
                        </Style.Triggers>
                    </Style>
                </Button.Style>
            </Button> 
```

# php - 如何在 PHP 中对 bcmath 数字进行舍入/天花板/地板？

> ID：231057
> 
> 赞同：10
> 
> 时间：2008-10-23T19:15:11.810
> 
> 标签：php, largenumber, bcmath

是否有任何用于此目的的库函数，所以我不手动完成并冒着以 TDWTF 结尾的风险？

```
echo ceil(31497230840470473074370324734723042.6);

// Expected result
31497230840470473074370324734723043

// Prints
<garbage> 
```

* * *

## 回答 #1

> 赞同：13
> 
> 时间：2009-10-31T09:00:41.753

**更新：在此处查看我改进的答案：[如何计算上限、下限和四舍五入 bcmath 数字？](https://stackoverflow.com/questions/1642614/how-to-ceil-floor-and-round-bcmath-numbers/1653826#1653826).**

* * *

这些功能似乎更有意义，至少对我来说：

```
function bcceil($number)
{
    if ($number[0] != '-')
    {
        return bcadd($number, 1, 0);
    }

    return bcsub($number, 0, 0);
}

function bcfloor($number)
{
    if ($number[0] != '-')
    {
        return bcadd($number, 0, 0);
    }

    return bcsub($number, 1, 0);
}

function bcround($number, $precision = 0)
{
    if ($number[0] != '-')
    {
        return bcadd($number, '0.' . str_repeat('0', $precision) . '5', $precision);
    }

    return bcsub($number, '0.' . str_repeat('0', $precision) . '5', $precision);
} 
```

**它们支持负数和 bcround() 函数的精度参数。**

一些测试：

```
assert(bcceil('4.3') == ceil('4.3')); // true
assert(bcceil('9.999') == ceil('9.999')); // true
assert(bcceil('-3.14') == ceil('-3.14')); // true

assert(bcfloor('4.3') == floor('4.3')); // true
assert(bcfloor('9.999') == floor('9.999')); // true
assert(bcfloor('-3.14') == floor('-3.14')); // true

assert(bcround('3.4', 0) == number_format('3.4', 0)); // true
assert(bcround('3.5', 0) == number_format('3.5', 0)); // true
assert(bcround('3.6', 0) == number_format('3.6', 0)); // true
assert(bcround('1.95583', 2) == number_format('1.95583', 2)); // true
assert(bcround('5.045', 2) == number_format('5.045', 2)); // true
assert(bcround('5.055', 2) == number_format('5.055', 2)); // true
assert(bcround('9.999', 2) == number_format('9.999', 2)); // true 
```

* * *

## 回答 #2

> 赞同：7
> 
> 时间：2008-10-23T19:43:13.377

这将为您工作：

```
$x = '31497230840470473074370324734723042.9';

bcscale(100);
var_dump(bcFloor($x));
var_dump(bcCeil($x));
var_dump(bcRound($x));

function bcFloor($x)
{
    $result = bcmul($x, '1', 0);
    if ((bccomp($result, '0', 0) == -1) && bccomp($x, $result, 1))
        $result = bcsub($result, 1, 0);

    return $result;
}

function bcCeil($x)
{
    $floor = bcFloor($x);
    return bcadd($floor, ceil(bcsub($x, $floor)), 0);
}

function bcRound($x)
{
    $floor = bcFloor($x);
    return bcadd($floor, round(bcsub($x, $floor)), 0);
} 
```

基本上它通过以零精度乘以一来找到flooy。

然后它可以通过从总数中减去它来执行 ceil / round ，调用内置函数，然后将结果添加回来

编辑：固定为 -ve 数字

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2019-04-10T06:37:56.353

好的，对于我目前在数百个生产站点上[**的高精度 Money 库**](https://github.com/phpexpertsinc/MoneyType)，我必须完全重写这个 bcround 功能。我在整个 Internet 上找到的任何内容都与代码无关。

这是我想出的：

```
/**
 * Based off of https://stackoverflow.com/a/1653826/430062
 * Thanks, [Alix Axel](https://stackoverflow.com/users/89771/alix-axel)!
 *
 * @param $number
 * @param int $precision
 * @return string
 */
function bcround($number, $precision = BCMathCalcStrategy::PRECISION)
{
    if (strpos($number, '.') !== false) {
        if ($number[0] != '-') return bcadd($number, '0.' . str_repeat('0', $precision) . '5', $precision);
        return bcsub($number, '0.' . str_repeat('0', $precision) . '5', $precision);
    }

    // Pad it out to the desired precision.
    return number_format($number, $precision);
} 
```

# regex - 正则表达式最常见的用途是什么？

> ID：231062
> 
> 赞同：0
> 
> 时间：2008-10-23T19:15:27.800
> 
> 标签：regex

我正在为 PHP 中的验证类建立一个过滤器库，其中一些使用正则表达式。我有很多过滤器，但我也不想错过任何一个。你最常使用正则表达式检查什么？您必须检查哪些不那么常见的东西在图书馆中仍然有用？注意：我不是在寻找实际的正则表达式代码，而是您使用它的目的。

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-23T19:18:42.413

应该使用其预期的用例对正则表达式进行严格测试。因此，可能很难开发一个完整的通用库。我的目标是建立一个你知道现在需要的函数库。然后在您有适当的测试用例时添加到此列表中。

也就是说，这里有一些常见的用例：

数字数据
电话号码
日期
邮政编码
SSN

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T19:20:21.473

所以您正在寻找我们用于验证的类型正则表达式？

电话（各种国际格式）、邮政编码、邮政编码、信用卡#s、电子邮件、日期、数字、ssn、url（http、ftp、...）

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T19:24:43.337

除了内西奥的回答...

*   密码
*   电子邮件地址
*   禁止在文本字段中使用各种字符，例如非字母数字字符

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-23T19:25:47.703

SQL 注入攻击模式

```
 '[\s]*-- 
```

密码强度

```
 ((?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,255}) 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-24T02:25:29.960

我对正则表达式的主要用途是：

*   拉开文字
*   在输入中选择行
*   验证格式
*   分析/清理输入
*   解析
*   提供广泛的定制（允许“可配置的配置”、快捷方式……）

其中许多事情是重叠的。但这一切都与人工输入有关。机器可读和人类可读是两个不同的东西。正则表达式帮助我们处理以人为本（我们知道一些）的东西，而不需要完整的语法。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-23T19:38:43.463

我的大部分 RE 使用是将各种来源提供给我的数据修复为标准化格式。许多将 excel 文档导出为 CSV 或制表符分隔，然后在 TextPad 中运行一堆 RE 转换。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-23T19:52:05.980

请参阅 Abigail 的规范 Regexp::Common。

[http://search.cpan.org/dist/Regexp-Common](http://search.cpan.org/dist/Regexp-Common)

# c - 如何使用 fwrite() 多次写入默认结构值

> ID：231069
> 
> 赞同：1
> 
> 时间：2008-10-23T19:17:49.497
> 
> 标签：c

我想使用 fwrite 将默认结构 N 次写入文件。

```
typedef struct foo_s {

 uint32 A;
 uint32 B;
 char desc[100];

}foo_t;

void init_file(FILE *fp, int N)
{
   foo_t foo_struct = {0};
   foo_struct.A = -1;
   foo_struct.B =  1;

   fwrite(&foo_struct, sizeof(foo_struct), N, fp);    } 
```

上述代码没有将 foo_struct N 次写入文件流 fp。

相反，它将从 &foo_struct 开始的 N*sizeof(foo_struct) 字节写入 fp。

谁能告诉如何通过单个 fwrite 实现相同的目标？

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-10-23T19:21:24.373

您不能使用单个 fwrite()。您必须使用循环：

```
int i;
for (i = 0; i < N; ++i)
    fwrite(&foo_struct, sizeof(foo_struct), 1, fp); 
```

fwrite() 的第三个参数是要写入的对象数，而不是单个对象的写入次数。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T19:20:56.947

使用单次 fwrite 执行此操作的唯一方法是在 RAM 中复制 foo_struct N 次，然后对所有 RAM 执行单次 fwrite。

我怀疑做一个 malloc，N 个副本，然后一个 fwrite 会比只做 N 个 fwrites 更快（这是我想这样做的唯一原因！），但如果你真的在乎，你应该试试.

# sharepoint - 禁用同事的MOSS自动导入

> ID：231088
> 
> 赞同：2
> 
> 时间：2008-10-23T19:23:43.183
> 
> 标签：sharepoint, api, moss

在为 SharePoint 导入 AD 时，MOSS 会自动执行此操作：“Office SharePoint Server 2007 会自动将您的经理、同事和直接下属添加为您的同事”。如何自动禁用此功能，使其成为干净的同事列表？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-23T19:59:37.697

用户配置文件的属性是从共享服务提供程序 (SSP) 配置的。转到 SSP > 用户配置文件和属性 > 查看配置文件属性。

在这种特殊情况下（我认为），Manager 属性定义了经理同行等的直接报告结构。

要清理数据，您可以禁用从 Manager 属性到 Active Directory 的连接。

使用下拉菜单选择属性，转到“属性导入映射”部分

将要映射的数据源字段设置为“未映射”

这应该确保该字段不会移动到您的用户属性中。

当然，您必须在更改课程后重新导入用户。

我建议（如果可能的话）设置一个内部流程，以确保 AD 是此信息的正确来源，以便将来正确输入 Manager 属性。

# c - 在 atexit() 中释放

> ID：231089
> 
> 赞同：13
> 
> 时间：2008-10-23T19:24:09.703
> 
> 标签：c, memory, free, atexit

在 atexit() 函数中释放内存有什么意义吗？

我有一个全局变量，在启动后会被 malloc'ed。我可以编写一个 atexit() 函数来释放它，但是当程序退出时系统不会回收所有内存吗？

自己整理并积极清理有什么好处吗？

* * *

## 回答 #1

> 赞同：22
> 
> 时间：2008-10-23T19:27:29.760

不是在 C 中 - 这就像在船沉没在你周围时重新布置躺椅一样。

在 C++ 中，答案是不同的，因为对象可以在其析构函数中删除临时文件等，因此您需要确保它们被调用。

* * *

## 回答 #2

> 赞同：15
> 
> 时间：2008-10-23T19:26:40.540

释放它的一个好处是，如果您曾经做过任何内存泄漏测试，试图在进程的生命周期内将分配与解除分配相匹配，您将不会从这种故意泄漏中得到误报。

* * *

## 回答 #3

> 赞同：14
> 
> 时间：2008-10-28T05:29:17.350

看到`malloc()`/`free()`通常涉及存在于用户空间中的大量数据结构，`free()`当您的程序结束时占用内存实际上可能会消耗性能。如果部分数据结构被分页到磁盘，它们只需要从磁盘加载就被丢弃了！

然而，如果您在没有`free()`ing 的情况下终止，则分页到磁盘的数据可以安然死去。

当然`free()`，在其他时间 ing 通常是有益的，因为进一步`malloc()`的 s 可以重新使用您释放的空间，`free()`甚至可能取消映射一些内存，然后其他进程可以使用这些内存。

* * *

## 回答 #4

> 赞同：13
> 
> 时间：2008-10-23T19:25:08.267

在所有现代操作系统中，您可以放心地假设程序退出时将释放所有内存。

* * *

## 回答 #5

> 赞同：6
> 
> 时间：2010-06-03T15:43:09.057

实际上，当您的程序发展时，整洁会很有趣。它会在您创建“初始化”函数时强制您编写清理函数。当您的程序变得更加复杂并且您想要重新启动程序的一部分时，好处就来了。如果您已经编写了有效的清理函数，那么在“重新启动”程序的一部分时，您就不太可能突然忘记一些清理工作。

“懒惰”地编写清理函数，即仅在需要时更容易出错。编写清理函数迫使您考虑清理和最终的清理依赖。它允许在另一个项目中更轻松地重用您的部分代码。

所以是的，在 atexit 中释放是没有用的，关闭文件描述符也是如此。然而，随着代码的增长编写和维护清理功能可能是一个约束，会迫使你思考你在做什么

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2008-10-24T00:16:46.010

如果调用 atexit() 的代码是动态加载的共享库的一部分（例如，使用 dlopen()），则应该使用 free()。在这种情况下，将在 dlclose() 时间调用 atexit 处理程序，因此堆将继续存在以供进程的其余部分使用。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-10-23T19:29:23.170

在 Windows 上，某些调用返回属于操作系统或 COM 的内存，您需要显式释放该内存，否则即使在您的进程终止后它也不会被释放。但这是一种罕见的情况。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-11-11T04:25:13.323

在进程终止之前不释放内存不是内存泄漏。当你失去它的句柄时，这是一个内存泄漏。但是内存不是唯一的资源类型，其他资源会跨进程持续存在（如窗口句柄和文件句柄），因此您确实需要“释放”这些资源。

# c# - 从 0x0000 循环到 0xFFFF

> ID：231098
> 
> 赞同：6
> 
> 时间：2008-10-23T19:25:18.360
> 
> 标签：c#, loops, for-loop

我想要一个使用 UInt16 (ushort) 循环遍历其所有值的循环。但是，这并没有这样做：

```
for( ushort i = 0; i < UInt16.MaxValue; i++ )
{
    // do something
} 
```

问题是当 i == 0xFFFF 而不是“做某事”时循环将退出。如果我将“for”语句更改为“for(ushort i = 0; i <= UInt16.MaxValue; i++)”，那么它就会变成一个无限循环，因为我永远不会到达 0x10000，因为 ushorts 只会到达 0xFFFF。

我可以将 'i' 设为 int 并将其强制转换或将其分配给循环中的 ushort 变量。

有什么建议么？

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2008-10-23T19:27:46.903

使用`do...while`循环

```
ushort i = 0;
do
{
    // do something
} while(i++ < UInt16.MaxValue); 
```

[这里](https://stackoverflow.com/questions/224059/do-your-loops-test-at-the-top-or-bottom)有一个关于顶部与底部测试循环的有趣讨论。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-23T19:47:43.430

[`UInt16.MaxValue`评估为`0xffff`](http://msdn.microsoft.com/en-us/library/system.uint16.maxvalue.aspx)，而不是`0x10000`。我认为您可以使用`do`/`while`循环来执行此操作，作为 burkhard1979 答案的变体。

```
ushort i = 0;
do {
   ...
} while (++i != 0); 
```

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-10-23T19:28:10.007

您可以简单地将 for 替换为 do-while 循环。

```
ushort i = 0;
do
{
i++;
...
} while(i!=UInt16.MaxValue); 
```

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-23T20:02:28.597

一定要短吗？为什么不只是

```
for(int i = 0;i<=0xFFFF;i++)
{
  //do whatever
} 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-23T20:20:43.443

假设您的代码遇到一个错误（当前代码在评估最终值之前停止。那么以下可能会回答您。

非常简单，因为您的计数器是一个 16 位无符号整数，它的值不能大于`0xffff`，因为该值仍然有效，您需要有一些超出该值的值作为保护。但是添加`1`到`0xffff`16 位只是环绕到`0`. 如建议的那样，要么使用 do while 循环（不需要保护值），要么使用更大的值来包含您的计数器。

ps. Using 16 bit variables on modern machines is actually less efficient than using 32 bit variables as no overflow code needs to be generated.

# c++ - 你最不喜欢的 C++ 编码指南

> ID：231121
> 
> 赞同：1
> 
> 时间：2008-10-23T19:30:37.647
> 
> 标签：c++, coding-style

[作为C++ 编码指南 102](https://stackoverflow.com/questions/215470/c-coding-guideline-102)的对应物，您最常违反或忽略[Sutter 和 Alexandrescu](http://www.gotw.ca/publications/c++cs.htm)的 101 条指南中的哪一条，为什么？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-23T20:54:02.080

我会说，可能是 16 岁。避免使用宏。我发现有很多事情我只能用宏来做（尤其是内联 __FILE__ 和 __LINE__ 到表达式中），并且在很多情况下我需要一个在外部函数上下文中运行的紧凑表达式（例如检查结果代码并返回）。结果，例如，我的代码往往会以宏的形式大量使用断言，所以我会说这是我忽略的一个。

也就是说，如果语言允许相同概念的替代类似紧凑表达式，我会放弃我的大部分使用，但由于它不允许，宏将存在很长时间。

我应该补充一点，这并不是说我认为这个建议不好，或者当你有替代方案时遵循它是不好的。我只是发现我最终使用了很多宏，通常是因为没有其他选择。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-23T22:00:00.497

我昨天才在这个网站上打破了 19 个（总是初始化变量）。我的代码片段是：

```
uint64_t i = getIEEEbitpatternByMeansRelevantToTheQuestion();
double d;
memcpy(&d, &i, 8); 
```

看不到初始化 d 的任何意义：没有可能有意义的值，编译器要么忽略我提供的值，要么对它做一些浪费的事情。

初始化非 POD 类型和作为类成员的 POD 类型是非常明智的。初始化一些东西只是为了 memcpy/memset ，而不是那么多。

事实上，初始化非 POD 的原因之一是为了避免您稍后在顶部分配的默认构造。初始化一个你计划乱写的 POD 基本上是同样的坏事。

不过，我没有这本书，所以这可能就是他们的意思，而且标题中的“总是”具有误导性。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-23T20:55:24.480

老实说，随着时间的推移，我自然而然地养成了几乎完全符合这些指导方针的习惯。遵循这些类型的编码标准会导致代码干净、易于维护。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-23T21:09:02.300

No. 56 - 默认使用矢量。我经常使用双端队列。有趣的是，赫伯萨特[本人似乎对此也有矛盾](http://www.gotw.ca/gotw/054.htm)。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-10-23T22:06:18.300

我时不时地喜欢优秀的 c 风格演员，我不敢承认。（我意识到它的问题 - 只是无法帮助自己）

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2009-01-16T13:46:37.510

*72\. 更喜欢使用异常来报告错误。*

相反，我使用*72-ALT。不要抛出异常。*:)

好的，除了在已发布代码库的*公共 API 层*中报告调用者的先决条件违规- 并且仅在该层中。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2009-01-16T13:19:19.733

看完[所有规则](http://www.gotw.ca/publications/c++cs.htm)后，应该是：*89\. 正确编写函数对象*。我从来没有花时间正确地写它们。有时我使用可变参数函数，但这并不是我的选择。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2009-01-16T06:02:22.957

我忽略了它们中的大多数，因为它们可以概括为：使用 C++，就好像它是一种高级面向对象的语言一样。但是如果你想要一门高级的面向对象语言，有更好的候选者（C#、Java、Lisp、Python 等）。C++ 本质上是所有结构化宏汇编器的母体，我就这样使用它，并且仅在需要它的工作中使用。

# documentation - 用例文档的详细程度

> ID：231124
> 
> 赞同：4
> 
> 时间：2008-10-23T19:31:25.087
> 
> 标签：documentation, use-case

我正在努力规范我的项目并在一开始就创建一个愿景/范围文档。其中包括用例图。仅仅列出用例确实帮助我充分了解了客户要求的所有需求，并且打开了对话。

我想知道用例应该有多详细。如果我正在制作一个 Web 应用程序并且用户将登录以查看报告，我是否会在用例描述中列出报告中的所有列？

如果没有，那么我什么时候会记录这些细节？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-23T19:40:17.987

用例图的优点是它们很简单，最终用户可以阅读和理解它们

报告中的列是设计或需求规范的一部分（敏捷术语中的功能细节），*不*属于用例图

任何使用例图混乱的东西都属于其他地方

在哪里？没关系，只要它是一个一致的地方并且你知道在哪里可以找到它;-)

提醒人们用例图是什么样的——以及为什么没有虚假细节的空间—— [（来源：][[agilemodeling.com](http://www.agilemodeling.com/images/models/useCaseDiagram.jpg)][）][![](https://i.stack.imgur.com/sjcGP.jpg)](https://i.stack.imgur.com/sjcGP.jpg)

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-23T19:49:35.657

我工作的用例是从用户的角度对应用程序的描述。在那个层面上，它是非常详细的。因此，在您的报告示例中，用例将描述报告的布局、显示的数据、显示的顺序等。用例并没有告诉您数据是如何获取的，或者来自哪里。

另一种看待它的方式是考虑将用例交给测试人员。他们可以测试文档中的任何内容（黑盒测试）并将其注册为缺陷。因此，如果某些数据应该在某些条件下显示，则应在您的用例中指定该案例，以便对其进行测试。

您可能想要创建以完成图片的其他文档是我们所说的 SAD（软件架构文档）和 NFR（非功能性要求）。SAD 将从软件设计的角度描述您将如何对解决方案进行编程、您将使用哪些技术以及需要哪些算法。NFR 将包括诸如从软件或硬件中断中恢复、响应时间等内容。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-23T19:40:26.003

如果您知道应该包含哪些列，那么可以，将它们放入文档中。如果您必须先考虑一下，然后这样做并记录下来。它将使程序员不必在以后考虑或询问它，从而使整个过程更加高效。

但是，如果您真的*不知道*应该包含哪些列，因为您对整个系统在开发过程中将如何发挥作用还不够了解，那么请不要担心，只需说“特定列 TBD 。”

您不可能预先知道*所有内容*，但一定要记录您所知道的。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-12-20T04:33:50.563

用例描述应介于：

*   低细节：让用户理解它，并认为：“*做起来多么容易*”
*   高细节：没有开放的可能性（详细描述每一步之后发生的事情）

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2010-02-24T12:53:48.397

使用 UML 符号构建用例图有助于我们快速理解和指定需求，通常可以在软件工程师团队面前绘制用例图以快速了解情况。

实际上，用例应该是书面格式。它具有三种格式。

1.  **简短的**
2.  **随意的**
3.  **穿着整齐**

如果是报告，报告格式和规格应附在SRS文件中，以便进行相应的测试。

有关详细信息...请参阅**“应用 UML 和模式：Craig Larman 的面向对象分析与设计和迭代开发简介”**

# sql-server - 我应该在 SQL Server 中索引一个位字段吗？

> ID：231125
> 
> 赞同：116
> 
> 时间：2008-10-23T19:31:53.400
> 
> 标签：sql-server, indexing

我记得有一次读到，索引具有低基数（少量不同值）的字段并不值得做。我承认我对索引的工作原理知之甚少，无法理解为什么会这样。

那么，如果我有一个包含 1 亿行的表，并且我正在选择位字段为 1 的记录，该怎么办？假设在任何时间点，只有少数记录位字段为 1（而不是 0）。是否值得索引该位字段？为什么？

当然我可以测试它并检查执行计划，我会这样做，但我也很好奇它背后的理论。基数什么时候重要，什么时候不重要？

* * *

## 回答 #1

> 赞同：80
> 
> 时间：2008-10-23T20:41:35.537

考虑一下 SQL 中的索引是什么——索引实际上是一块内存，指向其他内存块（即指向行的指针）。索引被分成页面，以便可以根据使用情况从内存中加载和卸载索引的一部分。

当您请求一组行时，SQL 使用索引比表扫描（查看每一行）更快地找到行。

SQL 有聚集索引和非聚集索引。我对聚集索引的理解是它们将相似的索引值分组到同一个页面中。这样，当您请求与索引值匹配的所有行时，SQL 可以从聚集的内存页中返回这些行。这就是为什么尝试对 GUID 列进行群集索引是一个坏主意的原因 - 您不要尝试对随机值进行群集。

当您索引一个整数列时，SQL 的索引包含一组针对每个索引值的行。如果您有 1 到 10 的范围，那么您将有 10 个索引指针。根据有多少行，可以对它进行不同的分页。如果您的查询查找与“1”匹配的索引，然后在其中 Name 包含“Fred”（假设 Name 列未编入索引），SQL 会非常快速地获取匹配“1”的行集，然后扫描表以查找其余行。

所以 SQL 真正在做的是试图减少它必须迭代的工作集（行数）。

当您索引一个位字段（或某个窄范围）时，您只需通过匹配该值的行数来减少工作集。如果您有少量匹配的行，它将大大减少您的工作集。对于具有 50/50 分布的大量行，与保持索引最新相比，它可能会给您带来很少的性能提升。

每个人都说要测试的原因是因为 SQL 包含一个非常聪明和复杂的优化器，如果它认为表扫描更快，它可能会忽略索引，或者可能使用排序，或者可能组织内存页面，但它非常喜欢。

* * *

## 回答 #2

> 赞同：22
> 
> 时间：2013-09-23T21:26:52.880

我只是通过另一个方式遇到了这个问题。假设您声明只有少数记录假定值为 1（并且那些是您感兴趣的记录），那么过滤索引可能是一个不错的选择。就像是：

```
create index [IX_foobar] on dbo.Foobar (FooID) where yourBitColumn = 1 
```

这将创建一个小得多的索引，优化器足够聪明地使用它作为查询中的谓词。

* * *

## 回答 #3

> 赞同：11
> 
> 时间：2008-10-23T20:58:56.267

1 亿条记录中只有少数的位字段设置为 1？是的，我认为索引位字段肯定会加快查询 bit=1 记录的速度。您应该从索引中获取对数搜索时间，然后只触摸 bit=1 记录的几页。否则，您将不得不触摸 1 亿条记录表的所有页面。

再说一次，我绝对不是数据库专家，可能会遗漏一些重要的东西。

* * *

## 回答 #4

> 赞同：8
> 
> 时间：2009-01-09T17:11:15.013

如果你还没有读过它，Jason Massie 最近写了一篇文章来讨论这个话题。

[http://statisticsio.com/Home/tabid/36/articleType/ArticleView/articleId/302/Never-Index-a-BIT.aspx](http://statisticsio.com/Home/tabid/36/articleType/ArticleView/articleId/302/Never-Index-a-BIT.aspx)

编辑：新文章位置 - [http://sqlserverpedia.com/blog/sql-server-bloggers/never-index-a-bit](http://sqlserverpedia.com/blog/sql-server-bloggers/never-index-a-bit)

以前“新”文章位置的回退机：http://web.archive.org/web/20120201122503/http: [//sqlserverpedia.com/blog/sql-server-bloggers/never-index-a-bit/](http://web.archive.org/web/20120201122503/http://sqlserverpedia.com/blog/sql-server-bloggers/never-index-a-bit/)

新的 SQL Server Pedia 位置是 Toadworld，其中有一篇来自 Kenneth Fisher 的新文章讨论了这个主题：

[http://www.toadworld.com/platforms/sql-server/b/weblog/archive/2014/02/17/dba-myths-an-index-on-a-bit-column-will-never-be-使用过的.aspx](http://www.toadworld.com/platforms/sql-server/b/weblog/archive/2014/02/17/dba-myths-an-index-on-a-bit-column-will-never-be-used.aspx)

回程机： [http ://web.archive.org/web/20150508115802/http://www.toadworld.com/platforms/sql-server/b/weblog/archive/2014/02/17/dba-myths-an -index-on-a-bit-column-will-never-be-used.aspx](http://web.archive.org/web/20150508115802/http://www.toadworld.com/platforms/sql-server/b/weblog/archive/2014/02/17/dba-myths-an-index-on-a-bit-column-will-never-be-used.aspx)

* * *

## 回答 #5

> 赞同：8
> 
> 时间：2015-05-21T19:15:07.070

如果您的分布非常知名且不平衡，例如 99% 的行是 bit = 1，而 1% 的行是 bit = 0，那么当您使用 bit = 1 执行 WHERE 子句时，全表扫描将与索引扫描。如果您想在位 = 0 时进行快速查询，我知道的最好方法是创建一个过滤索引，添加一个 WHERE 位 = 0 子句。这样，该索引将只存储 1% 的行。然后执行 WHERE bit = 0 只会让查询优化器选择该索引，并且其中的所有行都将是 bit = 0。您还可以使用非常少量的磁盘空间来比较位上的完整索引.

* * *

## 回答 #6

> 赞同：7
> 
> 时间：2008-10-23T19:54:36.333

虽然我不认为我会单独索引一个位列，但将位列作为复合索引的一部分包含在内是很常见的。

当您的应用程序几乎总是在寻找活跃的客户时，一个简单的示例就是 ACTIVE、LASTNAME 而不是 lastname 上的索引。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-10-23T19:39:12.793

如果您想知道一个索引是否具有您想要的效果：**测试并再次测试。**

通常，由于维护索引的成本，您不希望索引不足以缩小表的范围。（成本>利润）。但是，如果您的案例中的索引会将表格切成两半，那么您可能会有所收获，但会将其放在桌子上。这完全取决于表的确切大小/结构以及您如何使用它（读/写次数）。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-10-23T19:42:35.657

当然值得，尤其是当您需要按该值检索数据时。这类似于使用稀疏矩阵而不是使用普通矩阵。

现在使用 SQL 2008，您可以使用分区函数，并且可以过滤索引中的数据。早期版本的缺点是将为所有数据建立索引，但这可以通过将感兴趣的值存储在单独的文件组中来优化。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-10-23T19:47:18.797

正如其他人所说，您需要对此进行衡量。我不记得我在哪里读过这篇文章，但列需要具有非常高的基数（大约 95%）才能使索引有效。您对此的最佳测试是构建索引并检查 BIT 字段的 0 和 1 值的执行计划。如果您在执行计划中看到索引查找操作，那么您就知道您的索引将被使用。

您最好的做法是使用基本的 SELECT * FROM table WHERE BitField = 1; 进行测试 查询并从那里逐步构建功能，直到您对应用程序进行实际查询，检查每一步的执行计划以确保仍在使用索引查找。诚然，不能保证这个执行计划会在生产中使用，但很有可能会。

一些信息可以在[sql-server-performance.com 论坛](http://sql-server-performance.com/articles/per/indexing_low_sel_cols_p2.aspx)和参考[文章中找到](http://www.sql-server-performance.com/articles/per/indexing_low_sel_cols_p2.aspx)

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-10-23T20:07:12.533

“我记得有一次读到，索引具有低基数（不同值的数量少）的字段并不值得做”

那是因为 SQL Server 几乎总是会发现只进行表扫描比读取索引更有效。所以基本上你的索引永远不会被使用，维护它是一种浪费。正如其他人所说，在复合索引中可能没问题。

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2008-10-23T21:41:03.467

如果您的目标是更快地查询位字段值等于“1”的记录，您可以尝试基表的索引视图，该视图仅包含位字段等于“1”的记录。在企业版中，如果查询可以使用索引视图而不是指定的表来提高查询性能，它将使用视图。从理论上讲，这将提高仅查找位字段值为“1”的记录的选择查询的速度。

[http://www.microsoft.com/technet/prodtechnol/sql/2005/impprfiv.mspx](http://www.microsoft.com/technet/prodtechnol/sql/2005/impprfiv.mspx)

所有这些都假设您是 Microsoft SQL Server 2005 Enterprise。这可能适用于 2008 年，我不熟悉那个版本。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2008-10-23T20:29:04.393

您*不能*索引 SQL Server 2000 中的位字段，如当时联机丛书中所述：

> **少量**
> 
> 整数数据类型 1、0 或 NULL。
> 
> **评论**
> 
> **bit**类型的列上不能有索引。

是的，如果你只有几行，数百万，索引会有所帮助。但是，如果您想在这种情况下执行此操作，则需要将列设为 a `tinyint`。

**注意**：企业管理器不会让您在位列上创建索引。如果您希望仍然可以在位列上手动创建索引：

```
CREATE INDEX IX_Users_IsActiveUsername ON Users
(
   IsActive,
   Username
) 
```

但是 SQL Server 2000 实际上不会使用这样的索引 - 运行一个索引将是完美候选者的查询，例如：

```
SELECT TOP 1 Username 
FROM Users
WHERE IsActive = 0 
```

SQL Server 2000 将改为执行表扫描，就好像索引甚至不存在一样。如果将列更改为 tinyint，SQL Server 2000*将*执行索引查找。此外，以下未涵盖的查询：

```
SELECT TOP 1 * 
FROM Users
WHERE IsActive = 0 
```

它将执行索引查找，然后是书签查找。

* * *

SQL Server 2005 对位列索引的支持有限。例如：

```
SELECT TOP 1 Username 
FROM Users
WHERE IsActive = 0 
```

将导致通过覆盖索引进行索引搜索。但未涵盖的情况：

```
SELECT TOP 1 * 
FROM Users
WHERE IsActive = 0 
```

不会导致索引查找后进行书签查找，它将执行表扫描（或聚集索引扫描），而不是执行索引查找后执行书签查找。

通过实验和直接观察验证。

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2008-10-23T20:31:05.467

就其本身而言，不会，因为它导致的选择性很小。作为复合索引的一部分。很可能，但仅在其他相等列之后。

* * *

## 回答 #14

> 赞同：1
> 
> 时间：2011-12-21T15:20:26.117

很晚的答案...

[是的，根据 SQL CAT 团队的说法](http://blogs.msdn.com/b/sqlcat/archive/2013/10/23/sqlcat-com-ebook-downloads.aspx)，它可能很有用（已更新，已合并）

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-10-23T19:38:32.653

**测量**前后的响应时间，看看是否值得；从理论上讲，它应该可以提高使用索引字段的查询的性能，但它实际上取决于真/假值的分布以及您关注的查询中涉及的其他字段

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2008-10-23T19:38:43.683

这是一个常见的查询吗？在查找“少数”记录时可能值得这样做，但在其他行上对您没有多大帮助。还有其他方法可以识别数据吗？

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2008-10-23T20:13:22.070

基数是一个因素，另一个因素是索引划分数据的程度。如果你有大约一半的 1 和一半的 0，那么它会有所帮助。（假设该索引是比其他索引更好的选择路径）。但是，您多久插入和更新一次？为 SELECT 性能添加索引也会损害 INSERT、UPDATE 和 DELETE 性能，因此请记住这一点。

我想说，如果 1 到 0（反之亦然）不优于 75% 到 25%，请不要打扰。

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2010-02-09T23:49:09.060

Ian Boyd 说您无法通过 Enterprise Manager for SQL 2000 执行此操作是正确的（请参阅他关于通过 T-SQL 创建它的说明。

* * *

## 回答 #19

> 赞同：0
> 
> 时间：2017-04-01T12:54:33.797

你需要聪明地在这里查询，如果你的系统中的负载更多，你必须知道你的列上的负载值，并且你想检查所有的真实值写你的查询来检查不是假的..这将有很大帮助，它只是把戏。

# mysql - mySQL 在一个查询中从多个表中获取信息

> ID：231126
> 
> 赞同：4
> 
> 时间：2008-10-23T19:31:57.847
> 
> 标签：mysql, database

在尝试了一些不同的谷歌搜索并阅读了一些 SQL 教程之后，我对 SQL 非常陌生，似乎无法获得所需的信息。

我认为它涉及某种连接，但不能让它们直截了当。

给定以下示例表：

表 1（活动每次更改任务时都会更新，可能每天多次）：

```
ID  Who     What        When
001 John    Created 2008-10-01<br>
001 Bill    Closed  2008-10-02<br>
001 John    Updated 2008-10-03<br>
002 Bill    Created 2008-10-04<br>
002 John    Updated 2008-10-05<br>
002 Bill    Closed  2008-10-06<br> 
```

表 2（任务 - 这是主要任务跟踪表）：

```
ID  Created Status
001 2008-10-01  Closed
002 2008-10-04  Closed 
```

表 3（评论）：

```
ID  When    Comment<br
001 2008-10-01  "I'm creating a new task"
001 2008-10-02  "I have completed the task"
001 2008-10-03  "Nice job"
002 2008-10-04  "I'm creating a second task"
002 2008-10-05  "This task looks too easy"
002 2008-10-06  "I have completed this easy task" 
```

我将使用什么 SQL（如果有任何区别的话是 mySQL）查询来找出谁在已关闭的任务上做了某事？

结果将类似于：

```
Who What    ID  When    Comment
Bill Updated 002 2008-10-03 "Nice job" 
```

意思是Bill在关闭后更改了任务002，并添加了评论“Nice Job”

任何帮助将非常感激。

提前致谢。

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-23T20:32:49.190

```
SELECT a1.Who, a1.What, a1.ID, c.When, c.Comment
FROM Activity AS a1
  JOIN Activity AS a2 ON (a1.ID = a2.ID AND a1.When > a2.When)
  JOIN Comments AS c ON (a1.ID = c.ID AND a.When = c.When);
WHERE a2.What = 'Closed'; 
```

我认为您需要某种方法将评论中的一行与活动中的正确行相关联。现在，如果两个人在同一天对给定任务发表评论，您不知道谁的评论是谁的评论。我建议您为 Activity 中的每一行提供一个唯一键，然后从 Comments 表中引用它。

```
CREATE TABLE Tasks (
  Task_ID      INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
  Created      DATE NOT NULL,
  Status       VARCHAR(10)
) TYPE=InnoDB;

CREATE TABLE Activity (
  Activity_ID  INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
  Task_ID      INT NOT NULL REFERENCES Tasks,
  Who          VARCHAR(10) NOT NULL,
  What         VARCHAR(10) NOT NULL,
  When         DATE NOT NULL
) TYPE=InnoDB;

CREATE TABLE Comments (
  Comment_ID   INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
  Activity_ID  INT NOT NULL REFERENCES Activity,
  Who          VARCHAR(10) NOT NULL,
  When         DATE NOT NULL,
  Comment      VARCHAR(100) NOT NULL
) TYPE=InnoDB; 
```

然后您可以进行关联，以便查询返回更准确的结果：

```
SELECT c.Who, a1.What, a1.Task_ID, c.When, c.Comment
FROM Activity AS a1
  JOIN Activity AS a2 ON (a1.Task_ID = a2.Task_ID AND a1.When > a2.When)
  JOIN Comments AS c ON (a1.Activity_ID = c.Activity_ID);
WHERE a2.What = 'Closed'; 
```

确保`TYPE=InnoDB`在 MySQL 中使用，因为默认存储引擎 MyISAM 不支持外键引用。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T19:35:46.433

您将需要使用 JOIN 语句从多个表中检索字段。 [http://www.w3schools.com/Sql/sql_join.asp](http://www.w3schools.com/Sql/sql_join.asp)

```
SELECT Activity.Who, Activity.What, Comments.When, Comments.Comment FROM Activity JOIN Comments ON Activity.ID = Comments.ID JOIN Tasks ON Comments.ID = Tasks.ID WHERE Tasks.Status = 'Closed' 
```

此外，您的表结构看起来有点冗余。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T19:39:53.197

您是否打算根据日期加入表格？所以你每天只有 1 次变化？

# c++ - C++ 错误处理——示例代码的良好来源？

> ID：231128
> 
> 赞同：32
> 
> 时间：2008-10-23T19:32:32.790
> 
> 标签：c++, error-handling

几乎每一处示例代码都忽略了错误处理（因为它“混淆了示例代码正在解决的问题”）。我的编程知识主要来自书籍和网站，你很少看到那里使用任何错误处理，更不用说好东西了。

在哪里可以看到 C++ 错误处理代码的好例子？特定的书籍、特定的开源项目（最好有要查看的文件和功能）以及特定的网页或站点都将被感激地接受。

* * *

## 回答 #1

> 赞同：44
> 
> 时间：2008-10-23T19:50:35.080

Herb Sutter 和 Andrei Alexandrescu 的《[C++ 编码标准](http://www.gotw.ca/publications/c++cs.htm)》一书包含一整章关于*错误处理和异常*的内容，包括

*   断言自由地记录内部假设和不变量
*   建立合理的错误处理策略，并严格遵守
*   区分错误和非错误
*   设计和编写错误安全代码
*   更喜欢使用异常来报告错误
*   按值抛出，按引用捕获
*   适当地报告、处理和翻译错误
*   避免异常规范

每个主题还包括一个示例，我发现它是一个非常有价值的资源。

* * *

## 回答 #2

> 赞同：13
> 
> 时间：2009-04-11T14:50:39.513

*“使用例外”*与*“使用错误代码”*从来没有像示例所暗示的那样明确。

对程序流程使用错误代码。如果您有预期的错误，请不要抛出异常。*例如，你正在读取一个文件，你可能会抛出"file not found"*、*"file locked"*的异常；*但永远不要为“文件结尾”*扔一个。

如果这样做，您将永远无法编写简单的循环，您将始终将代码包装在异常处理程序中。并且不要忘记异常非常慢，这在大型多线程服务器中尤其重要。（在您的桌面应用程序中根本不那么重要）。

其次，对异常层次结构要非常小心。您可能认为有一个`Exception`类，然后`NetException`从它派生一个，然后`SMTPException`为您的 SMTP 类是可以的。但是除非您在基类中保存通用数据，否则您将始终必须捕获该层次结构中的每种类型的异常。例如，如果您将 SMTP 错误的原因放在您的`SMTPException`课​​程中，您必须捕获它 - 如果您只捕获`Exception`类型，您将无法访问`SMTPException`成员。解决此问题的一个好方法是在基异常类中包含一个字符串和一个 int 成员，并且只使用它们，即使对于派生类型也是如此。不幸的是`std::exception`只提供一个字符串:(

有人说这样做意味着你可能只有一个异常类型，特别是因为无论如何你总是会捕获基类类型。

如果你确实使用了异常，你必须不厌其烦地用比错误代码更多的数据来填充它们。出现错误时，您必须立即处理它们，否则它们会在代码中丢失。除了一个例外，它可能会在远离它被抛出的地方很多级别被捕获 - 就像在罗迪的例子中一样。`DoC`被调用，并在 from 中获得异常 2 级`DoA`。除非您将错误指定为特定于 中的代码，否则您可能会认为它是从函数`DoA`中抛出的。`DoB`（简单的例子，但我已经看到在调用堆栈中处理多个级别的异常的代码。调试是很抽象的。这尤其适用于*OO*程序）

所以希望，我已经给了你足够的思考。事情的简单事实是，风格在错误处理中没有任何意义，实用性就是一切。如果您必须在可能发生错误的任何地方放置日志语句，那么就这样做。与拥有优雅的异常层次结构或在代码中乱扔异常处理程序相比，您可以看到代码出错的地方（以及正在处理的数据）更重要。**如果您不能轻松地跟踪错误，那么您的错误处理代码将毫无用处。**

例外是好的，使用它们。但是想想你在做什么，不要滥用或过度使用它们。滥用的异常比没有错误处理更糟糕（因为您可以获取故障转储并查看未处理的异常以在几秒钟内找到错误。如果异常被吃掉并忽略，您就会被塞满）。

多年来，我发现调试的最大助手是日志记录。写日志，写很多日志。

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-10-23T19:39:37.923

我更喜欢本文中讨论的异常处理。它会产生干净的代码，并避免仅仅为了处理异常而显式创建/删除对象。 [http://www.informit.com/articles/article.aspx?p=373339](http://www.informit.com/articles/article.aspx?p=373339)

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2008-10-23T20:11:41.400

使用 C++，无论如何，您最终应该得到不太明显的错误处理代码，因为您可以将大量繁重的工作留给异常。

在我看来，最基本的例外规则（也是最常被破坏的规则）就是这个。 ***除非您有特定的计划来处理它们，否则不要尝试捕获异常。***

对于异常，您不必担心函数返回的错误代码，因为设计良好的函数只会抛出异常。

在 C 中，典型的错误处理场景如下所示：

```
int DoA() 
{
 if (location == hellInAHandcart)
  return ERROR;
 else
  RETURN OK;
}

int DoB()
{
  int err = DoA();
  if (err != OK)
     return err;
  else
     return DoSomethingElse1();
}

int DoC()
{
  int err = DoB();
  if (err != OK)
     //Handle My error here in whatever way...
} 
```

在 C++ 中...

```
void DoA() 
{
 if (location == hellInAHandcart)
  throw Exception("Gone To Hell in a Handcart");
}

void DoB()
{
  DoA();
  DoSomethingElse1();
}

void DoC()
{
  try
  {
    DoB();
  }
  catch (Exception &E)
  {
    // Handle My error here in whatever way...
  }
} 
```

# configuration - 将单个代码库用于多个网站的最佳方式

> ID：231131
> 
> 赞同：5
> 
> 时间：2008-10-23T19:33:33.927
> 
> 标签：configuration

为多个网站使用单个代码库的最佳方法是什么？

我们有在多个网站上使用的验证和会话管理库。是否存在保留单个副本而不是必须为每个网站维护本地副本更新的最佳实践？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-23T19:44:18.367

通过站点特定的配置文件使一切都可配置。更改每个客户的代码是让自己发疯的一种方式。从一开始就使代码多租户并通过配置，如皮肤 css，您可以轻松部署更多。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T20:48:18.847

如果您使用 subversion，您可以分支您的公共代码并使用 svn:external 来保持存储库中公共代码的最新版本（或特定标签）。( [http://svnbook.red-bean.com/en/1.0/ch07s03.html](http://svnbook.red-bean.com/en/1.0/ch07s03.html) )

其他 SCM 系统可能具有类似的功能。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T19:39:13.837

如果您使用源代码控制（如果您不使用，则应该使用），您可以分支公共代码。将其分组到文件夹中，并将文件夹分支到每个网站中。更改可以合并回原点，然后传播到每个网站。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-30T15:13:23.210

我们有一个与我们构建的所有网站共享的代码库。我们是一家 ASP.NET 商店，所以在实践中这意味着一个 VB.NET 类库。这包括基本 ASP.NET 控件的扩展（自定义 SqlDatasource、自定义 FormView、自定义 CheckboxList 等）以及其他自定义 Web 控件和实用程序类和函数库。

通常，一个网站由一个 2 项目 VisualStudio 解决方案组成，一个项目用于网站本身，另一个项目用于共享代码库。当我们构建解决方案时，对公共代码库的任何更改都会同时构建。对代码库的更改会签入源代码管理并在其他网站打开备份并拉取最新代码时传播到其他网站。

# offline - Wininet 的 INTERNET_OPTION_IGNORE_OFFLINE 不起作用？

> ID：231132
> 
> 赞同：1
> 
> 时间：2008-10-23T19:33:44.100
> 
> 标签：offline, wininet, internetsetoption

我试图让 Wininet 忽略 Internet Explorer 的“脱机工作”模式，用于 HTTP 和 FTP。

所以我正在尝试使用`InternetSetOption()`with `INTERNET_OPTION_IGNORE_OFFLINE`。文档说“这由请求句柄使用`InternetQueryOption`并`InternetSetOption`与请求句柄一起使用。” 但是，您无法获得请求句柄，因为如果 IE 处于脱机工作模式，那么`InternetConnect()`将始终返回空句柄。如果没有连接句柄，您将无法获得请求句柄。所以我尝试将它与`InternetOpen()`手柄和`NULL`手柄一起使用。两者都失败了`ERROR_INTERNET_INCORRECT_HANDLE_TYPE`。

有没有办法让这个选项起作用？我在 2003 年的一个 MS 新闻组上找到了一个`INTERNET_OPEN_TYPE_PRECONFIG`“损坏”的参考资料。5年后使用IE8 beta 2，他们仍然没有修复它？还是我做错了。

**编辑**
我不太正确。 `InternetConnect()`如果您处于“脱机工作”模式并使用 FTP，则始终返回 null，但如果您使用 Http，它将返回有效句柄。但是，即使使用请求句柄，它仍然不起作用。

如果我设置为“脱机工作”并且我打电话

```
BOOL a = TRUE;
::InternetSetOption(hData, INTERNET_OPTION_IGNORE_OFFLINE, &a, sizeof(BOOL)); 
```

在手柄上

```
HINTERNET hData = HttpOpenRequest(hInternet, L"POST", path, NULL, NULL, NULL, flags, 0 ); 
```

`InternetSetOption()`通话成功。
但是，调用`HttpSendRequest()`仍然失败，错误代码为 2（找不到文件），与我未设置选项时相同。
如果我打电话也是一样

```
::InternetSetOption(hData, INTERNET_OPTION_IGNORE_OFFLINE, 0, 0); 
```

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2011-04-21T05:03:21.190

我检查`INTERNET_OPTION_IGNORE_OFFLINE`了 IE 9 版本的 WinInet 的使用情况，它似乎确实有效。

确保在调用 HttpOpenRequest*之前*调用 InternetSetOption并传入 hInternet 句柄。必须在请求实际发送到服务器之前设置该选项。HttpOpenRequest

+++ 瑞克 ---

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2009-01-22T22:46:03.197

您是否尝试过在标头中发送其他数据`GET`而不是哪个？`POST`

例如，在 REST-ful API 中，POST 请求等同于 Create、Update、Delete 和 GET to Read，这可能会破坏离线模式。只是猜测...

# c++ - std::string 擦除最后一个字符失败？

> ID：231146
> 
> 赞同：5
> 
> 时间：2008-10-23T19:38:13.327
> 
> 标签：c++, string

我正在尝试将通配符形式的用户输入更改`("*word*")`为正则表达式格式。为此，我使用下面的代码去除`'*'`输入的开头和结尾，以便我可以在任一端添加正则表达式字符：

```
string::iterator    iter_begin = expressionBuilder.begin();
string::iterator    iter_end = expressionBuilder.end();
iter_end--;
if ((char)*iter_begin == '*' && (char)*iter_end == '*')
{
    expressionBuilder.erase(iter_begin);
    expressionBuilder.erase(iter_end);
    expressionBuilder = "\\b\\w*" + expressionBuilder + "\\w*\\b";
} 
```

但是，调用`"expressionBuilder.erase(iter_end)"`不会删除输入字符串的尾随，所以我*得到*`'*'`了一个不正确的正则表达式。我在这里做错了什么？ `"(char)*iter_end == '*'"`if 语句中的代码必须为 true 才能运行（它确实如此），那么为什么相同的迭代器在传递给 erase() 时不能工作？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-23T20:39:42.920

除了您发布的明显问题外，您的原始代码和建议的解决方案到目前为止还有几个问题：

*   修改字符串后使用无效的迭代器
*   甚至在修改字符串之前取消引用可能无效的迭代器（例如，如果字符串为空）
*   如果 expressionBuilder 字符串仅包含单个 '*' 字符，则会出现错误

现在，如果使用片段/例程的代码已经在验证字符串至少有 2 个字符，那么最后两项可能不是真正的问题，但如果不是这种情况，我相信以下内容在expressionBuilder 的任意值的面：

```
// using the reverse iterator rbegin() is a nice easy way 
//     to get the last character of a string

if ( (expressionBuilder.size() >= 2) &&
    (*expressionBuilder.begin()  == '*') &&
    (*expressionBuilder.rbegin() == '*') ) {

    expressionBuilder.erase(expressionBuilder.begin());

    // can't nicely use rbegin() here because erase() wont take a reverse
    //  iterator, and converting reverse iterators to regular iterators
    //  results in rather ugly, non-intuitive code
    expressionBuilder.erase(expressionBuilder.end() - 1); // note - not invalid since we're getting it anew

    expressionBuilder = "\\b\\w*" + expressionBuilder + "\\w*\\b";
} 
```

请注意，此代码将在`expressionBuilder`is `""`、`"*"`、 或`"**"`不执行任何未定义的操作时起作用。但是，在这些情况下，它可能不会产生您想要的结果（那是因为我不知道在这些情况下您到底想要什么）。修改以满足您的需求。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-23T19:43:46.840

尝试以相反的顺序擦除它们：

```
expressionBuilder.erase(iter_end);
expressionBuilder.erase(iter_begin); 
```

擦除第一个 * 后，iter_end 指的是示例中字符串末尾之后的一个字符。[STL 文档](http://www.sgi.com/tech/stl/basic_string.html)表明迭代器无效`erase()`，所以从技术上讲，我的示例也是错误的，但我相信它会在实践中起作用。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T19:46:17.070

（已修改，因为我错过了这`iter_end--`条线）。

您可能需要一个只检查 if 的 if 语句，`*iter_begin == '*'`然后调用`find()`以获取另一个`'*'`。或者您可以使用`rbegin()`来获取“反向序列的开始迭代器”，将其推进一个，然后调用`base()`将其转换为常规迭代器。这将使您获得序列中的最后一个字符。

* * *

更好的是，`std::string`有[`rfind()`和`find_last_of()`方法](http://www.sgi.com/tech/stl/basic_string.html)。他们会让你最后一个`'*'`。您也可以简单地调用`replace()`而不是剥离`'*'`s 然后重新添加新的东西。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-24T03:23:17.927

减去错误处理，您可能只是这样做：

```
#include <iostream>
#include <string>
using namespace std;

string stripStar(const string& s) {
    return string(s.begin() + 1, s.end() - 1);
}

int main() {
   cout << stripStar("*word*") << "\n";
} 
```

# asp.net - Asp.Net jQuery $.getJSON 有时会导致整页回发？

> ID：231158
> 
> 赞同：1
> 
> 时间：2008-10-23T19:41:11.650
> 
> 标签：asp.net, jquery, ajax, webforms

我正在编写一个 ASP.NET 网络表单应用程序，并且我正在使用 jQuery 进行 AJAX 调用。这运行良好，但在某些情况下，$.getJSON 调用会导致整页回发。我没有在应用程序的任何地方使用 ASP.NET AJAX 库。我无法始终如一地重现该问题，并且不确定是什么原因造成的。这是我正在使用的 jQuery 代码。有人遇到过这个吗？之前的 AJAX 调用是否可能尚未完成，并且请求重叠？

```
function getActionMismatch(id) {
    setPageElementVisibility();
    $(".ActionDetailArea").slideUp("fast");
    $("#AjaxLoader_Action").show();

    $.getJSON("Main.aspx?Callback=GetMismatch",
    { MismatchId: id },
    function(result) {
        $("#adMismatchId").text(result.MismatchId);
        $("#adAuthMerchId").text(result.AuthorizationMerchantId);
        $("#adSttlMerchId").text(result.SettlementMerchantId);
        $("#adCreateDate").text(formatJSONDate(Date(result.AppendDts)));

        $(".ActionDetailArea").slideDown('fast', toggleBlock('...click Adjust Promo to enter details', true));
        $("#AjaxLoader_Action").hide();
    }
    );
    return false;
} 
```

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-24T18:18:44.283

你是如何触发那个 JavaScript 函数的？

如果它是按钮等控件上的客户端单击处理程序，则需要确保调用 preventDefault()。否则，浏览器将提交表单并导致回发，即使在 AJAX 回调正在进行时也是如此。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T20:04:57.687

在某些情况下，当 jQuery 无法进行 AJAX 调用时，它会创建一个隐藏的 iframe 并从那里进行正常提交。我猜想这个过程是如何崩溃的。

# c# - 使用“大于或等于”或仅使用“大于”

> ID：231159
> 
> 赞同：13
> 
> 时间：2008-10-23T19:41:25.627
> 
> 标签：c#, .net, c

我记得从 C 天开始，我们被鼓励使用

```
i > -1 
```

代替

```
i >= 0 
```

因为性能。

这仍然适用于 C# .NET 世界吗？在当今的编译器中使用其中一种对性能有何影响？即编译器是否足够聪明，可以为您优化这些？

（顺便尝试在 Stack Overflow 上的问题字段中输入问题“使用 >= 或 >”，看看会发生什么。）

* * *

## 回答 #1

> 赞同：47
> 
> 时间：2008-10-23T19:44:24.077

不，没有与比较运算符相关的性能问题。无论如何，任何好的编译器都会优化这种微不足道的东西。

我不确定您从哪里得到使用“i > -1”而不是“i >= 0”的建议。在 x86 架构上，您使用哪个没有区别：任何一种情况都需要两条指令……一条用于比较，一条用于跳转：

```
 ;; if (i > -1) {
 cmp eax, -1
 jle else
then:
 ...
else:

 ;; if (i >= 0) {
 cmp eax, 0
 jl else
then:
 ...
else: 
```

在我知道的大多数 RISC 架构上，“i >= 0”实际上可能更快，因为通常有一个专用的零寄存器，而“i > -1”可能需要加载一个常量。例如，MIPS 只有一个 < 指令（没有 <=）。下面是这两个结构如何（天真地！）用 MIPS 汇编语言表达：

```
 // if (i >= 0) {   (assuming i is in register %t0)

 stl $t1, $0, $t0     // in C: t1 = (0 < t0)
 beq $t1, $0, else    // jump if t1 == 0, that is if t0 >= 0
 nop
then:
 ...
else:

// if (i > -1) {    (assuming i is in register %t0)

 addi $t2, $0, -1      // in C: t2 = -1
 stl $t1, $t2, $t0      // in C: t1 = (t2 < t0) = (-1 < t0)
 bne $t1, $0, else     // jump if t1 != 0, that is if t0 > -1
 nop
then:
 ...
else: 
```

所以在幼稚的一般情况下，在 MIPS 上执行“i >= 0”实际上会快一条指令。当然，RISC 代码的优化程度如此之高，以至于编译器可能会更改这些指令序列中的任何一个，几乎无法识别:-)

所以......简短的回答是不不不，没有区别。

* * *

## 回答 #2

> 赞同：12
> 
> 时间：2008-10-23T19:58:38.977

除了任何体面的编译器都做正确的事情这一事实之外，除了在现代架构中没有速度差异`>`和`>=`比较这一事实之外，更大的图景表明这是一个不影响运行时的“微优化”绝大多数情况下的表现。

在比较的情况下，无论您以哪种方式编写它，它通常都不会影响可读性，但在某些情况下，选择一个边界而不是另一个边界会更清晰：例如，

```
if (length >= str.size()) 
```

相对

```
if (length > str.size() - 1) 
```

我不了解你，但我每天都会选择选项 1。:-) 在不会明显影响性能的情况下，例如这种情况，更易读的选项应该会胜出。

* * *

## 回答 #3

> 赞同：9
> 
> 时间：2008-10-23T19:57:56.437

这里有一个非常相似的问题（没有暗示批评 - 正如你所说，搜索符号很棘手）：[“应该使用`<`还是`<=`在 for 循环中”](https://stackoverflow.com/questions/182600/should-one-use-or-in-a-for-loop#182620)

（是的，我碰巧能够很容易地找到它，因为我的答案得到了很多支持......）

基本上，做任何最易读的事情。有人正确猜测改变最易读的形式将解决性能问题（无需分析器的帮助）的那一天就是我停止谈论性能的那一天 :)

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-10-23T19:43:05.407

不，你不再需要这样做了。是的，编译器变得更加智能，这两个表达式没有性能差异。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-10-23T19:57:09.777

> 我记得从 C 天开始，我们被鼓励使用 .... 因为性能。

你*确定*吗？早在 70 年代初，我就使用过计算机（是的，在我父亲的膝盖上……），我从未见过 CPU 不能处理 >= 和 > 一样快。（IBM360 演讲中的 BH “Branch High”与 BNL “Branch Not Low”）。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-10-23T20:19:15.113

对于一些将 >= 分解为 2 个比较的可疑脚本语言来说，这可能是正确的，但是无论谁鼓励你将它用于 C ......嗯......你可能应该努力忘记他们曾经告诉过你的一切。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-10-23T20:56:44.383

这让我想起了使用 ++i 而不是 i++ 的建议（前增量与后增量），因为它被*认为是*一条指令更快。（我忘记了我最初在哪里读到的，但它可能是 C/C++ 用户日志或 Dobb 博士的日志，但我似乎找不到网络参考。）

我严重怀疑 > 或 >= 更快或更慢；而是为了清楚起见编写代码。

作为旁注，我开发了对预增量 (++i) 运算符的偏好，即使原因现在可能已过时。

* * *

## 回答 #8

> 赞同：-1
> 
> 时间：2016-06-06T20:43:14.693

对于大于零，它必须进行两次检查。它检查负位是否关闭，并检查零位是否关闭。

对于大于或等于零，它只需要检查负位是否关闭，因为我们不关心零位是打开还是关闭。

# c# - 最小起订量文档在哪里？

> ID：231175
> 
> 赞同：64
> 
> 时间：2008-10-23T19:44:15.777
> 
> 标签：c#, .net, testing, mocking, moq

我在哪里可以找到 MOQ 的综合文档？我刚开始嘲笑，我很难理解它。我已经阅读了[http://code.google.com/p/moq/wiki/QuickStart](http://code.google.com/p/moq/wiki/QuickStart)上的所有链接，但似乎找不到教程或温和的介绍。

我还简要地查看了 Rhino Mocks，但发现它非常令人困惑。

* * *

是的 - 我读过 Stephen Walthers 的文章 - 非常有帮助。我也浏览了链接。我似乎无法在~~[http://www.bestechvideos.com/2008/06/08/dimecasts-net-introduction-to-mocking-with-moq](http://www.bestechvideos.com/2008/06/08/dimecasts-net-introduction-to-mocking-with-moq)~~ ^(观看视频[断开链接])

具体来说，我试图确定是否从模拟类中引发了一个事件。我无法编译 QuickStarts 页面上的事件示例。在 google 组中，Daniel 解释说 CreateEventHandler 只能处理 type 的事件`EventHandler<TEventArgs>`，但即使这样我也无法编译代码。

更具体地说，我有一个实现`INotifyChanged`.

```
public class Entity : INotifyChanged
{
    public event PropertyChangingEventHandler PropertyChanging;

    public int Id 
      { 
          get {return _id;}
          set {
                 _id = value;
                 OnPropertyChanged("Id");
              }
      }

     protected void OnPropertyChanged(string property)
      {
         if (PropertyChanged != null)
            PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
      }
 etc .....    
} 
```

如何模拟课程以测试`PropertyChanged`事件是否被触发？我无法重写事件，`public event EventHandler<PropertyChangedEventArgs>`因为我收到此错误：

> 错误 1 ​​'CoreServices.Notifier' 没有实现接口成员 System.ComponentModel.INotifyPropertyChanged.PropertyChanged'。“CoreServices.Notifier.PropertyChanged”无法实现“System.ComponentModel.INotifyPropertyChanged.PropertyChanged”，因为它没有“System.ComponentModel.PropertyChangedEventHandler”的匹配返回类型。

* * *

## 回答 #1

> 赞同：35
> 
> 时间：2008-11-09T19:33:46.920

Moq 的最新文档现在可以在 github wiki 页面上找到：

[https://github.com/Moq/moq4/wiki/Quickstart](https://github.com/Moq/moq4/wiki/Quickstart)

以前他们在谷歌代码上。除 wiki 和其他在线资源外，还有 Windows .CHM 帮助文件格式的完整文档，包含在从[Moq 主页](https://github.com/Moq/)链接的[Moq 二进制下载](https://github.com/Moq/moq4/wiki/Quickstart)中。

* * *

## 回答 #2

> 赞同：16
> 
> 时间：2008-10-23T19:48:40.807

你看过[Moq 简介](http://dimecasts.net/Content/WatchEpisode/8)吗？这是使用 Moq 的介绍性概述，适用于那些不熟悉一般模拟或 Moq 框架本身的人。

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-10-23T19:59:14.563

您是否阅读过[https://github.com/Moq/moq4/wiki/Quickstart](https://github.com/Moq/moq4/wiki/Quickstart)上的链接页面？例如[这个](http://weblogs.asp.net/stephenwalther/archive/2008/06/11/tdd-introduction-to-moq.aspx)（可能转移到[斯蒂芬沃尔特的个人博客](http://stephenwalther.com/archive/2008/06/12/tdd-introduction-to-moq.aspx)）

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2011-12-17T17:31:51.083

> 我正在尝试确定是否从模拟类中引发了一个事件。

你是？或者您是否试图确定该`Id`属性是否已设置？请记住，默认情况下，模拟没有任何行为。它不会引发通知事件。

我会做：

```
const int ExpectedId = 123;
mockEntity.VerifySet(x => x.Id = ExpectedId); 
```

这假设 Entity 实现了一个接口；一个例子：

```
public interface IKeyedEntity
{
    int Id { get; set; }
} 
```

也就是说，如果`Entity`是一个没有有趣行为的[POCO](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object)，我既不会实现接口（除了`INotifyChanged`），也不会模拟它。使用实际`Entity`实例进行测试（只是不要使用数据库）。为服务和复杂依赖项保留模拟。

有关更多起订量功能，请参阅

[旧式命令式模拟与最小起订量功能规范](http://blogs.clariusconsulting.net/kzu/old-style-imperative-mocks-vs-moq-functional-specifications/) 和 [Mock.Of - 如何指定行为？（线程）](http://groups.google.com/group/moqdisc/browse_thread/thread/7c0477e3f4e6f400?pli=1)。我还发布了我自己的[Moq v4 功能规范](http://www.truewill.net/myblog/index.php/2011/04/20/moq_v4_functional_specifications)示例。

# search - 在代码库中搜索特定单词的最佳工具或方法是什么？

> ID：231189
> 
> 赞同：2
> 
> 时间：2008-10-23T19:47:51.807
> 
> 标签：search, command-line, replace

您推荐什么工具或方法来查找和替换代码中的值？如果代码在 Linux/Unix 上，find 和 grep 是最好的方法吗？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-23T19:59:26.573

看看[ack](http://petdance.com/ack/)，它是为搜索大型代码库而设计的。

要替换，请查看 Perl 的 -i、-p 和 -e 标志。您可以执行以下操作：

```
$ perl -i -p -e's/\bthisword\b/thatword/g' $(find . -name *.html) 
```

在树中的所有 .html 文件中用那个词替换这个词的所有实例。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T19:52:17.820

我假设您打算重命名一个变量。

这取决于代码主体是什么。对于 C#，Visual Studio 的重命名工具非常好。请记住，要使其可靠地工作，您需要重命名与编译器/解释器一起工作，因此您可以确保只在正确的范围内进行更改。

如果它是一个非常简单的查找/替换，那么低级记事本肯定会做得很好吗？

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T20:08:59.037

`find`并`grep`会找到您要查找的单词，但要替换它，您需要使用 `sed`，`awk`或您最喜欢的流编辑过滤器。

`groovy`, `python`,`perl`都将进行搜索/替换操作 - 使用您喜欢的或选择一个来学习。

对于代码库上的操作，我将使用`find | sed`简单的操作（`cygwin`是你的朋友）和 IDE 的搜索/替换为更复杂的操作的正则表达式支持。Eclipse、Idea、Visual Studio 甚至 SQL Server Manglement Studio 都有强大的搜索/替换功能。坏消息是并非所有人都使用相同的正则表达式语法。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-23T20:25:20.047

看看 PowerGrep ......它在 SO 中到处都有广告。即使我真的不需要它，我也开始想要它-

PD：他们有 15 天的免费演示，所以如果这是一项小工作，你可以使用演示。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2009-05-02T00:48:24.607

这只是安迪上述已接受答案的提示。由于声誉较低，无法将此添加为评论

采用 ！当您难以摆脱字符串时作为分隔符

例如 $ perl -i -p -e's!\bthisword\b!thatword!g' $(find . -name *.html)

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-23T19:53:02.267

find 和 grep 不会构建 indecies，因此它们总是会比其他替代品慢。也就是说，如果您的代码库只有几十个文件，它们就可以正常工作。在 Fi

Eclipse 有一个很好的文件搜索功能（Ctrl+H）。如果您有正确的插件，它还可以考虑语言语义（当然，Java 开箱即用）。唯一需要注意的是，第一次在某个文件集中搜索可能会有点慢。

# jsf - jsf登录超时

> ID：231191
> 
> 赞同：4
> 
> 时间：2008-10-23T19:48:18.563
> 
> 标签：jsf, login, viewexpiredexception

好的简单的问题。我有一个 JSF 应用程序，其中包含一个登录页面。问题是如果用户加载登录页面，离开一段时间，然后尝试登录会话过期并抛出 ViewExpiredException。发生这种情况时，我可以重定向回登录，但这不是很顺利。如何允许此流程正确登录而无需额外尝试？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2009-05-21T19:53:51.963

**更新**

从 Mojarra 2.1.19 / 2.2.0 开始，您现在可以将瞬态属性设置`<f:view>`为 true：

```
<f:view transient="true">
     Your regular content
</f:view> 
```

你可以在这里阅读[Balusc 的](https://stackoverflow.com/users/157882/balusc) 博客：

[http://balusc.blogspot.com.br/2013/02/stateless-jsf.html](http://balusc.blogspot.com.br/2013/02/stateless-jsf.html)

**原来的**

如果您使用 Facelets，您可以创建自己的 ViewHandler 来处理这个问题：

```
public class LoginViewHandler extends FaceletViewHandler
{
    public LoginViewHandler( ViewHandler viewHandler )
    {
        super( viewHandler );
    }

    @Override
    public UIViewRoot restoreView( FacesContext ctx, String viewId )
    {
        UIViewRoot viewRoot = super.restoreView( ctx, viewId );

        if ( viewRoot == null && viewId.equals( "/login.xhtml" ) )
        {
            // Work around Facelet issue
            initialize( ctx );

            viewRoot = super.createView( ctx, viewId );
            ctx.setViewRoot( viewRoot );

            try
            {
                buildView( ctx, viewRoot );
            }
            catch ( IOException e )
            {
                log.log( Level.SEVERE, "Error building view", e ); 
            }
        }

        return viewRoot;
    }
} 
```

将“/login.xhtml”更改为您的登录页面。这将检查它是否可以恢复您的视图，如果它不能并且当前视图是您的登录页面，它将为您创建和构建视图。

在你的 face-config.xml 中进行如下设置：

```
<application>
    <!-- snip -->
    <view-handler>my.package.LoginViewHandler</view-handler>
</application> 
```

如果您使用没有 Facelets（即 JSP）的 JSF，您可以尝试让类扩展 ViewHandlerWrapper - 请注意 buildView() 将不可用。希望它自己的 createView() 将正确设置视图，但我不能 100% 确定 JSF/JSP。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-11-04T18:09:28.307

听起来您的登录页面在会话范围内，而实际上并不需要。请求范围对于登录页面应该没问题（因为实际上在用户登录之前会话中不应该有任何内容）。用户登录后，您可能会再次遇到此问题，但 Phill 的想法从那时起就非常好。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-11-05T17:15:28.493

使用 jsp，您可以禁用包含此指令的页面的会话`<%@ page session="false" %>`。jsf必须有类似的东西。

* * *

## 回答 #4

> 赞同：-1
> 
> 时间：2008-10-24T08:27:28.983

几个有点hacky的解决方案：

*   （非常hacky）使用`<meta http-equiv="refresh" content="5"/>`标签每隔一段时间自动重新加载页面。
*   使用 JavaScript 函数定期向服务器发送“ping”请求以保持会话处于活动状态。

我们在工作中使用[IceFaces](http://www.icefaces.org)，它会自动检测您的会话何时过期并显示一个弹出窗口，提醒您注意这一事实。但是出于某种原因，我们有时仍然会在登录页面上遇到问题。

# c++ - 将自定义函子与 std::generate_n() 算法一起使用的正确方法？

> ID：231198
> 
> 赞同：2
> 
> 时间：2008-10-23T19:49:33.973
> 
> 标签：c++, stl, functional-programming

以下代码在 XPSP3 上的 VC++ 8 下正确编译，但运行它会导致运行时错误。

我的标题看起来像：

```
#include <stdexcept>
#include <iterator>
#include <list>

template<typename T>
class test_generator
{
    public:
    typedef T result_type;

    //constructor
    test_generator()
    {
        std::generate_n( std::back_inserter( tests ), 100, rand );
        value = tests.begin();
    }

    result_type operator()( void )
    {
        if( value == tests.end() )
        {
            throw std::logic_error( "" );
        }

            return *value++;
    }

    private:

    std::list<T> tests;
    typename std::list<T>::iterator value;

}; 
```

我的实现看起来像：

```
#include <functional>
#include <algorithm>
#include <iostream>
#include <deque>

#include "test.h"

int main()
{
    test_generator<double> test;
    std::deque<double> tests;

    std::generate_n( std::back_inserter( tests ), 10, test );

    return 0;
} 
```

这编译得很好，它会生成一个异常（不是头文件中定义的 logic_error 异常）。

如果我将实现更改为使用函数而不是仿函数，它将起作用：

```
int main()
{
    std::deque<int> tests;
    std::generate_n( std::back_inserter( tests ), 10, rand );

    return 0;
} 
```

在这里使用仿函数有什么问题？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-23T20:18:20.390

构造`test_generator`函数初始化`value`迭代器以引用`tests`列表中的第一个元素（它是 的成员`test_generator`）。

当您调用 时`std::generate_n`，会生成 的副本`test`（因为对象是按值传递的）。在复制的对象中，`value`迭代器指的`tests`是原始对象中的列表，而不是副本。

由于在 Visual Studio STL 实现中执行的迭代器调试检查，这会触发一个断言，因为从一个容器获得的迭代器不应与来自另一个容器的迭代器进行比较。

要解决这个问题，您可以为您的`test_generator`类实现一个复制构造函数，或者将初始化推迟`value`到第一次`operator()`被调用。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T20:04:40.057

到目前为止，我还没有弄清楚是什么导致了异常，但你可能希望`return *value++`在你的`operator()`. :-)

# .net - 自动启动智能客户端应用程序

> ID：231201
> 
> 赞同：3
> 
> 时间：2008-10-23T19:50:40.413
> 
> 标签：.net, winforms, smartclient

有一个标准的智能客户端应用程序，当用户在我们的网络上登录他们的机器时，我们希望它自动启动。我尝试了以下键：

HKLM\Software\Microsoft\Windows\CurrentVersion\Run HKCU\Software\Micrisoft\Windows\CurrentVersion\Run HKCU\Software\Micrisoft\Windows\CurrentVersion\Policy\Explorer\Run

ETC....

启动密钥类似于：共享驱动器上的 J:\Application\NewApp.application 或 UNC 路径 \\server1\Application\NewApp.application

我尝试将指定的文件更改为 setup.exe 文件、启动它的批处理文件、延迟的批处理文件，甚至是通过 Process.Start() 延迟后创建的用于启动 NewApp.application 文件的小型 .exe .

如果我在登录后手动运行这些选项，一切正常，但是在登录机器时没有任何作用（目标是）。

有人有什么想法吗？

更新：权限不是问题。我一直在测试管理员级别的权限。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2009-01-12T20:24:30.223

我的猜测是它与网络在启动时不直接可用有关。那些批处理（延迟）文件，它们是从计算机自己的硬盘驱动器上运行的吗？如果没有，你可以试试。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T21:13:41.883

在网络共享之外执行 .NET 应用程序的权限是否正确？

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T20:56:21.483

如果您在域中，则可以使用组策略来启动您的应用程序。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2009-01-14T15:41:18.750

将应用程序放在“开始”菜单的“启动”部分怎么样？我不确定这些是在注册表项之前还是之后运行，但这可能会导致足够的延迟。

至于您在批处理文件或入门应用程序中编码的延迟，它设置了多长时间？您是否尝试了足够大的值，例如 5 分钟？我想知道是否需要更长的延迟，或者问题是您的应用程序是在它依赖的其他东西之前启动的。

另外，启动失败是因为找不到应用程序，还是应用程序启动然后立即死亡？

# security - 使用经典 ASP 构建“退出”页面，避免主要的跨站点脚本陷阱

> ID：231204
> 
> 赞同：0
> 
> 时间：2008-10-23T19:51:02.923
> 
> 标签：security, asp-classic, legacy-code, xss

我正在更新一个经典的 ASP 网页，该网页由我工作的公司维护的许多子站点使用。

该页面的目的是通知用户他们将离开“我们的”网站并前往另一个网站。它基本上是免责声明，但由于资源限制和时间限制，我无法将免责声明添加到我们管理的每个站点。

这是问题的症结所在。当前代码从查询字符串中提取一个变量以在新窗口中创建“继续”链接。这显然会以跨站点脚本的形式产生许多问题。

如何处理此更新以消除大多数（如果不是全部）使用 vbScript/ASP 的跨站点脚本问题。

我正在使用的代码如下。

```
<%@ Language = vbScript %>
<% Option Explicit %>

<%
Dim strLink
strLink = Request.QueryString("site")
strLink = Replace(strLink, "<", "&lt")
strLink = Replace(strLink, ">", "&gt;")
strLink = Replace(strLink, chr(34), "")
strLink = Replace(strLink, "script", "", 1, -1, 1)
strLink = Replace(strLink, "onclick", "", 1, -1, 1)
strLink = Replace(strLink, "ondblclick", "", 1, -1, 1)
strLink = Replace(strLink, "onmousedown", "", 1, -1, 1)
strLink = Replace(strLink, "onmouseover", "", 1, -1, 1)
strLink = Replace(strLink, "onmousemove", "", 1, -1, 1)
strLink = Replace(strLink, "onmouseout", "", 1, -1, 1)
strLink = Replace(strLink, "onkeypress", "", 1, -1, 1)
strLink = Replace(strLink, "onkeydown", "", 1, -1, 1)
strLink = Replace(strLink, "onkeyup", "", 1, -1, 1)
strLink = Replace(strLink, "onfocus", "", 1, -1, 1)
strLink = Replace(strLink, "onblur", "", 1, -1, 1)
strLink = Replace(strLink, "&&", "")
strLink = Replace(strLink, "##", "")
strLink = Replace(strLink, "&#", "")
%>

<a href="<%= strLink %>">Continue</a> 
```

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-25T02:57:46.857

您需要实施一种遵循“积极安全模型”概念的方法。您应该解析“站点”变量并确保它明确符合允许的内容，而不是编写一些内容来查找应该禁止的内容。这将使您的方法对攻击更具弹性，尤其是意外攻击。

我建议编写一个正则表达式（或询问如何在 stackoverflow 上编写这样的正则表达式）。

此外，虽然 Michael 发布的 Web 服务非常酷，但您应该评估是否可以接受对此类事物的依赖。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T21:32:08.197

这是我推荐的 HTML 清理 -

HTML Whitelist 是我的好同事 DeWitt Clinton 提出的“App Engine 上推出的很酷的 Python Web 服务”中的最新一个。

它只做一件事，而且做得很好。您可以传递服务 HTML，它会返回经过清理的版本。

[http://html-whitelist.appspot.com/](http://html-whitelist.appspot.com/)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-26T17:32:03.960

您可以添加逻辑以继续页面，以确保它仅由您的一个站点上的页面基于 url 或 IP 地址调用。您还可以通过时间和散列代码以增加安全性。

# database - 数据库设计 - 硬编码行 ID

> ID：231206
> 
> 赞同：5
> 
> 时间：2008-10-23T19:51:35.280
> 
> 标签：database, database-design

每个人都在将代码枚举与数据库表中的行 ID 绑定在一起是什么？我真的在寻找更清洁的替代品。例如，如果给定表中的静态行是 ID 1、2、3，然后该表使用 ID 4-100 填充了用户事务数据，然后您稍后想要在本地添加一个新行 ID，该怎么办？生产数据库的行 ID 为 4，但是当该行进入客户数据库时，它必须是 101 ......好吧，这有点破坏了一切。

那么，如何处理同时填充事务数据的表中的静态锁定行呢？

谢谢，网人

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2008-10-23T19:54:50.390

不要那样做。;-)

如果您在具有事务性或至少可变的用户数据的表中具有静态行、永远不会更改的值，那么我会说您在模式中至少存在规范化问题。

参考数据通常属于它自己的表。如果表本身仅包含参考数据，则从应用程序分配 ID 或使用从 DB 生成的 ID 成为优先事项。

我经常玩弄从 DB 表生成“源代码”Enum 类或在构建/部署时用 Enum 类信息填充 DB 表的想法，但我从来没有“接触过”。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T20:04:44.863

不要将应用程序中的特殊逻辑建立在数据库中的行 ID 上，尤其是当您无法绝对控制该表中的内容时。（我承认我有时会为我绝对知道不会改变的查找表这样做，但即使在这里也可能是不好的做法。）

如果您需要标记某些特殊记录，则放置某种指示该标记的“标记”字段，然后查询该标记。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T19:58:09.557

我同意 Ken G - 让枚举值对应于行 ID 仅对具有静态（不变）内容的查找表有意义

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2012-07-23T15:27:46.630

我同意 Stephen W. 的观点，一个好的解决方案是使用`name`ENUM 项的字符串。我在 .Net 中一直使用这种方法，而且很容易使用。

这个想法是，无论您的枚举具有什么值（并且无论数据库记录具有什么 ID），只有当您的开发人员更改它时，枚举名称才会更改。与自动递增的 ID 号（不受您的控制）相比，这是一种更易于管理的情况。其他阅读您的代码的开发人员也知道一个名称试图描述什么，而不是一些看似随机的数字，它可能意味着任何东西，并且很可能意味着跨不同数据库的多个东西！

一种可行的方法是让您的表格具有文本代码或描述标识列。这可能是一个字母数字值，但关键是它应该唯一标识该记录。实际上，这可以用作主键，但实际上我总是有一个自动递增的主 ID 号列。此类表上的列示例：

`PK_ID | CODE | Other Data`等等

这里，code 字段的值实际上就是你的 Enum 名称。这是一个不需要更改的代码。您必须在您自己和您的团队之间制定规则，即这些不会更改，但如果有人需要更改它，请确保它反映在两个平台上。

使用 .Net 处理枚举（在此示例中称为 SortDirection）：

```
' Get the string name of an enum
[Enum].GetName(GetType(SortDirection), SortDirection.Ascending)

' Get the enum value from its string name
CType([Enum].Parse(GetType(SortDirection), "Ascending"), SortDirection) 
```

它不是一个完美的解决方案，但它对我很有帮助；我对硬编码的 ID 感到困惑和恼火太多次了，以至于无法理解这两个弊端中的哪一个。希望有帮助！

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-24T15:40:50.000

不判断你计划的合理性。DBA 和其他人总是喜欢说“不要那样做”。好像你问你是否应该这样做，即使你没有问，就像你可以选择不这样做。

我会假设您提出问题是有原因的，并且您没有选择不这样做的选择。

我有一个[朋友](https://stackoverflow.com/users/18941/thesoftwarejedi)认为 Oracle 序列很麻烦，而且自动编号字段要容易得多。它们没有那么“简单”，但更加灵活。到目前为止，您还没有说明您的平台，所以请不要使用 mod -1。

在 Oracle 中，您可以创建序列来填写自动编号字段。序列完全独立于表。您可以在多个表中使用一个序列，您可以在一个表中使用多个序列。如果我必须解决您的情况，我将创建 2 个序列，一个从 1 开始，以 2 为步长（用于管理数据），另一个从 2 开始，以 2 为步长（用于用户数据）。我会更改我的插入过程，以便为管理员插入提供一个选项参数，以提取正确的序列。您的数据和用户数据永远不会发生冲突。有一个副作用是能够根据 ID 的奇偶性区分两者。缺点是有一个硬性限制。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2009-01-22T02:30:54.400

我以前必须在状态表上这样做。安装应用程序时必须始终存在某些“内置”值，并在某些时间点进行特殊处理。

然后，用户可以出于工作流程的原因创建自己的。

您可以做的是从 1,001 开始您的序列。1 到 1,000 之间的任何值都是“内置”值。当然，1000 在这里是一个神奇的数字，但就我而言，我只有 5 个内置值，所以它看起来很安全。

另一个选项是大于零的 id 是用户创建的，小于零是系统内置的。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-23T19:55:48.673

也许您可以发布一个示例来帮助我们更好地理解，但是如果您有一些被指定为“系统”条目的行，您可以考虑在表中添加一个名为 Order 的列，然后，当您创建一个旨在用于作为系统条目，您可以增加订单列。

对于大多数其他事情，例如查找表，您应该能够更明确地控制行 ID 并使用它们。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-23T19:59:15.967

嗯，一个枚举应该是一个常数——你不希望改变的东西——你真的不能说来自数据库的数据。

无论如何，你的问题来自于你从 ENUM 文本后面的 INTEGER 保存/加载。在这里有帮助的解决方案是从枚举的 TEXT 值进行查找/保存/等

此 VB 代码将字符串转换回 ENUM，并且应该很容易移植到 C#：

```
[Enum].Parse(System.Type, Value) 
```

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-23T20:48:11.267

这是一个解决方案：大多数数据库都有一种机制来生成从 1 开始并沿正方向递增的新 ID 值。

但是，如果主键列是有符号整数，则可以对静态行使用负值。-1 的 ID 表示“--NONE--”，-2 的 ID 表示“--SPECIAL--”或其他。如果您需要更多静态行，请朝负方向前进。

如果外键也是有符号整数，那么您的外键仍然可以引用静态行和用户生成的行。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-10-23T22:55:34.177

永远不要存储 ROWID，因为它们可以更改。如果您将这些表之一移动到新表空间，则所有存储的 ROWID 都将变为无效（无论如何，这在 Oracle 中是正确的）。

如果您有一个需要保护的用于 FK 目的的特殊行，您可以使用触发器来防止它被更新。

# git - 使用 Git 如何查找本地和远程之间的更改

> ID：231211
> 
> 赞同：154
> 
> 时间：2008-10-23T19:52:30.020
> 
> 标签：git, mercurial

这是两个不同的问题，但我认为它们是相关的。

1.  使用 Git 时，如何找到我在本地提交但尚未推送到远程分支的更改？我正在寻找类似于 Mercurial 命令的东西`hg outgoing`。

2.  使用 Git 时，我如何找到远程分支在拉取之前所做的更改？我正在寻找类似于 Mercurial 命令的东西`hg incoming`。

第二：有没有办法查看可用的内容，然后挑选我想要的更改？

* * *

## 回答 #1

> 赞同：116
> 
> 时间：2011-06-17T17:18:37.267

从 Git 1.7.0 开始，有一个特殊的语法允许你泛指上游分支：`@{u}`或`@{upstream}`.

模仿`hg incoming`：

```
git log ..@{u} 
```

模仿`hg outgoing`：

```
git log @{u}.. 
```

我使用以下内容`incoming`和`outgoing`别名使上述内容更易于使用：

```
git config --global alias.incoming '!git remote update -p; git log ..@{u}'
git config --global alias.outgoing 'log @{u}..' 
```

* * *

## 回答 #2

> 赞同：99
> 
> 时间：2008-10-23T20:31:36.523

Git 不能像 Hg 那样通过网络发送那种信息。但是您可以运行`git fetch`（这更像是`hg pull`）`hg fetch`从远程服务器获取新提交。

所以，如果你有一个叫做的分支`master`和一个叫做远程的`origin`，在运行之后`git fetch`，你应该也有一个叫做的分支`origin/master`。然后，您可以通过 do 获得需要成为超集的`git log`所有提交中的。颠倒这两个以获得相反的结果。`master``origin/master``git log master..origin/master`

我的一个朋友 David Dollar 创建了几个 git shell 脚本来模拟`hg incoming/outgoing`. 您可以在[http://github.com/ddollar/git-utils](http://github.com/ddollar/git-utils)找到它们。

* * *

## 回答 #3

> 赞同：43
> 
> 时间：2008-10-23T20:07:24.890

不是完整的答案，但 git fetch 将拉取远程仓库而不进行合并。然后你可以做一个

```
git diff 主起源/主
```

* * *

## 回答 #4

> 赞同：34
> 
> 时间：2008-10-23T19:55:45.410

1.  使用“git log origin..HEAD”

2.  使用“git fetch”后跟“git log HEAD..origin”。您可以使用列出的提交 ID 挑选单个提交。

当然，上面假设“origin”是您的远程跟踪分支的名称（如果您使用带有默认选项的克隆）。

* * *

## 回答 #5

> 赞同：22
> 
> 时间：2011-05-25T09:57:40.900

还有这个，用于比较所有分支：

```
git log --branches --not --remotes=origin 
```

这是 git log 手册页对此的说明：

> 显示在任何本地分支中但不在任何远程跟踪分支中的所有提交（您拥有的源没有）。

以上是针对`outgoing`. 对于`incoming`，只需交换：

```
git log --remotes=origin --not --branches 
```

* * *

## 回答 #6

> 赞同：8
> 
> 时间：2014-01-21T14:30:36.983

我会做

```
$ git fetch --dry-run 
```

对于`hg incoming`和

```
$ git push --dry-run 
```

为`hg outgoing`.

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2011-11-05T00:33:57.393

[git-out](http://www.doof.me.uk/2011/01/08/list-outgoing-changesets-in-git/)`hg outgoing`是一个非常准确地模拟的脚本。它解析“push -n”输出，因此如果您需要指定要推送的其他参数，它会产生准确的输出。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2013-12-09T12:45:29.490

# git传入

```
$ git fetch && git log ..origin/master --stat
OR
$ git fetch && git log ..origin/master --patch 
```

# git传出

```
$ git fetch && git log origin/master.. --stat
OR
$ git fetch && git log origin/master.. --patch 
```

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2014-07-07T16:32:42.677

当“git log”和@{u} 的答案最初给了我“未知修订”错误时，我尝试了 Chris/romkyns 的`git push --dry-run`.

您将获得诸如“5905..4878 master->master”之类的输出。5905 是远程具有的最新提交，并且通过（包括）4878 提交将应用于远程。

然后，您可以使用 5905..4878 作为其他几个 git 命令的参数来获取更多详细信息：

```
git diff 5905..4878 # Gives full code changes in diff style

git log --online 5905..4878 # Displays each commit's comment 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2020-10-08T09:37:59.923

可以使用以下方法显示跨所有分支的传入提交。

该命令`git fetch-diff`通过添加一个调用`git-fetch-diff`到您的 PATH 的可执行文件变得可用，其中包含：

```
#!/bin/bash

set -e

# get hashes before fetch
old_hashes=$(git log --all --no-color --pretty=format:"%H")

# perform the fetch
git fetch

# get hashes after fetch
new_hashes=$(git log --all --no-color --pretty=format:"%H")

# get the difference
added_hashes=$(comm -1 -3 <(echo "$old_hashes") <(echo "$new_hashes"))

# print added hashes
[ ! -z "$added_hashes" ] && echo "$added_hashes" | git log --stdin --no-walk --oneline 
```

提交哈希在获取之前和之后进行比较。差异通过管道返回以`git log`进行漂亮的打印。打印日志的外观可以根据您的喜好进一步调整，例如`--pretty=<format>`和`--graph`。

**注意**：您可能希望`git log`根据 bash 变量可以在您的系统上保留多少或出于性能原因来限制时间回溯的距离。这可以通过添加参数来完成`--max-count=<count>`。

* * *

## 回答 #11

> 赞同：-1
> 
> 时间：2015-10-21T21:02:58.587

当您执行 git fetch 时，包括分支、标签（refs）在内的所有内容都临时存储在 .git/FETCH_HEAD 中，可以使用以下命令查看其内容： git log FETCH_HEAD 如果您不使用 git fetch 后缀 -a 则默认情况下, FETCH_HEAD 的内容将被新内容覆盖。从这些内容中，您可以查看并决定要将它们合并到哪个分支，或者如果您只想从 fetch 带来的内容中提交一些提交，则可以简单地挑选。

# asp.net - ASP.NET MVC Beta - 可以对控制器和视图进行分组吗？

> ID：231214
> 
> 赞同：2
> 
> 时间：2008-10-23T19:53:15.993
> 
> 标签：asp.net, asp.net-mvc, asp.net-mvc-routing

我正在使用最新的 beta 版本构建一个 ASP.NET MVC 应用程序，我想知道是否可以更改默认项目布局

/Views/Home/Index.aspx /Views/Home/About.aspx

到

/Blog/Views/Home/Index.aspx /Blog/Views/Home/About.aspx

/Forum/Views/Home/Index.aspx /Forum/Views/Home/About.aspx

目标是在单个 Web 项目中实现“应用程序”之间的某种分离，就像 Thomas Owens 在这里已经问过的问题：[在 MVC 框架下，其他开发人员期望哪种目录结构？](https://stackoverflow.com/questions/178398/under-an-mvc-framework-which-directory-structure-would-be-expected-by-other-dev)

当然，这也应该包括控制器，而不仅仅是视图。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-23T21:15:59.930

是的，应该可以做到这一点。我可以想到一种方法；可能还有其他人。

第一步是修改默认路由以包含您的应用程序名称：

```
routes.MapRoute("Default",
                "{applicationName}/{controller}/{action}/{id})",
                null, null); 
```

我假设您要将两个“应用程序”分组到单个程序集中的不同名称空间中。因此，您可能有两个命名空间，例如：

*   MyApp.Blog.Controllers
*   MyApp.Forum.Controllers

接下来，您需要更改控制器工厂，以便实例化正确的控制器。您可以通过子类型化 DefaultControllerFactory 并覆盖 GetControllerType 方法来做到这一点：

```
 protected override System.Type GetControllerType(string controllerName)
    {
        string applicationName;
        if (RequestContext != null && 
           RequestContext.RouteData.Values.TryGetValue(
           "applicationName", out applicationName)) {
           // return controller type using app name to 
           // look up namespace and controllerName argument
           return ...
        }

        // if no match, maybe it's a different controller/route
        return base.GetControllerType(controllerName);
    } 
```

最后，您需要告诉 MVC 使用您的 ControllerFactory。在 Global.asax.cs 中：

```
 private void Application_Start(object sender, EventArgs e)
    {
        RegisterRoutes(RouteTable.Routes);
        ControllerBuilder.Current.SetControllerFactory(
            MyApp.MyControllerFactory());
    } 
```

可以类似地处理定位视图。在这种情况下，您将子类型化为 WebFormViewEngine。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-11-04T21:16:58.693

我刚刚写了一篇博文，描述了一种对控制器进行分组的方法，该方法类似于单轨列车中的“区域”。不过，它还没有解决嵌套区域。

[http://haacked.com/archive/2008/11/04/areas-in-aspnetmvc.aspx](http://haacked.com/archive/2008/11/04/areas-in-aspnetmvc.aspx)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T21:41:08.523

这不是一个新概念。[它在Monorail](http://www.castleproject.org/MonoRail/)中被称为“区域” 。[最近在ATL.NET 论坛](http://tech.groups.yahoo.com/group/altdotnet/?m=0)和其他地方有很多关于这个话题的讨论。史蒂夫桑德森想出了一个[方法来做到这一点](http://blog.codeville.net/2008/07/30/partitioning-an-aspnet-mvc-application-into-separate-areas/)，但显然它留下了一些问题。作为回应，显然 MVC 团队将对它进行“[深入研究](http://tech.groups.yahoo.com/group/altdotnet/message/16571)”，以备将来发布。

# svn - 如何使用 Subversion 设置 asp.net mvc 应用程序？

> ID：231219
> 
> 赞同：1
> 
> 时间：2008-10-23T19:54:58.457
> 
> 标签：svn, version-control

我计划有2个项目。1\. mbtech.crm.mvc 2\. mbtech.crm.tests

我将有一个名为 mbtech.crm 的解决方案

设置这些以便我可以在 Subversion 中跟踪它们的最佳方法是什么？

选项 1（那么我的解决方案文件在哪里）？
- mbtech.crm.mvc
   - 标签
   - 树干
   - 分支
- mbtech.crm.tests
   - 标签
   - 树干
   - 分支

选项 2
- mbtech.crm
   - 树干
       mbtech.crm.sln
     - mbtech.crm.mvc
     - mbtech.crm.tests
   -标签
   - 分支

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-23T20:20:08.263

选项 2 是我的选择，它们是同一解决方案的两个部分，因此将它们分开没有多大意义。我看不出你为什么要分支你的代码而不是你的测试，反之亦然。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T20:03:18.533

如果项目相关性很强，那么您可能应该使用相同的主干。如果它们彼此独立，或者关系很浅，那么使用不同的树干可能会更好。

# c++ - 窗把手和窗尺寸

> ID：231220
> 
> 赞同：1
> 
> 时间：2008-10-23T19:55:02.370
> 
> 标签：c++, mfc

我创建的 MFC 应用程序是基于对话框的。只有一个对话框就可以了。如何在应用程序执行 InitDialog 时获取此窗口的窗口句柄。我还需要找出它的尺寸。GetForegroundWindow 不一定为您提供正在加载的此窗口的句柄

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-23T20:00:05.527

检查对话框对象的 m_hWnd 成员。GetClientRect() 应该可以为您提供对话框客户端（内部）的大小。GetWindowRect() 将为您提供包括窗口边框在内的总大小，但位置将关闭。

# php - 致命错误：尝试使用 ADODB 时未找到“COM”类

> ID：231226
> 
> 赞同：2
> 
> 时间：2008-10-23T19:56:12.603
> 
> 标签：php, adodb, fatal-error

```
 include('adodb5/adodb.inc.php');

        $myServer = "localhost";
        $myUser = "root";
        $myPass = "root";
        $myDB = "database";

        //create an instance of the  ADO connection object
        $conn = new COM("ADODB.Connection") or die("Cannot start ADO");

        //define connection string, specify database driver
        $connStr = "PROVIDER=SQLOLEDB;SERVER=".$myServer.";UID=".$myUser.";PWD=".$myPass.";DATABASE=".$myDB;
        $conn->open($connStr); //Open the connection to the database 
```

这是我第一次遇到 ADODB 库，据说它可以帮助我从 MySQL 切换到 Microsoft SQL Server。有谁知道我为什么会收到此错误，或者是否有更简单的方法不涉及使用 php.ini 文件？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2014-07-23T10:40:30.840

如果您想使用以下代码：

```
new COM("ADODB.Connection") 
```

您需要在 PHP 中启用“COM 支持”，例如使用 com_dotnet 扩展 (php_com_dotnet.dll)[如何安装 COM 扩展](http://php.net//manual/fr/com.installation.php)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-24T15:42:56.547

您似乎包含了 PHP adodb 库，但实际上并没有使用它——而是试图实例化一个（微软）ADO COM 对象。

如果您没有安装 ADO/使用 PHP 工作，您可以尝试使用 ODBC DSN-less 连接，例如：

```
include('adodb5/adodb.inc.php');

$myServer = "localhost";
$myUser = "root";
$myPass = "root";
$myDB = "database";

$db = ADONewConnection('odbc_mssql');
$dsn = "Driver={SQL Server};Server={{$myServer}};Database={{$myDB}};";
$db->Connect($dsn,$myUser,$myPass) or die($db->ErrorMsg());         

if (!$rs = $db->Execute('select * from table')) die($db->ErrorMsg());

while (!$rs->EOF) {
    print_r($rs->fields);
    $rs->MoveNext();
}

$rs->Close(); 
```

[另请参阅http://phplens.com/adodb/code.initialization.html#connect_ex](http://phplens.com/adodb/code.initialization.html#connect_ex)上的其他连接示例

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T20:11:18.127

最可能的原因是服务器上未正确安装 ADO。尝试运行最新版本的 MDAC 并确保其安装正确，然后再次尝试。使用更多信息更新您的问题以获取更多详细信息。我假设您在 Windows Server 上？

# makefile - 如何仅使用一个makefile在子目录中生成带有源代码的Makefile

> ID：231229
> 
> 赞同：64
> 
> 时间：2008-10-23T19:56:32.307
> 
> 标签：makefile

我在一堆子目录中有源代码，例如：

```
src/widgets/apple.cpp
src/widgets/knob.cpp
src/tests/blend.cpp
src/ui/flash.cpp 
```

在项目的根目录中，我想使用如下规则生成单个 Makefile：

```
%.o: %.cpp
   $(CC) -c $<

build/test.exe: build/widgets/apple.o build/widgets/knob.o build/tests/blend.o src/ui/flash.o
   $(LD) build/widgets/apple.o .... build/ui/flash.o -o build/test.exe 
```

当我尝试这个时，它没有找到 build/widgets/apple.o 的规则。我可以更改一些内容以便在需要制作 build/widgets/apple.o 时使用 %.o: %.cpp 吗？

* * *

## 回答 #1

> 赞同：73
> 
> 时间：2008-10-23T20:39:25.247

原因是你的规则

```
%.o: %.cpp
       ... 
```

期望 .cpp 文件与您的建筑物的 .o 位于同一目录中。由于您的情况下的 test.exe 依赖于 build/widgets/apple.o （等），因此 make 期望 apple.cpp 是 build/widgets/apple.cpp。

您可以使用 VPATH 来解决此问题：

```
VPATH = src/widgets

BUILDDIR = build/widgets

$(BUILDDIR)/%.o: %.cpp
      ... 
```

**当尝试构建“build/widgets/apple.o”时，make 将在 VPATH 中**搜索 apple.cpp 。请注意，构建规则必须使用特殊变量才能访问实际的文件名 make 发现：

```
$(BUILDDIR)/%.o: %.cpp
        $(CC) $< -o $@ 
```

其中 "$<" 扩展到 make 位于第一个依赖项的路径。

另请注意，这将在 build/widgets 中构建所有 .o 文件。如果您想在不同的目录中构建二进制文件，您可以执行类似的操作

```
build/widgets/%.o: %.cpp
        ....

build/ui/%.o: %.cpp
        ....

build/tests/%.o: %.cpp
        .... 
```

我建议您使用“[固定命令序列](http://www.gnu.org/software/make/manual/make.html#Canned-Recipes)”以避免重复实际的编译器构建规则：

```
define cc-command
$(CC) $(CFLAGS) $< -o $@
endef 
```

然后你可以有多个这样的规则：

```
build1/foo.o build1/bar.o: %.o: %.cpp
    $(cc-command)

build2/frotz.o build2/fie.o: %.o: %.cpp
    $(cc-command) 
```

* * *

## 回答 #2

> 赞同：71
> 
> 时间：2010-03-20T19:08:12.113

这可以解决问题：

```
CC        := g++
LD        := g++

MODULES   := widgets test ui
SRC_DIR   := $(addprefix src/,$(MODULES))
BUILD_DIR := $(addprefix build/,$(MODULES))

SRC       := $(foreach sdir,$(SRC_DIR),$(wildcard $(sdir)/*.cpp))
OBJ       := $(patsubst src/%.cpp,build/%.o,$(SRC))
INCLUDES  := $(addprefix -I,$(SRC_DIR))

vpath %.cpp $(SRC_DIR)

define make-goal
$1/%.o: %.cpp
    $(CC) $(INCLUDES) -c $$< -o $$@
endef

.PHONY: all checkdirs clean

all: checkdirs build/test.exe

build/test.exe: $(OBJ)
    $(LD) $^ -o $@

checkdirs: $(BUILD_DIR)

$(BUILD_DIR):
    @mkdir -p $@

clean:
    @rm -rf $(BUILD_DIR)

$(foreach bdir,$(BUILD_DIR),$(eval $(call make-goal,$(bdir)))) 
```

此 Makefile 假定您在源目录中有包含文件。它还检查构建目录是否存在，如果不存在则创建它们。

最后一行是最重要的。它使用该函数为每个构建创建隐含规则，`make-goal`无需一一编写。

您还可以使用[Tromey 的方式添加自动依赖项生成](http://make.paulandlesley.org/autodep.html)

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2009-09-15T13:33:02.017

事情`$@`将包括源文件的整个（相对）路径，而源文件又用于构造对象名称（以及它的相对路径）

我们用：

```
#####################
# rules to build the object files
$(OBJDIR_1)/%.o: %.c
    @$(ECHO) "$< -> $@"
    @test -d $(OBJDIR_1) || mkdir -pm 775 $(OBJDIR_1)
    @test -d $(@D) || mkdir -pm 775 $(@D)
    @-$(RM) $@
    $(CC) $(CFLAGS) $(CFLAGS_1) $(ALL_FLAGS) $(ALL_DEFINES) $(ALL_INCLUDEDIRS:%=-I%) -c $< -o $@ 
```

这将创建一个具有指定名称的对象目录，`$(OBJDIR_1)` 并根据源中的子目录创建子目录。

例如（假设 objs 为顶级对象目录），在 Makefile 中：

```
widget/apple.cpp
tests/blend.cpp 
```

导致以下对象目录：

```
objs/widget/apple.o
objs/tests/blend.o 
```

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2013-07-22T08:41:37.163

这是另一个技巧。

在主“Makefile”中为每个源目录定义 SRCDIR，并为每个 SRCDIR 值包含“makef.mk”。在每个源目录中放置文件“files.mk”，其中包含源文件列表和其中一些的编译选项。在主“Makefile”中，可以为每个 SRCDIR 值定义编译选项和排除文件。

生成文件：

```
PRG             := prog-name

OPTIMIZE        := -O2 -fomit-frame-pointer

CFLAGS += -finline-functions-called-once
LDFLAGS += -Wl,--gc-section,--reduce-memory-overheads,--relax

.DEFAULT_GOAL   := hex

OBJDIR          := obj

MK_DIRS         := $(OBJDIR)

SRCDIR          := .
include         makef.mk

SRCDIR := crc
CFLAGS_crc := -DCRC8_BY_TABLE -DMODBUS_CRC_BY_TABLE
ASFLAGS_crc := -DCRC8_BY_TABLE -DMODBUS_CRC_BY_TABLE
include makef.mk

################################################################

CC              := avr-gcc -mmcu=$(MCU_TARGET) -I.
OBJCOPY         := avr-objcopy
OBJDUMP         := avr-objdump

C_FLAGS         := $(CFLAGS) $(REGS) $(OPTIMIZE)
CPP_FLAGS       := $(CPPFLAGS) $(REGS) $(OPTIMIZE)
AS_FLAGS        := $(ASFLAGS)
LD_FLAGS        := $(LDFLAGS) -Wl,-Map,$(OBJDIR)/$(PRG).map

C_OBJS          := $(C_SRC:%.c=$(OBJDIR)/%.o)
CPP_OBJS        := $(CPP_SRC:%.cpp=$(OBJDIR)/%.o)
AS_OBJS         := $(AS_SRC:%.S=$(OBJDIR)/%.o)

C_DEPS          := $(C_OBJS:%=%.d)
CPP_DEPS        := $(CPP_OBJS:%=%.d)
AS_DEPS         := $(AS_OBJS:%=%.d)

OBJS            := $(C_OBJS) $(CPP_OBJS) $(AS_OBJS)
DEPS            := $(C_DEPS) $(CPP_DEPS) $(AS_DEPS)

hex:  $(PRG).hex
lst:  $(PRG).lst

$(OBJDIR)/$(PRG).elf : $(OBJS)
    $(CC) $(C_FLAGS) $(LD_FLAGS) $^ -o $@

%.lst: $(OBJDIR)/%.elf
    -@rm $@ 2> /dev/nul
    $(OBJDUMP) -h -s -S $< > $@

%.hex: $(OBJDIR)/%.elf
    -@rm $@ 2> /dev/nul
    $(OBJCOPY) -j .text -j .data -O ihex $< $@

$(C_OBJS) : $(OBJDIR)/%.o : %.c Makefile
    $(CC) -MMD -MF $@.p.d -c $(C_FLAGS) $(C_FLAGS_$(call clear_name,$<)) $< -o $@
    @sed -e 's,.*:,SRC_FILES += ,g' < $@.p.d > $@.d
    @sed -e "\$$s/$$/ $(subst /,\/,$(dir $<))files.mk\n/" < $@.p.d >> $@.d
    @sed -e 's,^[^:]*: *,,' -e 's,^[ \t]*,,' -e 's, \\$$,,' -e 's,$$, :,' < $@.p.d >> $@.d
    -@rm -f $@.p.d

$(CPP_OBJS) : $(OBJDIR)/%.o : %.cpp Makefile
    $(CC) -MMD -MF $@.p.d -c $(CPP_FLAGS) $(CPP_FLAGS_$(call clear_name,$<)) $< -o $@
    @sed -e 's,.*:,SRC_FILES += ,g' < $@.p.d > $@.d
    @sed -e "\$$s/$$/ $(subst /,\/,$(dir $<))files.mk\n/" < $@.p.d >> $@.d
    @sed -e 's,^[^:]*: *,,' -e 's,^[ \t]*,,' -e 's, \\$$,,' -e 's,$$, :,' < $@.p.d >> $@.d
    -@rm -f $@.p.d

$(AS_OBJS) : $(OBJDIR)/%.o : %.S Makefile
    $(CC) -MMD -MF $@.p.d -c $(AS_FLAGS) $(AS_FLAGS_$(call clear_name,$<)) $< -o $@
    @sed -e 's,.*:,SRC_FILES += ,g' < $@.p.d > $@.d
    @sed -e "\$$s/$$/ $(subst /,\/,$(dir $<))files.mk\n/" < $@.p.d >> $@.d
    @sed -e 's,^[^:]*: *,,' -e 's,^[ \t]*,,' -e 's, \\$$,,' -e 's,$$, :,' < $@.p.d >> $@.d
    -@rm -f $@.p.d

clean:
    -@rm -rf $(OBJDIR)/$(PRG).elf
    -@rm -rf $(PRG).lst $(OBJDIR)/$(PRG).map
    -@rm -rf $(PRG).hex $(PRG).bin $(PRG).srec
    -@rm -rf $(PRG)_eeprom.hex $(PRG)_eeprom.bin $(PRG)_eeprom.srec
    -@rm -rf $(MK_DIRS:%=%/*.o) $(MK_DIRS:%=%/*.o.d)
    -@rm -f tags cscope.out

#   -rm -rf $(OBJDIR)/*
#   -rm -rf $(OBJDIR)
#   -rm $(PRG)

tag: tags
tags: $(SRC_FILES)
    if [ -e tags ] ; then ctags -u $? ; else ctags $^ ; fi
    cscope -U -b $^

# include dep. files
ifneq "$(MAKECMDGOALS)" "clean"
-include $(DEPS)
endif

# Create directory
$(shell mkdir $(MK_DIRS) 2>/dev/null) 
```

makef.mk

```
SAVE_C_SRC := $(C_SRC)
SAVE_CPP_SRC := $(CPP_SRC)
SAVE_AS_SRC := $(AS_SRC)

C_SRC :=
CPP_SRC :=
AS_SRC :=

include $(SRCDIR)/files.mk
MK_DIRS += $(OBJDIR)/$(SRCDIR)

clear_name = $(subst /,_,$(1))

define rename_var
$(2)_$(call clear_name,$(SRCDIR))_$(call clear_name,$(1)) := \
    $($(subst _,,$(2))_$(call clear_name,$(SRCDIR))) $($(call clear_name,$(1)))
$(call clear_name,$(1)) :=
endef

define proc_lang

ORIGIN_SRC_FILES := $($(1)_SRC)

ifneq ($(strip $($(1)_ONLY_FILES)),)
$(1)_SRC := $(filter $($(1)_ONLY_FILES),$($(1)_SRC))
else

ifneq ($(strip $(ONLY_FILES)),)
$(1)_SRC := $(filter $(ONLY_FILES),$($(1)_SRC))
else
$(1)_SRC := $(filter-out $(EXCLUDE_FILES),$($(1)_SRC))
endif

endif

$(1)_ONLY_FILES :=
$(foreach name,$($(1)_SRC),$(eval $(call rename_var,$(name),$(1)_FLAGS)))
$(foreach name,$(ORIGIN_SRC_FILES),$(eval $(call clear_name,$(name)) :=))

endef

$(foreach lang,C CPP AS, $(eval $(call proc_lang,$(lang))))

EXCLUDE_FILES :=
ONLY_FILES :=

SAVE_C_SRC += $(C_SRC:%=$(SRCDIR)/%)
SAVE_CPP_SRC += $(CPP_SRC:%=$(SRCDIR)/%)
SAVE_AS_SRC += $(AS_SRC:%=$(SRCDIR)/%)

C_SRC := $(SAVE_C_SRC)
CPP_SRC := $(SAVE_CPP_SRC)
AS_SRC := $(SAVE_AS_SRC) 
```

./files.mk

```
C_SRC   := main.c
CPP_SRC :=
AS_SRC  := timer.S

main.c += -DDEBUG 
```

./crc/files.mk

```
C_SRC    := byte-modbus-crc.c byte-crc8.c
AS_SRC   := modbus-crc.S crc8.S modbus-crc-table.S crc8-table.S

byte-modbus-crc.c += --std=gnu99
byte-crc8.c       += --std=gnu99 
```

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2014-01-25T19:23:07.007

这是我的解决方案，灵感来自 Beta 的回答。它比其他建议的解决方案更简单

我有一个包含多个 C 文件的项目，存储在许多子目录中。例如：

```
src/lib.c
src/aa/a1.c
src/aa/a2.c
src/bb/b1.c
src/cc/c1.c 
```

这是我的 Makefile（在`src/`目录中）：

```
# make       -> compile the shared library "libfoo.so"
# make clean -> remove the library file and all object files (.o)
# make all   -> clean and compile
SONAME  = libfoo.so
SRC     = lib.c   \
          aa/a1.c \
          aa/a2.c \
          bb/b1.c \
          cc/c1.c
# compilation options
CFLAGS  = -O2 -g -W -Wall -Wno-unused-parameter -Wbad-function-cast -fPIC
# linking options
LDFLAGS = -shared -Wl,-soname,$(SONAME)

# how to compile individual object files
OBJS    = $(SRC:.c=.o)
.c.o:
    $(CC) $(CFLAGS) -c $< -o $@

.PHONY: all clean

# library compilation
$(SONAME): $(OBJS) $(SRC)
    $(CC) $(OBJS) $(LDFLAGS) -o $(SONAME)

# cleaning rule
clean:
    rm -f $(OBJS) $(SONAME) *~

# additional rule
all: clean lib 
```

这个例子适用于共享库，它应该很容易适应任何编译过程。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2009-09-16T00:43:39.643

这将在没有痛苦的操作或多个命令序列的情况下完成：

```
构建/%.o: src/%.cpp
src/%.o: src/%.cpp
%.o:
    $(CC) -c $< -o $@

build/test.exe: build/widgets/apple.o build/widgets/knob.o build/tests/blend.o src/ui/flash.o
    $(LD) $^ -o $@

```

JasperE 解释了为什么 "%.o: %.cpp" 不起作用；这个版本有一个模式规则 (%.o:) 有命令但没有 prereqs，两个模式规则 (build/%.o: 和 src/%.o:) 有 prereqs 但没有命令。（请注意，我在 src/%.o 规则中添加了处理 src/ui/flash.o，假设这不是 build/ui/flash.o 的拼写错误，所以如果你不需要它，你可以把它放在外面。）

build/test.exe 需要 build/widgets/apple.o，
build/widgets/apple.o 看起来像 build/%.o，所以它需要 src/%.cpp（在这种情况下是 src/widgets/apple.cpp），
build/widgets/apple.o 也看起来像 %.o，所以它执行 CC 命令并使用它刚刚找到的 prereq（即 src/widgets/apple.cpp）来构建目标（build/widgets/apple.o）

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-23T20:02:19.470

通常，您在每个子目录中创建一个 Makefile，并写入顶级 Makefile 以在子目录中调用 make。

此页面可能会有所帮助：[http ://www.gnu.org/software/make/](http://www.gnu.org/software/make/)

# algorithm - 您将如何编写非递归算法来计算阶乘？

> ID：231250
> 
> 赞同：18
> 
> 时间：2008-10-23T20:01:25.900
> 
> 标签：algorithm, recursion, factorial

你将如何编写一个非递归算法来计算`n!`？

* * *

## 回答 #1

> 赞同：31
> 
> 时间：2008-10-23T20:20:21.493

因为 Int32 会在大于 12 的任何东西上溢出！无论如何，只需执行以下操作：

```
public int factorial(int n) {
  int[] fact = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 
                362880, 3628800, 39916800, 479001600};
  return fact[n];
} 
```

* * *

## 回答 #2

> 赞同：19
> 
> 时间：2008-10-23T20:04:47.420

在伪代码中

```
ans = 1
for i = n down to 2
  ans = ans * i
next 
```

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-10-23T20:02:57.207

```
public double factorial(int n) {
    double result = 1;
    for(double i = 2; i<=n; ++i) {
        result *= i;
    }
    return result;
} 
```

* * *

## 回答 #4

> 赞同：6
> 
> 时间：2008-10-24T00:15:55.993

为了科学的利益，我对计算阶乘的各种算法实现进行了一些分析。我在 C# 和 C++ 中创建了每个迭代、查找表和递归实现。我将最大输入值限制为 12 或更少，因为 13！大于 2^32（能够保存在 32 位 int 中的最大值）。然后，我运行每个函数 1000 万次，循环遍历可能的输入值（即，将 i 从 0 增加到 1000 万，使用 i 模 13 作为输入参数）。

以下是标准化为迭代 C++ 图的不同实现的相对运行时间：

```
 C++    C#
---------------------
Iterative   1.0   1.6
Lookup      .28   1.1
Recursive   2.4   2.6 
```

而且，为了完整起见，以下是使用 64 位整数并允许输入值最大为 20 的实现的相对运行时间：

```
 C++    C#
---------------------
Iterative   1.0   2.9
Lookup      .16   .53
Recursive   1.9   3.9 
```

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2008-10-23T20:02:43.103

将递归解决方案重写为循环。

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2008-10-23T20:11:01.807

除非你有像 Python 那样的任意长度的整数，否则我会将 factorial() 的预计算值存储在一个大约 20 个 long 的数组中，并使用参数 n 作为索引。n 的增长率！相当高，计算20！或 21！无论如何，即使在 64 位机器上，你也会得到溢出。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-10-23T21:17:00.397

这是预先计算的函数，但实际上是正确的。如前所述，13！溢出，因此计算这么小的值范围没有意义。64 位更大，但我希望范围仍然相当合理。

```
int factorial(int i) {
    static int factorials[] = {1, 1, 2, 6, 24, 120, 720, 
            5040, 40320, 362880, 3628800, 39916800, 479001600};
    if (i<0 || i>12) {
        fprintf(stderr, "Factorial input out of range\n");
        exit(EXIT_FAILURE); // You could also return an error code here
    }
    return factorials[i];
} 
```

资料来源：[http ://ctips.pbwiki.com/Factorial](http://ctips.pbwiki.com/Factorial)

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2009-01-26T22:57:27.673

我喜欢 pythonic 解决方案：

```
def fact(n): return (reduce(lambda x, y: x * y, xrange(1, n+1))) 
```

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-10-23T20:03:55.457

```
long fact(int n) {
    long x = 1;
    for(int i = 1; i <= n; i++) {
        x *= i;
    }
    return x;
} 
```

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-10-23T20:04:46.343

```
int total = 1
loop while n > 1
    total = total * n
    n--
end while 
```

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-10-23T20:04:39.857

```
fac = 1 ; 
for( i = 1 ; i <= n ; i++){
   fac = fac * i ;
} 
```

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2008-10-23T20:05:34.330

```
public int factorialNonRecurse(int n) {
    int product = 1;

    for (int i = 2; i <= n; i++) {
        product *= i;
    }

    return product;
} 
```

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2009-01-26T14:48:07.583

在运行时，这是非递归的。在编译时它是递归的。运行时性能应该是 O(1)。

```
//Note: many compilers have an upper limit on the number of recursive templates allowed.

template <int N>
struct Factorial 
{
    enum { value = N * Factorial<N - 1>::value };
};

template <>
struct Factorial<0> 
{
    enum { value = 1 };
};

// Factorial<4>::value == 24
// Factorial<0>::value == 1
void foo()
{
    int x = Factorial<4>::value; // == 24
    int y = Factorial<0>::value; // == 1
} 
```

* * *

## 回答 #14

> 赞同：1
> 
> 时间：2019-07-09T04:53:42.017

对于非递归方法，没有比这更简单的了

```
int fac(int num) {
    int f = 1;
    for (int i = num; i > 0; i--)
        f *= i;
    return f;
} 
```

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-10-25T19:48:08.680

我会使用记忆。这样，您可以将方法编写为递归调用，并且仍然可以获得线性实现的大部分好处。

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2008-11-18T05:12:25.010

```
long fact(int n)
{
    long fact=1;
    while(n>1)
      fact*=n--;
    return fact;
}

long fact(int n)
{
   for(long fact=1;n>1;n--)
      fact*=n;
   return fact;
} 
```

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2008-10-23T20:04:23.617

伪代码

```
total = 1
For i = 1 To n
    total *= i
Next 
```

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2008-10-23T20:49:39.513

假设您希望能够处理一些非常大的数字，我将其编码如下。如果您希望在常见情况下（小数字）获得相当大的速度，但又希望能够处理一些超大量的计算，则此实现将适用。我认为这是理论上最完整的答案。在实践中，我怀疑除了家庭作业问题之外，您是否需要计算如此大的阶乘

```
#define int MAX_PRECALCFACTORIAL = 13;

public double factorial(int n) {
  ASSERT(n>0);
  int[MAX_PRECALCFACTORIAL] fact = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 
                362880, 3628800, 39916800, 479001600};
  if(n < MAX_PRECALCFACTORIAL)
    return (double)fact[n];

  //else we are at least n big
  double total = (float)fact[MAX_PRECALCFACTORIAL-1]
  for(int i = MAX_PRECALCFACTORIAL; i <= n; i++)
  {
    total *= (double)i;  //cost of incrimenting a double often equal or more than casting
  }
  return total;

} 
```

* * *

## 回答 #19

> 赞同：0
> 
> 时间：2012-08-09T16:18:34.493

迭代：

```
int answer = 1;
for (int i = 1; i <= n; i++){
    answer *= i;
} 
```

或者...在 Haskell 中使用尾递归：

```
factorial x =
    tailFact x 1
    where tailFact 0 a = a
        tailFact n a = tailFact (n - 1) (n * a) 
```

在这种情况下，尾递归的作用是使用累加器来避免堆栈调用堆积。

参考：[Haskell 中的尾递归](http://jxs.me/2010/06/28/tail-recursion-haskell/)

* * *

## 回答 #20

> 赞同：0
> 
> 时间：2016-03-02T10:37:08.520

Java中的非递归阶乘。此解决方案使用自定义迭代器（以演示迭代器的使用:)）。

```
/** 
 * Non recursive factorial. Iterator version,
 */
package factiterator;

import java.math.BigInteger;
import java.util.Iterator;

public class FactIterator
{   
    public static void main(String[] args)
    {
        Iterable<BigInteger> fact = new Iterable<BigInteger>()
        {
            @Override
            public Iterator<BigInteger> iterator()
            {
                return new Iterator<BigInteger>()
                {
                    BigInteger     i = BigInteger.ONE;
                    BigInteger total = BigInteger.ONE;

                    @Override
                    public boolean hasNext()
                    {
                        return true;
                    }

                    @Override
                    public BigInteger next()
                    {                        
                        total = total.multiply(i);
                        i = i.add(BigInteger.ONE);
                        return total;
                    }

                    @Override
                    public void remove()
                    {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
        int i = 1;
        for (BigInteger f : fact)
        {
            System.out.format("%d! is %s%n", i++, f);
        }
    }
} 
```

* * *

## 回答 #21

> 赞同：-1
> 
> 时间：2008-10-23T20:03:57.783

```
int fact(int n){
    int r = 1;
    for(int i = 1; i <= n; i++) r *= i;
    return r;
} 
```

* * *

## 回答 #22

> 赞同：-2
> 
> 时间：2012-10-23T16:16:15.767

递归地使用带有缓存的 JavaScript。

```
var fc = []
function factorial( n ) {
   return fc[ n ] || ( ( n - 1 && n != 0 ) && 
          ( fc[ n ] = n * factorial( n - 1 ) ) ) || 1;
} 
```

# compiler-construction - 非机器字原语的倍数是个好主意吗？

> ID：231257
> 
> 赞同：1
> 
> 时间：2008-10-23T20:03:17.580
> 
> 标签：compiler-construction, embedded

假设您有一种动态语言（类似于常见的脚本语言）并想为它编写一个编译器。为类型标签之类的东西保留一些机器字是个好主意吗？特别是对于微控制器和类似设备，这是一个好主意吗？

我可以想到一些优点，例如减少类型信息的存储，更容易的内存管理（甚至可能是 gc）和更容易调试。但是这些是否可以证明普通算术运算或其他需要完整单词的运算的开销是合理的？请注意，字节码虚拟机在这方面会更糟，因为性能开销要大得多。所以不建议这样做；）

无论如何，有些人不会为微控制器级硬件编写数字密集型代码，但仍然......

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-23T20:24:59.067

必须确保您的类型位不会通过任何计算所增加的复杂性可能远远超过任何存储节省。您始终可以分配与包含任何所需元数据/标志的任何原始字段相邻的类型字段。然后你知道任何值的存储大小总是 n+1 个字，假设你可以用一个字来存储你想要的类型和状态信息。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T21:01:37.680

[SPARC](http://en.wikibooks.org/wiki/SPARC_Assembly/Arithmetic_Instructions)芯片直接在硬件中标记了算术工具 - 专门为此类应用程序设计。我还看到了对具有此功能的其他架构的引用。它们在实践中的广泛使用是另一个问题 - 大多数动态语言（如 Python）都是为可移植性而构建的，因此在您的架构中并没有真正选择依赖它的选项。

我认为旧的 smalltalks 过去常常用小整数来做到这一点 - 直到某个值是一个 int 并且超过阈值是一个对象指针。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T20:49:37.347

这可能取决于您的微控制器的“微型”程度。

例如，我猜测（从未尝试过）ARM 内核上的桶形移位器和/或您可以在加载/存储时拥有的免费掩码将使处理这些标志的成本保持相当合理。显然，这是一流的，但如今 ARM 确实无处不在。

LISP 使用类型标志，这意味着 fixnum 小于一个单词。因此，您可以查看 LISP 实现（如果您可以为您关心的处理器找到它们），看看它们如何最大限度地降低成本，以及它们是否会尽最大努力满足您的要求。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T20:27:41.133

不，这对于通用编译器来说绝不是一个好主意。在算术运算中处理“类型标签”位的开销将是严重的。

就其本质而言，动态类型语言需要额外的空间来存储每个值的类型信息。如果您必须存储大量同质类型的数据，正确的方法通常是使用设计用于在 C 中执行此操作的本机代码模块！

例如，当你想存储一个由 5 个整数组成的数组时，一个 Python`list`就可以了（它可以存储任意复杂的混合类型）。但是，如果你想存储一个包含 500 万个整数的数组，你应该使用将`array`它们存储为同构 C 数组的模块，或者使用 NumPy 来执行类似的操作，但针对对它们进行大量数学运算进行了优化。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-23T23:03:14.020

一方面，如果您希望编译后的代码直接测试每个操作的标志，它会很慢，原因与解释的字节码很慢一样。也许不像字节码那么慢，但阿姆达尔定律会对你不利。

另一方面，完全动态语言的简单编译器无论如何都需要进行某种形式的类型检查。动态调度的普遍使用将对现代处理器造成严重的性能损失（尽管对于微控制器来说可能没有那么严重？）

如果您的编译器可以优化上述大部分运行时类型检查，则可以恢复性能。然而，实现这一点可能既不简单也不简单。我的猜测是，在这种情况下，您希望避免使用位标志，因为所需的屏蔽只是不必要的工作。

# c# - 从远程计算机中删除文件

> ID：231259
> 
> 赞同：2
> 
> 时间：2008-10-23T20:03:38.657
> 
> 标签：c#, windows, file-io, permissions

我正在尝试从远程计算机中删除包含 XML 文件的目录。我的代码编译并运行良好，但是当我在我指定的路径中获取 XML 文件列表时，它没有返回任何内容。我错过了什么许可吗？

我已经从以我自己身份登录的计算机和以其他用户身份登录的另一台计算机运行它。两个帐户都可以完全控制包含 XML 文件的目录。

我正在使用.NET 2.0。

```
 static void Main(string[] args) {
        string directory, ext = ".xml"; // have tried xml and .xml

        if (args.Length != 1) {
             // do absolutely nothing if we do not exactly 1 argument
        } else {
            Console.WriteLine("Argument accepted.");
            directory = args[0];

            // make sure the directory passed is valid
            if (ValidateDirectory(directory)) {
                Console.WriteLine("Directory is valid.");
                DeleteFiles(directory, ext);
            }
        }
        Console.WriteLine("Done.");
    }

    static bool ValidateDirectory(string d) {
        return Regex.IsMatch(d, @""); // I removed my regex - it validates properly
    }

    static void DeleteFiles(string d, string ext) {
        DirectoryInfo di;
        FileInfo[] fi;

        di = new DirectoryInfo(d);
        fi = di.GetFiles(ext);

        Console.WriteLine("Number of files = " + fi.Length + ".");
        foreach (FileInfo f in fi) {
            try {
                Console.WriteLine(f.FullName);
                f.Delete();
            } catch (Exception ex) {
                // do nothing when there is an exception
                // just do not want it to quit
                Console.WriteLine(ex.ToString());
            }
        }
    } 
```

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-23T20:10:30.017

我认为您应该使用 *.xml 而不是简单的 .xml。但我也同意 Kyralessa，首先在您的本地机器上进行测试，然后增加通过网络的复杂性。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T20:10:49.547

在 DeleteFiles 中，您有以下行：

fi = di.GetFiles(ext);

其中 ext 是您传入的扩展名，我相信它只是“.xml”。获取文件正在寻找任何名为“.xml”的文件。GetFiles 需要通配符，我相信这是您打算做的。在前面放一个星号 (*) 并尝试一下。

-布雷特

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T20:18:24.400

**跟进：**

我需要使用 *.xml （应该知道！）现在它可以工作了。

这个网站很棒！

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T20:09:46.570

我假设您正在传递网络路径？当您在本地路径上运行程序时它会失败吗？此行是否：fi = di.GetFiles(ext); 返回任何 fileInfo 对象？

您可能只是有一些小错误，可以通过一些调试来修复。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-23T20:15:30.207

你传递什么作为论点？您使用的是映射驱动器还是直接引用（即//服务器/文件夹）？

而不是您的 ValidateDirectory，您应该使用 Directory.Exists(directory) 只是为了查看它是否可以看到该目录。

# deployment - 自动部署资源

> ID：231283
> 
> 赞同：7
> 
> 时间：2008-10-23T20:07:23.720
> 
> 标签：deployment, continuous-integration, build-automation, automated-deploy

我知道我们需要通过单个用户操作来部署我们的应用程序。但是，我**不**知道：

1.  在 .NET 商店中使用哪些好工具？
2.  您如何管理每个环境的配置更改？

有人可以为我指出一些用于持续集成的好资源。我希望看到一些理论以及一步一步的实践指南。

**编辑：**
我现在需要自动化网络部署；但是，我还想了解如何为桌面应用程序执行此操作。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2009-07-13T19:23:10.503

我写了一篇可能有帮助的博文：

[Visual Studio Web 部署项目](http://murrayon.net/2008/02/visual-studio-web-deployment-projects.html)

它已有一年半的历史，但谈到了一些新的（当时）VS 项目模板以及来自 IIS 团队的名为 MSDeploy 的命令行实用程序。它们听起来很有希望，而且看起来它们非常适合针对多个构建配置、跨场同步多个服务器以及对网站部署的实际输出进行更多控制。

也许到现在为止，这些技术也已经成熟了。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T20:15:35.497

我们在[Windows Installer XML](http://sourceforge.net/projects/wix/)方面取得了巨大成功。基本上，您在 XML 中定义构成应用程序的组件，然后 WiX 将其转换为 MSI 包。文档相对稀疏，但提供的 CHM 文件与 search fu 相结合将使您有很长的路要走。

MSI 包可以获取配置值的输入参数，并在部署应用程序后执行操作以操作配置文件。例如，“msiexec /i MyCustomPackage.msi SqlServer=SomeSQLBox”可以部署 Web 应用程序并修改从属 SQL 框的配置条目。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T20:14:43.890

[Kinook 的Visual Build Pro](http://www.kinook.com/VisBuildPro/)是一个非常好的一键部署工具。它易于使用并且具有很多功能。我已经使用它多年了。当然还有 NAnt，我用的不多。

至于管理配置更改，我管理多个带有指示部署环境的扩展名的配置文件，然后在我的构建脚本中执行一个简单的重命名作为一个步骤。

例如，如果我要部署到 Test，我可能有一个名为 Web.test.config 的配置文件，它会被构建脚本自动重命名为 Web.config。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2011-02-12T05:40:15.997

我写了一篇非常详细的博客文章，使用 TeamCity 和 Web 部署项目来自动化构建和部署，作为初学者在这里：

[http://www.diaryofaninja.com/blog/2010/05/09/automated-site-deployments-with-teamcity-deployment-projects-amp-svn](http://www.diaryofaninja.com/blog/2010/05/09/automated-site-deployments-with-teamcity-deployment-projects-amp-svn)

然后我添加到此以显示 FTP 添加

[http://www.diaryofaninja.com/blog/2010/09/21/continuous-integration-tip-1-ndash-ftp-deployment](http://www.diaryofaninja.com/blog/2010/09/21/continuous-integration-tip-1-ndash-ftp-deployment)

一个基本的流程非常简单：

*   使用我从我的 SVN 存储库下载的 teamcity 构建服务器
*   我构建站点并将其部署到构建服务器上的本地文件夹
*   我启动了一个支持脚本的命令行 FTP 客户端，称为
*   WinSCP 使用 MSBUILD 任务执行 (http://winscp.net/)
*   上传我的所有网站内容
*   有[插入饮料]的选择

然后，我确保我只部署我的 SVN 存储库的主干，并在合并之前开发和测试分支中的所有内容 - 这样只有经过测试的东西才会被部署。将自动化测试添加到您的构建周期中，您将获得天作之合。

一些很棒的免费工具是：

*   [Visual Studio Web 部署项目](http://www.microsoft.com/downloads/en/details.aspx?FamilyID=89F2C4F5-5D3A-49B6-BCAD-F776C6EDFA63&amp%3Bdisplaylang=en)
*   [TeamCity（对 20 个以下的构建配置免费）](http://www.jetbrains.com/teamcity/)
*   [竹子](http://www.atlassian.com/software/bamboo/)

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-23T20:20:16.127

我看到两个不同的问题：

*   对于部署的事情：ClickOnce 部署应该这样做。您只需在 VS.net 中的 Build 菜单 > Publish 中发布您的桌面应用程序。VS.net 然后编译一个网页和一个 setup.exe。当使用 IE 或 Firefox 和 .net 3.5 SP1 的用户单击该链接时，它会立即运行。ClickOnce 还为您处理更新，并且有广泛的 API 可供开发。
*   持续集成是一个非常不同的事情。我建议您在谷歌上搜索“CruiseControl.net”并下载并尝试尽可能多的资源。它基本上是一个构建服务器，但您可以将它与 SVN、NUnit 连接以进行测试等。我不建议为这种不稳定的产品买书。最好下载并尝试一下。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-23T20:29:57.917

CruiseControl.NET 用于您的 ContinuousIntegration 解决方案。对于部署，我使用 MSBuild 项目文件。最重要的是，我保留了所有服务器配置文件。我通过参数将一个服务器属性传递给 MSBuild，该属性告诉 MSbuild 要使用哪些配置值，然后完成部署。唯一无法从 CruiseControl 直接完成的部署是部署到我们的实时服务器。我们保留该命令行 MSBuild 只是为了避免意外按下按钮，或者有权访问 CC.NET Web 仪表板的人只是在玩弄它。

# jython - 需要帮助使 Jython (dom4j) 脚本更优雅:)

> ID：231288
> 
> 赞同：0
> 
> 时间：2008-10-23T20:08:42.017
> 
> 标签：jython, refactoring, dom4j

我已经开始使用 Jython，因为它似乎是一种优秀的语言，并且到目前为止已经证明是这样。

我正在使用 dom4j 从磁盘上的一堆 HTML 文件的 DOM 中操作和检索数据。我编写了下面的脚本来检查使用 Xpath 的**H1**标签和抓取文本的 DOM，如果**H1**标签不存在于 DOM 中，它会搜索**标题**标签并从中获取文本。

我对 Jython 很陌生，但我确信有一种方法可以比下面的方法更优雅地执行所需的任务，如果我的想法是正确的，有没有人可以告诉我一个更好的方法来做到这一点？

```
elemHolder = dom.createXPath('//xhtml:h1')
elemHolder.setNamespaceURIs(map)
elem = elemHolder.selectSingleNode(dom)
if elem != None:
    h1 = elem.getText()
else:
    elemHolder = dom.createXPath('//xhtml:title')
    elemHolder.setNamespaceURIs(map)
    elem = elemHolder.selectSingleNode(dom)
    if elem != None:
        title = elem.getText()
    else:
        title = "Page does not contain a H1 or title tag" 
```

如果有人可以提供帮助，那就太好了。干杯

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-23T20:21:07.107

这个怎么样（顺便说一下，我并没有声称对 Python 了解很多，但这看起来像是一个明显的第一步）：

```
for path in ('//xhtml:h1', '//xhtml:title'):
    elemHolder = dom.createXPath(path)
    elemHolder.namespaceURIs = map
    elem = elemHolder.selectSingleNode(dom)
    if elem is not None:
        return (elem.localName, elem.text)

return (None, "Page does not contain h1 or title tag") 
```

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T20:35:27.483

看起来它会完美地工作，只有另一件事是。我会将值传递给数据库，并根据找到的内容将其放入相应的列中。

如果它是一个 H1 标签，它将把它放在 H1 列中，如果它是一个标题标签，它将被放在标题列中。

有没有办法确定也发现了什么标签？这有意义吗？

# iis - 有没有办法在没有通配符证书的情况下在同一台服务器上配置多个 SSL 站点？

> ID：231303
> 
> 赞同：4
> 
> 时间：2008-10-23T20:12:21.493
> 
> 标签：iis, ssl

根据本文，我使用 Servier 绑定在 iis 上设置了多个 ssl 站点：http: [//www.microsoft.com/technet/prodtechnol/WindowsServer2003/Library/IIS/8d9f2a8f-cd23-448c-b2c7-f4e87b9e2d2c.mspx？出厂=真](http://www.microsoft.com/technet/prodtechnol/WindowsServer2003/Library/IIS/8d9f2a8f-cd23-448c-b2c7-f4e87b9e2d2c.mspx?mfr=true)

我为安装的两个站点安装了两个不同的 ssl 证书，但是当我浏览到任一站点时，我得到了相同的证书。有没有办法在不购买通配符证书的情况下进行配置？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-24T00:11:56.050

如果浏览器和 Web 服务器都支持[服务器名称指示](http://en.wikipedia.org/wiki/Server_Name_Indication)扩展，则 Web 服务器可以使用它来选择正确的证书。否则，您将不得不使用两个单独的 IP 地址或通配符证书（正如已经提到的其他答案，HTTP 标头，包括告诉 Web 服务器正在请求哪个站点的 Host 标头，被封装在 SSL/TLS 连接中）。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-23T20:17:34.993

不使用不同的 IP 或端口，不。由于 HTTPS 连接的工作方式，加密连接发生在诸如主机标头之类的东西可以发送之前，因此服务器无法知道要连接到哪一个。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T20:15:11.050

将站点配置为在不同的 IP 地址或端口上运行。这样做的原因是因为 SSL 被包裹在 http 周围，并且主机标头在 HTTP 内部发送。例如，服务器不知道 SSL 层的请求是针对哪个站点的。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T20:15:10.600

每个站点都需要一个单独的 IP 地址。

# c++ - 战略与政策的对立和政策与战略的对立

> ID：231318
> 
> 赞同：15
> 
> 时间：2008-10-23T20:18:03.057
> 
> 标签：c++, design-patterns, strategy-pattern

当我第一次发现策略模式时，我对它为我和我的程序提供的看似无穷无尽的可能性感到惊讶。我可以更好地封装模型的行为，甚至可以即时交换这种行为。但该策略也可用于为包含对象提供特征和有效负载 - 在超类中声明的数据。生活很好。

```
class MyMonsterAI   { float const see_radius_; virtual void attack () = 0; /* .. */ };
class ElveAI        { ElveAI() : see_radius_(150.0f) {} /* ... */ };
class CycloneAI     { CycloneAI() : see_radius_(50.0f) {} /* ... */ };
class Monster       { MyMonsterAI* ai_; }; 
```

随之而来的是 Policy 模式，它可以让我在向包含类提供参数方面更加灵活 - 整个类，我喜欢的装备，尽管动态交换行为......这不太容易（除非策略的一部分是要有策略！）。

```
class MyMonsterTrait { typedef typename ElveAI AI; };

template< class MonsterTrait >
class Monster : public MonsterTrait::AI
{
    void idle (void) { attack(); }
}; 
```

这两种模式对我来说似乎都非常强大，我喜欢在不同的情况下同时使用这两种模式。但我不确定在某些情况下是否有特定/典型/更实用的应用程序。

**我想知道：您在哪里使用策略以及在哪里使用策略？哪里更适合？**

* * *

## 回答 #1

> 赞同：27
> 
> 时间：2008-10-23T20:34:43.600

策略主要是在编译时设置的，而策略是在运行时设置的。此外，策略通常是 C++ 概念，仅适用于少数其他语言（例如 D），而策略模式适用于许多（大多数？）面向对象语言，以及将函数视为一等公民的语言，如 python .

话虽如此：

*   在编译时确定的策略通常仅适用于您需要基于每个二进制文件的不同应用程序逻辑的特殊情况。例如，您可能会开发为每个客户稍微定制的软件，无论是通过 Web 界面还是手动，这将是一种基于策略的模式。

*   策略是在运行时确定的，实际上可以随时更改。例如，您可能拥有为销售人员实现与支持组不同的用户界面和逻辑的软件，但它们都必须处理相同的客户和许可信息，因此您只需拥有一个应用程序，而不是拥有两个单独维护的应用程序根据需要更改界面。

-亚当

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-23T20:24:15.900

我以为它们是[一样的](http://en.wikipedia.org/wiki/Strategy_pattern)。

# .net - 如何在 XAML 中引用当前对象

> ID：231321
> 
> 赞同：6
> 
> 时间：2008-10-23T20:18:29.640
> 
> 标签：.net, wpf, xaml

我无法弄清楚如何在 XAML 文件中引用由 XAML 文件定义的当前实例对象。

我有一个转换器，我想在当前实例中作为参数对象发送。

```
{Binding Path=<bindingObject>, Converter={x:Static namespace:Converter.Instance}, ConverterParameter=this} 
```

在此代码中，这被转换为字符串，而不是对当前实例对象的引用。

谢谢

约翰

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-23T20:56:59.813

根据[数据绑定概述](http://msdn.microsoft.com/en-us/library/ms752347.aspx#current_record_pointers)，您可以使用“/”表示当前项。然后，您可以根据需要使用以下类型语法在树中上下导航：

```
<Button Content="{Binding }" />
<Button Content="{Binding Path=/}" />
<Button Content="{Binding Path=/Description}" /> 
```

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-24T00:29:44.080

从技术上讲，ConverterParameter 不是 DependencyProperty，因此您无法绑定到它。做一个 ConverterParameter={Binding ElementName=this} 会很好，但你不能绑定到非依赖属性。

但是，有人想出如何在[这里](http://rauscheronline.de/item/2008/08/using-databinding-in-a-converterparameter)做到这一点。然而，这有点复杂。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T20:46:43.217

您是否尝试过使用[`RelativeSource`标记扩展](http://msdn.microsoft.com/en-us/library/ms743599.aspx)？你可以`Self`在那里使用。

# .net-3.5 - 将 XmlNode 转换为 XNode？

> ID：231323
> 
> 赞同：10
> 
> 时间：2008-10-23T20:18:57.673
> 
> 标签：.net-3.5, c#-3.0, linq-to-xml

任何人都知道如何将 System.Xml.XmlNode 转换为 System.Xml.Linq.XNode？

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2009-05-06T05:39:07.557

[Eric White 的博客](http://blogs.msdn.com/ericwhite/archive/2008/12/22/convert-xelement-to-xmlnode-and-convert-xmlnode-to-xelement.aspx)是进行酷 XML/XLINQ 转换等的地方。我知道这个问题早于发布，但我在查看其他 Q 时发现了它，所以也许人们仍然会遇到这个问题。他的博客有很多优化的 LINQ，就像我怀疑对原始响应的 .Parse() 调用不是最佳的，事实上我知道它不是。

Parse 将要求一次性加载 XML，Eric 使用扩展方法来处理与 XmlReader/Writer 的 XML 转换。这些方法能够对输入进行流式传输，因此如果您的 XML 具有任何实质性大小，则必须使用它们。

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2008-10-23T20:38:41.177

我从未尝试过，但我的第一个想法是：

```
XmlNode myNode;
XNode translatedNode = XDocument.Parse(myNode.OuterXml); 
```

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T20:26:14.663

我不认为有，但你为什么需要呢？每个都是 XML 结构的最低“叶子”，用于不同的文档读取方式。

如果您使用 Linq to Xml 和 XDocument，您将拥有所有 linq 样式的语法和新功能，但实际上所有这些都是关于选择节点的。

一旦有了要处理的元素，为什么需要切换？

# hibernate - 混合 RDF 和 ORM 方法

> ID：231325
> 
> 赞同：4
> 
> 时间：2008-10-23T20:19:42.337
> 
> 标签：hibernate, oop, database-design, rdf, system-integration

我正在一个团队研究一个新的系统集成项目的技术堆栈。我们偏爱的技术堆栈的一部分使用 Hibernate 来保持其内部状态并将挂钩暴露到 Hibernate 事务中，以便业务实体与该实用程序的状态保持同步。很好，除了我们需要维护有关未知类型实体的信息并将该数据链接到预定义类型。我们需要一个不需要预先定义模式的可扩展数据存储。最佳点是混合 RDF 数据和 Hibernate 托管实体。

您是否遇到过类似的要求，您可以推荐哪些方法？
任何 RDF/ORM 混合都需要支持不频繁的大规模查询以进行报告和数据探索，还需要支持频繁的集中读写操作以支持事务。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-23T20:29:16.123

我在我的项目中使用 RDF，我们所做的是使用[OWL](http://www.w3.org/2004/OWL/)为 RDF 数据定义一个本体并赋予它一些结构。从那里我们从 OWL 本体生成 C# 类。这样做的好处是您仍然可以添加有关主题的其他数据，但仍然具有在大多数情况下有意义的类结构。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2009-07-16T17:37:28.857

一种解决方案是将对象模型保持在 RDF 三元存储级别，例如通过为

*   节点：uris、空格和文字
*   语句：三个或更多节点的集合（三个用于 RDF 三元组，附加节点用于元）

在这样的存储上运行查询本质上是对语句进行三元组/n 元组模式匹配。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2009-07-17T08:18:42.483

您是否考虑过为已知数据定义休眠模型并使用 XML 添加 CLOB 来存储未知数据？通过这种方式，您主要保留正常的休眠代码，并且仅当您需要访问从 CLOB 字段加载 XML 并处理它的其他内容时。

[在此处](https://stackoverflow.com/questions/881355/extending-jpa-entity-data-at-runtime/1131917#1131917)查看具有类似解决方案的类似问题。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2010-01-19T11:56:31.697

在[Tripresso wiki 页面上](http://semanticweb.org/wiki/Tripresso)有一个 Object-RDF 映射器列表，可让您以面向对象的方式处理 RDF 数据。我怀疑它们中的任何一个都直接与 Hibernate 集成，但它们至少提供了类似的东西。

# php - 什么是回调函数以及如何在 OOP 中使用它

> ID：231327
> 
> 赞同：12
> 
> 时间：2008-10-23T20:19:49.340
> 
> 标签：php, oop, dom, callback, function-calls

我想使用[php 简单的 HTML DOM 解析器](http://simplehtmldom.sourceforge.net/manual_api.htm)从充满文章的页面上的每篇文章中获取图像、标题、日期和描述。在查看 API 时，我注意到它有一个 set_callback 设置回调函数。但是我不确定这是做什么的或我将如何使用它？在其中一个示例中，它用于调用删除一些内容的函数，我想知道您是否必须使用它来调用所有函数？

我想我想知道为什么我使用它，它有什么作用，因为我以前从未遇到过回调函数！

* * *

## 回答 #1

> 赞同：25
> 
> 时间：2008-10-23T20:22:49.070

这是一个基本的回调函数示例：

```
<?php

function thisFuncTakesACallback($callbackFunc)
{
    echo "I'm going to call $callbackFunc!<br />";
    $callbackFunc();
}

function thisFuncGetsCalled()
{
    echo "I'm a callback function!<br />";
}

thisFuncTakesACallback( 'thisFuncGetsCalled' );
?> 
```

您可以调用一个函数，该函数的名称存储在如下变量中： **$variable()**。

因此，在上面的示例中，我们将**thisFuncGetsCalled**函数的名称传递给**thisFuncTakesACallback()**，然后调用传入的函数。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-23T20:25:15.663

回调函数将对特定方法返回的任何数据使用该函数。

我不确定这个特定的库是如何工作的，但它可能很简单：

```
$html = file_get_html('http://example.com');
$html->set_callback('make_bold');
$html->find('#title'); // returns an array

function make_bold($results) {
// make the first result bold
  return '<b>'.$results[0].'</b>';
} 
```

即，函数“ `make_bold()`”将对找到的任何数据运行。同样，我不确定这个特定的库是如何工作的（即回调函数将被调用的方法）

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-23T22:53:34.803

回调要么是一个函数、一个对象实例的方法，要么是一个类的静态方法。无论哪种方式，它都是一种函数指针。在某些语言中，函数是一种特定类型。因此，您可以将函数分配给变量。这些通常被称为面向函数的语言。一个很好的例子是 Javascript。

在 PHP 中，回调可以是以下任何一种：

```
$fn = 'foo'; // => foo()
$fn = array($obj, 'foo'); // => $obj->foo()
$fn = array('Foo', 'bar'); // => Foo::bar() 
```

参见手册条目[`is_callable`](http://docs.php.net/is_callable)。

您可以使用相当冗长的函数调用回调[`call_user_func`](http://docs.php.net/manual/en/function.call-user-func.php)。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2017-08-14T14:59:05.457

**定义**

回调/可调用是一个简单的函数（它是匿名函数或命名函数），我们将其作为函数参数传递给另一个函数，结果返回传递的函数。

**例子**

```
function iWillReturnCallback($callBackHere){
    return $callBackHere;
}

function iAmCallBack(){
    echo "I am returned with the help of another function";
}

iWillReturnCallback(iAmCallBack());

//--Output -> I am returned with the help of another function 
```

**不要混淆**

php 中有一些默认函数接受回调函数的名称作为参数中的字符串，因为避免了常量名称和函数名称之间的冲突。所以不要对这些事情感到困惑。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2017-11-14T06:45:16.783

使用`PHP 5.3`，您现在可以执行以下操作：

```
function doIt($callback) { $callback(); }

doIt(function() {
    // this will be done
}); 
```

最后，一个很好的方法来做到这一点。一个很好的补充`PHP`，因为回调很棒。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2022-01-06T16:21:38.843

目的是调用我们想要的函数，例如：`secretCode()`但我们想使用另一个函数作为`helper`或`service`为我们调用它：

```
<?php

    // $call parameter can be anything
    function callBackServiceCenter($call)
    {
        echo "[callBackServiceCenter]: Hey, this is callBackServiceCenter function <br>We have received your command to call your requested function and we are now calling it for you! <br />";
        // Below is the part where it will call our secretCode()'s function
        $call();
        // And we can print other things after the secretCode()'s function has been executed:
        echo "[callBackServiceCenter]: Thank you for using our service at callBackServiceCenter. Have a nice day!<br />";
    }

    function secretCode()
    {
        echo "[secretCode]: Hey, this is secretCode function. Your secret code is 12345<br />";
    }

    callBackServiceCenter( 'secretCode' );
?> 
```

输出：

```
[callBackServiceCenter]: Hey, this is callBackServiceCenter function
We have received your command to call your requested function and we are now calling it for you!
[secretCode]: Hey, this is secretCode function. Your secret code is 12345
[callBackServiceCenter]: Thank you for using our service at callBackServiceCenter. Have a nice day! 
```

# ruby-on-rails - 我可以让 url_for 在 Ruby on Rails 中使用前缀选项吗？

> ID：231340
> 
> 赞同：0
> 
> 时间：2008-10-23T20:23:22.157
> 
> 标签：ruby-on-rails, ruby

在我正在进行的一个项目中，Apache 被设置为仅将 /prefix/* 的请求转发给 mongrel。如何告诉 ruby​​ on rails 生成所有带有该前缀的 URL？

我通过执行以下操作设置了转发到正确控制器操作的路由：

```
map.connect 'sfc/:controller/:action' 
```

但这似乎不会影响 url 编写器生成 URL 的方式。

有任何想法吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-23T20:39:21.330

环境变量应该可以解决问题，`RAILS_RELATIVE_URL_ROOT`尽管我自己没有尝试过。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-24T21:21:49.280

您可能有另一个路由（可能是 routes.rb 底部的默认路由之一），URL 生成优先于 sfc 前缀匹配使用。例如，如果您有

```
map.connect "sfc/:controller/:action"
map.connect ":controller/:action/:id" 
```

然后`url_for(:controller => 'x', :action => 'y', :id => 3)`会返回`"/x/y/3"`。如果您将其更改为

```
map.connect "sfc/:controller/:action"
map.connect "sfc/:controller/:action/:id" 
```

你应该得到`"/sfc/x/y/3"`.

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T22:15:30.840

使用 :path_prefix 选项怎么样：

```
map.connect ':controller/:action', :path_prefix => 'sfc' 
```

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2009-04-30T16:42:42.597

Mongrel 接受一个 --prefix 选项，然后将其添加到所有生成的 URL 之前。这是我所知道的能够在一台服务器上运行同一应用程序的多个实例的唯一方法。

# asp.net - 如何使 reCAPTCHA 与 ASP.Net 中的 ValidationGroup 一起工作（验证码）

> ID：231344
> 
> 赞同：10
> 
> 时间：2008-10-23T20:24:54.307
> 
> 标签：asp.net, captcha, recaptcha

我正在使用[reCAPTCHA](http://recaptcha.net)提供的 ASP.Net 插件和控件。如果 web 表单上的提交按钮不在验证组中，我可以成功地使控件工作。reCAPTCHA 控件没有验证组属性。

当 Web 表单上有验证组时，是否有人通过此方法或任何解决方案使 reCAPTCHA 控件正常工作？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2012-09-05T14:06:44.703

以为我会用一些工作代码来扩展其他一些人的评论......

```
<recaptcha:RecaptchaControl ID="RecaptchaControl" runat="server" />

<asp:CustomValidator ID="RecaptchaValidator" runat="server" OnServerValidate="RecaptchaValidator_ServerValidate" ErrorMessage="Recaptcha input invalid." ValidationGroup="SomeValidationGroup" /> 
```

还有后面的代码...

```
protected void RecaptchaValidator_ServerValidate(object sender, ServerValidateEventArgs e)
{
    this.RecaptchaControl.Validate();
    e.IsValid = this.RecaptchaControl.IsValid;
} 
```

谁能想到更简单的方法？感谢 Vidalik 关于使用 OnServerValidate 的想法。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2009-03-18T03:36:27.487

您可以添加 CustomValidator，实现将验证 ReCAPTCHA 数据的 OnServerValidate。CustomValidator 可以分配给任何 ValidatorGroup。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-12-09T11:26:43.763

reCAPTCHA ASP.NET 插件被编写为向后兼容 ASP.NET 1.1，这意味着`ValidationGroup`不支持该概念（这是 ASP.NET 2.0 中的新概念）。但该插件自带可[下载源代码](http://code.google.com/p/recaptcha/downloads/list?q=label:aspnetlib-Latest)，您可以自行修改支持`ValidationGroup`。

在 ASP.NET 2.0 中，[验证器应该继承自`BaseValidator`](http://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.basevalidator_methods.aspx)并实现`IValidator`，这意味着您应该将 RecaptchaControl 类型更改为继承自`BaseValidator`而不是`WebControl`. 然后，您将不得不稍微修改代码以实现在`BaseValidator`. 然后你可以在你的页面上使用这个新控件，它现在支持`ValidationGroup`.

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2010-12-07T18:32:55.440

这对我有用...

1.  添加具有正确验证组的自定义验证器。

2.  它的 ServerValidate 方法调用..

    ```
    recaptcha.Validate(); 
    ```

3.  然后在您的主要处理之前检查如下...

    if (Page.IsValid && recaptcha.IsValid) { respose.write("valid"); }

HTH。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2013-01-28T18:24:08.007

[RemotecUk](https://stackoverflow.com/users/169640/remotecuk)的建议在没有添加自定义验证器的情况下对我有用。

```
protected void button_onclick(object sender, EventArgs e){
    recaptcha.Validate();
    if(!Page.IsValid && recaptcha.IsValid){
        lblError.Text = "Please check your captcha entry";
    } else {
        //do your thing
    }
} 
```

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2013-04-05T06:19:42.870

为了在不更改 reCaptcha 源代码的情况下进行客户端所需的验证，我在表单中添加了一个 CustomValidator 并创建了一个 JavaScript 函数来验证输入文本字段。

```
<asp:CustomValidator ID="reqRecaptcha" runat="server" ClientValidationFunction="validateRecaptcha" Text="Required"></asp:CustomValidator> 
```

为了找出`ID`生成的输入字段，我查看了页面的源代码，发现输入字段总是`recaptcha_response_field`. （如果我错了，请纠正我）知道了这一点，我能够创建 JavaScript（使用 JQuery 和自定义函数来检查控件的有效性）。

```
 function validateRecaptcha(sender, args) {
        args.IsValid = isFieldValid("input[id$='recaptcha_response_field']");
    } 
```

注意：如果开发人员更改了 reCaptcha 控件的输出，您可能不知道导致验证器占用工作的更改。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2011-01-11T21:49:27.617

请参阅作为 Altairis Web UI 工具包一部分的 ReCaptchaImage 和 ReCaptchaValidator 控件：http: [//altairiswebui.codeplex.com/](http://altairiswebui.codeplex.com/)

它是一组开源的 Web 组件，包含相当不错且符合 ASP.NET 标准的（如果我可以说它是作者 :-) 用于 Web 窗体的 ReCaptcha 实现。

# c# - 为什么这段代码不起作用？

> ID：231355
> 
> 赞同：0
> 
> 时间：2008-10-23T20:26:45.847
> 
> 标签：c#, .net, arrays, arraylist

大家好，我写了这段代码，我有两个错误。

1.  无效的排名说明符：预期为 ',' 或 ']'
2.  无法将带有 [] 的索引应用于“int”类型的表达式

你能帮忙吗？

```
 static void Main(string[] args)
    {
        ArrayList numbers = new ArrayList();

        foreach (int number in new int[12] {10,9,8,7,6,5,4,3,2,1}) //error No.1
        {
            numbers.Add(number);
        }

        numbers.Insert(numbers.Count - 1, 75);
        numbers.Remove(7);
        numbers.RemoveAt(6);

        for(int i=0; i<numbers.Count; i++)
        {
            int number = (int) number[i]; // error No.2
            Console.WriteLine(number);
        }
    } 
```

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-23T20:28:31.977

1 - 您不必指定数组的长度，只需说 new int[]

2 - number 只是一个整数，我认为您正在尝试访问 numbers[i]

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-23T20:31:41.097

对于 1：

```
foreach (int number in new int[] {10,9,8,7,6,5,4,3,2,1}) 
```

对于 2：

```
int number = (int)numbers[i]; 
```

你正在使用`number`你应该拥有的地方`numbers`（复数）。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-23T20:36:43.970

```
using System;
using System.Collections;

namespace ConsoleApplication3
{
    class Program
    {
        static void Main(string[] args)
        {
            ArrayList numbers = new ArrayList();
            foreach (int number in new int[] { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 })
            {
                numbers.Add(number);
            }
            numbers.Insert(numbers.Count - 1, 75);
            numbers.Remove(7);
            numbers.RemoveAt(6);
            for (int i = 0; i < numbers.Count; i++)
            {
                int number = (int)numbers[i];
                Console.WriteLine(number);
            }
        }
    }
} 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T20:32:27.600

您应该将数组初始化为

```
new int[] { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 }; 
```

编译器将为您设置大小。但你正在艰难地做这件事。试试这个：

```
for (int i = 10; i > 0; i-- )
{
    numbers.Add(i);
} 
```

如果您使用的是 .Net 3.5，您还可以使用 System.Linq.Enumerable 创建一个范围：

```
IEnumerable<int> numbers = Enumerable.Range(1, 10).Reverse(); 
```

这将取代 ArrayList，这在 3.5 中毫无意义。由于您刚刚开始，ArrayList 一开始可能更容易掌握，但请记住泛型和 IEnumerables 之类的东西，它们非常重要。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-23T20:38:02.190

为什么不是#1的以下内容？

```
 for (int x = 10; x > 0; --x)
    {
        numbers.Add(number);
    } 
```

尽管将其声明为 int[12] （作为明显的意图？），但似乎我们只使用从 10 到 1 的值，包括 10 到 1。为什么`foreach`在这种情况下使用 a，而 a`for`的意图要清楚得多？

# php - SOAP 消息的最大大小是如何确定的？

> ID：231358
> 
> 赞同：3
> 
> 时间：2008-10-23T20:27:18.297
> 
> 标签：php, soap, wsdl, nusoap

我在 PHP 5.2.6 上使用 NuSOAP，我看到最大消息大小只有 1000 字节（这使得做任何有意义的事情变得困难）。这是在端点的 WSDL 中设置的，还是我可以在 NuSOAP 中配置的？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2010-10-13T17:45:54.217

关于关于“1000 字节限制”的 FUD……我查阅了 nusoap_client 源代码，发现该限制仅对**调试输出**有效。

这意味着所有数据都被处理并传递给 Web 服务（无论其大小），但调试日志中仅显示前 1000 个字节（或更准确地说：字符）。

这是代码：

```
$this->debug('SOAP message length=' . strlen($soapmsg) . ' contents (max 1000 bytes)=' . substr($soapmsg, 0, 1000));

// send
$return = $this->send($this->getHTTPBody($soapmsg),$soapAction,$this->timeout,$this->response_timeout); 
```

可以清楚地看到，`getHTTPBody()`调用使用了整个`$soapmsg`，并且只有调试输出限制为前 1000 个字符。如果您想更改此设置，只需更改`substr()`调用以满足您的需要，或者只需将其替换为`$soapmsg`（因此所有内容也都显示在调试输出中）。

这应该与实际发送的数据的任何实际限制完全无关。当然可能还有其他因素实际上限制了您可以发送的内容的大小（例如，为您的 PHP 脚本设置的 RAM 限制、您的 HTTP 实现的限制或可用的虚拟内存不足），但理所当然地没有对于可以使用 NuSOAP 发送的数据，诸如“1000 字节限制”之类的东西。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-24T03:57:57.170

我对 PHP 只是略知一二，从来没有使用过 NuSOAP 包。但是，SOAP 消息的大小应该只受传输介质的限制。在 HTTP 的情况下，它应该几乎是无限的（表单 POST 请求中 16384 字节的限制不是由于 SOAP，而是来自浏览器的限制（实际上可能不再存在，但我不确定） ）。

我建议为 NuSOAP 的作者/维护者找到一个联系地址并直接询问他们。除非 WSDL 中有某些内容（而且我不记得 WSDL 规范中的任何内容会限制整个消息体大小......单个参数（通过 XML Schema 方面），而不是整个主体），那么限制似乎在工具包中。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-24T09:01:51.033

在生产机器上，我们使用 PHP 5.2.5 内置的 Soap 函数作为服务器，在 PHP 4 上使用 NuSoap，并成功传输了大于 1 MB 的消息。

我认为这两种产品都没有限制，但您应该检查 php.ini 中的设置

```
max_input_time        (defaults to 60) 
```

这是允许每个脚本解析输入的时间。如果在解析完成之前时间到了，脚本甚至不会运行。

旁注：如果可能，我建议迁移到 SoapClient/SoapServer PHP 扩展类。NuSoap 已经证明自己在重负载情况下不是很可靠，尤其是在缓存方面。有时我们看到 NuSoap 只是简单地“忘记”了 wsdl 定义并在非 wsdl 模式下工作。奇怪的...

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-11-03T00:46:41.330

您还没有说您是在发送还是接收 SOAP 消息。如果您要发送，我会检查 NuSOAP 是通过 POST 而不是 GET 发送的（您可能必须深入研究代码才能看到；我发现文档很少）。如果您正在接收，请检查您的 PHP.INI 设置，了解内存和数据大小等内容。实际上，无论如何，请检查您的内存限制——NuSOAP 是一个相当大的内存消耗者，IIRC。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2013-03-28T08:19:13.707

我认为消息大小将受到 PHP 内存限制而不是某些硬编码值的限制。至少我可以毫无问题地发送一个 6.5MB 的字符串。当我尝试发送一个 8MB 的字符串时，我在 nusoap.php 中遇到了内存不足的异常（我的服务器对 PHP 有 64MB 的限制）。

# windows - “gem install”冻结在“正在更新 [..] 的 Gem 源索引”

> ID：231362
> 
> 赞同：1
> 
> 时间：2008-10-23T20:27:50.230
> 
> 标签：windows, ruby, rubygems

几个星期以来，我根本无法在 Windows 中运行 gem install 。它坚持这一行：

```
C:\Windows\System32>gem install rails --version 2.1.2
Bulk updating Gem source index for: http://gems.rubyforge.org/ 
```

有什么想法吗？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-24T08:03:24.210

我在 gem 版本 < 1.2 时遇到了同样的问题。升级到 1.2 修复了它。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T21:30:43.270

它在我的 Windows Server 2003 机器上运行良好。我正在使用 gem 版本 1.3.0。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T21:49:05.963

你以前能安装东西吗？

gem 索引相当大，看起来大约 26MB - 你有什么样的连接？如果您有拨号（或 512kbit“宽带”等），更新*将*需要相当长的时间。

您可以获取 rails gem 文件并使用`gem install rails.gem`- [http://rubyforge.org/frs/?group_id=307安装它](http://rubyforge.org/frs/?group_id=307)

或者，您可以使用其中一个 prepackage-rails 安装程序，例如[InstantRails](http://instantrails.rubyforge.org/wiki/wiki.pl)

# php - 通过 ajax echo 命令包含 html 的最佳方法是什么？

> ID：231364
> 
> 赞同：1
> 
> 时间：2008-10-23T20:28:07.733
> 
> 标签：php, html, ajax

我目前正在构建一个小型网站，其中主要 div 的内容通过 Ajax 调用填充。我基本上有一个 php 脚本，它返回如下内容：

（简化的 php 脚本...）

```
 if(isset($_POST["id_tuto"])){
  PrintHtml($_POST["id_tuto"]);
}

function PrintHtml($id)
{
  switch($id)
  {
    case [...]:
      echo "THIS IS MY HTML CONTENT";
    break;
    [...]
  }
} 
```

然后网页从该 echo 命令获取文本并替换内容 div 的内部 html。

我的问题是：回显该 html 内容的最佳方式是什么？每次都有很多内容，因为它是一步一步的教程。每个字符串大约有 50-80 行 HTML 代码。有没有办法将该 html 内容放在单独的 html 文件中并回显该文件或...？

非常感谢！！

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-23T20:43:36.750

你可以这样做：

```
<?php
    function PrintHtml($id) {
      switch($id) {
          case [...]:
?>
      <h1>Tut page 1</h1>
      <p>this is html content.</p>
<?php
      break;
      [...]
    }
  }
?> 
```

也许：

```
<?php
  function PrintHtml($id) {
     switch($id) {
      case [...]:
      include 'section1.php';
      break;
      [...]
    }
  }
?> 
```

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T20:35:27.297

您只需按照通常生成 HTML 页面的方式进行操作，只是它没有包含在 HTML HEAD 或 BODY 标记中。它只是将添加到您的页面的 HTML 片段。

您“回显”的所有内容都将成为输出的一部分。您可以一次性完成或全部完成，这没关系，因为它调用作为“响应”作为一个块发送到浏览器。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T20:51:16.733

您应该使用模板系统，例如[Smarty](http://www.smarty.net/)。这将允许您将 html 与代码逻辑分开。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T20:51:36.267

尝试将您的数据（人类可读文本）与您的格式（HTML）分离我怀疑可以分离 50 - 80 行 HTML。您可以创建多个 HTML 模板，然后根据需要将数据添加到模板中。我肯定会使用 Prototype 或一些 JavaScript 库来处理在客户端接收 JSON 格式的数据。您可以将数据保存在平面文件中，但我认为数据库会更快且更不容易出错。MVC 模式在这里肯定会有所帮助。

# python - 用python练习BDD

> ID：231371
> 
> 赞同：133
> 
> 时间：2008-10-23T20:30:44.763
> 
> 标签：python, testing, bdd

python 有哪些最先进的框架和工具可用于实践行为驱动开发？尤其是为 ruby​​ 找到与 rspec 和 mocha 类似的工具会很棒。

* * *

## 回答 #1

> 赞同：48
> 
> 时间：2010-05-05T23:20:18.953

Lettuce的意思是成为python的类似黄瓜的工具：http: [//lettuce.it/](http://lettuce.it/)

您可以在 github.com/gabrielfalcao/lettuce 获取源代码

* * *

## 回答 #2

> 赞同：46
> 
> 时间：2012-07-18T14:23:39.960

我真的建议[表现](http://packages.python.org/behave/)。

在寻找 Python 的 Cucumber 克隆时，我开始使用生菜，但发现它是一个设计非常笨拙的复制品。非常不合常理。

然后我发现了表现，并且对此非常满意。

* * *

## 回答 #3

> 赞同：38
> 
> 时间：2008-10-24T02:06:21.247

[Ian Bicking](http://blog.ianbicking.org/behavior-driven-programming.html)建议使用[doctest](http://docs.python.org/library/doctest.html?highlight=doctest#module-doctest)进行行为驱动设计：

我个人倾向于在行为驱动的设计风格中使用[鼻子](https://web.archive.org/web/20110610084952/http://somethingaboutorange.com/mrl/projects/nose/1.0.0)和[虚空模拟。](http://www.voidspace.org.uk/python/mock.html)具体来说，nose 的规范[插件](http://darcs.idyll.org/~t/projects/pinocchio/doc/#spec-generate-test-description-from-test-class-method-names)非常适合 BDD。

* * *

## 回答 #4

> 赞同：29
> 
> 时间：2010-06-08T17:20:57.047

我推荐你使用一套工具来帮助程序员进行 BDD 和 TDD 的实践。该工具集由：[pycukes](https://pypi.python.org/pypi/pycukes/0.1.2)、[specloud](https://pypi.python.org/pypi/specloud/0.4.5)、[ludibrio](https://pypi.python.org/pypi/ludibrio/2.0)和[should-dsl](http://www.should-dsl.info/)组成。

[should-DSL](http://www.should-dsl.info/)会给你类似 RSpec 的期望。你可以用 RSpec 期望 API 做的所有事情，should-dsl 也可以。您可以[从 Github](http://github.com/rodrigomanhaes/should-dsl/tree/matchers-as-functions)获取最新版本。

[SpecLoud](https://pypi.python.org/pypi/specloud/0.4.5)可帮助您运行类似 BDD 的单元测试。您可以通过执行安装它

```
pip install specloud 
```

[Ludibrio](https://pypi.python.org/pypi/ludibrio/2.0)是一个用于测试替身（Mocks、Stubs 和 Dummies）的库。通过安装它

```
pip install ludibrio 
```

而[PyCukes](https://pypi.python.org/pypi/pycukes/0.1.2)是 BDD 的主要工具。它将运行场景等。再次，

```
pip install pycukes 
```

有关更多信息，请阅读[PyPi](https://pypi.python.org/pypi)上的工具文档。

* * *

## 回答 #5

> 赞同：11
> 
> 时间：2010-11-12T20:28:16.820

很棒的帖子和答案。只是想更新以将[Freshen](https://github.com/rlisagor/freshen)包含在此列表中，因为我读到 pycukes 已停产。一篇关于将 BDD 和 Django 与 Freshen 结合使用的好帖子在[这里](http://www.franciscosouza.com/2010/06/making-development-with-django-more-fun-with-bdd-using-freshen/)。

* * *

## 回答 #6

> 赞同：9
> 
> 时间：2012-08-08T07:17:40.633

您可以将[“确定”](https://github.com/gabrielfalcao/sure#fluent-assertions)用于表达性断言（就像在 RSpec 中一样）

* * *

## 回答 #7

> 赞同：8
> 
> 时间：2009-05-01T18:04:03.830

Pyccuracy 项目旨在为 Python 中的 BDD 提供特定领域的语言。

与在 API 级别工作的 doctest 不同，它对更高级别的操作进行编码，例如加载网页和提交表单。我没有使用它，但如果这是您正在寻找的东西，它看起来很有希望。

* * *

## 回答 #8

> 赞同：6
> 
> 时间：2009-06-02T15:47:25.237

我非常喜欢[Pyccuracy](https://github.com/heynemann/pyccuracy/wiki/)。这些天我正在一个中型项目上实施它。

* * *

## 回答 #9

> 赞同：6
> 
> 时间：2012-07-01T03:53:53.927

试试[pyspecs](https://github.com/mdwhatcott/pyspecs)。使测试易于阅读并在开发过程中持续运行是我创建这个项目的两个主要目标。

## 测试代码：

```
from pyspecs import given, when, then, and_, the, this

with given.two_operands:
    a = 2
    b = 3

    with when.supplied_to_the_add_function:
        total = a + b

        with then.the_total_should_be_mathmatically_correct:
            the(total).should.equal(5)

        with and_.the_total_should_be_greater_than_either_operand:
            the(total).should.be_greater_than(a)
            the(total).should.be_greater_than(b)

    with when.supplied_to_the_subtract_function:
        difference = b - a

        with then.the_difference_should_be_mathmatically_correct:
            the(difference).should.equal(1) 
```

## 控制台输出：

```
# run_pyspecs.py

  | • given two operands 
  |   • when supplied to the add function 
  |     • then the total should be mathmatically correct 
  |     • and the total should be greater than either operand 
  |   • when supplied to the subtract function 
  |     • then the difference should be mathmatically correct 

(ok) 6 passed (6 steps, 1 scenarios in 0.0002 seconds) 
```

* * *

## 回答 #10

> 赞同：4
> 
> 时间：2008-10-23T21:19:06.117

我可能完全没有抓住重点，但我保留的[原始 BDD 论文](http://dannorth.net/introducing-bdd)是 BDD 只是[TDD](http://c2.com/cgi/wiki?TestDrivenDevelopment)重新打包以强调一些最佳实践。

[如果我的解释是正确的，您可以通过在任何xUnit](http://www.martinfowler.com/bliki/Xunit.html)实现中重命名方法来获得 BDD 框架。所以继续使用标准库的[unittest](http://www.python.org/doc/2.5.2/lib/module-unittest.html)。

编辑：快速谷歌在[Cheese Shop中发现了一个](http://pypi.python.org/pypi)[Behavior](http://pypi.python.org/pypi/Behaviour)模块。进一步[搜索](http://pypi.python.org/pypi?%3Aaction=search&term=BDD&submit=search)BDD 没有找到其他任何东西。

# xml - XSLT IE6 默认处理器

> ID：231373
> 
> 赞同：3
> 
> 时间：2008-10-23T20:31:15.230
> 
> 标签：xml, xslt, internet-explorer-6, exslt

IE6 的默认 XSLT 处理器是什么。它支持 EXSLT 吗？反正有没有让它支持它？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-23T21:01:26.153

IE6 的默认 XSLT 处理器是 MSXML 3.0。您可以忘记在 MSXML 3 中执行 XSLT。它所支持的甚至不是 XSLT 的一个子集，而是一个较旧的草案。但是，大多数人会通过软件更新、ms office 或其他方式安装 MSXML 4 或更高版本。MSXML 4 及更高版本中的 XSLT 非常快，比 Firefox 中的 XSLT 快得多。

所以，不要测试 IE 版本，而要测试 MSXML 版本。首先尝试 MSXML 6，如果不存在则回退到 MSXML 4。不要尝试 MSXML 5，它是 Office 使用的中间版本，但 Microsoft 不再支持。

MSXML 支持扩展功能（遗憾的是，Firefox 不支持），因此您可以使用 javascript 添加 EXSLT 支持。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T20:47:23.327

你唤醒了我过去的折磨者。

MSXML，它是作为服务更新安装的，并且最初包含在 MSIE6 中的 XSLT 处理器除了非常一般级别的草稿功能外，不支持任何其他功能。服务更新大大改进了它。

由于需要存在服务更新，我们从未考虑使用 MSIE6 执行任何客户端 XSLT，而是在客户端浏览器为 MSIE6 并中继转换后的内容时在服务器端执行转换。

# javascript - 将 JavaScript 与 JSF 和 Facelets 一起使用

> ID：231377
> 
> 赞同：2
> 
> 时间：2008-10-23T20:31:27.400
> 
> 标签：javascript, jsf, facelets

我想使用 JavaScript 来操作 JSF/Facelets 页面中的隐藏输入字段。页面加载时，我需要为客户端的颜色深度设置一个隐藏字段。

来自我的 Facelet：

```
<body onload="setColorDepth(document.getElementById(?????);">

<h:form>
  <h:inputHidden value="#{login.colorDepth}" id="colorDepth" />
</h:form> 
```

当 JSF 处理页面时，它当然会更改元素的 ID。从我的 JavaScript 代码中引用这些元素的最佳方式是什么？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-23T20:35:02.523

您需要设置表单的 ID，以便知道它是什么。然后，您将能够构建实际的元素 ID。

```
<body onload="setColorDepth(document.getElementById('myForm:colorDepth');">

<h:form id="myForm">
  <h:inputHidden value="#{login.colorDepth}" id="colorDepth" />
</h:form> 
```

如果您不想设置表单的 ID 字段，可以在运行时找到它，如下所示：

```
<body onload="setColorDepth(document.getElementById(document.forms[0].id + ':colorDepth');"> 
```

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T20:35:38.140

查看生成的html源码，看看jsf给标签的id属性取了什么名字。

您很快就会看到命名约定是如何工作的。它通常像 FORMNAME:FIELDNAME

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-11-05T17:43:41.120

您可以使用[UIComponent.getClientId(FacesContext)](http://java.sun.com/javaee/javaserverfaces/1.1_01/docs/api/javax/faces/component/UIComponent.html#getClientId(javax.faces.context.FacesContext))返回的控件的*clientId*。有关示例代码，请参见[此处](https://stackoverflow.com/questions/265175/how-does-jsf-generate-the-name-of-the-form-input-field#265561)。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-11-05T18:19:39.037

全局定义一个函数 findElement 并在任何地方使用它

```
function findElement(elementId) {
        if(document.getElementById(elementId)) return elementId;
        for(var  i = 0; i < document.forms.length; i++) {
            if(document.getElementById(document.forms[i].id + ':' + elementId)) {
                return document.forms[i].id + ':' + elementId;
            }
        }
        return null;
    }

    <body onload="setColorDepth(findElement('colorDepth'));"> 
```

# c++ - 这个素数生成器是低效的 C++ 吗？

> ID：231381
> 
> 赞同：2
> 
> 时间：2008-10-23T20:32:01.063
> 
> 标签：c++, performance, primes

这是否被视为有效的素数生成器。在我看来，这非常有效。是使用流使程序运行更慢吗？

我正在尝试将此提交给[SPOJ](http://www.spoj.pl/)，它告诉我超出了我的时间限制...

```
#include <iostream>
#include <sstream>

using namespace std;

int main() {
    int testCases, first, second, counter = 0;
    bool isPrime = true;
    stringstream out;

    cin >> testCases;

    for (int i = 0; i < testCases; i++) {
        // get the next two numbers
        cin >> first >> second;

        if (first%2 == 0)
            first++;

        // find the prime numbers between the two given numbers
        for (int j = first; j <= second; j+=2) {
            // go through and check if j is prime
            for (int k = 2; k < j; k++) {
                if (j%k == 0) {
                    isPrime = false;
                    break;
                }
            }
            if (isPrime) {
                out << j << "\n";
            }
            isPrime = true;
        }
        out << "\n";
    }

    cout << out.str();

    return 0;
} 
```

编辑：该程序应该在输入中指定的数字之间生成素数。（有关详细信息，请参见此处：[Prime Generator Problem](http://www.spoj.pl/problems/PRIME1/)）

-托梅克

* * *

## 回答 #1

> 赞同：14
> 
> 时间：2008-10-23T20:36:08.450

这是朴素算法之上的一步（跳过偶数）。我建议将[埃拉托色尼筛](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)法作为一种更有效的算法。从上面的链接：

> 该算法的复杂度为 O((nlogn)(loglogn))，内存需求为 O(n)。Eratosthenes 筛子的分段版本，具有基本优化（例如轮分解），使用 O(n) 操作和 O(n1 / 2loglogn / logn) 位内存。

您给出的算法接近 O(n^2)。通过跳过偶数获得的加速并不是那么好，因为您会在第一次测试中发现偶数不是素数。筛子有更大的内存需求，但运行时复杂度对于大*N*来说要好得多。

* * *

## 回答 #2

> 赞同：7
> 
> 时间：2008-10-23T20:36:48.433

您搜索的数字比您必须搜索的*要*多得多 - 最多您只需要访问`<= (sqrt(num))`.

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-10-24T22:45:16.523

这是一个简单的埃拉托色尼筛法。它不需要预先声明一个大的布尔数组，但它在时间和空间上仍然是 >>O(n)。不过，只要你有足够的内存，它应该比你目前的幼稚方法要快得多。

```
#include <iostream>
#include <map>

using namespace std;

template<typename T = int, typename M = map<T, T> >
class prime_iterator {
    public:
        prime_iterator() : current(2), skips() { skips[4] = 2; }
        T operator*() { return current; }
        prime_iterator &operator++() {
            typename M::iterator i;
            while ((i = skips.find(++current)) != skips.end()) {
                T skip = i->second, next = current + skip;
                skips.erase(i);
                for (typename M::iterator j = skips.find(next);
                        j != skips.end(); j = skips.find(next += skip)) {}
                skips[next] = skip;
            }
            skips[current * current] = current;
            return *this;
        }
    private:
        T current;
        M skips;
};

int main() {
    prime_iterator<int> primes;
    for (; *primes < 1000; ++primes)
        cout << *primes << endl;
    return 0;
} 
```

如果这对您来说仍然太慢，您可能想要追求[阿特金筛子](http://en.wikipedia.org/wiki/Sieve_of_Atkin)，一种优化的埃拉托色尼筛子。

实际上，只有在生成的素数范围开始较低时，这些才是相对有效的。如果下界已经相当大，而上界并不比下界大多少，那么筛分方法是浪费工作，最好运行一个[素数测试](http://en.wikipedia.org/wiki/Primality_test)。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2009-07-04T08:34:58.047

还有一件事，不要在循环中使用 sqrt(n)：

```
for(int k=1;k<sqrt(n);++k) 
```

如果没有很好的优化，每次迭代都会计算 sqrt。

采用

```
for (int k=1;k*k < n;++k) 
```

或者干脆

```
int sq = sqrt ( n );
for (int k=1;k<sq;++k) 
```

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-23T20:38:19.960

它可以稍微提高效率。您不需要从 2 开始 k，您已经确保不要测试偶数。因此，k 从 3 开始。
然后每次将 k 增加 2，因为您不需要测试其他偶数。我能想到的最有效的方法是只测试一个数字是否可以被已知的素数整除（然后当你找到另一个数时，将它添加到你测试的列表中）。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-23T20:40:43.027

```
for (int k = 2; k < j; k++) {
     if (j%k == 0) {
         isPrime = false;
         break;
     }
} 
```

应该：

```
for(int k = 3; k <= j/2; k+=2 )
{
  if( j % k == 0 )
      break;
} 
```

j/2 确实应该是 sqrt(j) 但它通常是一个足够好的估计。

# ruby-on-rails - 从 Git 存储库安装 rails 插件

> ID：231390
> 
> 赞同：4
> 
> 时间：2008-10-23T20:34:04.180
> 
> 标签：ruby-on-rails, git, plugins

我一直在尝试安装[应该](http://thoughtbot.com/projects/shoulda)

```
script/plugin install git://github.com/thoughtbot/shoulda.git 
```

但我得到的是：

```
removing: C:/Documents and Settings/Danny/My Documents/Projects/Ruby On Rails/_ProjectName_/vendor/plugins/shoulda/.git
> 
```

而且`vender/plugins`目录是空的。我将 Rails 2.1.1 作为 gem 安装，并验证了 2.1.1 已加载（使用插入到 config/boot.rb 的 puts）。关于发生了什么的任何想法？

（这是在一个 Windows 盒子上）

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-23T20:35:37.250

你有安装 git 吗？如果你不这样做，它就行不通。Rails 假定 git 已安装并且可以在您的 PATH 中找到。

您可以[在此处](http://code.google.com/p/msysgit/downloads/list)获取适用于 Windows 的 Git 。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2010-06-18T04:25:33.790

对于仍然有这个问题的人，从 Rails 2.3.5 开始，您可能仍然会遇到错误，因为最近的 Ruby/Win32 构建是使用 MinGW 完成的。但是，该问题已在 2.3.8 之间修复，只要您此时安装了 msysgit，它应该可以正常工作。

如果您对升级不满意（来吧，这只是一点点发布），以下补丁将处理这些问题：

```
--- reporting.rb.orig   2010-06-11 01:00:24.739991600 -0400
+++ reporting.rb        2010-06-18 00:16:39.517649400 -0400
@@ -35,7 +35,7 @@
   #   puts 'But this will'
   def silence_stream(stream)
     old_stream = stream.dup
-    stream.reopen(RUBY_PLATFORM =~ /mswin/ ? 'NUL:' : '/dev/null')
+    stream.reopen(RUBY_PLATFORM =~ /(:?mswin|mingw)/ ? 'NUL:' : '/dev/null')
     stream.sync = true
     yield
   ensure
@@ -56,4 +56,4 @@
       raise unless exception_classes.any? { |cls| e.kind_of?(cls) }
     end
   end
-end
\ No newline at end of file
+end 
```

# asp.net - 与提供 ajax 内容的网页相比，Web 服务有什么优势吗？

> ID：231402
> 
> 赞同：2
> 
> 时间：2008-10-23T20:36:52.677
> 
> 标签：asp.net, ajax, web-services

我的 ajax 调用应该与 Web 服务还是与简单的网页通信？简单地 Response.Write() 内容似乎要容易得多。Web 服务更可靠或更安全吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-11-09T01:44:36.890

进行 AJAX 调用时可能需要考虑的东西是页面方法。使用 ASP.NET 页面方法，您可以使用 javascript 调用代码中存在的服务器端函数，而无需页面生命周期的开销，因为该方法必须是静态的。有关 Page 方法的更多信息，请查看

[http://www.singingeels.com/Articles/Using_Page_Methods_in_ASPNET_AJAX.aspx](http://www.singingeels.com/Articles/Using_Page_Methods_in_ASPNET_AJAX.aspx)

如果您确实想在多个页面上从您的方法访问功能，请考虑使用 Web 服务——您可以使用 Microsoft AJAX javascript 库以类似的方式连接到它。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T20:38:41.050

由于页面的生命周期更复杂，调用网页的开销更大。

也就是说，我怀疑它最终是否真的很重要，但在语义和实践上，网页效率并不高。

* * *

更新：你能澄清一下吗？您是在谈论典型的 ASP.NET 页面吗？还是“经典”ASP？正如对此答案的评论中有人指出的那样，如果我们谈论的是“经典” ASP，那么它会比 ASP.NET 页面更简单，但我认为这是不言而喻的......

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T20:42:17.860

Web 服务是标准化的，因此您可以从使用它们中获得某些优势，至少在 Microsoft 开发平台方面是这样。您可以将 Visual Studio 指向 ASMX，以将来自外部 Web 服务的引用添加到您的项目 - 虽然我确信您可以从 *.aspx 页面获得相同的结果，但您也有很多与 * 相关的开销.aspx 页面（页面生命周期、视图状态）。

如果有人在您身后维护您的代码，他们可能会查看 *.aspx“Web 服务”并挠头。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T20:48:47.537

我认为答案最终取决于您在网站上所做的事情。如果您具有将/可以跨多个页面或组件使用的功能，那么您最好编写一个 Web 服务来完成这项工作。

此外，根据您使用的 AJAX 库/代码，Web 服务可能会更好地工作。请记住，Web 服务不必是单独的站点，而可以是放置在当前站点结构中可访问位置的 .asmx 页面。

我使用了一个 .asmx 文件来返回一个控件，例如登录控件、依赖于用户的 UI 以及来自网站和 Windows 应用程序的并发数据更新的集成。

话虽如此，您可以使用后面的页面，但对于代码重用和跨站点数据处理来说，使用 Web 服务通常更实用。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-11-03T13:00:02.020

我不认为 SOAP Web 服务比标准网页更有优势。然而，我会说类似 REST 的 Web 服务更合适。您可以以任何您想要的方式实现类似 REST 的 Web 服务，包括作为带有简单 Response.Write 的 ASP 页面。最好您应该返回 JSON 对象。重要的是正确设计您的服务，这意味着定义哪个 URL 返回什么内容。

jQuery 有一个方便的 getJSON 函数来读取服务器的响应。

* * *

## 回答 #6

> 赞同：-1
> 
> 时间：2008-10-23T20:39:04.810

无论如何我都看不到。这只是来回的http流量。

* * *

## 回答 #7

> 赞同：-1
> 
> 时间：2008-10-23T20:43:32.850

取决于您用于执行 AJAX 调用的库。无论机制如何，直接从您的调用中获取 JSON 甚至更好的反序列化对象都很好。解析 SOAP 是您不必担心的苦差事。也就是说，匹配流入和流出的内容很重要，这将首先影响我的选择。（基于各种经理/建筑师/等可能正在传递的限制。）

# visual-studio-2005 - VS2005 中缺少调试器类型

> ID：231406
> 
> 赞同：5
> 
> 时间：2008-10-23T20:38:06.903
> 
> 标签：visual-studio-2005, debugging

我有一台缺少手动调试器类型列表的计算机。请参阅下面的屏幕截图。

它有VS2005 SP1。什么可能导致这种情况？

[空白调试器 http://img505.imageshack.us/img505/5240/blankdebuggerki3.png](http://img505.imageshack.us/img505/5240/blankdebuggerki3.png)

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2013-09-04T07:33:39.627

你用的是快递版还是专业版。因为在特快版中这些是缺失的。

# gwt - GWT 分页小部件

> ID：231407
> 
> 赞同：5
> 
> 时间：2008-10-23T20:38:09.927
> 
> 标签：gwt, pagination, widget

我正在寻找一个 GWT 通用分页小部件。到目前为止，我已经找到了[GWT 小部件库](http://gwt-widget.sourceforge.net/)和 [Google Incubator 小部件](http://code.google.com/p/google-web-toolkit-incubator/w/list)。是否有任何其他免费（可能是开源）小部件库实现分页行为。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2010-11-18T15:38:09.777

GWT 2.1 现在附带分页小部件。

[带分页的单元格表](http://gwt.google.com/samples/Showcase/Showcase.html#!CwCellTable)

[数据展示小部件（单元格小部件）](http://code.google.com/webtoolkit/doc/latest/DevGuideUiCellWidgets.html)

[如何使用 GWT 2.1 数据表示小部件](https://stackoverflow.com/questions/2891803/how-to-use-gwt-2-1-data-presentation-widgets/2944454#2944454)

[com.google.gwt.user.cellview.client](http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/user/cellview/client/package-summary.html)

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-25T19:19:52.013

你找到了两个主要的。Google Incubator 小部件可能是一个不错的选择，因为其目的是让这些小部件最终进入主库。一般来说，GWT 小部件库小部件往往更漂亮，但 GWT 孵化器库小部件往往更加模块化，并且在更多 Web 浏览器中也更加健壮。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-12-02T22:04:52.703

我使用了 GXT（一个 GWT 库）提供的那个，我喜欢它！看看这个！

[http://extjs.com/products/gxt/](http://extjs.com/products/gxt/)

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2009-02-12T15:11:44.810

这个 GXT 库有商业许可！

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2009-07-15T14:11:42.647

实际上他们既做喜剧又做交换条件

[http://extjs.com/company/dual.php](http://extjs.com/company/dual.php)

因此，只要您开源您的项目，您就可以免费使用它。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2010-11-29T03:45:23.773

还有一个使用 GWT 2.1 的示例`CellTable`：`AsyncDataProvider`http: [//robin.mytechtip.com/2010/11/17/gwt-celltable-example-using-asyncdataprovider/](http://robin.mytechtip.com/2010/11/17/gwt-celltable-example-using-asyncdataprovider/)

# mysql - 实时 MySQL 二进制日志解析

> ID：231426
> 
> 赞同：6
> 
> 时间：2008-10-23T20:42:26.003
> 
> 标签：mysql

我们正在处理一个基于 MySQL 5.0 (MyISAM) 的遗留应用程序。我需要**实时**了解特定表何时发生更新、删除或插入。“问题”是我无法以任何方式更改数据库（即写触发器）。我必须使用 bin 日志、复制或其他一些非侵入性的东西。

我们已经研究过使用“mysqlbinlog”命令来解析二进制日志。然而，这不是实时的，我们宁愿做一些更受事件驱动的事情。

有任何想法吗？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-23T20:50:22.150

检查[MySQL 代理](http://forge.mysql.com/wiki/MySQL_Proxy)。它可以让你在命令/响应流中直接点击，它在 Lua 中是完全可编程的。如果需要，您甚至可以实时修改命令

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2011-03-26T12:00:43.447

另外，如果您想实时了解一个表是否发生了更改，那么我建议您在主服务器上进行触发器，然后您可以将数据插入到一个单独的数据库中，该数据库自行复制。在触发器内部，即使使用联合服务器，您也可以访问另一台服务器。[http://dev.mysql.com/tech-resources/articles/mysql-federated-storage.html](http://dev.mysql.com/tech-resources/articles/mysql-federated-storage.html)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2011-03-26T10:51:45.270

我正在尝试使用 mysqlbinlog -R -t 来实时获取提要，它一直工作到最后，然后你需要找到最后读取的位置，然后继续，结合对日志文件的查询，这应该会给你所有一个接一个的文件..正在试验这个..

# .net - .NET 的 Wiki 平台

> ID：231436
> 
> 赞同：4
> 
> 时间：2008-10-23T20:44:31.163
> 
> 标签：.net, wiki

寻找基于 .NET 的 Wiki 平台的好选择。不需要开源，但越便宜越好。

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-23T20:52:54.500

**就可扩展性和**易用性/安装而言， [Screwturn Wiki](http://www.screwturn.com)
可能是最好的。

 **我已经能够编写非常有用和强大的插件。这是我们开发团队的主要 wiki。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T20:47:55.913

[链接笔记](http://www.heartland-it.com/LinkedNotes/ProductInfo.aspx)

[SharpForge](http://en.wikipedia.org/wiki/SharpForge) 是一个 asp.net 2.0(c#) 项目管理应用程序，在新的 BSD 许可下发布。每个项目都有自己的 wiki。wiki 没有使用特殊语法，而是使用标准 HTML。内容在版本控制系统中进行版本控制。

[FlexWiki](http://en.wikipedia.org/wiki/FlexWiki) 是用 C# 编写的，使用 .NET 框架，并将数据存储在文件或 Microsoft SQL Server 中。FlexWiki 是一个开源 wiki 软件，在 CPL 下发布（二进制文件和源代码可供下载）。

[Perspective](http://en.wikipedia.org/wiki/Perspective_(software))是用 C# 编写的，使用 .NET 框架，并将数据存储在 XML 文件中。二进制和源代码可供下载。

[SharpForge](http://en.wikipedia.org/wiki/SharpForge) 是一个 asp.net 2.0(c#) 项目管理应用程序，在新的 BSD 许可下发布。每个项目都有自己的 wiki。wiki 没有使用特殊语法，而是使用标准 HTML。内容在版本控制系统中进行版本控制。

* * *

## 回答 #3

> 赞同：-1
> 
> 时间：2011-02-10T08:47:30.427

如果有人感兴趣，我刚刚发布了一个自制的.... [http://codebrewery.blogspot.com/2011/02/iknow-release-10.html](http://codebrewery.blogspot.com/2011/02/iknow-release-10.html)

它很小，非常小，但我主要为内网知识库场景创建它。

# c - C中的杜鹃散列

> ID：231438
> 
> 赞同：16
> 
> 时间：2008-10-23T20:45:11.537
> 
> 标签：c, hashtable

有人在 C 中实现了[Cuckoo 散列吗？](http://en.wikipedia.org/wiki/Cuckoo_hashing)如果有一个开源的非 GPL 版本就完美了！

既然亚当在他的评论中提到了它，有谁知道它为什么用得不多？仅仅是实施的问题，还是良好的理论特性在实践中没有实现？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2009-04-10T12:39:38.153

正如其他答案所指出的那样，最简单的杜鹃哈希表确实要求该表为半空。然而，这个概念已经被推广到*d* - ary cuckoo 散列，其中每个键有*d*个可能的嵌套位置，而不是简单版本中的 2 个位置。

可接受的负载系数随着*d*的增加而迅速增加。只有*d* =3，您已经可以使用大约 75% 的完整表。缺点是您需要*d 个*独立的哈希函数。我是 Bob Jenkins 为此目的的散列函数的粉丝（请参阅[http://burtleburtle.net/bob/c/lookup3.c](http://burtleburtle.net/bob/c/lookup3.c)），您可能会发现它在布谷鸟散列实现中很有用。

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-10-23T20:53:59.117

Cuckoo 散列在学术界之外相对未使用（除了硬件缓存，它有时会借用想法，但并没有真正完全实现）。它需要一个非常稀疏的哈希表才能获得良好的插入时间——您确实需要将 51% 的表留空才能获得良好的性能。因此，它要么速度快，占用大量空间，要么速度慢，有效利用空间——绝不是两者兼而有之。其他算法既节省时间又节省空间，尽管仅考虑时间或空间时它们比杜鹃差。

这是[杜鹃哈希表的代码生成器](http://www.theiling.de/projects/lookuptable.html)。检查生成器的许可证以验证输出是否为非 GPL。应该是，但无论如何都要检查。

-亚当

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-10-27T14:13:11.320

[http://www.mpi-inf.mpg.de/~sanders/programs/cuckoo/](http://www.mpi-inf.mpg.de/~sanders/programs/cuckoo/)

高温高压

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2010-08-09T11:39:09.647

尽管这是一个老问题，但有人可能仍然感兴趣:)

[本文](http://portal.acm.org/citation.cfm?id=1618500)描述了在 GPU (CUDA/OpenCL) 上实现并行 d-ary cuckoo hash。它描述得很好，根据描述实现它非常容易。如果您对此主题感兴趣，通常值得一读。（不过，您需要 ACM 登录。）

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2009-05-12T12:44:04.647

我不能说软件，但杜鹃散列肯定用于硬件并且变得非常流行。网络设备的主要供应商一直在研究布谷鸟哈希，有些已经在使用它。Cuckoo 哈希的吸引力当然来自于恒定的查找时间，但也来自于几乎恒定的插入时间。

尽管插入理论上可以是无限的，但实际上它可以限制为表中行数的 O(log n)，并且在测量时，插入时间平均约为 1.1*d 内存访问。这仅比绝对最小值多出 10%！内存访问通常是网络设备的限制因素。

独立的散列函数是必须的，正确选择它们是困难的。祝你好运。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-23T20:58:24.833

IO 语言有一个，在 PHash.c 中。你可以在 Github 上找到[IO 的代码。](http://github.com/stevedekorte/io)IO 是 BSD 许可的。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-24T06:15:52.197

我看到了利用率的重点，但这是我尝试这种特殊哈希方案的原因。如果我错过了什么，请告诉我。

据我所知，创建动态字典的哈希表的可能替代方法是（平衡）二叉树和跳过列表。只是为了讨论，让我们从 key 和 value 类型中抽象出来，假设我们将通过`void *`.

对于二叉树，我将拥有：

```
struct node {
  void *key;
  void *value;
  struct node *left;
  struct node *right;
} 
```

因此，假设指针具有相同的大小*s*，要存储*n 个*项目，我将需要 4 *s*字节。

跳过列表几乎与节点中的平均指针数为 2 相同。

在哈希表中，我将拥有：

```
struct slot {
  void *key;
  void *value;
} 
```

因此，每个项目只需要存储 2 *s*个字节。如果负载因子为 50%，要存储*n 个*项目，我将需要与树相同的 4 *s*字节。

对我来说这似乎并不算太​​糟糕：cuckoo 哈希表将占用与二叉树大致相同的内存量，但会给我 O(1) 的访问时间而不是 O(log n)。

不计算保持树平衡的复杂性以及在节点中存储平衡信息可能需要的附加信息。

其他散列方案可以实现更好的负载因子（比如 75% 或 80%），但不能保证最坏情况下的访问时间（甚至可能是 O(n) ）。

顺便说一句，[d-ary cuckoo hashing](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5337)和“ [cuckoo hashing with a stash](http://research.microsoft.com/users/uwieder/papers/stash-full.pdf) ”似乎能够增加负载因子，同时仍然保持恒定的访问时间。

Cuckoo hashing 对我来说似乎是一种有价值的技术，我认为它已经被探索过了；这就是我的问题的原因。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-10-27T13:58:02.160

根据“onebyone”的评论，我已经实现并测试了几个版本的 Cuckoo 散列以确定真正的内存需求。

经过一些实验后，声称您不必在表几乎 50% 满之前重新启动的说法似乎是正确的，尤其是在实施“[存储](http://research.microsoft.com/pubs/73856/stash-full.9-30.pdf)”技巧的情况下。

问题是当你扩大表格时。通常的方法是将其大小增加一倍，但这会导致新表的利用率仅为 25%！

事实上，假设哈希表有 16 个槽，当我插入第 8 个元素编号时，我会用完好的槽，必须重新计算。我将它加倍，现在桌子上有 32 个插槽，其中只有 8 个被占用，这是 75% 的浪费！

这是获得“恒定”检索时间（就访问/比较次数的上限而言）所付出的代价。

不过，我设计了一个不同的模式：从大于 1 的 2 的幂开始，如果表有 n 个插槽并且 n 是 2 的幂，则添加 n/2 个插槽，否则添加 n/3 个插槽：

```
+--+--+
|  |  |                             2 slots
+--+--+

+--+--+--+
|  |  |  |                          3 slots
+--+--+--+ 

+--+--+--+--+
|  |  |  |  |                       4 slots
+--+--+--+--+

+--+--+--+--+--+--+
|  |  |  |  |  |  |                 6 slots
+--+--+--+--+--+--+

+--+--+--+--+--+--+--+--+
|  |  |  |  |  |  |  |  |           8 slots
+--+--+--+--+--+--+--+--+ 
```

等等

再加上仅在表 50% 满时才会发生重新刷新的假设，这导致在重新刷新后表将只有 66% 空（1/3）而不是 75% 空（1/4）（即最坏的情况）。

我还发现（但我仍然需要检查数学）每次放大 sqrt(n)，浪费的空间渐近接近 50%。

当然，减少内存消耗的代价是最终需要的 reash 数量的增加。唉，没有什么是免费的。

如果有人感兴趣，我将进一步调查。

# string - 自动缩写词创建

> ID：231439
> 
> 赞同：0
> 
> 时间：2008-10-23T20:45:12.393
> 
> 标签：string, language-agnostic

有什么简单的方法可以从字符串创建首字母缩写词？

```
First_name Middle_name Last_name => FML
first_name middle_name last_name => FML
First_name-Middle_name Last_name => F-ML
first_name-middle_name last_name => F-ML 
```

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-23T20:51:52.473

```
Tokenize the string on whitespace.
For each token1,
  Tokenize on dash.
  For each token2
    Take token2[0] and capitalize
    if not first token2, prepend with dash
    Concatenate to result2
  Concatenate to result 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T21:16:24.797

与语言无关是否意味着您必须使用伪代码？如果没有，那么在 Ruby 中：

`"First_name-Middle_nameLast_name".gsub('-', ' - ').gsub(/\B[A-Z]+/, ' \&').split(' ').map { |s| s[0..0] }.join.upcase => "F-ML"`

如果事实证明第三个示例中缺少空间是错字，您可以跳过第二次调用`gsub`（使用丑陋的正则表达式。）

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T21:17:40.753

JavaScript 中的示例，假设第三个示例中 Last 之前缺少空格是一个错字：

```
var testStrings = [
'First_name Middle_name Last_name',
'first_name middle_name last_name',
'First_name-Middle_name Last_name',
'first_name-middle_name last_name'
];
var re = /\b(\w)\w*\b(-?)\s*/g;
var mr;
for (var i = 0, l = testStrings.length; i < l; i++)
{
  var name = testStrings[i];
  var abbr = name.replace(re, function (match, ini, dash)
  {
    return ini.toUpperCase() + dash;
  });
  alert(abbr);
} 
```

应该很容易（？）适应其他语言。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T20:50:00.653

我不知道语言不可知论，但我会创建一个接受 args[] 参数的函数来引入所有字符串，然后循环遍历这些字符串并将每个字符串的第一个字符连接到返回的另一个字符串上。

编辑：罢工。没想到是一根绳子。您必须遍历所有字符以查找特殊字符类型。第一个之后的任何字母都将被忽略，直到出现空格或特殊字符。

# preprocessor - VC6 使用环境变量设置附加包含路径？

> ID：231441
> 
> 赞同：3
> 
> 时间：2008-10-23T20:46:03.000
> 
> 标签：preprocessor, environment-variables, visual-c++-6

我不敢相信我在问这个...

自从我使用VC6以来已经有一段时间了。我设置了我认为正确的方法来包含包含文件的附加目录（我删除了另一个开发人员的硬编码路径）并放入如下内容：

%MY_DIR%\包括

但这不起作用。我错过了什么吗？VC6不允许这样做吗？这似乎是一件非常基本的事情，现在我想起来了，我不记得以前做过……

（设置变量后，我确实停止并重新启动了 VC6）

谷歌搜索和这里的快速搜索没有显示任何内容。

编辑

显然我不能投票给我自己的答案 - 但它在下面：

语法是：

$(ENV_VAR)

不是

%ENV_VAR%

* * *

我宁愿不必添加到包含环境变量中——这似乎意味着我现在必须从命令行构建。我希望能够在项目设置中添加环境变量。这似乎是一件非常简单的事情，但也许这对 IDE 团队的期望太高了。

我不确定没有正确考虑 %MY_DIR% 是什么意思...我确实按照您的建议从工具菜单启动了 cmd.exe，并且我设置的 env 路径在那里并且符合预期。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-24T20:56:32.077

这是答案...

它工作正常。

$(ENV_VAR_NAME) 不是 %ENV_VAR_NAME%

（我觉得自己像个白痴。）

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T21:03:57.957

除非您使用该标志，否则我认为 IDE 不会采用任何环境设置。

哦，如果你从命令行启动它，你就没有*从命令行*构建。您仍然可以使用 IDE 中的构建菜单。

# javascript - AJAX、子域和 SSL

> ID：231478
> 
> 赞同：17
> 
> 时间：2008-10-23T20:52:49.650
> 
> 标签：javascript, ajax, ssl, subdomain

我有一个站点 foo.com，它向 bar.foo.com 发出 ajax 请求。这行得通吗。

另外，如果 foo 是安全连接 https，bar.foo.com 也需要是 https 吗？这两个站点可以使用不同的证书吗？

* * *

## 回答 #1

> 赞同：21
> 
> 时间：2008-10-23T21:57:06.290

使用纯 http AJAX：您正在谈论跨域 XMLHttpRequest，这是浏览器不允许的。有一个[W3C 提案等待](https://wiki.mozilla.org/Cross_Site_XMLHttpRequest)在未来以安全的方式实现这一点（部分由 IE8、IIRC 实现），但目前绝对不可能。

但是，有一些解决方法可以安全地执行此操作：[子空间](http://www2007.org/program/paper.php?id=801)（使用 iframe 和`document.domain`）、[片段标识符技术](http://softwareas.com/cross-domain-communication-with-iframes)（再次使用 iframe）和[`window.name`技术](http://www.sitepen.com/blog/2008/07/22/windowname-transport/)（再次使用 iframe！）。

就 SSL 而言，您可以为域和子域购买单独的证书，或者购买涵盖两者的单个通配符 (*.foo.com) 证书（自然，通配符证书会更贵）。

如果您有一个从其他域请求项目的 HTTPS 页面，那么只要一切都是 HTTPS，一切都会好起来的。这意味着如果您使用其中一种 iframe 解决方法，则必须在 iframe 的属性中指定`https://`方案 URL 。`src`

最后一个效率较低的解决方法是在`https://foo.com`代理请求上设置一个脚本以不安全`http://bar.foo.com`。（这也解决了 XHR 跨域问题，因此您可以忽略其他解决方法。）当然，这意味着您将 XHR 请求发送到`https://foo.com/someurl`，然后点击`http://bar.foo.com/someurl`，接收响应并将其发送回浏览器，所以性能方面，如果你有这个选项，你最好将 bar.foo.com 的服务器端功能移到 foo.com 上。但是如果你不能移动服务器脚本，那么代理就是要走的路。

**编辑：**在做了一些额外的测试并获得 iframe AJAX 解决方法（#fragmentidentifier 之一）以跨不同的 HTTPS 域工作后，我更改了最后 3 个 grafs。您*可以*使用 iframe 进行 SSL 跨域 AJAX，只要一切正常`https`并且`https`在 iframe 中使用了该方案`src`。总结：

1.  简短回答：不，不允许真正的跨域 XHR
2.  使用 iframe 的解决方法：更高效，需要 2 个 SSL 证书（或通配符证书），有点复杂
3.  使用代理的解决方法：效率较低，可以使用 1 个或 2 个 SSL 证书（1 个通过 http 对 bar.foo.com 的后端请求），有点复杂

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T20:58:43.507

大多数浏览器会根据它们的安全/隐私设置阻止任何外部调用 - 并且只允许对同一域进行 AJAX 调用。甚至子域也被阻止，因为在共享环境中它们可能构成真正的威胁。

简而言之：只通过同一个域进行 AJAX 调用（也许调用一个页面，然后从另一个域调用另一个页面 - 通过 curl/fopen/...），否则你会遇到麻烦。这也回答了您的 SSL 问题 - 无论您使用什么 SSL，或者它们是否相同 - 呼叫都会被阻止，尽管有 SSL。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T21:02:35.277

是的，您可以获得两个域的不同证书。这完全取决于您决定如何配置它。

您可以为 foo.com 配置 Web 服务器，您可以为非安全打开端口 80，为安全打开端口 443 并同时使用两者。

您可以为 bar.foo.com 配置不同的 Web 服务器并执行相同的端口配置。

如果您需要确保两者都安全，那么您需要为每个不同的域获取证书。

您也许可以购买 *.foo.com 证书，使您能够将一个证书复制到另一个站点并使用它。

无论您的请求是否链接到[http://bar.foo.com](http://bar.foo.com)，您都不会获得安全连接。

你必须有 http"s" 告诉网络服务器使用端口 443 并尝试验证证书。

所有证书真正做的是说来源是可信的。即使它不受信任并且您确实使用了 http"s" 并且浏览器上有锁，您的数据无论如何都会被加密。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2010-07-22T17:25:53.210

您可以结合 JavaScript TLS 和 Flash 来完成安全的跨域请求。通过这种方式，您的访问者可以访问[https://foo.com](https://foo.com)，您可以将 XmlHttpRequests 发送到[https://bar.foo.com](https://bar.foo.com)。你可以用普通的 http 做同样的事情。

您需要为 foo.com 购买访问者的浏览器信任的 SSL 证书，但您可以为 bar.foo.com、bar2.foo.com 等生成自己的 SSL 证书。生成自己的更昂贵的替代方案SSL 证书（免费）是为 *.foo.com 购买通配符 SSL 证书。但是，如果您只是通过 foo.com 对这些站点进行跨域请求，那么您就不需要花费额外的现金。

查看 github 上的开源 Forge 项目：

[http://github.com/digitalbazaar/forge/blob/master/README](http://github.com/digitalbazaar/forge/blob/master/README)

最后的博客链接提供了更深入的解释。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2013-02-11T16:14:46.903

是的，您当然可以进行跨域 ajax 提交。[我们使用ssl.com 通配符证书](https://www.ssl.com/certificates/wildcard)进行了完全相同的设置，但您可以在 2 个站点上使用 2 个标准证书。

基本上你会使用 JSONP（yahoo、google、fb 等使用这个）。返回值被包装在一个函数中，amd 看起来像

```
someFunction("{...}"); 
```

# .net - 如何找到我的 .Net 应用程序泄漏 Windows 句柄的位置？

> ID：231480
> 
> 赞同：4
> 
> 时间：2008-10-23T20:53:04.920
> 
> 标签：.net, winforms, com, xps, handles

我有一个 WinForms .Net 应用程序，它可以运行大量 XPS 文档（数千个），在此运行期间，每个文档的句柄数量（根据 sysinternals 进程监视器和任务管理器）增加了 3-10 个。我严重怀疑这些是由 MS .Net XPS 框架库打开而不是关闭的句柄，但我无法追踪它。

尽管单步执行代码，但在同一运行期间，句柄计数在不同点会增加。例如，一次通过循环，句柄计数将在一行上跳 1，下一次可能不会跳，或者它可能跳 2。所以我怀疑 XPS com 组件有句柄泄漏。

虽然内存使用很好，但如果我一直像这样耗尽句柄，那么我会崩溃应用程序，也许是桌面。

到目前为止，我已经尝试过 sysinternals 进程资源管理器来查看句柄，但它们都被标记为没有更多细节。还使用了来自 sysinternals 的 handle.exe，这并没有显示快照之前、期间和之后的任何显着差异。

关于如何追踪把手的去向的任何线索？我想我将不得不简化为一个单线程控制台应用程序来测试。

问候

瑞安

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-23T20:54:50.253

可能很愚蠢，但你有没有检查过你正在处理所有一次性的东西？

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T20:57:13.790

虽然单独使用有点贵，但我们使用[ANTS Profiler](http://www.red-gate.com/Products/ants_profiler/index.htm)，它对于发现此类问题非常有帮助。您可以下载并试用试用版。

那里可能还有其他好的分析器，但这是我熟悉的。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2012-06-18T11:53:26.997

我在使用[YourKit .net profiler](http://www.yourkit.com/)准确诊断这种故障方面有很好的经验。强烈推荐 - 它相对便宜，甚至可以很好地处理 C++-CLI（我已经尝试过其他方法，例如[来自 jetbrains 的 dottrace](http://www.jetbrains.com/profiler/)，它们要么拒绝，要么直接崩溃）。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2009-03-30T21:31:17.717

那么，您是否忘记从 PackageStore 中删除您创建的 XPS 文档？那么用于支持您的包的任何 MemoryStreams 呢？

# c++ - 如何初始化'const std::vector ' 像 ac 数组

> ID：231491
> 
> 赞同：79
> 
> 时间：2008-10-23T20:54:59.707
> 
> 标签：c++, stl

有没有一种优雅的方法来创建和初始化`const std::vector<const T>`一个`const T a[] = { ... }`固定（和少量）数量的值？
我需要经常调用一个需要 a 的函数`vector<T>`，但在我的情况下这些值永远不会改变。

原则上我想到了类似的东西

```
namespace {
  const std::vector<const T> v(??);
} 
```

因为 v 不会在这个编译单元之外使用。

* * *

## 回答 #1

> 赞同：61
> 
> 时间：2008-10-23T20:56:10.093

对于 C++11：

```
vector<int> luggage_combo = { 1, 2, 3, 4, 5 }; 
```

**原答案：**

您要么必须等待 C++0x，要么使用[Boost.Assign](http://www.boost.org/doc/libs/1_36_0/libs/assign/doc/index.html)之类的东西来做到这一点。

例如：

```
#include <boost/assign/std/vector.hpp>
using namespace boost::assign; // bring 'operator+=()' into scope

vector<int> v;
v += 1,2,3,4,5; 
```

* * *

## 回答 #2

> 赞同：39
> 
> 时间：2008-10-23T21:04:17.457

如果您要问如何初始化 const 向量以使其具有有趣的内容，那么答案可能是使用复制构造函数。首先，您费力地填写一个向量，然后从中创建新的 const 向量。或者您可以使用`vector<InputIterator>(InputIterator, InputIterator)`构造函数模板从其他类型的容器或数组进行初始化。如果是一个数组，那么它可以用一个初始化列表来定义。

希望这样的事情接近你想要的：

```
const T ra[3] = {t1, t2, t3};
const vector<const T> v(ra, ra+3); 
```

如果您要问如何将 const 向量传递给采用向量的函数，那么答案是：

*   你不能，因为函数可能会改变向量并且你的对象/引用是常量。制作原始副本的非常量副本，然后将其传入。

或者

*   用于`const_cast`删除常量，以便将其传递给一个函数，该函数采用非常量向量，但您恰好知道它不会修改向量。

后者是其中一件非常正确的事情，它会导致任何看到它的人对护目镜发表评论，以及他们什么都不做的事实。这正是它的`const_cast`用途，但有一个相当有力的论据说，如果你需要`const_cast`，你已经输了。

做这两件事（使用复制构造函数从非常量向量创建一个常量向量，然后丢弃常量）绝对是错误的——你应该只使用一个非常量向量。因此，最多选择其中一项来做...

[**编辑：**刚刚注意到你在谈论和之间的`vector<T>`区别`const vector<const T>`。不幸的是，在 STL 中，`vector<const T>`它们`vector<T>`是完全不相关的类型，在它们之间进行转换的唯一方法是通过复制。这是向量和数组之间的区别 - a`T**`可以静默安全地转换为`const T *const *`]

* * *

## 回答 #3

> 赞同：15
> 
> 时间：2008-10-31T16:38:34.593

短而脏的方式（类似于 Boost 的`list_of()`）

```
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
using namespace std;

template <typename T>
struct vlist_of : public vector<T> {
    vlist_of(const T& t) {
        (*this)(t);
    }
    vlist_of& operator()(const T& t) {
        this->push_back(t);
        return *this;
    }
};

int main() {
    const vector<int> v = vlist_of<int>(1)(2)(3)(4)(5);
    copy(v.begin(), v.end(), ostream_iterator<int>(cout, "\n"));
} 
```

现在，C++11 有初始化列表，所以你不需要那样做，甚至不需要使用 Boost。但是，作为示例，您可以像这样在 C++11 中更有效地执行上述操作：

```
 #include <iostream>
    #include <vector>
    #include <utility>
    #include <ostream>
    using namespace std;

    template <typename T>
    struct vlist_of : public vector<T> {
        vlist_of(T&& t) {
            (*this)(move(t));
        }
        vlist_of& operator()(T&& t) {
            this->push_back(move(t));
            return *this;
        }
    };

    int main() {
        const vector<int> v = vlist_of<int>(1)(2)(3)(4)(5);
        for (const auto& i: v) {
            cout << i << endl;
        }
    } 
```

但是，它仍然不如使用 C++11 初始化列表高效，因为没有`operator=(vlist_of&&)`为向量定义。

tjohns20 的方式修改如下可能是更好的 c++11 `vlist_of`：

```
#include <iostream>
#include <vector>
#include <utility>
using namespace std;

template <typename T>
class vlist_of {
    public:
        vlist_of(T&& r) {
            (*this)(move(r));
        }
        vlist_of& operator()(T&& r) {
            v.push_back(move(r));
            return *this;
        }
        vector<T>&& operator()() {
            return move(v);
        }
    private:
        vector<T> v;

};

int main() {
    const auto v = vlist_of<int>(1)(2)(3)(4)(5)();
    for (const auto& i : v) {
        cout << i << endl;
    }

} 
```

* * *

## 回答 #4

> 赞同：12
> 
> 时间：2008-10-23T21:06:45.563

正如其他人所说，您不能像初始化 C 样式数组一样初始化向量，除非您给它指向源数组的指针。但是在这种情况下，如果你的向量是一个全局常量，为什么不直接使用一个旧的 C 风格的数组呢？

```
const int MyInts[] = {
1, 2, 3, 4, 5};

const size_t NumMyInts = sizeof(MyInts)/sizeof(MyInts[0]); 
```

您甚至可以对这个数组使用 STL 算法，就像对 const 向量使用算法一样...

```
const int* myInt = std::find( &MyInts[0], &MyInts[NumMyInts], 3); 
```

* * *

## 回答 #5

> 赞同：6
> 
> 时间：2008-10-23T21:25:21.457

您可以分两步完成：

```
namespace {
    const T s_actual_array[] = { ... };
    const std::vector<const T> s_blah(s_actual_array,
        s_actual_array + (sizeof(s_actual_array) / sizeof(s_actual_array[0])));
} 
```

也许没有你想的那么漂亮，但很实用。

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2012-05-04T09:40:38.020

怎么样：

```
int ar[]={1,2,3,4,5,6};
const int TotalItems = sizeof(ar)/sizeof(ar[0]);
std::vector<int> v(ar, ar+TotalItems); 
```

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2014-01-14T21:55:27.777

老问题，但我今天遇到了同样的问题，这是我最能接受的方法：

```
vector<int> initVector(void)
{
    vector<int> initializer;
    initializer.push_back(10);
    initializer.push_back(13);
    initializer.push_back(3);
    return intializer;
}

int main()
{
    const vector<int> a = initVector();
    return 0;
} 
```

避免过度复制的示例：

```
vector<int> & initVector(void)
{
    static vector<int> initializer;
    if(initializer.empty())
    {
        initializer.push_back(10);
        initializer.push_back(13);
        initializer.push_back(3);
    }
    return intializer;
}

int main()
{
    const vector<int> & a = initVector();
    return 0;
} 
```

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-23T21:10:42.327

不确定我是否理解正确。我理解您的问题是这样的：您想将向量初始化为大量元素。`push_back()`在向量上使用有什么问题？:-)

如果您知道要存储的元素的数量（或确定它将存储小于 2 的下一个幂），如果您有一个 X 类型的指针向量（仅适用于指针），则可以这样做：

```
std::vector< X* > v;
v.reserve(num_elems);
X* p = v.begin();
for (int count = 0; count < num_elems; count++)
   p[count] = some_source[count]; 
```

小心添加超过 2 次幂的元素，即使使用`push_back()`. 指向的指针`v.begin()`将无效。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-23T21:35:50.187

如果它们都一样，你可以这样做

```
vector<T> vec(num_items, item); 
```

但我认为他们不是——在这种情况下，最简洁的方法可能是：

```
vector<T> vec(num_items);
vec[0] = 15;
vec[1] = 5;
... 
```

C++0x 将让您完全按照您的想法使用初始化列表，但不幸的是，目前这并不是很好。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2011-05-09T16:45:13.803

根据 Shadow2531 的响应，我使用这个类来初始化向量，而不是像 Shadow 的解决方案那样实际继承 std::vector

```
template <typename T>
class vector_init
{
public:
    vector_init(const T& val)
    {
        vec.push_back(val);
    }
    inline vector_init& operator()(T val)
    {
        vec.push_back(val);
        return *this;
    }
    inline std::vector<T> end()
    {
        return vec;
    }
private:
    std::vector<T> vec;
}; 
```

用法：

```
std::vector<int> testVec = vector_init<int>(1)(2)(3)(4)(5).end(); 
```

与 Steve Jessop 的解决方案相比，它创建了更多代码，但如果数组创建不是性能关键，我发现它是在一行中初始化数组的好方法

# ruby-on-rails - RedCloth 对 标签

> ID：231512
> 
> 赞同：1
> 
> 时间：2008-10-23T21:00:00.413
> 
> 标签：ruby-on-rails, ruby

我正在使用带有 Rails 2.1.1 的 RedCloth。Textile`<del>`标签标记格式（即-delete-）根本没有翻译。尝试了一些选择。

```
> x=RedCloth.new('foobar -blah-')
=> "foobar -blah-"
> x.to_html
=> "<p>foobar <del>blah</del></p>"  # WORKED!
> x=RedCloth.new('foobar * -blah-')
=> "foobar * -blah-"
> x.to_html
=> "<p>foobar * <del>blah</del></p>"  # WORKED!
> x=RedCloth.new("foobar\n* -blah-")
=> "foobar\n* -blah-"
> x.to_html
=> "<p>foobar</p>\n<ul>\n\t<li>-blah-</li>\n</ul>"  # DID NOT WORK! 
```

在我看来，换行符是引发 RedCloth 的罪魁祸首。让 RedCloth 正确识别“-delete-”的任何解决方案？我已经尝试过 RedCloth 4.0.1、4.0.3 和 4.0.4。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-23T21:47:10.677

看起来 RedCloth 需要更多语法来将删除标记解释为列表项之后的第一个元素......

```
>> RedCloth.new("foobar\n* [-blah-]").to_html
=> "<p>foobar</p>\n<ul>\n\t<li><del>blah</del></li>\n</ul>" 
```

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-31T15:36:05.827

这是因为**新行上的星代表一个列表项**，它忽略了删除标记，而没有明确告诉它渲染它们，正如迈克尔指出的那样。

# forms - pdf 格式的多部分文本字段，使用 OpenOffice Writer

> ID：231514
> 
> 赞同：1
> 
> 时间：2008-10-23T21:01:07.200
> 
> 标签：forms, pdf, openoffice.org, fdf

所以，这可能是一个疯狂的想法，所以请耐心等待。

[警告：骇人听闻]

使用 OpenOffice.org Writer，可以轻松制作简单的 pdf 表单（因为 Writer 可以使用 XForms，并且可以导出为 PDF，并使用 FDF 嵌入表单）。我想用这个属性创建一个文本输入字段：

*   如果该字段溢出，请将溢出放在附加页面上，或页面上的某个特殊区域，标记为“附加评论”或其他内容
*   基本上，我想象的：
    *   textbox1 = 固定大小
    *   textbox2 = 固定大小（可能在另一页上）以包含来自 textbox1 的溢出

我是 Writer、FDF 等的新手，所以如果这是不可能的，我也很高兴听到这个消息。提前致谢！

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2012-05-21T16:48:20.840

不，您不能在 OpenOffice Writer 中执行此操作。

# c# - 使用扩展方法引发 C# 事件 - 这很糟糕吗？

> ID：231525
> 
> 赞同：50
> 
> 时间：2008-10-23T21:04:35.320
> 
> 标签：c#, .net, events, event-handling, extension-methods

我们都熟悉 C# 事件声明的可怕之处。为了确保线程安全，[标准是这样写](http://blogs.msdn.com/brada/archive/2005/01/14/353132.aspx)：

```
public event EventHandler SomethingHappened;
protected virtual void OnSomethingHappened(EventArgs e)
{            
    var handler = SomethingHappened;
    if (handler != null)
        handler(this, e);
} 
```

最近在这个板上的其他一些问题（我现在找不到）中，有人指出在这种情况下可以很好地使用扩展方法。这是一种方法：

```
static public class EventExtensions
{
    static public void RaiseEvent(this EventHandler @event, object sender, EventArgs e)
    {
        var handler = @event;
        if (handler != null)
            handler(sender, e);
    }
    static public void RaiseEvent<T>(this EventHandler<T> @event, object sender, T e)
        where T : EventArgs
    {
        var handler = @event;
        if (handler != null)
            handler(sender, e);
    }
} 
```

有了这些扩展方法，您只需要声明和引发事件就是这样：

```
public event EventHandler SomethingHappened;

void SomeMethod()
{
    this.SomethingHappened.RaiseEvent(this, EventArgs.Empty);
} 
```

我的问题：这是个好主意吗？我们是否因为没有标准的 On 方法而遗漏了什么？（我注意到的一件事是它不适用于具有显式添加/删除代码的事件。）

* * *

## 回答 #1

> 赞同：59
> 
> 时间：2008-10-23T21:09:04.513

它仍然适用于具有显式添加/删除的事件 - 您只需要使用委托变量（或者您已经存储了委托）而不是事件名称。

但是，有一种更简单的方法可以使其成为线程安全的 - 使用无操作处理程序对其进行初始化：

```
public event EventHandler SomethingHappened = delegate {}; 
```

调用额外委托对性能的影响可以忽略不计，而且它确实使代码更容易。

顺便说一句，在您的扩展方法中，您不需要额外的局部变量 - 您可以这样做：

```
static public void RaiseEvent(this EventHandler @event, object sender, EventArgs e)
{
    if (@event != null)
        @event(sender, e);
}

static public void RaiseEvent<T>(this EventHandler<T> @event, object sender, T e)
    where T : EventArgs
{
    if (@event != null)
        @event(sender, e);
} 
```

就我个人而言，我不会使用关键字作为参数名称，但它并没有真正改变调用方，所以做你想做的:)

编辑：至于“OnXXX”方法：你打算派生你的类吗？在我看来，大多数课程都应该是密封的。如果*这样做*，您是否希望这些派生类能够引发事件？如果这两个问题的答案是“否”，那么不要打扰。如果两者的答案都是“是”，那么做:)

* * *

## 回答 #2

> 赞同：15
> 
> 时间：2015-08-14T17:03:49.477

现在 C# 6 出现了，有一种更紧凑、线程安全的方式来触发事件：

```
SomethingHappened?.Invoke(this, e); 
```

`Invoke()`仅当为事件注册了委托（即它不为空）时才调用，这要归功于空条件运算符“？”。

问题中的“处理程序”代码要解决的线程问题在这里被回避，因为与该代码一样，`SomethingHappened`它只被访问一次，因此在测试和调用之间不可能将其设置为 null。

这个答案可能与原始问题相切，但对于那些寻找更简单的方法来引发事件的人来说非常相关。

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-10-23T21:49:35.260

[这里有一个想法]

只需以推荐的方式编写一次代码并完成它。那么你不会让你的同事在查看代码时误以为你做错了什么？

[我阅读的文章试图找到编写事件处理程序的方法比我编写事件处理程序所花费的更多。]

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-10-23T21:11:15.993

更少的代码，更多的可读性。我喜欢。

如果您对性能不感兴趣，您可以像这样声明您的事件以避免空检查：

```
public event EventHandler SomethingHappened = delegate{}; 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-23T21:16:52.113

您不是通过将处理程序分配给局部变量来*“确保”线程安全。*分配后您的方法仍然可能被中断。例如，如果用于侦听事件的类在中断期间被释放，则您正在调用已释放类中的方法。

正如 Jon Skeet 和 cristianlibardo 在他们的回答中指出的那样，您可以避免空引用异常，但有更简单的方法可以做到这一点。

另一件事是，对于非密封类， OnFoo 方法应该是虚拟的，我认为扩展方法不可能。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2019-07-18T13:05:15.687

为了更进一步地回答上述问题，您可以保护自己免受其中一个处理程序抛出异常的影响。如果发生这种情况，则不会调用后续处理程序。

同样，您可以对处理程序进行任务分配，以防止长时间运行的处理程序导致通知后者处理程序的过度延迟。这也可以保护源线程不被长时间运行的处理程序劫持。

```
 public static class EventHandlerExtensions
  {
    private static readonly log4net.ILog _log = log4net.LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

    public static void Taskify(this EventHandler theEvent, object sender, EventArgs args)
    {
      Invoke(theEvent, sender, args, true);
    }

    public static void Taskify<T>(this EventHandler<T> theEvent, object sender, T args)
    {
      Invoke(theEvent, sender, args, true);
    }

    public static void InvokeSafely(this EventHandler theEvent, object sender, EventArgs args)
    {
      Invoke(theEvent, sender, args, false);
    }

    public static void InvokeSafely<T>(this EventHandler<T> theEvent, object sender, T args)
    {
      Invoke(theEvent, sender, args, false);
    }

    private static void Invoke(this EventHandler theEvent, object sender, EventArgs args, bool taskify)
    {
      if (theEvent == null)
        return;

      foreach (EventHandler handler in theEvent.GetInvocationList())
      {
        var action = new Action(() =>
        {
          try
          {
            handler(sender, args);
          }
          catch (Exception ex)
          {
            _log.Error(ex);
          }
        });

        if (taskify)
          Task.Run(action);
        else
          action();
      }
    }

    private static void Invoke<T>(this EventHandler<T> theEvent, object sender, T args, bool taskify)
    {
      if (theEvent == null)
        return;

      foreach (EventHandler<T> handler in theEvent.GetInvocationList())
      {
        var action = new Action(() =>
        {
          try
          {
            handler(sender, args);
          }
          catch (Exception ex)
          {
            _log.Error(ex);
          }
        });

        if (taskify)
          Task.Run(action);
        else
          action();
      }
    }
  } 
```

# mysql - 是否有任何数据库支持自动索引创建？

> ID：231528
> 
> 赞同：26
> 
> 时间：2008-10-23T21:05:45.287
> 
> 标签：mysql, database, indexing

为什么数据库不根据查询频率自动索引表？是否存在任何工具来分析数据库及其接收的查询，并自动创建或至少建议创建哪些索引？

我对 MySQL 特别感兴趣，但我也对其他数据库感到好奇。

* * *

## 回答 #1

> 赞同：13
> 
> 时间：2008-10-24T02:35:16.760

这是我在 stackoverflow 上看到的最好的问题。不幸的是，我没有答案。Google 的 bigtable 会自动索引正确的列，但 BigTable 不允许任意连接，因此问题空间要小得多。

我能给出的唯一答案是：

有一天，有人问：“为什么计算机不能只分析我的代码并编译和静态键入最常运行的代码片段？”

今天人们正在解决这个问题（例如 FF3.1 中的 Tamarin），我认为“自动索引”关系数据库是同一类问题，但它不是优先考虑的问题。十年后，手动向数据库添加索引将被认为是浪费时间。目前，我们只能监控慢查询和运行优化器。

* * *

## 回答 #2

> 赞同：10
> 
> 时间：2008-10-23T21:12:24.010

有一些数据库优化器可以启用或附加到数据库以建议（并在某些情况下执行）可能有助于解决问题的索引。

然而，这实际上并不是一个微不足道的问题，当这些辅助工具第一次出现时，用户有时会发现它实际上会因为劣质优化而减慢他们的数据库速度。

最后，数据库架构师在行业中有很多钱，他们更喜欢现状。

尽管如此，数据库正变得更加智能。如果您将 SQL Server Profiler 与 Microsoft SQL Server 一起使用，您将找到加快服务器速度的方法。其他数据库也有类似的分析器，并且有第三方实用程序可以完成这项工作。

但是，如果您是编写查询的人，希望您对索引正确字段的操作有足够的了解。如果没有，那么拥有正确的索引可能是您的问题中最少的......

-亚当

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-10-23T21:14:51.010

MS SQL 2005 还维护建议索引的内部引用，以根据使用数据创建。它不如 Tuning Advisor 完整或准确，但它是自动的。研究 dm_db_missing_index_groups 以获取更多信息。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2009-01-20T13:21:17.660

我认为一个 MS SQL 博客上有一个脚本，其中有一个用于在 SQL 2005 中建议索引的脚本，但我现在找不到确切的脚本！我记得它只是描述中的东西。这是指向更多信息的链接[http://blogs.msdn.com/bartd/archive/2007/07/19/are-you-using-sql-s-missing-index-dmvs.aspx](http://blogs.msdn.com/bartd/archive/2007/07/19/are-you-using-sql-s-missing-index-dmvs.aspx)

PS 仅适用于 SQL Server 2005 +

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-10-23T21:09:08.883

有一些工具可以做到这一点。

对于 MS SQL，使用 SQL Profiler（记录数据库活动）和数据库引擎优化顾问 (SQL 2005) 或索引优化向导 (SQL 2000) 来分析活动并推荐索引或其他改进。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2009-11-25T18:44:07.330

是的，一些引擎确实支持自动索引。mysql 的一个这样的例子是 Infobright，他们的引擎不支持“常规”索引，而是隐式索引所有内容 - 这是一个基于列的存储引擎。

此类引擎的行为往往与开发人员所期望的大不相同（是的，您甚至不需要成为开发人员就可以考虑使用 Infobright；它不是标准引擎的插件替代品）。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-23T21:21:13.773

我同意亚当戴维斯在评论中所说的话。我要补充一点，如果存在这样一种自动创建索引的机制，那么对此功能最常见的反应是，“太好了……我该如何关闭它？”

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-10-24T15:02:25.180

部分原因可能是索引不仅仅提供了小的加速。如果您在大型表上没有合适的索引，查询可能会运行得如此缓慢，以至于应用程序完全无法使用，并且如果它正在与其他软件交互，它可能根本无法工作。因此，在开始尝试使用应用程序之前，您确实需要正确的索引。

此外，与其在后台构建索引并在构建过程中进一步减慢速度，不如在开始添加大量数据之前定义索引。

我相信我们会得到更多的工具来获取样本查询并计算出哪些索引是必要的；也可能我们最终会获得按照您的建议执行并监控性能并添加他们认为必要的索引的数据库，但我认为它们不会替代从正确的索引开始。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2009-08-21T09:12:41.317

似乎 MySQL 没有用户友好的分析器。也许你想尝试这样的东西[，](http://www.php-trivandrum.org/open-php-myprofiler)一个基于 MySQL profiler 的 php 类。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2013-02-14T00:06:27.827

Amazon 的 SimpleDB 会根据您的使用情况对所有列进行自动索引：

[http://aws.amazon.com/simpledb/](http://aws.amazon.com/simpledb/)

但它还有其他限制：

*   它是键值存储，而不是 RDB。显然，这意味着慢速连接（并且没有内置的连接支持）。
*   它对表大小有 10gb 的限制。有一些库可以为您处理大数据分区，尽管这会将您锁定在该库的做事方式中，这可能有其自身的问题。
*   它将所有值存储为字符串，偶数，这使得使用 1,9 和 10 对列进行排序，结果就像 1,10,9 一样，除非您使用通过 0 填充来破解它的库。这也会影响负数。

10gb 的限制比许多人想象的要大，所以你可以继续这个简单的网站，如果它变得很大，你计划重写。

不幸的是，这种自动索引没有进入 DynamoDb，它似乎已经取代了它——他们甚至不再在他们的产品列表中提到 SimpleDb，你必须通过它的旧链接找到它。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-10-23T21:09:24.187

[Google App Engine](http://code.google.com/appengine/)会这样做（请参阅 index.yaml 文件）。

# sharepoint - SharePoint 问题跟踪列表中的评论字段

> ID：231529
> 
> 赞同：2
> 
> 时间：2008-10-23T21:05:59.233
> 
> 标签：sharepoint

我使用 SharePoint (MOSS 2007) 问题跟踪列表创建了一个列表。在此列表中会自动创建一个“评论”字段。Comments 列具有额外的功能，可在对列表项进行编辑时提供某种历史记录/日志。不幸的是，即使进行了微不足道的编辑，也会创建评论条目。例如，我可以编辑列表项的标题并将注释字段留空。这会导致为“评论”字段保存一个空白条目（编辑的日期/时间和进行编辑的人除外）。如果进行了多次编辑（注释字段留空），则数据中似乎存储了几个空白条目（用于注释字段）。如果评论条目为空，有没有办法不保存评论条目？

另外，有没有办法在自定义列表中有一个评论字段？此列似乎仅在问题跟踪列表中可用。

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-10-23T21:56:40.130

“评论”字段实际上是一个“仅附加评论”列。您应该能够将其添加到任何自定义列表中。（您需要在列表中打开版本控制，才能以与问题跟踪器中相同的方式进行操作。）

至于没有获得“空白”条目，唯一的方法是关闭列表设置下列上的“将更改附加到现有文本”选项。这样做会将它变成另一个多行文本框。

我认为您错过了本专栏的重点。进行编辑后，您可以单击此列中的日期/时间，它将显示该列表项的版本。我意识到您也可以在版本历史记录中执行此操作，但这会为您提供项目内的快速链接。此外，受过培训的用户应该记录他们在此框中所做的更改。可能有助于将该列重命名为“注意此处所做的更改”。:)

祝你好运

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2011-01-22T03:28:54.180

我设法通过将其更改为纯文本来删除空白评论。看到这个博客

[http://mekalikot.blogspot.com/2011/01/how-to-remove-blank-comments-on-append.html](http://mekalikot.blogspot.com/2011/01/how-to-remove-blank-comments-on-append.html)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2018-01-30T02:31:28.860

这篇文章可能会有所帮助：[将评论列添加到您的共享点列表](https://chuvash.eu/2012/04/02/add-comments-column-to-your-sharepoint-list/)

> 1.  列表设置 -> 版本设置 -> 项目版本历史 = 是
>     
>     
> 2.  从现有网站栏添加“仅附加评论”栏

# installation - SxS 安装和 WiX

> ID：231532
> 
> 赞同：2
> 
> 时间：2008-10-23T21:07:10.353
> 
> 标签：installation, wix, winsxs, sxs

我试图弄清楚如何处理我们作为框架的项目的安装和部署。通常，开发人员会安装框架，然后让他们的 .Net 应用程序引用我们的 dll。

该框架有2个层次：

1.  许多本机 C++ dll
2.  一些引用本机 dll 的 C++\CLI 和 C# 程序集（都是 dll）

我想提供一个安装程序，将 .Net 程序集放在 GAC 中，并将本机程序集安装在 WinSxS 文件夹中。到目前为止，我还没有找到很多关于安装 SxS 程序集的信息。我知道它可以使用 MSI 来完成，我想知道是否有人知道如何使用 WiX 或其他一些安装工具来完成。

我相信这不能使用 Visual Studio 安装项目来完成。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-23T21:19:28.410

我在 wix 邮件堆中进行了搜索，然后出现了“[教程：如何将文件安装到 WinSxS](http://windows-installer-xml-wix-toolset.687559.n2.nabble.com/Tutorial-How-to-install-files-into-WinSxS-td841475.html) ”。希望对你有帮助。

# ruby-on-rails - 让渲染器识别自定义路由路径

> ID：231538
> 
> 赞同：5
> 
> 时间：2008-10-23T21:09:11.317
> 
> 标签：ruby-on-rails, ruby

所以我有一个时髦的自定义登录路径

```
# routes.rb
map.login '/login', :controller => 'sessions', :action => 'new' 
```

访问 www.asite.com/login，您就在那里。然而，与登录失败的习惯一样，我们将在我们的操作中执行以下操作。请注意登录失败时会发生什么。

```
 # sessions_controller.rb

 def create
   self.current_user = User.authenticate(params[:email], params[:password])
   if logged_in?
     # some work and redirect the user
   else
     flash.now[:warning] = "The email and/or password you entered is invalid."
     render :action => 'new'
   end
 end 
```

这是非常典型的。只需呈现新操作并再次提示登录。不幸的是，您还会得到一个丑陋的 URL：www.asite.com/session。哎呀！是否可以进行渲染以尊重原始 URL？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-24T09:04:01.530

你的问题是这样的：用户第一次访问`/login`并填写表格。当他们提交表单时，他们 POST 到`/sessions`，这就是浏览器 URL 更改的原因。为了解决这个问题，你可以做两件事：

正如迈克尔所说，您可以重定向回 :new 操作，将 else 更改为：

```
 else
   flash[:warning] = "The email and/or password you entered is invalid."
   redirect_to login_path
 end 
```

请注意，您需要更改 flash 以便消息在下一个请求中可用（在重定向之后）。

第二种方法稍微有点hackier，但也许值得一提。通过在路由上使用条件，您可以将登录表单（即 GET）和表单提交（即 POST）映射到同一路径。就像是：

```
map.login '/login',
  :controller => 'sessions', :action => 'new', 
  :conditions => {:method => :get}

map.login_submit '/login',
  :controller => 'sessions', :action => 'create', 
  :conditions => {:method => :post} 
```

然后，如果您的表单操作是登录提交路径，那么事情应该会按您的预期工作。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T21:38:31.383

更改`render :action => 'new'`为`redirect_to login_path`

# embedded - 软件开发人员很难进行低级/嵌入式系统编程吗？

> ID：231543
> 
> 赞同：15
> 
> 时间：2008-10-23T21:09:28.507
> 
> 标签：embedded, hardware, firmware

鉴于我作为通才的背景，我可以涵盖从模拟电子到编写与 RDBMS 后端接口的简单应用程序的大部分领域。

我目前在一家开发硬件以解决行业特定问题的公司工作。我们有一位经验丰富的程序员，他为 PC 编写了商业应用程序、视频游戏和一大堆其他东西。但是当我和他谈论做低级编程时，他同时表达了对加入该项目的兴趣和怀疑/不确定性。

即使在谈论 PC 时，他似乎在语言级别上操作比在较低级别的东西（指令集、ISR）上操作更舒服。尽管如此，他还是个聪明人，我认为一旦他克服了最初的学习障碍，他就会喜欢这份工作。但也许这就是我自己对低级东西说话的热情……如果他真的感兴趣，也许他已经开始朝那个方向学习了？

您是否有进行软件到硬件（或低级软件）转换的经验？或者，更好的是，让一个只做软件的人，把他转移到低级的东西上？

编辑：

PS 我很想从响应者那里听到他们自己的背景是什么——EE，CS，两者都是？

* * *

## 回答 #1

> 赞同：16
> 
> 时间：2008-10-23T21:26:51.920

归根结底，一切都是 API。

需要为微控制器内的 SPI 外设编写代码？好吧，获取数据表或硬件手册，然后查看 SPI 外设。它是一个庞大而复杂的 API。

问题是您必须了解硬件和一些基本的 EE 基础知识才能理解 API 的含义。数据表不是由软件开发人员编写的，也不是为软件开发人员编写的，它是为硬件工程师编写的，也许是软件工程师。

所以这一切都是从硬件的角度来看的（面对现实 - 微控制器公司是一家充满硬件/asic工程师的硬件公司）。

这意味着过渡绝非简单明了。

但这并不难 - 它只是一个稍微不同的域。如果您可以实施学习计划，请从[Rabbit Semiconductor](http://www.rabbit.com)的套件开始。那里有足够多的软件，所以一个 SW 人可以毫不费力地真正深入研究，而且 HW 很容易处理，因为所有东西都包含在漂亮的小库中。当他们想要做一些复杂的事情时，他们可以挖掘直接硬件访问并在较低级别上摆弄，但同时他们可以做一些非常酷的事情，例如构建小型[网络服务器](http://www.rabbit.com/products/RCM4000/index.shtml)或[平移/倾斜网络摄像机](http://www.rabbit.com/products/Camera_Interface_App_Kit/)。还有其他公司提供类似的产品，但 Rabbit 真正专注于为软件工程师简化硬件。

或者，让它们进入 Android 平台。对他们来说，它看起来像是一个 unix 系统，直到他们想做一些有趣的事情，然后他们就会有解决这个小问题的愿望，他们会了解硬件。

如果您真的想深入了解，请使用[arduino 工具包](http://www.arduino.cc/)- 便宜、免费的编译器和库，很容易上手，但是您必须连接线才能做一些有趣的事情，这可能太大了不情愿的软件工程师的障碍。但是一点点帮助和一些朝着正确方向的推动，他们会非常高兴拥有一个像夜行者灯一样摇晃*的 LED 小显示屏......

-亚当

*是的，这是一个技术工程术语。

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2008-10-24T00:01:20.860

我合作过的最好的嵌入式程序员都是受过EE培训并在工作中学习过软件的。最差的嵌入式开发人员是最近的 CS 毕业生，他们认为软件是解决问题的唯一方法。我喜欢将嵌入式编程视为软件金字塔的底部。它是一个稳定的抽象层/基础，使应用程序开发人员的生活变得轻松。

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-10-23T21:15:03.007

“硬”是一个非常相对的术语。如果您习惯于对小型嵌入式代码（例如，您是驱动程序开发人员）进行严格的、有时令人费解的思考，那么这肯定不是“难”的。

不是“bash”（不是双关语）shell 脚本编写者，但是如果你整天编写 perl 和 shell 脚本，那么它很可能是“困难的”。

同样，如果您是 Windows 的 UI 专家。这是一种不同的思维方式。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2013-10-01T19:49:58.043

为什么嵌入式开发“难”：

1) 上下文可能会在每条机器指令之间切换到中断。由于高级语言结构可能映射到多个汇编指令，这甚至可能在一行代码中，例如 long var = 0xAAAA5555。如果在中断服务例程中访问，则在 16 位处理器中 var 可能只设置了一半。

2) 对系统的可见性是有限的。除非您自己编写，否则您甚至可能没有输出到 Hyperterm。模拟器并不总是那么好或始终如一地工作（尽管它们比以前好得多）。您将必须知道如何使用示波器和逻辑分析仪。

3) 操作需要时间。例如，假设您的串行发送器在发送另一个字节时使用中断来发出信号。您可以将 16 个字节写入传输缓冲区，然后清除中断并想知道为什么您的消息永远不会发送。一般来说，时序是嵌入式编程的一个棘手部分。

4) 你会受到微妙的竞争条件的影响，这些条件很少发生并且很难调试。

5）你必须阅读手册。很多。你不能通过鬼混来使它工作。有时必须正确设置 20 件事才能得到你想要的东西。

6）硬件不总是工作或容易损坏，需要一段时间才能弄清楚是你坏了它。

7) 嵌入式系统中的软件修复通常非常昂贵。您不能只更新网页。召回可能会抹去您在设备上获得的任何利润。

可能还有更多，但我有这个比赛条件要解决......

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2008-10-23T21:35:45.133

我想这是非常主观的，他的原因可能很多。但如果他像我一样，我知道他来自哪里。让我解释。

在我的职业生涯中，我在电信行业投入了 6 年的时间，主要从事将 SDK 中间件嵌入到低端手机等方面的工作。

我经历过的大多数嵌入式环境对程序员来说就像恶劣的天气，你必须不断地克服资源等方面的限制。有些人可能会觉得这是一个挑战并享受挑战本身，有些人可能会觉得接近“真实的东西” -硬件，有些人可能会觉得这限制了他们的创造力。

我是那种觉得它限制了我的创造力的人。

我喜欢回到 Windows 桌面环境，用精心设计的课程振奋我的翅膀，额外伸展我的腿几个时钟周期，使用不必要的内存量进行诊断等。

在过去的某些嵌入式单元上，我几乎不支持 fseek()（一个 ANSI C 标准文件函数）。如果幸运的话，“看门狗”可以提供坠毁地点的线索。更不用说在单线程抢占式沼泽中与用户交流的痛苦。

嗯，你知道我在说什么。在我看来，这不一定很难，但这是一个很大的飞跃，可能很少重用您当前的经验。

问候

罗伯特

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-10-24T03:32:04.150

他需要对低级的东西感到满意，但主要是为了调试和现场问题。取决于架构，有一个严重的学习曲线，但并非不可能。另一方面，低级代码（通常）比高级代码花费更多的时间和调试。因此，如果您需要一直返回到低级别，那么可能是设计中出现了问题。即使对于我构建的嵌入式控件，我也将绝大多数时间花在高级代码上。虽然*当*你遇到问题时，拥有非常好的底层知识是非常有利的。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-10-23T21:29:58.590

从用户级应用程序开发（即通用 PC 或 Web 应用程序）到硬期限、实时响应应用程序开发（即硬件/软件接口），思维方式存在非常实际的差异。

中断、指令集、上下文切换和硬资源约束对于您的普通开发人员来说是相对未知的。我在这里假设您的“普通开发人员”不是经过培训的电气/电子或其他工程师。

您提到的这位开发人员的过渡可能远远超出了他的舒适区。我们中的一些人喜欢这样伸展。我们中的其他人可能认为这个观点不值得攀登。

同样，从事硬件领域的人（即工程师）通常对软件开发的假设和语言有困难。

当然，这些都是粗略的概括，但希望能提供一些见解。

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2009-05-18T02:16:13.200

我是一名 EE 转为软件工程师。我更喜欢编程低级。大多数软件开发人员都接受过经典培训，我知道他们不想在他们希望 api 调用的这个级别上操作。所以对我来说这是一个双赢，我创建了低级驱动程序和 api 供他们使用。有一个“新”学位，至少是我上大学以来的新学位，叫做计算机工程师。嗯，它可能是电气工程学位而不是计算机科学，但它是软件和数字硬件基础知识的完美结合。我在这个领域共事过的人对低水平更适应。

如果个人不舒服或不愿意，那么将他们放在他们舒适的地方。让他们做文档或在用户界面上工作。如果公司的所有工作都需要低水平的工作，那么这个人需要去做或找到另一份工作。不要糖衣。

我还认为，一旦他们克服了困难，他们就会享受它，你在那个级别上拥有的自由，不受操作系统的阻碍等等。最近我亲眼目睹了一些同事第一次看到他们的软件在模拟下运行的体验。处理器和其他片上外围设备内的每个网络。不，您在 gui（调试器）上没有显示内存当前状态的表格，您必须查看内存总线，查找您感兴趣的地址，查找读取或写入信号和数据总线。我担心芯片到货的那一天，它们不再具有这种可见度。会像排毒瘾君子一样。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-11-11T03:04:48.430

好吧，当我 14 岁开始阅读《大众电子》时，我在硬件方面大吃一惊——那是在个人电脑之前，以防你想知道，如果你身体不好，无论如何你都知道。哈哈

我已经在 8048/51 微处理器上完成了低级别的 bit-bang 工作，完成了 PIC 和其他一些单芯片变体，当然还有 Rabbit Semiconductor。（如果你喜欢 C，那就太好了）。这是很棒（也很有趣）的东西；是的，有一种不同的看待事物的方式——不是更难，但其中一些信息更难获得，因为它不像软件问题那样被讨论。（当然，这要看你交往的朋友圈，嗯）。

但是，说了这么多，我想提醒您一种技术，它开始为程序员架起通往硬件世界的桥梁，并从此成为一个非常重要的参与者，那就是 .NET 微框架。您可以在以下位置找到有关此技术的信息；

[http://msdn.microsoft.com/en-us/embedded/bb267253.aspx](http://msdn.microsoft.com/en-us/embedded/bb267253.aspx)

它解决了 .NET Web 开发解决的一些相同问题，您可以在新环境中使用您现有的一些基于 PC 的知识（实际上相当多）——当然，请注意，因为您的目标计算机没有有 4 GIG 的 RAM - 它可能只有 64K（或更少）

从 .NET 微框架的 2.5 版开始，您可以访问网络和 Web 服务 - 方式 kewl，是吗？不止于此……想控制家里的灯光吗？临时录音站怎么样？所有这些都具有您已经拥有的技能。好吧，主要是-查看链接。

SDK 插入您的 VisualStudio IDE。有许多“开发工具包”可用于非常合理的现金数量 - 现在，通常需要花费大量学习曲线的组件，构建电路板和连接“东西”可以通过开发工具包相当容易地完成还有一些非常简单的代码——当然，你可能需要偶尔做一些位爆炸操作，但是越来越多的传感器人员正在提供 .NET 微框架驱动程序——所以，硬件开发可能比你想象的更接近……

希望能帮助到你...

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-10-23T22:32:56.327

我都喜欢。嵌入式挑战我，真的让我以一种发自内心的方式前进。制作影响宏观物理世界的东西是*非常*令人满意的。但是我必须在电气/电子方面做很多事情，因为我的学士学位是计算机科学。我有一个非常通才的背景，在那里我学习了人工智能、图形、编译器、自然语言等。现在我正在从事嵌入式系统的研究生工作。真正困难的部分是适应操作系统等运行时设施的缺乏。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2013-03-27T10:33:53.120

低级嵌入式编程也倾向于包括低级调试。其中（以我的经验）通常涉及（至少）使用示波器。除非您的同事愿意至少花一些时间与硬件进行物理接触并以微秒和伏特为单位进行思考，否则我很想离开它们。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-10-23T21:34:39.253

同意“硬”这个词是相当相对的。

我会说不同，因为您需要采用在其他类型的环境中不会使用的不同开发模式。例如，时间限制可能需要学习曲线。然而好奇，这对开发人员来说是一种品质，不是吗？

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-10-23T21:40:32.347

你是对的，任何有足够知识不会完全迷失在某个领域（在驼峰上？）的人都会享受学习新事物的挑战。

我自己会感到非常紧张，因为要在环境中感到舒适，需要大量的背景知识才能转移到指令集等级别。

如果您能够支持开发人员学习如何做到这一点，它可能会有所作为。有一个人在那里你可以询问和讨论问题，这对这种领域的变化有很大的帮助。

作为第一步，将开发人员与其他人一起分配到一个较小的项目可能是值得的，看看情况如何。如果他表达了尝试另一个项目的热情，事情应该从那里继续下去。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-10-23T22:08:18.483

我想说这并不难，它只是需要不同的知识集，不同的考虑。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-10-23T23:16:53.320

我认为这取决于他们在选择的环境中编程的方式，以及您所谈论的嵌入式工作的类型。

例如，在嵌入式 linux 平台上工作比在根本没有操作系统的 8 位平台上编写代码要小得多。

如果他们是那种了解他们习惯的 api 和环境下发生的事情的人，那么进入嵌入式开发就不会太费力了。

但是，如果他们的世界观停留在他们一直在使用的高级 api 上，并且他们对这之下的任何东西都没有概念，那么他们将很难过。

作为一个（非常）一般性的陈述，如果他们对多线程应用程序工作感到满意，他们可能会没事，因为这与您在处理嵌入式项目时遇到的一些数据易失性问题相同。

综上所述，我见过更多的嵌入式程序员在 PC 开发中成功工作，而不是相反。（当然我可能没有看到一个公平的横截面）

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2008-10-24T00:03:00.687

“但是当我和他谈论做低级编程时，他同时表达了对加入该项目的兴趣和怀疑/不确定性。” -- 这意味着你让他尝试并且你准备雇用其他人以防他没有通过学习曲线。

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2013-03-26T14:55:02.763

我最初是一名软件工程师，现在我是一名硬件工程师！重要的是要了解它是如何工作的并有动力！

# c++ - 跟踪打开特定文件的进程

> ID：231547
> 
> 赞同：3
> 
> 时间：2008-10-23T21:11:07.023
> 
> 标签：c++, winapi, file, process-management

在 Windows 的内核模式下，我几乎可以拦截和监控在特定磁盘上执行的所有操作。当出于任何目的打开文件时，我会收到一个事件。

现在我想追踪打开它的应用程序。我认为这应该是可能的，但不知道如何。

我正在使用 Windows Win32 API 中的标准文件管理功能。

提前致谢。

/罗伯特

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-23T21:15:12.943

[Sysinternals Filemon](http://technet.microsoft.com/en-us/sysinternals/bb896642.aspx)（免费）这样做，更好的是他们描述了他们是如何做到的：

> 对于 Windows 9x 驱动程序，FileMon 的核心是虚拟设备驱动程序 Filevxd.vxd。它是动态加载的，并在初始化时通过 VxD 服务 IFSMGR_InstallFileSystemApiHook 安装文件系统过滤器，以将自身插入到所有文件系统请求的调用链中。在 Windows NT 上，FileMon 的核心是一个文件系统驱动程序，它创建过滤设备对象并将其附加到目标文件系统设备对象，以便 FileMon 将看到所有指向驱动器的 IRP 和 FastIO 请求。当 FileMon 看到打开、创建或关闭调用时，它会更新一个内部哈希表，该哈希表用作内部文件句柄和文件路径名之间的映射。每当它看到基于句柄的调用时，它就会在哈希表中查找句柄以获得显示的全名。

-亚当

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T21:26:03.030

Sysinternals 在做这件事和解释它方面做得非常好，例如，一些旧版本的源代码在[这里](http://www.wasm.ru/baixado.php?mode=tool&id=283)仍然可用，并且代码有据可查（恕我直言）。这也可能是一个好的开始。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T21:14:38.170

我会使用 Sysinternals 的“handle.exe”应用程序。

或者，您实际上是在尝试以编程方式执行此操作吗？

* * *

## 回答 #4

> 赞同：-3
> 
> 时间：2008-10-24T15:52:17.463

只需使用 Win32 N.API 从文件句柄中获取 pid。这是一个 15 年的常见问题解答...

# java - 有没有人使用或编写过 Ant 任务来将（Rhino）JavaScript 编译为 Java 字节码？

> ID：231550
> 
> 赞同：7
> 
> 时间：2008-10-23T21:11:51.747
> 
> 标签：java, javascript, ant, rhino

我想使用[Rhino JavaScript](https://developer.mozilla.org/en/Rhino_JavaScript_Compiler)编译器将一些 JavaScript 编译为 .class 字节码文件，以便在项目中使用。看起来这应该已经存在，因为 Groovy、NetREXX(!) 和 Jython 分别有 groovyc、netrexxc 和 jythonc 任务。有没有人使用或编写过这样的 Ant 任务，或者任何人都可以提供一些关于如何编写的提示？

理想情况下，它将有一些方法来解决 JavaScript 或 Java 类之间的依赖关系。

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2010-08-25T15:14:21.467

我在我的项目中使用[RequireJS](http://requirejs.org/)，它包括一个脚本，该脚本跟踪模块之间的依赖关系，并将它们组合成一个 JavaScript 文件。或者，它还可以使用 Google Closure 编译器缩小组合的 js 文件。一旦采用这种形式，其中所有依赖项都包含在单个 js 文件中，就可以使用 jsc 轻松编译该文件。

这是我用来创建单个组合 js 文件，将其编译为类文件，然后创建可执行 JAR 的 ant 脚本的一部分：

```
<target name="compile-single-js">
    <mkdir dir="${build-js}"/>

    <java classname="org.mozilla.javascript.tools.shell.Main">
        <classpath>
            <path refid="rhino-classpath"/>
            <path refid="closure-classpath"/>
        </classpath>
        <arg value="${js-build-script}"/>
        <arg value="${js-build-dir}"/>
        <arg value="name=${build-js-main-rhino-frontend-module}"/> 
        <arg value="out=${build-js-main}"/>
        <arg value="baseUrl=."/>
        <arg value="includeRequire=true"/>
        <arg value="inlineText=true"/> 
        <arg value="optimize=none"/>
    </java>
</target>

<target name="compile-single-class" depends="compile-single-js">
    <mkdir dir="${build-class}"/>

    <!-- TODO: set -opt -->
    <java classname="org.mozilla.javascript.tools.jsc.Main">
        <classpath>
            <path refid="rhino-classpath"/>
        </classpath>
        <arg value="-o"/>
        <arg value="${build-class-main-name}.class"/>
        <arg value="${build-js-main}"/>
    </java>
    <move file="${build-js}/${build-class-main-name}.class" todir="${build-class}"/>
</target>

<target name="jar-single-class" depends="compile-single-class">
    <mkdir dir="${build-jar}"/>

    <jar destfile="${build-jar-main}"
        basedir="${build-class}"
        includes="${build-class-main-name}.class">
        <manifest>
            <attribute name="Main-Class" value="${build-class-main-name}" />
        </manifest>
    </jar>
</target> 
```

完整的构建脚本可以在[这里](https://svn.apache.org/repos/asf/commons/sandbox/gsoc/2010/scxml-js/trunk/build.xml)找到。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-23T22:15:24.723

为什么不简单地使用 java 任务？

```
<java fork="yes" 
  classpathref="build.path" 
  classname="org.mozilla.javascript.tools.jsc.Main" 
  failonerror="true">
    <arg value="-debug"/>
        ...
    <arg value="file.js"/>          
</java> 
```

有异议吗？

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2009-07-16T21:26:19.333

这是我用于我的 rhino 应用程序的示例 build.xml。如果你有很多 javascript 文件，你只需要不断添加更多标签
~:ant compile jar run

```
<project>
<target name="compile">
    <mkdir dir="build/classes"/>
    <java fork="yes" 
      classpath="js.jar" 
      classname="org.mozilla.javascript.tools.jsc.Main" 
      failonerror="true">
        <arg value="-nosource"/>
        <arg value="-opt"/>
        <arg value="9"/>
        <arg value="-version"/>
        <arg value="170"/>
        <arg value="src/SwingApplication.js"/>
    </java>
    <move todir="build/classes">
        <fileset dir="src">
            <include name="**/*.class"/>
        </fileset>
    </move>
</target>
<target name="jar">
    <mkdir dir="build/jar"/>
    <jar destfile="build/jar/SwingApplication.jar" basedir="build/classes">
        <zipfileset src="js.jar" includes="**/*.class"/>
        <manifest>
            <attribute name="Main-Class" value="SwingApplication"/>
        </manifest>
    </jar>
</target>
<target name="run">
    <exec executable="java">
        <arg valUe="-jar"/>
        <arg value="build/jar/SwingApplication.jar"/>
    </exec>
</target>
</project> 
```

~

# xml - 设计 XML 模式的最佳实践是什么？

> ID：231553
> 
> 赞同：43
> 
> 时间：2008-10-23T21:12:16.833
> 
> 标签：xml, xsd

作为一名业余软件开发人员（我还在学术界），我已经为 XML 文档编写了一些模式。我经常遇到导致 XML 文档难看的设计错误，因为我不完全确定 XML 的语义到底是什么。

我的假设：

```
<property> value </property> 
```

属性=值

```
<property attribute="attval"> value </property> 
```

具有特殊描述符的属性，即属性。

```
<parent>
  <child> value </child>
</parent> 
```

父母有一个特征“孩子”，它的价值是“价值”。

```
<tag /> 
```

“标签”是一个标志或直接翻译成文本。我不确定这个。

```
<parent>
  <child />
</parent> 
```

“孩子”描述“父母”。“child”是一个标志或布尔值。我也不确定这个。

如果您想做诸如表示笛卡尔坐标之类的事情，则会出现歧义：

```
<coordinate x="0" y="1" />

<coordinate> 0,1 </coordinate>

<coordinate> <x> 0 </x> <y> 1 </y> </coordinate> 
```

这些选项中哪一个最正确？根据我目前对 XML 模式设计的概念，我会倾向于第三种，但我真的不知道。

有哪些资源可以简洁地描述如何有效地设计 xml 模式？

* * *

## 回答 #1

> 赞同：25
> 
> 时间：2008-10-23T21:52:31.073

一个普遍（但重要！）的建议是永远不要将多个逻辑数据块存储在单个节点（无论是文本节点还是属性节点）中。否则，您最终需要在通常从框架中免费获得的 XML 解析逻辑**之上使用自己的解析逻辑。**

所以在你的坐标例子中， `<coordinate x="0" y="1" />` 对 `<coordinate> <x>0</x> <y>1</y> </coordinate>` 我来说都是合理的。

但这`<coordinate> 0,1 </coordinate>`不是很好，因为它在单个 XML 节点中存储了两个逻辑数据（X 坐标和 Y 坐标）——迫使消费者在他们的 XML 解析器**之外解析数据。**虽然用逗号分割字符串非常简单，但仍然存在一些歧义，例如如果末尾有一个额外的逗号会发生什么。

* * *

## 回答 #2

> 赞同：17
> 
> 时间：2008-11-18T04:13:32.557

看教程：

*   [**Roger Costello**](http://www.xfront.com/)的“ [**XML 模式：最佳实践**](http://www.xfront.com/BestPracticesHomepage.html)” 。[](http://www.xfront.com/)

 **我还推荐：

*   [**Priscilla Walmsley**](http://www.datypic.com/about.html)的书“ [**Definitive XML Schema**](https://rads.stackoverflow.com/amzn/click/com/0130655678) ”。

*   [**Jeni Tennison**](http://www.jenitennison.com/)的[**XML Schema 页面**](http://www.jenitennison.com/schema/index.html)

* * *

## 回答 #3

> 赞同：11
> 
> 时间：2008-10-24T02:36:27.600

我同意以下 cdragon 的建议以避免选项 #2。#1 和 #3 之间的选择很大程度上取决于风格。我喜欢将属性用于我认为是实体的属性，而将元素用于我认为是数据的东西。有时，很难分类。尽管如此，两者都不是“错误的”。

当我们讨论模式设计的主题时，我将添加我的两分钱，关于我喜欢的（最大）重用级别（元素和类型），这也可以促进这些实体的外部“逻辑”引用，比如说，存储在数据库中的数据字典。

请注意，虽然“伊甸园”模式模式提供了最大的重用性，但它也涉及最多的工作。在这篇文章的底部，我提供了指向博客系列中涵盖的其他模式的链接。

•**伊甸园方法** [http://blogs.msdn.com/skaufman/archive/2005/05/10/416269.aspx](http://blogs.msdn.com/skaufman/archive/2005/05/10/416269.aspx)

> 通过全局定义所有元素来使用模块化方法，并且像 Venetian Blind 方法一样，所有类型定义都是全局声明的。每个元素都被全局定义为节点的直接子节点，并且其类型属性可以设置为指定的复杂类型之一。

```
<?xml version="1.0" encoding="UTF-8"?> 
<xs:schema targetNamespace="TargetNamespace" xmlns:TN="TargetNamespace" 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  elementFormDefault="qualified" attributeFormDefault="unqualified"/> 
<xs:element name="BookInformation" type="BookInformationType"/> 
  <xs:complexType name="BookInformationType"/> 
    <xs:sequence> 
      <xs:element ref="Title"/> 
      <xs:element ref="ISBN"/> 
      <xs:element ref="Publisher"/> 
      <xs:element ref="PeopleInvolved" maxOccurs="unbounded"/> 
    </xs:sequence> 
  </xs:complexType> 
  <xs:complexType name="PeopleInvolvedType"> 
    <xs:sequence> 
      <xs:element name="Author"/> 
    </xs:sequence> 
  </xs:complexType> 
  <xs:element name="Title"/> 
  <xs:element name="ISBN"/> 
  <xs:element name="Publisher"/> 
  <xs:element name="PeopleInvolved" type="PeopleInvolvedType"/> 
</xs:schema> 
```

> 这种方法的优点是模式是可重用的。由于元素和类型都是全局定义的，因此两者都可以重用。这种方法提供了最大数量的可重用内容。缺点是架构冗长。当您创建通用库时，这将是一个合适的设计，在这些库中，您可以对模式元素和类型的范围以及它们在其他模式中的使用做出任何假设，特别是在可扩展性和模块化方面。

由于每个不同的类型和元素都有一个单一的全局定义，这些规范的粒子/组件可以与数据库中的标识符一对一地关联。乍一看，维护文本 XSD 粒子/组件与数据库之间的关联似乎是一项令人厌烦的持续手动任务，但 SQL Server 2005 实际上可以通过语句生成规范架构组件标识符

```
CREATE XML SCHEMA COLLECTION 
```

[http://technet.microsoft.com/en-us/library/ms179457.aspx](http://technet.microsoft.com/en-us/library/ms179457.aspx)

相反，为了从规范粒子构造模式，SQL Server 2005 提供了

```
SELECT xml_schema_namespace function 
```

[http://technet.microsoft.com/en-us/library/ms191170.aspx](http://technet.microsoft.com/en-us/library/ms191170.aspx)

ca·non·i·cal 与数学有关。（方程、坐标等）“最简单或标准形式” [http://dictionary.reference.com/browse/canonical](http://dictionary.reference.com/browse/canonical)

其他更容易构建但不太可重复/更“非规范化/冗余”的模式模式包括

•**俄罗斯娃娃方法**[http://blogs.msdn.com/skaufman/archive/2005/04/21/410486.aspx](http://blogs.msdn.com/skaufman/archive/2005/04/21/410486.aspx)

> 该模式有一个单一的全局元素 - 根元素。所有其他元素和类型都嵌套得越来越深，因为每种类型都适合它上面的类型，所以给它起了名字。由于此设计中的元素是在本地声明的，因此它们不能通过 import 或 include 语句重用。

•**萨拉米切片方法** [http://blogs.msdn.com/skaufman/archive/2005/04/25/411809.aspx](http://blogs.msdn.com/skaufman/archive/2005/04/25/411809.aspx)

> 所有元素都是全局定义的，但类型定义是本地定义的。这样其他模式可以重用这些元素。使用这种方法，具有本地定义类型的全局元素提供了元素内容的完整描述。此信息“切片”是单独声明的，然后重新聚合在一起，也可以拼凑在一起以构建其他模式。

•**威尼斯盲人方法** [http://blogs.msdn.com/skaufman/archive/2005/04/29/413491.aspx](http://blogs.msdn.com/skaufman/archive/2005/04/29/413491.aspx)

> 与俄罗斯娃娃方法类似，它们都使用单个全局元素。Venetian Blind 方法通过全局命名和定义所有类型定义来描述模块化方法（与全局声明元素和本地类型的 Salami Slice 方法相反）。每个全局定义的类型都描述了一个单独的“slat”，并且可以被其他组件重用。此外，根据架构顶部的 elementFormDefault 属性设置，所有本地声明的元素都可以是命名空间限定的或命名空间非限定的（slat 可以“打开”或“关闭”）。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-10-23T21:26:36.680

XML 在设计方面有些主观 - 我认为元素和属性的布局方式没有确切的指导方针，但我倾向于使用元素来表示“事物”和属性来表示单个属性/属性其中。

就坐标示例而言，两者都是完全可以接受的，但我倾向于使用它，`<coordinate x="" y=""/>`因为它更简洁，并且如果你有很多这样的文档，会使文档更具可读性。

然而，最重要的是模式的命名空间。确保（a）你有一个，并且（b）你有一个版本，这样你将来可以改变并发布一个新版本。版本可以是日期或数字，例如

```
http://company.com/2008/12/something/somethingelse/
urn:company-com:2008-12:something:somethingelse

http://company.com/v1/something/somethingelse/
urn:company-com:v1:something:somethingelse 
```

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-10-23T21:46:10.853

我不知道任何关于如何设计 XML 文档模型的好的学习资源（模式只是指定文档模型的一种正式方式）。

在我看来，对 XML 的一个重要见解是它不是一种语言：它是一种语法。每个文档模型都是一种单独的语言。

不同的文化将各自以自己特殊的方式使用 XML。即使在 W3C 规范中，您也可以在 XSLT 的破折号分隔名称中闻到 Lisp，在 XML Schema 的 camelCaseNames 中闻到 Java。同样，不同的应用程序域将调用不同的 XML 习惯用法。

叙事文档模型（如[HTML](http://www.w3.org/TR/REC-html40/)或[DocBook](http://www.docbook.org/)）倾向于将可打印文本放在文本节点中，将元数据放在元素名称和属性中。

更多面向对象的文档模型（例如[SVG](http://www.w3.org/TR/SVG11/) ）很少或根本不使用文本节点，而只使用元素和属性。

我个人的文档模型设计经验是这样的：

*   如果是那种需要[混合内容](http://www.w3.org/TR/REC-xml/#sec-mixed-content)的免费标签汤，请使用 HTML 和 DocBook 作为灵感来源。其他规则仅在其他方面相关。
*   如果一个值将是复合的或分层的，请使用元素。XML 数据不需要进一步解析，除了已建立的惯用语，例如 IDREFS，它们是简单的以空格分隔的序列。
*   如果一个值可能需要多次出现，请使用元素。
*   如果某个值可能需要进一步细化或稍后丰富，请使用元素。
*   如果一个值显然是原子的（布尔值、数字、日期、标识符、简单标签），并且最多可能出现一次，则使用属性。

另一种说法可能是：

*   如果它是叙述性的，它就不是面向对象的。
*   如果它是面向对象的，则将对象建模为元素，将原子属性建模为属性。

编辑：有些人似乎喜欢完全放弃属性。它没有任何*问题*，但我不喜欢它，因为它会使文档膨胀，并且使它们变得不必要，难以手动读写。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-23T21:39:46.357

在设计基于 XML 的格式时，通常最好考虑一下您所代表的内容。尝试模拟一些符合您预期目的的 XML 数据。一旦您得到满意的满足您的要求的东西，就可以开发模式来验证它。

在设计格式时，我倾向于使用元素来保存数据内容，并使用属性将特征应用于数据，例如 id、名称、类型或有关元素包含的数据的其他元数据。

在这方面，坐标的 XML 表示可能是：

```
<coordinate type="cartesian">
  <ordinate name="x">0</ordinate>
  <ordinate name="y">1</ordinate>
</coordinate> 
```

这迎合了不同的坐标系。如果您知道它们总是笛卡尔坐标，那么更好的实现可能是：

```
<coordinate>
  <x>0</x>
  <y>1</y>
</coordinate> 
```

当然，后者可能会导致更冗长的模式，因为每个元素类型都需要声明（尽管我希望定义一个复杂的类型来实际为这些元素完成艰苦的工作）。

就像在编程中一样，通常有多种方法可以达到相同的目的，但在许多情况下没有对错，只有更好和更坏。重要的是保持一致并尝试直观，以便当其他人查看您的架构时，他们可以理解您试图实现的目标。

您应该始终对您的模式进行版本控制，并确保针对您的模式编写的 XML 表明它是这样的。如果您没有正确地对 XML 进行版本控制，那么在支持写入旧模式的 XML 的同时对模式进行补充将更加困难。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-11-15T17:46:37.113

在我们的 Java 项目中，我们经常使用[JAXB](http://en.wikipedia.org/wiki/JAXB)来自动解析 XML 并将其转换为对象结构。我想对于其他语言你会有类似的东西。合适的生成器可以用您选择的编程语言自动创建对象结构。这使得 XML 的处理通常更加容易，同时仍然具有用于系统之间通信的可移植 XML 表示。

如果您确实使用了这样的自动映射，您会发现这会极大地限制模式 -`<coordinate> <x> 0 </x> <y> 1 </y> </coordinate>`除非您想在翻译中使用特殊魔法，否则这是可行的方法。您最终将得到一个`Coordinate`具有两个属性`x`和`y`模式中声明的适当类型的类。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2017-03-15T18:44:11.787

我被指定编写一堆 XML 模式来将我的公司系统与我们的客户集成。我在 10 多年前设计了十几个，发现规范中的很多扩展特性在实践中都不能很好地工作。在设计新的之前，我已经搜索了当前的最佳实践（并到达这里！）。

上面的一些技巧很有用，但我不喜欢几乎所有的参考资料。我发现最好的设计建议来自微软。

最好的参考是[XML Schema Design Patterns: Avoiding Complexity](https://msdn.microsoft.com/en-us/library/aa468564.aspx)。在这里你会发现这个明智的建议：

> 似乎许多模式作者最好通过理解和利用 W3C XML 模式提供的功能的一个有效子集来获得最佳服务，而不是试图理解该语言的所有深奥和细节。

并详细解释以下准则：

*   为什么应该使用全局和局部元素声明
*   为什么应该使用全局和局部属性声明
*   为什么您应该了解 XML 名称空间如何影响 W3C XML Schema
*   为什么您应该始终将 elementFormDefault 设置为“合格”
*   为什么应该使用属性组
*   为什么你应该使用模型组
*   为什么你应该使用内置的简单类型
*   为什么应该使用复杂类型
*   为什么不应该使用符号声明
*   为什么要谨慎使用替代组
*   为什么你应该更喜欢 key/keyref/unique 而不是 ID/IDREF 来进行身份约束
*   为什么你应该小心使用变色龙模式
*   为什么不应该使用默认值或固定值，尤其是对于 xs:QName 类型
*   为什么应该使用简单类型的限制和扩展
*   为什么应该使用复杂类型的扩展
*   为什么要谨慎使用复杂类型的限制
*   为什么要谨慎使用抽象类型
*   使用通配符来提供明确定义的可扩展点
*   不要使用组或类型重新定义

我对他们的建议的建议是，当他们说*“谨慎使用”*时，你应该避免它。我的印象是 Schema 规范不是由软件开发人员编写的。他们试图使用一些面向对象的概念，但做得一团糟。许多扩展机制是无用的或极其冗长。我真的不明白有人怎么能发明复杂类型的限制。

本站还有两篇不错的文章是：

*   [模式设计模式：应对变化](https://msdn.microsoft.com/en-us/library/aa468563.aspx)
*   [XML Schema 设计模式：是否不需要复杂类型派生？](https://msdn.microsoft.com/en-us/library/aa468548.aspx)

And one tip that is pervasive is to specify your schemas with something different than the official specification. Relax NG looks the most favored specification language. Unfortunately you will loose one of the best features of it that is the standardization.

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-23T21:19:44.930

查看您尝试表示的数据的关系是我发现的最佳方法。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-10-23T21:28:27.020

我经常发现自己在同样的问题上苦苦挣扎，但我发现在实践中这并不重要，xml 只是数据。

也就是说，我通常更喜欢“如果它说明了节点的某些内容，则它是一个属性，否则它是一个子节点”方法。

在您的示例中，我会选择：

```
<coordinate>
    <x>0</x>
    <y>1</y>
</coordinate> 
```

因为 x 和 y 是坐标的属性，实际上并没有说关于 xml 的任何内容，而是关于它所代表的对象。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-10-23T21:40:24.063

我想，这取决于结构的复杂程度或简单程度。
我会将 x 和 y 作为属性，除非 x 和 y 有自己的详细信息

您可以查看用于定义事物的 HTML 或任何其他形式的标记（在 WPF 的情况下为 XAML，在 Flash 的情况下为 MXML）以了解为什么选择某事物作为属性而不是子节点）

如果 x 和 y 不重复，它们可以是属性。

假设坐标有多个 x 和 y，我猜 xml 不允许一个节点具有多个具有相同名称的属性。在这种情况下，您将不得不使用子节点。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-10-23T21:40:40.490

为您想要表示的每个值使用元素或子元素本身并没有错。

主要考虑因素是有时使用属性更简洁。由于一个元素只能具有一个给定名称的属性，因此您会遇到 1:1 的基数。如果您将数据表示为子元素，则可以使用您想要的任何基数（或稍后扩展它）。

Rob Wells 的上述回答是正确的：这取决于您尝试建模的关系。

任何时候，除了 1:1 的关系，显然永远不会有任何东西，一个属性可能会更清晰。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2009-09-28T11:32:58.820

[这](http://www.xmlpatterns.com)是设计 XML 语法的方法的一个很好的列表。

如上所述，这是一种主观做法，但本网站提供了一些有用的指导，例如“使用此模式解决问题 X”……或“优点和缺点是……”。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2012-01-20T20:19:52.390

在处理笛卡尔坐标时，我发现属性形式更易于管理。我的项目往往需要多个命名空间，并且在命名空间之间共享坐标类型定义在子元素形式中变得很难看。在子元素表单中，您必须限定子元素，在基本或根元素上处理命名空间，或者默认为不限定的元素名称（即[命名空间隐藏](http://www.xfront.com/HideVersusExpose.pdf)）

# ssl - 带有 XCRC 和 SSL 的 Windows FTP 服务器（CuteFTP SS 除外）

> ID：231564
> 
> 赞同：0
> 
> 时间：2008-10-23T21:15:41.397
> 
> 标签：ssl, ftp

我目前正在使用 CuteFTP Secure Sever 3.3，但它有问题。它似乎破坏了连接管理，偶尔断开连接并在大文件上死机。

我正在寻找支持 XCRC 的替代品，因为我在 CuteFTP 客户端中使用了*同步文件夹*功能。如果可能，我更愿意通过 XCRC 检测文件相似性，而不是简单的大小/名称/修改日期。

是否还有其他支持 XCRC 和 SSL 的服务器？我正在寻找建议，而不是从 Google 抓取的常规列表。我希望节省自己单独尝试每一个的时间。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-23T21:42:42.170

[SmartFTP](http://www.smartftp.com/support/kb/2549)支持 XCRC，并且运行良好。它不是开源或免费的，但它是一个不错的产品。链接页面还显示了一些支持它的 FTP 服务器。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T21:35:16.787

如果这确实是您想要的，FileZilla 总是好的。 [http://filezilla-project.org/](http://filezilla-project.org/)

SmartFTP 还有一个支持 XCRC 的 FTP 服务器列表[http://www.smartftp.com/support/kb/2549](http://www.smartftp.com/support/kb/2549)

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T21:46:14.923

[Serv-U](http://www.serv-u.com/) ftp 服务器，不是免费的但是相当不错

# algorithm - Knowing the plaintext, how to discover the encryption scheme used?

> ID：231592
> 
> 赞同：4
> 
> 时间：2008-10-23T21:27:47.083
> 
> 标签：algorithm, encryption

I have some char() fields in a DBF table that were left encrypted by a past developer in the project.

However, I know the plaintext result of the decryption of several records. How can I determine the function/algorithm/scheme to decrypt the original data? These are some sample fields:

For cryptext:

```
b5 01 02 c1 e3 0d 0a 
```

plaintext should be:

```
3543921 or 3.543.921 
```

And for cryptext:

```
41 c3 c5 07 17 0d 0a 
```

plaintext should be

```
1851154 or 1.851.154 
```

I believe `0d 0a` is just padding. Was from data gathered in win-1252 encoding (dunno if matters)

**EDIT:** It's for the sake of curiosity and learning. I want to be able to undestand the encryption used(seems a simple one, although is binary data) to recover the value of the fields for the tuples whose plaintext I don't know.

**EDIT 2:** Added a couple samples.

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-23T21:33:02.843

There is no easy way in general case. This question is too general. Try posting these plain + encrypted strings.

EDIT:

*   for the sake of learning you can read this article : [Cryptography on Wikipedia](http://en.wikipedia.org/wiki/Cryptography)
*   if you really beleive the encryption is simple - check if it's a byte (or word) level XOR - see the following pseudocode

    ```
    for (i in originalString) {
    newString[i] = originalString[i] ^ CRYPT_BYTE;
    } 
    ```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T22:05:59.190

Assuming it's not something as simple as a substitution cipher (try frequency analysis) or a poorly applied XOR (e.g., reusing the key; try XORing two ciphertexts with known plaintexts and then see whether the result is the XOR of the plaintexts; or try XORing the ciphertext with itself shifted by some number of bytes), you should probably assume it's well-known stream/block cipher with an unknown key (which most likely consists of ASCII characters). If you have a big enough sample of ciphertext-plaintext pairs, you could start by checking whether plaintexts with the same first few characters/bytes have ciphertexts with the same first characters/bytes. There you might also see whether it's a block or a stream cipher and whether there is any feedback mechanism involved. Padding, if present, might also suggest that it's a block cipher rather than a stream cipher.

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-23T22:16:26.983

Depending on how much effort you want to put into it, you should be able to get somewhere. Start by reading up on [cryptanalysis](http://en.wikipedia.org/wiki/Cryptanalysis), in particular the [methods of cryptanalysis](http://en.wikipedia.org/wiki/Cryptanalysis#Methods_of_cryptanalysis).

The things that will determine how easy this task will be are:

*   how good the encryption method used is; if it's a recent, well-regarded method such as RSA or AES, you're probably out of luck
*   how much ciphertext and plaintext you have -- the more the better
*   what kind of data it is -- simple text is the easiest, while random data would be the hardest
*   whether the data is all encrypted with the same key, or whether multiple keys have been used.

The key to success is don't be disheartened; the history of cryptanalysis is filled with stories of supposedly unbreakable codes being cracked; perhaps the most famous is the Enigma machine from World War II, the cracking of which contributed to the development of modern computers.

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-24T09:59:42.197

We can tell a few things from what you've provided:

*   With a ciphertext length of 7 bytes in each case, it's unlikely to be a block cipher (since block ciphers encrypt a block at a time, their length will be a multiple of the blocksize, and a blocksize of 56 bits is pretty unlikely*).
*   The length of the ciphertext and the number of characters in the plaintext is the same in each case, so it could be straightforward encoding of numbers as ascii with a stream cipher applied.
*   XORing the plaintext (as ascii) and the ciphertext together gives neither a single repeated octet nor the same cryptostream for each, so it's not a trivial cipher. It's also not a simple stream cipher using the same key for both, unless some of the ciphertext bytes are an IV.
*   The last two bytes are identical in ciphertext but not in plaintext. This could be a coincidence but also could be indicative of padding as you suggest. If they are padding, some other encoding mechanism must be used.

Do you know if all the encrypted values are integers, or are other values also possible?

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-23T21:29:36.657

Determining the algorithm used without the corresponding key may not be entirely useful.

If the text is small enough, and you have the plaintext, why would you ant to figure it out? Other than, of course, for curiosity sake?

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-23T21:30:28.340

There's no deterministic way to tell, but often there are hints in the ciphertext. Is it really encrypted (with some sort of key)? Or is it just hashed and (possibly) salted.

If it's hashed, you could get lucky and just google for a matching pair (assuming you have any that are dictionary words) because there are pre-hashed dictionaries already online.

If you have an example of the ciphertext, you could post it, someone might recognize the cipher format...

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-24T16:58:46.783

I think it's a misconception that XOR is an easily decryptable scheme. The theoretically strongest form of encryption is a one-time pad: simply a string of predetermined bits which you xor your plaintext with...

Finite XORs, on the other hand...

# repository-pattern - 从多个 DTO 构造域对象

> ID：231607
> 
> 赞同：4
> 
> 时间：2008-10-23T21:32:19.290
> 
> 标签：repository-pattern, dto, domain-object

假设您有规范的客户域对象。您在三个不同的屏幕上显示客户：外部管理员、内部管理员和更新帐户。

进一步假设每个屏幕仅显示 Customer 对象中包含的所有数据的一个子集。

问题是：当 UI 从每个屏幕传回数据时（例如通过 DTO），它只包含完整客户域对象的子集。因此，当您将该 DTO 发送到客户工厂以重新创建客户对象时，您只有客户的一部分。

然后您将此客户发送到您的客户存储库以保存它，一堆数据将被清除，因为它不存在。悲剧接踵而至。

所以问题是：你将如何处理这个问题？

我的一些想法：

*   在存储库中包含一个参数，指示要更新客户的哪一部分，并忽略其他部分

*   当您加载客户时，将其保存在静态内存中、会话中或任何地方，然后当您从 UI 接收到其中一个 DTO 时，仅更新与 DTO 相关的部分

IMO，这两者都是kludges。还有其他更好的想法吗？

@chadmyers：这是问题所在。

实体具有属性 A、B、C 和 D。

DTO #1 包含 B 和 C 的属性。

DTO #2 包含 C 和 D 的属性。

UI 要求 DTO #1，您从存储库加载实体，将其转换为 DTO #1，仅填写 B 和 C，然后将其提供给 UI。

现在 UI 更新 B 并将 DTO 发回。您重新创建实体，它只填写了 B 和 C，因为这就是 DTO 中包含的全部内容。

现在您要保存仅填充了 B 和 C 的实体，其中 A 和 D 为空/空白。存储库无法知道它是否应该将持久性中的 A 和 D 更新为空白，或者是否应该忽略它们。

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-23T21:48:46.447

在收到 DTO 后，我会使用工厂从存储库中加载完整的客户对象。之后，您只能更新在 DTO 中指定的那些字段。

例如，这还允许您通过检查最后更新的时间戳对您的客户应用一些乐观的并发性。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-23T21:43:11.780

这是一个网络应用程序吗？从存储库加载客户对象，从 DTO 更新它，然后将其保存回来。这对我来说似乎不是一个杂物。:)

更新：根据您的更新（A、B、C、D 示例）

所以我在想的是，当你加载实体时，它已经填写了 A、B、C 和 D。如果 DTO#1 只更新 B 和 C，那没关系。A 和 D 不受影响（这是理想的情况）。

存储库如何处理 B & C 更新取决于他。例如，如果您使用的是 Hibernate/NHibernate，它只会弄清楚并发布更新。

仅仅因为 DTO #1 只有 B 和 C 并不意味着您也必须取消 A 和 D。不要管它们。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2009-02-10T04:47:58.517

起初我错过了这个问题的重点，因为它基于一些我认为从设计角度来看没有意义的事情。

1.  从存储库中水化一个实体，然后将其转换为 DTO 是浪费精力。我假设您的 DAL 将 DTO 传递给您的存储库，然后将其转换为完整的实体对象。因此将其转换回 DTO 似乎很浪费。

2.  如果您的搜索结果页面显示大量记录并且仅显示部分实体数据，则拥有多个 DTO 是有意义的。在这种情况下，只传递该页面所需的数据是有效的。将包含部分数据的 DTO 传递给 CRUD 页面是没有意义的。只需给它一个完整的 DTO 甚至一个完整的实体对象。如果它不使用所有数据，很好，不会造成任何伤害。

所以主要问题是我认为您不应该使用部分 DTO 将数据传递到这些页面。如果您使用完整的 DTO，我会在执行保存操作时执行以下 3 个步骤：

1.  从存储库或数据库中提取完整的 DTO
2.  使用通过表单所做的任何更改更新 DTO
3.  将完整的 DTO 保存回存储库或数据库

此方法需要额外的数据库命中，但这在 CRUD 表单上确实不是一个重要问题。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2009-05-25T00:12:12.297

如果我们了解存储库（几乎完全）处理非常丰富的域实体，那么您众多的 DTO 可以简单地映射回来。

IE

```
dtoUser.MapFrom<In,Out>(Entity)
or
dtoAdmin.MapFrom<In,Out>(Entity) 
```

您将执行相反的操作以将 dto 信息返回给实体，依此类推。所以你的存储库只保存了丰富的实体而不是大量的 DTO

```
entity.Foo = dtoUser.Foo
or
entity.Bar = dtoAdmin.Bar

entityRepsotiry.Save(entity) <-- do not pass DTO. 
```

DTO 的全部意义在于使演示文稿保持简单，或者说 WCF 数据传输，它与存储库或实体无关。

此外，您永远不应该从 DTO 构造实体......获取实体的唯一两种方法是分别通过工厂（新）或存储库（现有）。

您提到将实体存储在某个地方，您为什么要这样做？那是您的存储库的工作。它将决定从哪里获取实体（数据库、缓存等），无需将其存储在其他地方。

希望这有助于在您的域中分配责任，这始终是一个挑战，并且到处都有灰色区域，但总的来说，这些是存储库、DTO 等的典型用途

# vbscript - 在 VBScript 中重写 CreateObject 函数

> ID：231630
> 
> 赞同：0
> 
> 时间：2008-10-23T21:39:47.247
> 
> 标签：vbscript, createobject

我想用我自己的覆盖 VBScript 中的默认 CreateObject() 函数。

基本上这个例子在VB6中：

[http://www.darinhiggins.com/the-vb6-createobject-function/](http://www.darinhiggins.com/the-vb6-createobject-function/)

我不知道是这条线：

```
 Set CreateObject = VBA.CreateObject(Class$, ServerName$) 
```

如何在 VBSript 中引用“VBA”？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-23T21:55:52.143

这个快速测试似乎有效......

```
Function CreateObject(className, serverName)
   '---- override the CreateObject
   '     function in order to register what
   '     object is being created in any error message
   '     that's generated
   Dim source, descr, errNum

   WScript.echo "In custom CreateObject"
   If Len(serverName) > 0 Then
      Set CreateObject = WScript.CreateObject(className, serverName)
   Else
      Set CreateObject = WScript.CreateObject(className)
   End If

End Function

Dim fso
Set fso = CreateObject("Scripting.FileSystemObject", "")
path = fso.GetAbsolutePathName(".")

WScript.echo path 
```

没有保证！;-)

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T21:46:34.517

我不认为你可以覆盖它，以便所有代码都使用它，只有你的代码。

在这种情况下，它叫什么并不重要（除非您有大量无法更改的现有代码）。你可以称它为 CreateObjectEx() 或 ExCreateObject() 或类似的东西吗？让此函数添加所有错误处理等，然后转身并调用主/核心 CreateObject() 方法

# php - 为什么这个正则表达式在 PHP 中不起作用？

> ID：231637
> 
> 赞同：3
> 
> 时间：2008-10-23T21:41:16.447
> 
> 标签：php, regex

我需要匹配（不区分大小写）“abcd”和可选的商标符号

正则表达式：`/abcd(™)?/gi`

参见示例：

```
preg_match("/abcd(™)?/gi","AbCd™  U9+",$matches);
print_r($matches); 
```

当我运行它时，`$matches`没有填充任何东西......甚至没有创建为空数组。有任何想法吗？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-23T21:46:22.163

你的文件是如何编码的？PHP 在涉及 unicode 时遇到了问题。在您的情况下，请尝试使用转义序列`\x99`而不是直接嵌入 TM 符号。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-23T21:47:03.690

**注意：**我不是 PHP 专家。但是，这似乎是关于字符编码的问题。例如，您的 PHP 文件可以编码为 win-1252（其中 ™ 编码为`\x99`），而您尝试匹配的数据可以编码为 UTF-8（其中 ™ 编码为`\xe2\x84\xa2`），反之亦然（即您的文件是 UTF-8 并且您的数据是 win-1252）。试着朝这个方向看，并给我们更多关于你在做什么的信息。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-23T21:44:24.723

我怀疑这与文字商标符号有关。

您可能想了解如何[在正则表达式中使用 Unicode](http://www.regular-expressions.info/unicode.html)，然后为[商标符号](http://www.fileformat.info/info/unicode/char/2122/index.htm)嵌入转义序列。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-23T21:55:31.300

这是多种事物的结合……这是最终奏效的正则表达式：

```
/abcd(\xe2\x84\xa2)?/i 
```

我不得不删除`/g`修饰符并将 tm 符号更改为`\xe2\x84\xa2`.

# visual-studio-2008 - 对加载解决方案时 Visual Studio 2008 崩溃进行故障排除

> ID：231638
> 
> 赞同：4
> 
> 时间：2008-10-23T21:41:28.943
> 
> 标签：visual-studio-2008

我已经通过 SVN 下载了 SubSonic 的源代码。当我尝试在 Visual Studio 2008 中打开项目时，它会转换解决方案，加载所有项目，然后消失且没有错误消息。解决方案的后续加载也是如此。如果我运行 devenv /safemode 然后打开项目它工作正常，但我不能使用任何加载项。

有什么想法可以追踪坠机事件吗？

编辑：在事件查看器中：

```
    事件类型：错误
    事件源：.NET 运行时事件
    类别：无
    事件编号：1023
    日期：2008 年 10 月 23 日
    时间：下午 4:45:05  
    用户：不适用
    电脑：Foo
    说明：.NET 运行时版本 2.0.50727.3053 - 致命执行引擎错误 (7A035E00) (80131506)

```

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-23T21:53:17.530

这是与 PowerCommands 的冲突（请参阅[ASP.NET MVC CTP5 崩溃 IDE](https://stackoverflow.com/questions/134131/aspnet-mvc-ctp5-crashing-ide)）

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T21:55:36.997

似乎报告了此问题：

[http://code.msdn.microsoft.com/PowerCommands/WorkItem/View.aspx?WorkItemId=34](http://code.msdn.microsoft.com/PowerCommands/WorkItem/View.aspx?WorkItemId=34)

# math - 绘制二维隐式标量场的等值线

> ID：231642
> 
> 赞同：5
> 
> 时间：2008-10-23T21:42:05.087
> 
> 标签：math, graphics, function, 2d, contour

我有一个在 2D 中定义的隐式标量场，对于 2D 中的每个点，我都可以让它计算一个精确的标量值，但它的计算有点复杂。
我想画一条该表面的等值线，比如“0”值的线。函数本身是连续的，但“0”等值线可以有多个连续实例，不能保证所有实例都连接。
计算每个像素的值不是一种选择，因为这会花费太多时间 - 大约几秒钟，并且需要尽可能实时。

我目前使用的是空间的递归划分，可以被认为是一种四叉树。我对空间进行了一个初始的、非常粗略的采样，如果我找到一个包含从正值到负值的过渡的正方形，我将它递归地划分为 4 个较小的正方形并再次检查，在像素级别停止。通过在其 4 个角采样一个正方形来检测正负转换。这工作得相当好，除非它没有。绘制的等值线有时会被剪切，因为对于发生在边缘的小区域且不跨越正方形角的过渡，过渡检测失败。

在此设置中是否有更好的方法来绘制等线图？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-23T21:46:04.317

我在这里描述的算法取得了很大的成功[http://web.archive.org/web/20140718130446/http://members.bellatlantic.net/~vze2vrva/thesis.html](http://web.archive.org/web/20140718130446/http://members.bellatlantic.net/~vze2vrva/thesis.html) 讨论自适应轮廓（类似于您所描述的），以及一般等高线绘图的其他一些问题。

在不查看每个像素的情况下，没有通用的方法可以保证找到函数的所有轮廓。可能有一个非常小的闭合轮廓，其中函数为正的区域仅约为像素大小，而函数通常为负。除非您的采样足够精细，以至于您将样本放在阳性区域内，否则没有一般的方法可以知道它在那里。

如果您的函数足够平滑，您可能能够猜到这些小的闭合轮廓所在的位置，因为函数的模数在它们周围的区域中变得很小。然后可以仅在这些区域中细化抽样。

# ruby - 如何在 Ruby 中设置套接字超时？

> ID：231647
> 
> 赞同：19
> 
> 时间：2008-10-23T21:44:09.047
> 
> 标签：ruby, network-programming

如何为 Ruby 套接字上的阻塞操作设置超时？

* * *

## 回答 #1

> 赞同：16
> 
> 时间：2008-10-23T21:47:45.763

我发现似乎可行的解决方案是使用[Timeout::timeout](http://www.ruby-doc.org/stdlib/libdoc/timeout/rdoc/index.html)：

```
require 'timeout'
    ...
begin 
    timeout(5) do
        message, client_address = some_socket.recvfrom(1024)
    end
rescue Timeout::Error
    puts "Timed out!"
end 
```

* * *

## 回答 #2

> 赞同：15
> 
> 时间：2008-10-24T07:34:20.337

超时对象是一个很好的解决方案。

这是异步 I/O 的一个示例（本质上是非阻塞的，并且与应用程序的流程异步发生。）

```
IO.select(read_array
[, write_array
[, error_array
[, timeout]]] ) => array or nil 
```

可以用来获得相同的效果。

```
require 'socket'

strmSock1 = TCPSocket::new( "www.dn.se", 80 )
strmSock2 = TCPSocket::new( "www.svd.se", 80 )
# Block until one or more events are received
#result = select( [strmSock1, strmSock2, STDIN], nil, nil )
timeout=5

timeout=100
result = select( [strmSock1, strmSock2], nil, nil,timeout )
puts result.inspect
if result

  for inp in result[0]
    if inp == strmSock1 then
      # data avail on strmSock1
      puts "data avail on strmSock1"
    elsif inp == strmSock2 then
      # data avail on strmSock2
      puts "data avail on strmSock2"
    elsif inp == STDIN
      # data avail on STDIN
      puts "data avail on STDIN"
    end
  end
end 
```

* * *

## 回答 #3

> 赞同：8
> 
> 时间：2010-05-07T19:46:16.673

我认为非阻塞方法是要走的路。
我试过上面提到的文章，仍然可以让它挂起。
这篇文章[非阻塞网络](http://peasleer.wordpress.com/2006/11/14/non-blocking-networking-in-ruby/)和上面的 jonke 方法让我走上了正确的道路。我的服务器在初始连接时被阻塞了，所以我需要它稍微低一点。
套接字 rdoc 可以在 connect_nonblock 中提供更多详细信息

```
def self.open(host, port, timeout=10)
 addr = Socket.getaddrinfo(host, nil)
 sock = Socket.new(Socket.const_get(addr[0][0]), Socket::SOCK_STREAM, 0)

 begin
  sock.connect_nonblock(Socket.pack_sockaddr_in(port, addr[0][3]))
 rescue Errno::EINPROGRESS
  resp = IO.select([sock],nil, nil, timeout.to_i)
  if resp.nil?
    raise Errno::ECONNREFUSED
  end
  begin
    sock.connect_nonblock(Socket.pack_sockaddr_in(port, addr[0][3]))
  rescue Errno::EISCONN
  end
 end
 sock
end 
```

to get a good test. startup a simple socket server and then do a ctrl-z to background it

the IO.select is expecting data to come in on the input stream within 10 seconds. this may not work if that is not the case.

It should be a good replacement for the TCPSocket's open method.

# lisp - Lisp 内省？何时调用函数以及何时退出

> ID：231649
> 
> 赞同：3
> 
> 时间：2008-10-23T21:44:25.957
> 
> 标签：lisp, introspection

使用常见的 lisp，我假设具有自省属性。如何将代码添加到常见的 lisp 代码中，以便告诉我何时调用函数以及何时完成执行。我想采用任何 lisp 代码和对代码的特殊修改。我用 lisp 的 AST 分析计算，这应该是可能的。

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-24T06:25:12.410

您可以使用[`(trace function)`](http://www.sbcl.org/manual/Function-Tracing.html)一个简单的机制。对于更多涉及的内容，这是来自[comp.lang.lisp](http://groups.google.com/group/comp.lang.lisp/browse_thread/thread/75ddcdcc160508b0?pli=1)的一个很好的讨论。

```
[CL_USER]>
(defun fac (n)
    "Naïve factorial implementation"
    (if (< 1 n)
        (* n (fac (- n 1)))
        1))
FAC
[CL_USER]> (trace fac)
;; Tracing function FAC.
(FAC)
[CL_USER]> (fac 5)
1\. Trace: (FAC '5)
2\. Trace: (FAC '4)
3\. Trace: (FAC '3)
4\. Trace: (FAC '2)
5\. Trace: (FAC '1)
5\. Trace: FAC ==> 1
4\. Trace: FAC ==> 2
3\. Trace: FAC ==> 6
2\. Trace: FAC ==> 24
1\. Trace: FAC ==> 120
120
[CL_USER]> 
```

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-28T03:41:44.417

如果[CLOS](http://en.wikipedia.org/wiki/Common_Lisp_Object_System)是一个选项，则它具有[在](http://www.ravenbrook.com/doc/2003/07/15/clos-fundamentals/)其他方法之前、之后和周围运行的 before、after 和 around 方法。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-23T22:27:24.577

Common lisp 有一个 TRACE 函数，它报告指定的每个调用的函数、参数和结果值。这是 Steel Bank 版本的文档页面，但您应该在大多数实现中找到类似的内容：

[http://www.sbcl.org/manual/Function-Tracing.html](http://www.sbcl.org/manual/Function-Tracing.html)

该系统还包括一个分析器：

[http://www.sbcl.org/manual/Det​​erministic-Profiler.html](http://www.sbcl.org/manual/Deterministic-Profiler.html)

# javascript - 依次通过并以以下格式构建数组：“value1”、“value2”、“value3” 我想知道是否有人可以建议使用 jQuery 循环遍历 <select> 元素中的所有 <option> 并构建数组的最佳方法。例如。而不是下面的，其中一个字符串 ins 传递给 autoCompleteArray(), $("#CityLocal").autocompleteArray( [ "Aberdeen", "Ada", "Adamsville", "Zoar" //和一百万

> ID：231666
> 
> 赞同：4
> 
> 时间：2008-10-23T21:48:19.287
> 
> 标签：javascript, jquery, autocomplete

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-10-23T21:55:37.900

这应该有效：

```
$(document).ready(function(){
  // array of option elements' values
  var optionValues = [];
  // array of option elements' text
  var optionTexts = [];

  // iterate through all option elements
  $('#sel > option').each(function() {
    // get value/text and push it into respective array
    optionValues.push($(this).val());
    optionTexts.push($(this).text());
  });

  // test with alert
  alert(optionValues);
  alert(optionTexts);
}); 
```

鉴于您的`select`元素具有 ID *sel*。

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-10-23T22:22:33.633

jQuery.map[函数](http://docs.jquery.com/Utilities/jQuery.map#arraycallback)可能是您正在寻找的。下面的代码将创建一个数组，其中包含选项的所有值或文本值`<select>`。

```
var values = jQuery.map(jQuery("#select")[0].options, function(option)
             {
                return option.value;
             });

var texts = jQuery.map(jQuery("#select")[0].options, function(option)
            {
                return option.innerHTML;
            }); 
```

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-24T01:27:25.397

您需要做的就是将数组作为不带括号的第一个参数传递。括号创建一个新数组，但您不需要这样做，因为您已经在传递一个数组。做就是了：

```
$("#CityLocal").autocompleteArray(
                MyBigArrayOfOptions,
                {
                        delay:10,
                        minChars:1,
                        matchSubset:1,
                        onItemSelect:selectItem,
                        onFindValue:findValue,
                        autoFill:true,
                        maxItemsToShow:10
                }
        ); 
```

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-24T02:06:46.223

如果我正确理解您的问题，以下代码应该可以满足您的需求：

```
myFunction($("#my-select option")); 
```

查询的输出已经是一个选项数组，它们是选择的后代，因此您不需要将它们推入另一个数组。或者，如果您的选择没有 id，但您有 DOM 元素：

```
myFunction($("option", theSelect)); 
```

将此想法重新插入您的代码中：

```
$("#CityLocal").autocompleteArray(
    $("option", theSelect),
    {
            delay:10,
            minChars:1,
            matchSubset:1,
            onItemSelect:selectItem,
            onFindValue:findValue,
            autoFill:true,
            maxItemsToShow:10
    }
); 
```

# xml - 在 grails 中漂亮地打印 XML 响应的最佳方法

> ID：231677
> 
> 赞同：11
> 
> 时间：2008-10-23T21:50:49.127
> 
> 标签：xml, grails, groovy, render, pretty-print

鉴于此在 grails 操作中：

```
def xml = {
    rss(version: '2.0') {
        ...
    }
}
render(contentType: 'application/rss+xml', xml) 
```

我看到这个：

```
<rss><channel><title></title><description></description><link></link><item></item></channel></rss> 
```

有没有一种简单的方法来漂亮地打印 XML？渲染方法中内置的东西，也许？

* * *

## 回答 #1

> 赞同：19
> 
> 时间：2008-10-24T00:33:25.227

这是一种打印 XML 的简单方法，仅使用 Groovy 代码：

```
def xml = "<rss><channel><title></title><description>" +
   "</description><link></link><item></item></channel></rss>"

def stringWriter = new StringWriter()
def node = new XmlParser().parseText(xml);
new XmlNodePrinter(new PrintWriter(stringWriter)).print(node)

println stringWriter.toString() 
```

结果是：

```
<rss>
  <channel>
    <title/>
    <description/>
    <link/>
    <item/>
  </channel>
</rss> 
```

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2010-08-11T15:19:35.200

根据[参考文档](http://grails.org/Converters+Reference)，您可以使用以下配置选项来启用漂亮的打印：

```
 grails.converters.default.pretty.print (Boolean)
 //Whether the default output of the Converters is pretty-printed ( default: false ) 
```

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2011-06-13T05:02:13.050

使用 MarkupBuilder 漂亮地打印您的 Groovy xml

```
def writer = new StringWriter()
def xml = new MarkupBuilder (writer)

xml.rss(version: '2.0') {
        ...
    }
}

render(contentType: 'application/rss+xml', writer.toString()) 
```

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2012-02-29T22:08:50.320

使用 XmlUtil ：

```
def xml = "<rss><channel><title></title><description>" +
   "</description><link></link><item></item></channel></rss>"

println XmlUtil.serialize(xml) 
```

# javascript - 通过javascript获取SVG图形的大小

> ID：231679
> 
> 赞同：10
> 
> 时间：2008-10-23T21:51:47.207
> 
> 标签：javascript, svg

要在 html 页面中添加 svg 图形，通常使用 object 标签来包装它，如下所示：

```
<object id="svgid" data="mysvg.svg" type="image/svg+xml" 
  wmode="transparent" width="100" height="100">

this browser is not able to show SVG: <a linkindex="3"
href="http://getfirefox.com">http://getfirefox.com</a> 
is free and does it!
If you use Internet Explorer, you can also get a plugin: 
<a linkindex="4" href="http://www.adobe.com/svg/viewer/install/main.html">
http://www.adobe.com/svg/viewer/install/main.html</a>

</object> 
```

如果您不在对象标签中使用宽度和高度属性，则 svg 将以全尺寸显示。通常我从 Open Graphics Library 获取 svg 文件进行测试。有没有办法通过使用 JavaScript 来获取 svg 的大小？或者也许我应该只查看 svg xml 文件以找出顶部 svg 标记的大小？

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2009-10-16T12:54:00.627

见[http://dev.opera.com/articles/view/svg-evolution-not-revolution/?page=2](http://dev.opera.com/articles/view/svg-evolution-not-revolution/?page=2)

只要 SVG 文件位于同一个域中，就可以访问 HTML:object 引用的 SVG DOM（否则这将是一个安全漏洞。如果您的对象标签具有 id="myobj" 您可以这样做：

```
var obj = document.getElementById("myobj"); // reference to the object tag
var svgdoc = obj.contentDocument; // reference to the SVG document
var svgelem = svgdoc.documentElement; // reference to the SVG element 
```

然后您可以通过以下方式访问 svg 元素的宽度/高度：

```
svgelem.getAttribute("width")
svgelem.getAttribute("height") 
```

请注意，这些属性可能是“100px”、“300”、“200em”、“40mm”、“100%”之类的东西，因此您需要仔细解析。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-24T14:42:21.757

**> 有没有办法通过使用 JavaScript 来获取 svg 的大小？**

不，是的。

**不：**

JavaScript 将无法访问浏览器中的 SVG 文件内容。

所以不可能有一个包含任意 SVG 图像的页面，然后让 JavaScript 从 SVG 文件本身确定任何内容。

JS 可以访问的唯一数据包含在页面的 DOM 中：原始标记以及对 DOM 的任何与 JS 相关的修改。您可以访问`object`元素的属性和后代节点，但这不会让您看到比您自己查看页面标记所能看到的更多的东西。

**是的：**

JS（在现代浏览器中）可以将任何 XML 字符串解析为 DOM，然后使用基于 DOM 的方法访问内容。

您可以通过发出 xmlHttpRequest 样式的请求来获取 SVG 文件内容（即 JS 对 SVG 文件的 URL 执行 HTTP GET）。JS 将拥有 SVG 文件的完整 XML 字符串，然后您可以访问任何您喜欢的内容。

**> 或者我应该只查看 svg xml 文件以从顶部 svg 标记中找出大小？**

到目前为止，这将更加可行。

唯一基于 JS 的解决方案将需要 JS 对 SVG 文件的 URL 执行 GET 请求（如上），这不太可能 - 每次页面加载都可能导致重复下载每个 SVG 文件，并解析 SVG 的通过 JS 将 XML 转换为 DOM 可能过于占用资源。

让 JS 检索 SVG 的 XML 内容并将其解析为 DOM 以仅检索图像尺寸有点矫枉过正。这是完全可能的，但通常不实用。

在服务器端查询 SVG 的 XML 内容，确定合适的宽度和高度，然后在将标记返回浏览器之前动态添加`width`和属性将是您最好的选择。`height`

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2018-09-19T17:55:31.563

**ES6**：使用`async/await`你可以以类似序列的方式执行此操作

```
async function getImage(url) {
    return new Promise((resolve, reject) => {
        let img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
    });
} 
```

并使用上述功能

```
let img = await getImage("yourimage.svg");
let w = img.width;
let h = img.height; 
```

只要 SVG 文件在同一个域中，您就可以使用它（详情请参阅[此处](https://stackoverflow.com/a/43001137/860099)）。工作示例

```
async function getImage(url) {
  return new Promise((resolve, reject) => {
    let img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}

async function start() {
  // here is example url with embeded svg but you can use any url
  let svgURL = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='120' width='220'%3E%3Cellipse cx='110' cy='60' rx='100' ry='50' stroke='black' stroke-width='3' fill='red' /%3E%3C/svg%3E";

  let img = await getImage(svgURL);
  let w = img.width;
  let h = img.height; 

  // print
  console.log({w,h});
  pic.src = svgURL;
}

start();
```

```
<img id="pic">
```

* * *

## 回答 #4

> 赞同：-6
> 
> 时间：2010-10-17T04:10:33.233

> 有没有办法通过使用 JavaScript 来获取 svg 的大小？

**是的**

```
var filesize = function(url, requestHandler) {
  var requestObj = new XMLHttpRequest();  
  requestObj.open('head', address, true);  
  requestObj.onreadystatechange = callback;
  requestObj.send(null);  
}; 
```

现在是一个处理函数：

```
var requestHandler = function(result) {
    if (this.readyState === 1) {
        this.abort();
    }
    return this.getResponseHeader("Content-length");
};

var size = fileSize("http://whatever.org/someSVGFile.svg", requestHandler);
alert(size); 
```

这应该会顺利返回您的 svg 或任何其他文件的文件大小。服务器配置是唯一可能干扰的事情。

# build - VS 2005 中的增量构建？

> ID：231688
> 
> 赞同：0
> 
> 时间：2008-10-23T21:53:22.973
> 
> 标签：build, visual-studio-2005

我们在 VS 2005 中有 50 个项目的解决方案。

如果没有任何改变，有什么方法可以进行增量构建吗？

它现在有点做，但它为每个项目执行所有预构建和构建后事件。

编译本身并没有发生，但它遍历所有项目并为每个项目执行所有预构建和构建后事件。

有什么办法可以预防吗？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-23T22:52:54.133

[请参阅我在另一个问题中的回答](https://stackoverflow.com/questions/227991/build-incrementally-in-vs-2005#231867)。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-23T21:56:13.530

您可以设置一个单独的项目配置，例如 Debug_INC，并且在这些配置中没有构建前或构建后事件，然后在需要时运行它们。

# sharepoint - Sharepoint：Web 部件与 ASP.NET 用户控制

> ID：231690
> 
> 赞同：11
> 
> 时间：2008-10-23T21:53:42.180
> 
> 标签：sharepoint, web-parts

为 Sharepoint 创建 Web 部件时，是创建一个实际的 Web 部件更好，还是使用 ASP.NET 用户控件 (.ascx) 更好？

我已经知道如何创建我需要的用户控件，因此创建 Web 部件的额外工作似乎只是不必要的工作。

与仅创建和 ASP.NET 用户控件相比，使用 Web 部件有哪些优势？

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-10-23T22:04:55.853

除了最简单的 Web 部件之外，我是用户控件的忠实粉丝。我创建了一个实例化并加载用户控件的 web 部件。您可以使用其他工具来公开您的用户控件，例如 smartpart，但我建议您自己包装它，因为它是一个很好的学习体验。一旦你完成了一次，你基本上就拥有了一个你想要创建的任何其他 webpart 的模板。

祝你好运！

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2008-10-24T01:20:19.843

必须将裸 ASP.NET ascx 控件添加到自定义布局页面。这会稍微限制控件的实用性，因为它不能“在任何地方”添加。

拥有 Web 部件可以灵活地将控件添加到站点中，在不同的位置多次，甚至在具有不同属性的同一页面上多次添加。

正如已经提到`CreateChildControls()`的，在 web 部件中创建控件是很好的，并且将 web 部件编码和打包到解决方案中并不是什么大不了的事情，因此值得付出额外的努力。

Webparts 还能够接受来自同一页面上的“过滤器”webparts 的连接，与在站点上托管 ascx 控件相比，为 webparts 提供了更大的灵活性。

对于使用该站点的编辑器而言，与编辑页面布局、发布它然后基于该页面布局创建页面相比，他们能够添加 Web 部件有很大的不同，所以从站点的角度来看编辑器，可用性上的差异确实很大。

我建议更进一步，对 webpart 进行编码以使用 xslt 文件来显示内容，并使 xslt 的位置成为 webpart 的可配置属性。这*确实*增加了您控制的灵活性。

查看 Dataview Webpart，了解添加自定义渲染可以完成多少工作。

# html - 使用 ActionScript 2.0 POST 登录

> ID：231693
> 
> 赞同：0
> 
> 时间：2008-10-23T21:54:18.370
> 
> 标签：html, flash, actionscript, post, actionscript-2

我为客户创建了一个非常基本的 Flash 网站，但在编写他想要的客户登录功能时遇到了问题。目前，如果我导航到该站点并单击客户端登录，它会将我带到登录页面。我需要这个工作的方式是——在 Flash 中，使用 ActionScript 2.0——让用户输入他们的用户 ID 和密码并单击登录，这会将 POST vars 提交到客户端登录网站的表单操作。

从不同的域做这可能/合法吗？假设有可能，我该怎么做呢？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-23T22:24:04.537

试试这个：

```
myVars = new LoadVars();
myVars.username = username.text;
myVars.password = pwd.text;
myVars.onLoad = function(success) {
        trace("yay!");
    else {
        trace("try again");    
    }
}
myVars.sendAndLoad("login.php", myVars, "POST"); 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T22:37:44.883

所以，我得到“耶！” 使用下面提供的代码（您的代码中有错误）。但是，我需要被重定向到生成的“登录”页面。我怎么做？

```
myVars = new LoadVars();
myVars.txtUserID = "some_user";
myVars.txtPassword = "some_password";
myVars .__ VIEWSTATE = “dDw3MTcxMTg3ODM7dDw7bDxpPDM + O2k8NT47PjtsPHQ8cDxsPFRleHQ7PjtsPGRlbW87Pj47Oz47dDw7bDxpPDE + O2k8Mz47aTw1Pjs + O2w8dDxwPGw8VGV4dDs + O2w8YmFja2dyb3VuZC1jb2xvcjojZjZmNmY2XDtjb2xvcjojMzMzMzMzXDs7Pj47Oz47dDxwPDtwPGw8c3R5bGU7PjtsPHdpZHRoOjEwMHB4XDs7Pj4 +盎司+ O3Q8cDw7cDxsPHN0eWxlOz47bDx3aWR0aDoxMDBweFw7Oz4 + Pjs7Pjs + PJS + PJS + 56k0UDxn5ED61lGLjP0fIkStm6o =”;
myVars.onLoad = 函数（成功）{
    如果（成功）
    {
        跟踪（“耶！”）；
    } 别的 {
        跟踪（“再试一次”）；    
    }
}
myVars.sendAndLoad("http://www.buildertrend.net/loginFrame.aspx?builderID=35&bgcolor=%23f6f6f6&fcolor=%23333333&uwidth=100&pwidth=100", myVars, "POST");

```

# database - 固定大小的数组数据库字段

> ID：231695
> 
> 赞同：2
> 
> 时间：2008-10-23T21:55:16.403
> 
> 标签：database, database-design

我需要在数据库字段中存储几个日期值。这些值将与“用户”相关联，这样每个用户都将拥有自己独特的这几个日期值集。

我可以在这里使用一对多的关系，但每个用户将有 4 个与之相关的日期值，所以我觉得一对多的表会过大（在很多方面，例如速度）但如果我需要查询针对他们，我需要将这 4 个值放在不同的字段中，例如 MyDate1 MyDate2 ... 等，但是用于获取它的 SQL 命令每次都必须检查 4 个值。

所以一对多的关系可能是最好的解决方案，但有没有更好/更干净/更快/其他方式？我的设计是否正确？

该平台是 MS SQL 2005，但任何平台上的解决方案都可以，我主要是在寻找合适的数据库设计技术。

**编辑：** 4 个字段代表同一事物的 4 个实例。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-23T21:58:49.140

如果您将其作为四个单独的字段进行，那么您不必加入。为了避免查询语法过于糟糕，您可以编写：

```
SELECT * FROM MyTable WHERE 'DateLiteral' IN (MyDate1, MyDate2, MyDate3, MyDate4); 
```

正如评论中提到的，IN 运算符在涉及日期字段时非常具体（直到最后（毫秒）秒）。您始终可以在子查询上使用日期时间函数，但 BETWEEN 不可用：

```
SELECT * FROM MyTable WHERE date_trunc('hour', 'DateLiteral') 
IN (date_trunc('hour', MyDate1), date_trunc('hour', MyDate2), date_trunc('hour', MyDate3), date_trunc('hour', MyDate4)); 
```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T23:49:55.237

[像Firebird](http://www.firebirdsql.org)这样的一些数据库具有数组数据类型，它完全符合您的描述。它是这样声明的：

```
alter table t1 add MyDate[4] date; 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T22:35:48.147

对于它的价值，规范化的设计是将日期作为行存储在从属表中。

在单个列中存储多个值不是标准化设计；规范化明确意味着每一列都有一个值。

您可以通过这种方式确保将不超过四行插入到依赖表中：

```
 CREATE TABLE ThisManyDates (n INT PRIMARY KEY);
 INSERT INTO ThisManyDates VALUES (1), (2), (3), (4);

 CREATE TABLE UserDates (
   User_ID INT REFERENCES Users,
   n INT REFERENCES ThisManyDates,
   Date_Value DATE NOT NULL,
   PRIMARY KEY (User_ID, n)
 ); 
```

但是，此设计不允许您强制使用日期值。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T21:57:23.060

有 4 个字段和用户 ID 怎么样（如果你确定，它不会超过那个）？

* * *

## 回答 #5

> 赞同：-1
> 
> 时间：2008-10-23T22:05:39.020

创建四个日期字段并将日期存储在字段中。日期字段可能是您的用户表的一部分，或者它们可能位于以一对一关系连接到用户表的其他表中。这是你的电话。

# css - Myspace 音乐布局问题

> ID：231696
> 
> 赞同：0
> 
> 时间：2008-10-23T21:55:18.743
> 
> 标签：css, layout, myspace

如何将我的内容推送到页面顶部，而不是掩盖广告，而是掩盖菜单和 myspace 链接。我想做类似的事情：[http://www.myspace.com/sensesfail](http://www.myspace.com/sensesfail)和[http://www.myspace.com/attackx2](http://www.myspace.com/attackattack)。谢谢。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-28T15:37:15.207

绝对定位可以工作，或者您可以使用负边距。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-24T01:57:31.047

在不剖析您提供的链接的 html 源代码的情况下（因为我懒得为您完成所有工作），我最好的猜测是他们使用绝对定位（或负相对定位）和高 z-index 来浮动他们默认横幅上的图片

# php - 在 PHP5 中处理内存消耗的策略？

> ID：231707
> 
> 赞同：6
> 
> 时间：2008-10-23T21:57:16.383
> 
> 标签：php, memory

我们有一个大型管理软件，它基于大量循环生成各种大型报告，包括数据库检索、对象创建（许多）等等。

在 PHP4 上，它可以在内存限制为 64 MB 的情况下愉快地运行 - 现在我们已经将它移动到新服务器上并使用相同的数据库 - 相同的代码，相同的报告不会在没有内存限制的情况下出现......

我知道 PHP5 在底层发生了很多变化，但是有没有办法让它表现得更好呢？

最后的问题是，当你需要让你的剧本节食时，你会采用什么策略？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-23T22:29:40.453

我们遇到的一个大问题是对象之间的循环引用阻止它们在超出范围时释放内存。

根据您的架构，您可以使用 __destruct() 并手动取消设置任何引用。对于我们的问题，我最终重组了类并删除了循环引用。

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-10-23T23:16:59.750

当我需要优化任何脚本的资源时，我总是尝试分析、分析和调试我的代码，我使用[xDebug](http://www.xdebug.org/)和[xDebug Profiler](http://www.xdebug.org/docs/profiler)，还有其他选项，例如[APD](http://php.net/apd)和[Benchmark Profiler](http://pear.php.net/package/Benchmark)。

另外我推荐你这篇文章：

*   [使 PHP 应用程序更快、更快、更快..](http://www.ibm.com/developerworks/library/os-php-fastapps2/index.html)
*   [分析 PHP 应用程序](http://www.schlossnagle.org/~george/talks/Profiling-phpworks-2004.pdf) *(PDF)*
*   [PHP 与性能](http://ilia.ws/files/frankfurt_perf.pdf) *(PDF)*

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T22:03:12.223

自从迁移到新服务器后，您是否确认您的 MySQL 和 PHP 系统变量与旧服务器上的方式相同？

PHP5 引入了许多新功能，但由于其向后兼容的口头禅，我认为 PHP5 和 PHP4 之间的差异不会对代码和数据库未更改的应用程序的性能造成如此大的影响。

您是否也在相同版本的 Apache 或 IIS 上运行？

这听起来像是一个更可能与您的新系统环境相关的问题，而不是从 PHP4 升级到 5 的问题。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T22:27:52.080

伯特兰，

如果您对重构现有代码感兴趣，那么我建议您在执行报告时首先监控 CPU 和内存使用情况。您是在锁定您的 SQL 服务器还是在锁定 Apache（如果 PHP 代码对系统施加了很大压力，就会发生这种情况）？

我从事的一个项目最初使 MySQL 严重陷入困境，以至于我们不得不重构整个报告生成过程。然而，当我们完成时，负载只是简单地转移到了 Apache（通过更复杂的 PHP 代码）。我们最终的解决方案是重构数据库设计，为报告功能提供更好的性能，并使用 PHP 来弥补我们在 MySQL 中无法实现的功能。

根据报告的性质，您可能会考虑对用于报告的数据进行非规范化处理。您甚至可以考虑构建第二个数据库，用作数据仓库，并围绕 OLAP 原则而不是 OLTP 原则设计。您可以从 Wikipedia 开始，了解 OLAP 和数据仓库的一般说明。

但是，在开始认真重构之前，您是否通过查看 phpinfo(); 来验证您的环境是否足够相似？用于 PHP 和显示变量；在 MySQL 中？

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-11-11T02:54:50.057

演出！？！

甚至 64MB 也很大。

忽略环境之间的差异（听起来确实很奇怪），听起来代码可能需要一些重构。

任何机会您都可以重构您的代码，以便数据库查询的结果集不会转储到数组中。我建议您为结果集构建一个迭代器。（因此您可以在大多数情况下将它们视为数组）。一次处理一条记录与一次处理 10,000 条记录之间存在很大差异。

其次，看看你的代码正在创建多个数据实例的天气。你能通过引用传递对象吗？（使用 '＆'）。在使用 horde 框架的早期变体时，我们必须做类似的事情。一个 1 MB 的附件会因多次调用而膨胀到 50 MB，这些调用将整个数据集作为副本传递，而不是作为参考。

# sql-server-2005 - 如何在 SQL Management Studio 2005 中制作脚本？

> ID：231716
> 
> 赞同：3
> 
> 时间：2008-10-23T22:01:01.993
> 
> 标签：sql-server-2005

我在 MS SQL Server 数据库中有一个表。我想创建一个脚本，将表和所有记录放入另一个数据库。所以我在 Management Studio 中右键单击表并选择 Create-To new query editor... 但我得到的只是表结构。

我究竟如何获得这些值？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-23T22:04:15.153

可以肯定的是，SQL Server 缺少开箱即用的 MySQL 工具是我真正喜欢的一件事。

但是，您可以使用[脚本来执行此操作](http://vyaskn.tripod.com/code/generate_inserts.txt)。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-23T22:22:20.310

您可能还想考虑使用[Red-Gate SQL Compare](http://www.red-gate.com/products/SQL_Compare/index.htm)和[Red-Gate SQL Data Compare 之](http://www.red-gate.com/products/SQL_Data_Compare/index.htm)类的东西。它们不是便宜的工具，每个售价 395 美元（标准版），但有 14 天的免费试用版可供下载，它们使得将架构和数据从一个 SQL Server 复制到另一个非常容易。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-23T22:16:21.290

如果两者都在同一台机器上（或在不同的机器上但[服务器是链接](http://msdn.microsoft.com/en-us/library/aa213778(SQL.80).aspx)的），您可以使用可以自动生成的脚本创建表并执行此操作以复制数据：

```
INSERT INTO [destinationdb].[dbo].[destinationtable] SELECT * 
FROM [originaldb].[dbo].[originaltable] 
```

（如果您将使用链接服务器，请将 [servername] 添加到数据库名称）

另一种选择是[启用 xp_cmdshell](http://weblogs.sqlteam.com/tarad/archive/2006/09/14/12103.aspx)（小心操作，它会放宽安全限制）并使用管理工作室中的[bcp](http://www.windowsitlibrary.com/Content/77/14/1.html)命令行实用程序创建副本，然后您可以将其导入其他数据库/服务器。当然，您也可以直接从 shell 执行此操作，并且在这种情况下不需要启用 xp_cmdshell。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-23T22:39:35.580

它并没有真正创建“SQL 脚本”，但它完成了这项工作：

*   在对象资源管理器中选择数据库

*   右键点击

*   选择导入/导出数据

*   跟随向导

*   在流程结束时，您可以保存“集成服务包”以重复使用它

*   稍后您可以通过打开 .dtsx 来修改详细信息

*   （它会照顾安全，不会多花一分钱，看来我们必须与其他答案竞争:)）

希望能帮助到你。

# java - 在 Netbeans 中使用 Master/Detail Sample Form 时如何加入另一个 MySQL 表？

> ID：231720
> 
> 赞同：1
> 
> 时间：2008-10-23T22:02:43.953
> 
> 标签：java, mysql, netbeans

我正在尝试使用 MySQL/JAVA 来实现一个应用程序，我在 netbeans 中找到了这个工具，可以轻松地为现有表创建一个新表单。（编辑、插入、删除等）是否有一种简单的方法可以修改代码以加入另一个表以显示该表中的字段。

示例：我有一个具有外键 TitleID 的员工表和另一个名为 Title 的表，该表具有 TitleID 和 TitleName。我想在主表员工中显示 TitleName 而不是 TitleID。

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2008-11-02T19:33:23.727

我认为您不会在 NetBeans 中找到类似的东西。但是，如果您的数据库设计足够简单（即标题示例是真实的），您可以尝试使用可更新视图（[更多信息](http://dev.mysql.com/doc/refman/5.0/en/create-view.html)）并将其用作表格。

在复杂的情况下，您将不得不重写（扩展？）您用于数据库访问的任何类。但是仍然应该可以使用您一直在使用的任何 UI 组件。

# java - NetBeans 6.5 上的强制外观

> ID：231738
> 
> 赞同：4
> 
> 时间：2008-10-23T22:11:29.710
> 
> 标签：java, netbeans, look-and-feel

您如何看待 NetBeans 6.5 的特定外观？我的意思是通过将标志传递给 netbeans 脚本（在 Ubuntu 上）或通过修改 netbeans 脚本或通过一些设置。

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-24T14:50:49.883

在您的 netbeans.conf 文件中，[将“--laf”添加](http://wiki.netbeans.org/FaqCustomLaf)到您的`netbeans_default_options`值中。

查看[Netbeans Wiki](http://wiki.netbeans.org/)。

注意：截至 2008 年 8 月 25 日， [Netbeans Substance 插件](http://wiki.netbeans.org/LookAndFeel)不再处于开发阶段。

# asp.net - 如何从动态添加的文本框中检索数据？

> ID：231739
> 
> 赞同：1
> 
> 时间：2008-10-23T22:11:29.960
> 
> 标签：asp.net, textbox, dynamic-controls

我将文本框（不是固定数量的文本框）动态添加到 ASP.NET 页面上的表单中，我如何从这些文本框中读回数据？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-23T22:18:48.307

假设您想要访问回发上的控件，您可能会重新创建动态控件，就像它们在初始加载时创建的一样，然后使用页面的 FindControls 方法来查找控件。使用 Textbox1、Textbox2 等 ID 创建文本框可能会有所帮助。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T22:13:38.550

查看 Request.Params 并从那里提取它们。当然，你必须给他们 id 才能区分他们。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T22:14:18.877

当您添加它们时，您应该为它们提供名称/ID，并且您可以使用它们来引用它们。

如果没有，请在 javascript 中遍历您的 DOM 以在您制作的表单中找到它们 - 它们的顺序与您插入它们的顺序相同。

最后，它们都可以作为您页面的 post/get 输入使用，因此只要您为它们分配不同的名称，您就应该能够查看它们。

-亚当

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-23T22:18:17.183

在我使用过的所有 ASP.NET 应用程序中，.NET 在为服务器控件生成 Id 时喜欢使用以下算法：

```
ctl00$cphBody$[ControlID] 
```

从动态生成的文本框访问数据时，请尝试使用此算法。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-23T22:23:42.773

动态创建文本框时（可能使用 JavaScript，但 ASP.NET 控件也是如此）以特定模式为它们命名。你以后*能认出*的那个。

在服务器端，在 Page_Init 之后发生的任何事件处理程序中，您都可以遍历[Request.Form](http://msdn.microsoft.com/en-us/library/system.web.httprequest.form.aspx)集合。

不要试图使用 Request.Param，因为它可用于在您的应用程序上应用跨站点请求伪造（攻击者可能会引诱用户发出 GET 请求，您的应用程序会像解释 POST 请求一样解释该请求，这通常不是一件好事）。

如果要添加动态 ASP.NET 控件（例如在 Page_Render 中），您还可以重构控件并使用它们的属性。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-23T22:30:51.090

您可以使用 FindControl 并在回发时传递文本框 ID 以获取文本框的实例。Text 属性包含数据，假设我们处于页面加载阶段或周期的后期。添加动态控件时，重写 CreateChildControls 方法并在循环的此阶段将动态控件添加到控件层次结构中。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-23T22:37:26.427

请记住，在 ASP.Net 中，每个回发都是您的类的一个新实例。如果您在之前的回发期间或在第一个视图中创建了这些控件，那么它们将与之前实例的其余部分一起被垃圾收集。因此，要在这个新实例中使用控件，您需要再次创建它们。如果您需要为这些控件加载状态信息（包括用户输入的任何值），您还需要在加载视图状态*之前*创建，这意味着您在 Init 事件而不是加载事件期间执行此操作。

* * *

## 回答 #8

> 赞同：-2
> 
> 时间：2008-10-23T22:29:49.423

要创建动态控件，我通常会使用 ASP.NET PlaceHolder 控件并将动态控件添加到此容器中。

我会给每个动态控件一个 ID。

随后，您可以在 PlaceHolder 上使用 FindControl 来访问动态控件。

我说“动态控件”是指您在运行时添加的控件

# asp.net - 你如何压缩存储在会话/缓存中的对象？

> ID：231740
> 
> 赞同：2
> 
> 时间：2008-10-23T22:12:08.787
> 
> 标签：asp.net, compression

Scott Hanselman 最近发布了[一篇博客文章](http://www.hanselman.com/blog/TheWeeklySourceCode35ZipCompressingASPNETSessionAndCacheState.aspx)，描述了如何压缩存储在会话/缓存中的字符串。这看起来很有希望，但我存储在会话/缓存中的大部分数据不是字符串，而是自定义类。你将如何压缩这些？

我最初的想法是先利用 BinaryFormatter 序列化对象（就像 ASP.NET 框架在将自定义类对象存储到会话/缓存中时通常会做的那样），然后压缩生成的字节数组。但是，这会产生不利的副作用，即从会话/缓存中检索到的数据将是只读的（因为解压缩和反序列化会创建一个新的内存对象）。

换句话说，如果我的代码当前如下所示，有没有办法将其存储压缩到会话中？

```
MyClass foo = new MyClass();
Session["foo"] = foo;

MyClass retrievedFoo1 = (MyClass) Session["foo"];
retrievedFoo1.Property1 = "property 1";

// retrievedFoo2.Property1 should equal "property 1"!
MyClass retrievedFoo2 = (MyClass) Session["foo"]; 
```

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-25T07:06:38.243

首先，我会看看为什么需要压缩会话/缓存中的数据。压缩应该是最后的手段，更好的编程应该是第一。

您是否内存不足，如果是，哪些对象消耗最多？这应该为您指明代码改进的方向，以减少使用的内存量。

如果您的应用程序使用它需要的对象进行了最佳优化，您可能需要查看内存不足的存储，例如数据库或文件系统以缓存更大的对象（这是序列化派上用场的地方）。

您还可以将 InProc 会话放置在与 Web 服务器不同的服务器上，以提高可伸缩性并将站点分布在 Web 场上。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-24T14:16:31.043

您可以使用 XML 序列化器将其转换为 XML 格式吗？

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-25T06:37:39.190

据我了解，您从（重载）会话中获得的性能下降是由于序列化/反序列化的开销，而不是存储大小。如果您正在寻找压缩以帮助解决性能问题，我认为您走错了路。(De)Compression 只会增加更多开销。

现在，如果您谈论的是缓存，那么情况就有些不同了。但是您特别提到了会话...

* * *

刚刚阅读了您对斯科特文章的评论，我对您的问题感到困惑。似乎您并不真正了解通过将某些内容放入 Session/Cache 中来获得数据持久性，就像您将其放入数据库或将其写入文件一样。压缩不会解决你所问的问题。

# camera - QR码（二维条码）的编解码算法？

> ID：231741
> 
> 赞同：43
> 
> 时间：2008-10-23T22:12:43.013
> 
> 标签：camera, barcode, encode, decode, qr-code

寻找免费/开源代码或算法描述来编码（简单）和解码（硬）二维条码[QR 码](http://en.wikipedia.org/wiki/QR_Code)。

这似乎不是一个小问题，但它在日本如此受欢迎，以至于必须有一些已经可用的东西......

* * *

## 回答 #1

> 赞同：31
> 
> 时间：2008-10-23T22:15:28.030

我有一个同事在[ZXing](http://code.google.com/p/zxing/)（“斑马线”）工作。

那有各种各样的平台支持。

* * *

## 回答 #2

> 赞同：15
> 
> 时间：2011-11-04T05:29:24.200

[QR 码揭秘 - 第 1 部分](https://www.matchadesign.com/news/blog/qr-code-demystified-part-1/)
[QR 码揭秘 - 第 2 部分](https://www.matchadesign.com/news/blog/qr-code-demystified-part-2/)
[QR 码揭秘 - 第 3 部分](https://www.matchadesign.com/news/blog/qr-code-demystified-part-3/)
[QR 码揭秘 - 第 4 部分](https://www.matchadesign.com/news/blog/qr-code-demystified-part-4/)
[QR 码揭秘 - 第 5 部分](https://www.matchadesign.com/news/blog/qr-code-demystified-part-5/)
[QR 码揭秘 - 第 6 部分](https://www.matchadesign.com/news/blog/qr-code-demystified-part-6/)

和

[http://www.thonky.com/qr-code-tutorial/introduction/](http://www.thonky.com/qr-code-tutorial/introduction/)

要了解其背后的数学理论，请参阅 Math Stackexchange 中的讨论

[https://math.stackexchange.com/questions/76045/reed-solomon-polynomial-generator](https://math.stackexchange.com/questions/76045/reed-solomon-polynomial-generator)

* * *

## 回答 #3

> 赞同：12
> 
> 时间：2010-06-22T14:56:29.893

[http://www.swetake.com/qrcode/qr1_en.html](http://www.swetake.com/qrcode/qr1_en.html)

只是想我会提到这个解释它们是如何工作的。

* * *

## 回答 #4

> 赞同：11
> 
> 时间：2009-02-25T06:47:08.523

（回应那些询问PHP中的二维码的人）

如果您不希望有很多流量，或者您可以缓存图像，Google Charts QR 图表类型可能适合您[。](http://code.google.com/apis/chart/types.html#qrcodes)它非常易于使用 - 只需将要编码的文本放入 URL 中。

* * *

## 回答 #5

> 赞同：10
> 
> 时间：2008-12-08T20:35:44.233

这是一个很好的 LGPL 库，用于编码 QR 码[libqrencode](http://megaui.net/fukuchi/works/qrencode/index.en.html)

> Libqrencode 是一个用于将数据编码为二维码符号的 C 库，二维码符号是一种二维符号，可以通过带有 CCD 的手机等便携终端进行扫描。二维码的容量高达7000位或4000个字符，具有很强的鲁棒性。

这是一个[解码 QR 码的 Google 代码项目](http://code.google.com/p/iphone-qrcode/)- 针对 iPhone，但它是 LGPL 并且源代码可用。应该适应...

-亚当

* * *

## 回答 #6

> 赞同：8
> 
> 时间：2008-12-31T23:11:58.287

[PyQrCodec](http://pyqrcode.sourceforge.net/)是一个 Python 库，用于将二维码编码为 PNG 并从各种图像格式解码它们。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2010-11-09T07:22:18.520

您可以在这里免费找到 c# 示例[http://twit88.com/home/opensource/qrcode](http://twit88.com/home/opensource/qrcode)（只需注册）

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2011-07-04T19:28:13.790

可以直接使用zbar来解码二维码。

```
#!/usr/bin/python

from sys import argv
import zbar
import Image

# create a reader
scanner = zbar.ImageScanner()

# configure the reader
scanner.parse_config('enable')

# obtain image data    
pil = Image.open("base.png").convert('L')
width, height = pil.size
raw = pil.tostring()

# wrap image data
image = zbar.Image(width, height, 'Y800', raw)

# scan the image for barcodes
scanner.scan(image)

# extract results
for symbol in image:
    # do something useful with results
    print 'decoded', symbol.type, 'symbol', '"%s"' % symbol.data

# clean up
del(image) 
```

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2011-06-20T23:25:03.473

您可以尝试 python-qrtools：[https](https://launchpad.net/qr-tools) ://launchpad.net/qr-tools 它使用 qrencode 生成和 zbar 解码（来自网络摄像头或文件；-）

# c++ - 如何使用 C++ 监视文本文件更改？难度：没有.NET

> ID：231746
> 
> 赞同：4
> 
> 时间：2008-10-23T22:13:55.633
> 
> 标签：c++, file, monitoring

用例：第 3 方应用程序希望以编程方式监视另一个程序正在生成的文本文件。文本文件包含您要在更新时分析的数据。

我在 FileSystemWatcher 周围找到了很多关于这个问题的答案，但是假设您正在为 Windows 机器编写应用程序并且不能保证已安装 .NET。

有没有可用的库，还是我只需要推出自己的解决方案？

谢谢。

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-10-23T22:30:22.057

您可以在任何窗口上使用[FindFirstChangeNotification](http://msdn.microsoft.com/en-us/library/aa364417.aspx)监视目录。
如果您知道文件在哪里，这很有效 - 否则您可以使用下面描述的虚拟驱动程序/Filemon 来检查系统上任何地方的更改。

示例代码[在这里](http://msdn.microsoft.com/en-us/library/aa365261(VS.85).aspx)

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-23T22:49:37.587

一个更简单的解决方案可能是检查文件的最后修改时间戳。

如果你使用 _stat64() 函数来做这件事，它就变成了一个跨平台的解决方案。

示例代码：

```
struct __stat64 fileinfo;

if(-1 != _stat64(filename, &fileinfo)
   return fileinfo.st_mtime; 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T22:31:38.840

看起来像这样：[跟踪打开特定文件的进程](https://stackoverflow.com/questions/231547/tracing-which-process-that-has-opened-a-particular-file#231585)

[sysinternal](http://technet.microsoft.com/en-us/sysinternals/default.aspx)再次 给出了一些提示和[工具](http://www.wasm.ru/baixado.php?mode=tool&id=283)

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-23T22:52:53.587

这听起来很像来自 sysinternals（现在是 MS）的 FileMon。他们通过创建一个动态加载的虚拟设备驱动程序来做到这一点。他们很好地描述了它[在这里](http://technet.microsoft.com/en-us/sysinternals/bb896642.aspx)的工作原理：

> FileMon 的工作原理
> 
> 对于 Windows 9x 驱动程序，FileMon 的核心是虚拟设备驱动程序 Filevxd.vxd。它是动态加载的，并在初始化时通过 VxD 服务 IFSMGR_InstallFileSystemApiHook 安装文件系统过滤器，以将自身插入到所有文件系统请求的调用链中。在 Windows NT 上，FileMon 的核心是一个文件系统驱动程序，它创建过滤设备对象并将其附加到目标文件系统设备对象，以便 FileMon 将看到所有指向驱动器的 IRP 和 FastIO 请求。当 FileMon 看到打开、创建或关闭调用时，它会更新一个内部哈希表，该哈希表用作内部文件句柄和文件路径名之间的映射。每当它看到基于句柄的调用时，它就会在哈希表中查找句柄以获得显示的全名。

# c - _t（下划线-t）后跟的类型代表什么？

> ID：231760
> 
> 赞同：313
> 
> 时间：2008-10-23T22:18:39.117
> 
> 标签：c, naming-conventions, types

这似乎是一个简单的问题，但我无法通过 Stack Overflow 搜索或 Google 找到它。一个类型后跟一个`_t`意思是什么？如

```
int_t anInt; 
```

我在旨在密切处理硬件的 C 代码中看到了很多——我不禁认为它们是相关的。

* * *

## 回答 #1

> 赞同：254
> 
> 时间：2008-10-23T22:29:47.003

正如 Douglas Mayle 所指出的，它基本上表示一个类型名称。因此，不建议您使用 ' `_t`' 结束变量或函数名称，因为这可能会引起一些混乱。此外`size_t`，C89 标准还定义了`wchar_t`、`off_t`、`ptrdiff_t`，可能还有一些我已经忘记的其他内容。C99 标准定义了很多额外的类型，例如`uintptr_t`, `intmax_t`, `int8_t`, `uint_least16_t`, `uint_fast32_t`, 等等。这些新类型是正式定义的，`<stdint.h>`但大多数情况下您会使用`<inttypes.h>`which（通常用于标准 C 头文件）包括`<stdint.h>`. 它 ( `<inttypes.h>`) 还定义了与`printf()`and一起使用的宏`scanf()`。

正如 Matt Curtis 所指出的，后缀中的编译器没有意义；这是一个以人为本的公约。

但是，您还应该注意，[POSIX](https://en.wikipedia.org/wiki/POSIX)定义了许多以 ' ' 结尾的额外类型名称`_t`，并为实现**保留了后缀**。这意味着，如果您正在使用与 POSIX 相关的系统，那么使用约定定义您自己的类型名称是不明智的。我工作的系统已经做到了（超过 20 年）；我们经常被定义与我们定义的名称相同的类型的系统绊倒。

* * *

## 回答 #2

> 赞同：59
> 
> 时间：2008-10-23T22:26:14.750

这是用于命名数据​​类型的约定，例如`typedef`：

```
 typedef struct {
  char* model;
  int year;
...
} car_t; 

```

* * *

## 回答 #3

> 赞同：56
> 
> 时间：2012-10-04T12:16:41.060

`_t`通常包装一个不透明的类型定义。

GCC 只是添加以您可能不使用的保留命名空间结尾`_t`的名称，以避免与标准 C 和 POSIX [（GNU C 库手册）](http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html)的未来版本发生冲突。经过一番研究，我终于在 POSIX Standard 1003.1: [B.2.12 Data Types](https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xsh_chap02.html#tag_22_02_12) (Volume: [Rationale](https://pubs.opengroup.org/onlinepubs/9699919799/idx/xrat.html) , Annex: [B. Rationale for System Interfaces](https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xsh_chap01.html) , Chapter: [B.2 General Information](https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xsh_chap02.html) ) 中找到了正确的参考：

> **B.2.12 数据类型**
> *定义类型*
> 本节中定义的附加类型以“_t”结尾的要求是由名称空间污染问题引起的。很难在一个头文件中定义一种类型（该类型不是 POSIX.1-2017 定义的类型）并在另一个头文件中使用它而不在程序的名称空间中添加符号。为了允许实现者提供他们自己的类型，所有符合要求的应用程序都必须避免以“_t”结尾的符号，这允许实现者提供额外的类型。由于类型的主要用途是定义结构成员，可以（并且在许多情况下必须）将其添加到 POSIX.1-2017 中定义的结构中，因此对其他类型的需求非常迫切。

简而言之，标准说有很好的机会扩展标准类型的列表，因此标准限制`_t`命名空间供自己使用。

例如，您的程序匹配*POSIX 1003.1 第 7 版*，并且您定义了一个 type `foo_t`。*POSIX 1003.1 第 8 版*最终以新定义的类型发布`foo_t`。您的程序与新版本不匹配，这可能是个问题。限制`_t`使用可以防止重构代码。因此，如果您的目标是符合 POSIX 标准，那么您绝对应该避免`_t`按照标准的规定。

*旁注：就个人而言，我尝试坚持使用 POSIX，因为我认为它为干净的编程提供了良好的基础。此外，我非常喜欢[Linux 编码风格（第 5 章）](https://elixir.bootlin.com/linux/latest/source/Documentation/process/coding-style.rst#L343)指南。不使用 typedef 有一些很好的理由。希望这有帮助！*

* * *

## 回答 #4

> 赞同：19
> 
> 时间：2008-10-23T22:31:53.693

它是数据类型的标准命名约定，通常由 typedefs 定义。许多处理硬件寄存器的 C 代码使用 C99 定义的标准名称来表示有符号和无符号的固定大小数据类型。作为约定，这些名称位于标准头文件 (stdint.h) 中，并以 _t 结尾。

* * *

## 回答 #5

> 赞同：14
> 
> 时间：2008-10-23T22:32:10.713

本质上`_t`没有任何特殊含义。但是将`_t`后缀添加到 typedef 已成为普遍使用。

您可能更熟悉用于变量命名的常见 C 实践......这类似于将 ap 粘贴在指针前面以及在全局变量前面使用下划线的常见方式（这不太常见） , 和 使用变量名`i`, `j`, 和`k`临时循环变量。

在字长和顺序很重要的代码中，使用明确的自定义类型是很常见的，例如`BYTE` `WORD`（通常为 16 位）`DWORD`（32 位）。

`int_t`不太好，因为`int`平台之间的定义不同 - 那么`int`你符合谁？（尽管如今，大多数以 PC 为中心的开发都将其视为 32 位，但非 PC 开发的许多东西仍将 int 视为 16 位）。

* * *

## 回答 #6

> 赞同：13
> 
> 时间：2008-10-23T22:20:32.700

这意味着类型。 `size_t`是尺寸类型。

* * *

## 回答 #7

> 赞同：12
> 
> 时间：2008-10-23T22:23:53.787

这只是一个约定，意思是“类型”。这对编译器没有什么特别的意义。

* * *

## 回答 #8

> 赞同：9
> 
> 时间：2008-10-24T11:09:25.537

关于这个主题有一些很好的解释。只是为了添加重新定义类型的另一个原因：

在许多嵌入式项目中，所有类型都被重新定义，以正确地说明类型的给定大小并提高跨不同平台（即硬件类型编译器）的可移植性。

另一个原因是使您的代码可跨不同的操作系统移植，并避免与您在代码中集成的操作系统中的现有类型发生冲突。为此，通常会添加一个唯一（尽可能）的前缀。

例子：

```
typedef unsigned long dc_uint32_t; 
```

* * *

## 回答 #9

> 赞同：8
> 
> 时间：2008-10-23T22:26:21.347

如果您正在处理硬件接口代码，您正在查看的代码的作者可能已定义`int_t`为特定大小的整数。C 标准没有为`int`类型分配特定的大小（它可能取决于您的编译器和目标平台），并且使用特定`int_t`类型可以避免这种可移植性问题。

对于硬件接口代码来说，这是一个特别重要的考虑因素，这可能是您首先注意到那里的约定的原因。

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2018-07-11T07:43:26.003

例如在 C99 中，/usr/include/stdint.h：

```
typedef unsigned char           uint8_t;
typedef unsigned short int      uint16_t;
#ifndef __uint32_t_defined
typedef unsigned int            uint32_t;
# define __uint32_t_defined
#endif
#if __WORDSIZE == 64
typedef unsigned long int       uint64_t;
#else
__extension__
typedef unsigned long long int  uint64_t;
#endif 
```

`_t`总是意味着由 typedef 定义。

# communication - 密集编程会降低沟通技巧？

> ID：231764
> 
> 赞同：12
> 
> 时间：2008-10-23T22:20:24.700
> 
> 标签：communication

这是可能属于也可能不属于 SO 的元编程问题之一，但这里有……

有没有其他程序员注意到他们与人（技术或其他）交流的能力在一段紧张的编程期间和之后几乎消失了？

我通常认为自己是一个相对较好的沟通者。然而，昨晚在完成一些相对具有挑战性的编程任务后，我发现即使是点外卖也很困难：我的话还没说出口就被束缚住了。这不是第一次发生这种情况了......

有没有其他人经历过这种现象？它有名字吗？

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2008-10-23T22:25:44.780

是的，这叫疲劳。

* * *

## 回答 #2

> 赞同：15
> 
> 时间：2008-12-17T07:07:34.083

在某种程度上，这种情况发生在我身上，基本上每个工作日都会发生。我的女朋友知道，当我处于“机器人模式”时，我对她微妙的肢体语言提示的反应会大大降低，并且需要更长的时间才能做出口头回应。

我敢肯定，其中一些只是高度集中，以及由此引起的疲劳；但对我来说，将大脑包裹在围绕机器的需求和限制而形成的语言上也很有意义，至少暂时地，对那些围绕人们的需求和限制形成的语言不那么熟练。

* * *

## 回答 #3

> 赞同：11
> 
> 时间：2008-11-26T03:19:06.610

*虽然疲劳肯定是一个组成部分，但在任何*需要高度集中注意力且不涉及与他人交流的任务之后，我都经历过这种现象。如果任务是重复的或对短期记忆征税，例如在遵循多条逻辑路径的同时记住中间结果，则会加剧这种情况。非编程示例包括解决数学问题；比较复杂的竞争策略；并按日期、帐户和类别组织一年的纸质收据。

我的猜测是这些任务鼓励“内部”交流，这并不一定要求你用文字表达你的想法，当然也不需要用有组织的句子。如果你必须以合乎逻辑、有条理的方式向另一个人描述你的想法，那么你的大脑会更有效地走“捷径”。当你全神贯注于任务时，你会完全专注于它，失去对时间、环境和身体状况的意识，以及当你意识到你的“自我”时通常会出现在你脑海中的“喋喋不休”。我想当运动员达到“大步”时，类似的事情会发生在他们身上，尽管我很遗憾地不知从经验中得知。:-)

对我来说，这是一种非常舒适的状态，因为我喜欢专注于一个问题并找到解决方案。如果我在没有几分钟过渡的情况下被迫回到“现实”，那就像从一个生动的梦中醒来，在恢复正常的社交思维过程之前，我不会以最佳状态进行交流。

当我和妻子互相解释事情时，也会发生这种情况，尽管程度要小得多：我们每个人都倾向于假设对方有很多背景和理解，因此我们省略了很多细节和“偶然事件”如果我们与其他人交谈，我们会包括在内。当我们彼此“合拍”时，这很容易、高效，并产生巨大的协同作用；当我们假设太多的理解时，它可能会非常令人沮丧，并让我们每个人都想知道对方怎么可能如此密集。:-)

* * *

## 回答 #4

> 赞同：8
> 
> 时间：2008-12-17T07:00:24.160

我注意到，长时间专注于编程问题有时会导致我在口头和书面交流方面都遇到困难。当我第一次开始努力寻找通常对我来说很容易回忆的单词和短语时，它变得很明显。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-12-25T06:51:53.293

我的理论：我所有的短期记忆都与非语言概念有关；说某事需要我执行非常昂贵的上下文切换（或“分页”操作，如果你愿意的话）

盯着和咕哝是我有时能做到的

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-10-24T02:59:50.500

当我的沟通技巧下降时，我发现这通常与我的编程技能同时下降，通常（正如其他人所指出的）由于疲劳。

但是当我一直在紧张地编程时，我发现我的一般沟通技巧水平得到了磨练——我说话、倾听和争论的强度更高，当然是关于我正在工作的一般空间，甚至是其他事情。这就像认真思考一个问题让我进入认真思考所有事情的模式。

我什至发现编写技术文档的最佳方式——我通常不喜欢这样做——是做一些有趣的编码，即使它是原型设计或实验性的或以其他方式丢弃的，以使我处于正确的模式并且只是让我的大脑工作。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-23T22:50:06.073

我想这里有几个问题要问：

1) 您是通过口头、在线还是通过手写笔记订购的？如果你做了第一个，那么你的大脑可能无法切换齿轮，如果你真的进入一个区域，你的反应被优化为输入这个和那个而不是解释如何订购披萨，这是可以理解的.

2）你真的在吃饭前休息了一会儿，还是快速的一部分，“好吧，我要去拿这个，这个和这个不时完成，然后我会回来完成这个，”心理？我已经多次完成后者，通常这只是表明我的注意力集中在那个编程任务上，而不是我周围的其他事情上。

3) 当您下单时，您有多警觉？疲劳当然是另一个可能的因素，再加上不规律的起床时间。

4）你出去之前花了多长时间编程？如果超过几个小时，例如 3 个小时，那么我可以看到如果您倾向于随时优化您正在做的事情，例如当您编程时，您是否尝试优化鼠标、键盘和显示器的所有位置?

这些将是我要研究的几个领域。也许你只是有一种强烈的适应能力，你正在学习你有。:)

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-12-26T15:01:37.687

语言技能通常位于大脑的左半球。

当我“在区域中”时我得到的感觉类似于我在画画时得到的右脑感觉。

我得出结论，编程对我来说更像是一种右脑活动。

贝蒂·爱德华兹的“大脑右侧绘画”是一本关于大脑和绘画的好书。在那里我学会了如何进行切换。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-23T22:42:51.033

```
SYN 
```

导致...

```
ACK 
```

或许...

```
NACK 
```

那！

是问题！

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-11-26T03:34:03.757

我编码的越多，我对计算机说的 f 炸弹就越多。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-12-25T06:38:00.967

今天优秀的沟通技巧的重要性是巨大的，地球上所有最成功的人都精通强大的沟通技巧。这是一门艺术，如果一个人愿意花几个小时在自己身上并认识到这一点，就可以获得它，这是隐藏的技能。

# python - “yield”关键字有什么作用？

> ID：231767
> 
> 赞同：11880
> 
> 时间：2008-10-23T22:21:11.623
> 
> 标签：python, iterator, generator, yield, coroutine

`yield`Python中关键字的用途是什么？它有什么作用？

例如，我试图理解这段代码^(**1**)：

```
def _get_child_candidates(self, distance, min_dist, max_dist):
    if self._leftchild and distance - max_dist < self._median:
        yield self._leftchild
    if self._rightchild and distance + max_dist >= self._median:
        yield self._rightchild 
```

这是调用者：

```
result, candidates = [], [self]
while candidates:
    node = candidates.pop()
    distance = node._get_dist(obj)
    if distance <= max_dist and distance >= min_dist:
        result.extend(node._values)
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))
return result 
```

调用方法时会发生什么`_get_child_candidates`？是否返回列表？单一元素？又叫了吗？后续调用何时停止？

* * *

[1\. 这段代码由 Jochen Schulz (jrschulz) 编写，他为度量空间制作了一个很棒的 Python 库。这是完整源代码的链接：[Module mspace](https://well-adjusted.de/~jrspieker/mspace/)。]

* * *

## 回答 #1

> 赞同：16781
> 
> 时间：2008-10-23T22:48:44.797

要了解做什么`yield`，您必须了解*生成器*是什么。在你了解生成器之前，你必须了解*iterables*。

## 可迭代对象

创建列表时，您可以一一阅读其项目。一项一项地读取它的项目称为迭代：

```
>>> mylist = [1, 2, 3]
>>> for i in mylist:
...    print(i)
1
2
3 
```

`mylist`是*可迭代*的。当您使用列表推导时，您会创建一个列表，因此是一个可迭代的：

```
>>> mylist = [x*x for x in range(3)]
>>> for i in mylist:
...    print(i)
0
1
4 
```

您可以使用“ `for... in...`”的所有内容都是可迭代的；`lists`, `strings`, 文件...

这些可迭代对象很方便，因为您可以随心所欲地读取它们，但是您将所有值存储在内存中，当您有很多值时，这并不总是您想要的。

## 发电机

生成器是迭代器，一种**只能迭代一次**的可迭代对象。生成器不会将所有值存储在内存中，**它们会即时生成值**：

```
>>> mygenerator = (x*x for x in range(3))
>>> for i in mygenerator:
...    print(i)
0
1
4 
```

它是一样的，只是你使用`()`而不是`[]`. 但是，您**不能**执行`for i in mygenerator`第二次，因为生成器只能使用一次：它们计算 0，然后忘记它并计算 1，然后一个接一个地结束计算 4。

## 屈服

`yield`是一个与 类似的关键字`return`，除了该函数将返回一个生成器。

```
>>> def create_generator():
...    mylist = range(3)
...    for i in mylist:
...        yield i*i
...
>>> mygenerator = create_generator() # create a generator
>>> print(mygenerator) # mygenerator is an object!
<generator object create_generator at 0xb7555c34>
>>> for i in mygenerator:
...     print(i)
0
1
4 
```

这是一个无用的示例，但是当您知道您的函数将返回大量值而您只需要读取一次时，它会很方便。

要掌握`yield`，你必须明白，**当你调用函数时，你写在函数体中的代码是不会运行的。**该函数只返回生成器对象，这有点棘手。

然后，您的代码将在每次`for`使用生成器时从中断处继续。

现在最困难的部分：

第一次`for`调用从你的函数创建的生成器对象时，它会从头开始运行你的函数中的代码，直到它命中`yield`，然后它会返回循环的第一个值。然后，每个后续调用将运行您在函数中编写的循环的另一次迭代并返回下一个值。这将一直持续到生成器被认为是空的，这发生在函数运行时没有命中`yield`. 那可能是因为循环已经结束，或者因为您不再满足`"if/else"`.

* * *

## 你的代码解释

*发电机：*

```
# Here you create the method of the node object that will return the generator
def _get_child_candidates(self, distance, min_dist, max_dist):

    # Here is the code that will be called each time you use the generator object:

    # If there is still a child of the node object on its left
    # AND if the distance is ok, return the next child
    if self._leftchild and distance - max_dist < self._median:
        yield self._leftchild

    # If there is still a child of the node object on its right
    # AND if the distance is ok, return the next child
    if self._rightchild and distance + max_dist >= self._median:
        yield self._rightchild

    # If the function arrives here, the generator will be considered empty
    # there is no more than two values: the left and the right children 
```

*呼叫者：*

```
# Create an empty list and a list with the current object reference
result, candidates = list(), [self]

# Loop on candidates (they contain only one element at the beginning)
while candidates:

    # Get the last candidate and remove it from the list
    node = candidates.pop()

    # Get the distance between obj and the candidate
    distance = node._get_dist(obj)

    # If distance is ok, then you can fill the result
    if distance <= max_dist and distance >= min_dist:
        result.extend(node._values)

    # Add the children of the candidate in the candidate's list
    # so the loop will keep running until it will have looked
    # at all the children of the children of the children, etc. of the candidate
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))

return result 
```

此代码包含几个智能部分：

*   循环在一个列表上进行迭代，但在迭代循环时列表会扩展。这是一种遍历所有这些嵌套数据的简洁方法，即使它有点危险，因为您最终可能会陷入无限循环。在这种情况下，`candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))`会耗尽生成器的所有值，但`while`会不断创建新的生成器对象，这些生成器对象将产生与以前的值不同的值，因为它没有应用在同一个节点上。

*   该`extend()`方法是一个列表对象方法，它需要一个可迭代对象并将其值添加到列表中。

通常我们传递一个列表给它：

```
>>> a = [1, 2]
>>> b = [3, 4]
>>> a.extend(b)
>>> print(a)
[1, 2, 3, 4] 
```

但是在您的代码中，它有一个生成器，这很好，因为：

1.  您不需要读取两次值。
2.  您可能有很多孩子，并且您不希望他们都存储在内存中。

它之所以有效，是因为 Python 不关心方法的参数是否为列表。Python 需要可迭代对象，因此它可以处理字符串、列表、元组和生成器！这被称为鸭子类型，这也是 Python 如此酷的原因之一。但这是另一个故事，另一个问题......

你可以在这里停下来，或者阅读一下以了解生成器的高级用法：

## 控制发电机耗尽

```
>>> class Bank(): # Let's create a bank, building ATMs
...    crisis = False
...    def create_atm(self):
...        while not self.crisis:
...            yield "$100"
>>> hsbc = Bank() # When everything's ok the ATM gives you as much as you want
>>> corner_street_atm = hsbc.create_atm()
>>> print(corner_street_atm.next())
$100
>>> print(corner_street_atm.next())
$100
>>> print([corner_street_atm.next() for cash in range(5)])
['$100', '$100', '$100', '$100', '$100']
>>> hsbc.crisis = True # Crisis is coming, no more money!
>>> print(corner_street_atm.next())
<type 'exceptions.StopIteration'>
>>> wall_street_atm = hsbc.create_atm() # It's even true for new ATMs
>>> print(wall_street_atm.next())
<type 'exceptions.StopIteration'>
>>> hsbc.crisis = False # The trouble is, even post-crisis the ATM remains empty
>>> print(corner_street_atm.next())
<type 'exceptions.StopIteration'>
>>> brand_new_atm = hsbc.create_atm() # Build a new one to get back in business
>>> for cash in brand_new_atm:
...    print cash
$100
$100
$100
$100
$100
$100
$100
$100
$100
... 
```

**注意：**对于 Python 3，使用`print(corner_street_atm.__next__())`或`print(next(corner_street_atm))`

它可以用于控制对资源的访问等各种事情。

## Itertools，你最好的朋友

itertools 模块包含操作可迭代对象的特殊函数。曾经想复制一个生成器吗？链接两个发电机？使用单线对嵌套列表中的值进行分组？`Map / Zip`不创建另一个列表？

那么就`import itertools`.

一个例子？让我们看看四马比赛的可能到达顺序：

```
>>> horses = [1, 2, 3, 4]
>>> races = itertools.permutations(horses)
>>> print(races)
<itertools.permutations object at 0xb754f1dc>
>>> print(list(itertools.permutations(horses)))
[(1, 2, 3, 4),
 (1, 2, 4, 3),
 (1, 3, 2, 4),
 (1, 3, 4, 2),
 (1, 4, 2, 3),
 (1, 4, 3, 2),
 (2, 1, 3, 4),
 (2, 1, 4, 3),
 (2, 3, 1, 4),
 (2, 3, 4, 1),
 (2, 4, 1, 3),
 (2, 4, 3, 1),
 (3, 1, 2, 4),
 (3, 1, 4, 2),
 (3, 2, 1, 4),
 (3, 2, 4, 1),
 (3, 4, 1, 2),
 (3, 4, 2, 1),
 (4, 1, 2, 3),
 (4, 1, 3, 2),
 (4, 2, 1, 3),
 (4, 2, 3, 1),
 (4, 3, 1, 2),
 (4, 3, 2, 1)] 
```

## 了解迭代的内在机制

迭代是一个包含可迭代对象（实现`__iter__()`方法）和迭代器（实现`__next__()`方法）的过程。可迭代对象是您可以从中获取迭代器的任何对象。迭代器是允许您迭代可迭代对象的对象。

在这篇文章中有更多关于[循环](https://web.archive.org/web/20201109034340/http://effbot.org/zone/python-for-statement.htm)[如何`for`](https://web.archive.org/web/20201109034340/http://effbot.org/zone/python-for-statement.htm)工作的内容。

* * *

## 回答 #2

> 赞同：2322
> 
> 时间：2008-10-25T21:22:30.393

## 理解的捷径`yield`

当你看到一个带有`yield`语句的函数时，应用这个简单的技巧来理解会发生什么：

1.  `result = []`在函数的开头插入一行。
2.  将每个替换`yield expr`为`result.append(expr)`。
3.  `return result`在函数底部插入一行。
4.  是的 - 没有更多的`yield`声明！阅读并找出代码。
5.  将功能与原始定义进行比较。

这个技巧可能会让您了解函数背后的逻辑，但实际发生的事情与`yield`基于列表的方法中发生的事情有很大不同。在许多情况下，yield 方法的内存效率也会更高，速度也更快。在其他情况下，这个技巧会让你陷入无限循环，即使原始函数工作得很好。请继续阅读以了解更多信息...

## 不要混淆你的迭代器、迭代器和生成器

一、**迭代器协议**——当你写

```
for x in mylist:
    ...loop body... 
```

Python 执行以下两个步骤：

1.  获取 的迭代器`mylist`：

    Call `iter(mylist)`-> this 返回一个带有`next()`方法的对象（或`__next__()`在 Python 3 中）。

    [这是大多数人忘记告诉你的步骤]

2.  使用迭代器循环项目：

    继续调用`next()`步骤 1 返回的迭代器上的方法。返回值 from`next()`被赋值给`x`并执行循环体。`StopIteration`如果从 inside 引发异常`next()`，则意味着迭代器中没有更多值并退出循环。

事实上，Python 在任何时候想要*循环*对象的内容时都会执行上述两个步骤 - 所以它可能是一个 for 循环，但它也可能是类似代码`otherlist.extend(mylist)`（`otherlist`Python 列表在哪里）。

这`mylist`是一个*可迭代*的，因为它实现了迭代器协议。在用户定义的类中，您可以实现该`__iter__()`方法以使您的类的实例可迭代。此方法应返回一个*迭代器*。迭代器是具有`next()`方法的对象。可以在同一个类上实现两者，`__iter__()`并具有return 。这适用于简单的情况，但不适用于您希望两个迭代器同时遍历同一个对象的情况。`next()``__iter__()``self`

这就是迭代器协议，许多对象都实现了这个协议：

1.  内置列表、字典、元组、集合、文件。
2.  实现`__iter__()`.
3.  发电机。

请注意，`for`循环不知道它正在处理什么样的对象 - 它只是遵循迭代器协议，并且很高兴在它调用时获取一个接一个的项目`next()`。内置列表一一返回它们的项目，字典一一返回*键*，文件一一返回*行*，等等。生成器返回......这就是`yield`进来的地方：

```
def f123():
    yield 1
    yield 2
    yield 3

for item in f123():
    print item 
```

而不是`yield`语句，如果你有三个`return`语句，`f123()`只有第一个会被执行，并且函数会退出。但`f123()`不是普通的功能。当`f123()`被调用时，它*不会*返回 yield 语句中的任何值！它返回一个生成器对象。此外，该功能并没有真正退出 - 它进入暂停状态。当`for`循环试图遍历生成器对象时，函数在`yield`它之前返回的下一行从其挂起状态恢复，执行下一行代码，在本例中为`yield`语句，并将其作为下一个返回物品。这种情况一直发生，直到函数退出，此时生成器 raise `StopIteration`，循环退出。

所以生成器对象有点像一个适配器——在一端，它展示了迭代器协议，通过暴露`__iter__()`和`next()`方法来保持`for`循环愉快。然而，在另一端，它运行的函数刚好足以从中获取下一个值，并将其重新置于挂起模式。

## 为什么要使用生成器？

通常，您可以编写不使用生成器但实现相同逻辑的代码。一种选择是使用我之前提到的临时列表“技巧”。这并非在所有情况下都有效，例如，如果您有无限循环，或者当您的列表非常长时，它可能会低效使用内存。另一种方法是实现一个新的可迭代类SomethingIter，它将状态保存在实例成员中，并在它的`next()`（或`__next__()`Python 3）方法中执行下一个逻辑步骤。根据逻辑，`next()`方法中的代码最终可能看起来非常复杂并且容易出现错误。在这里，生成器提供了一个干净且简单的解决方案。

* * *

## 回答 #3

> 赞同：681
> 
> 时间：2008-10-23T22:28:41.187

这样想：

迭代器只是一个听起来很花哨的术语，用于具有`next()`方法的对象。所以一个 yielded 函数最终会是这样的：

原始版本：

```
def some_function():
    for i in xrange(4):
        yield i

for i in some_function():
    print i 
```

这基本上是 Python 解释器对上述代码所做的事情：

```
class it:
    def __init__(self):
        # Start at -1 so that we get 0 when we add 1 below.
        self.count = -1

    # The __iter__ method will be called once by the 'for' loop.
    # The rest of the magic happens on the object returned by this method.
    # In this case it is the object itself.
    def __iter__(self):
        return self

    # The next method will be called repeatedly by the 'for' loop
    # until it raises StopIteration.
    def next(self):
        self.count += 1
        if self.count < 4:
            return self.count
        else:
            # A StopIteration exception is raised
            # to signal that the iterator is done.
            # This is caught implicitly by the 'for' loop.
            raise StopIteration

def some_func():
    return it()

for i in some_func():
    print i 
```

为了更深入地了解幕后发生的事情，`for`可以将循环重写为：

```
iterator = some_func()
try:
    while 1:
        print iterator.next()
except StopIteration:
    pass 
```

这更有意义还是让你更困惑？:)

我应该指出，这*是*为了说明目的而过度简化了。:)

* * *

## 回答 #4

> 赞同：562
> 
> 时间：2011-06-19T06:33:58.953

关键字简化为两个简单的`yield`事实：

1.  如果编译器在函数内的*任何位置*`yield`检测到关键字，则该函数不再通过语句返回。***相反***，它**立即**返回一个称为生成器的**惰性“待处理列表”对象***`return`*
********   生成器是可迭代的。什么是*可迭代*的？它类似于`list`or or or `set`or `range`or dict-view，具有*用于按特定顺序访问每个元素的内置协议*。*******

 *******简而言之：**生成器是一个惰性的、增量挂起的列表**，并且**`yield`语句允许您使用函数表示法来编程**生成器应该增量吐出的列表值。

```
generator = myYieldingFunction(...)  # basically a list (but lazy)
x = list(generator)  # evaluate every element into a list

   generator
       v
[x[0], ..., ???]

         generator
             v
[x[0], x[1], ..., ???]

               generator
                   v
[x[0], x[1], x[2], ..., ???]

                       StopIteration exception
[x[0], x[1], x[2]]     done 
```

基本上，每当`yield`遇到语句时，函数都会暂停并保存其状态，然后根据 python 迭代器协议发出“'list' 中的下一个返回值”（对于某些语法结构，如反复调用`next()`和捕获的 for 循环例外`StopIteration`等）。你可能遇到过带有[生成器表达式](https://www.python.org/dev/peps/pep-0289/)的生成器；生成器函数更强大，因为您可以将参数传回暂停的生成器函数，使用它们来实现协程。稍后再谈。

* * *

## 基本示例（“列表”）

让我们定义一个函数`makeRange`，就像 Python 的`range`. 调用`makeRange(n)`返回生成器：

```
def makeRange(n):
    # return 0,1,2,...,n-1
    i = 0
    while i < n:
        yield i
        i += 1

>>> makeRange(5)
<generator object makeRange at 0x19e4aa0> 
```

要强制生成器立即返回其挂起的值，您可以将其传递给`list()`（就像您可以任何可迭代的一样）：

```
>>> list(makeRange(5))
[0, 1, 2, 3, 4] 
```

* * *

## 将示例与“仅返回列表”进行比较

上面的示例可以被认为只是创建一个您附加并返回的列表：

```
# return a list                  #  # return a generator
def makeRange(n):                #  def makeRange(n):
    """return [0,1,2,...,n-1]""" #      """return 0,1,2,...,n-1"""
    TO_RETURN = []               # 
    i = 0                        #      i = 0
    while i < n:                 #      while i < n:
        TO_RETURN += [i]         #          yield i
        i += 1                   #          i += 1
    return TO_RETURN             # 

>>> makeRange(5)
[0, 1, 2, 3, 4] 
```

但是，有一个主要区别；见最后一节。

* * *

## 如何使用生成器

可迭代是列表推导的最后一部分，所有生成器都是可迭代的，因此它们经常这样使用：

```
#                  < ITERABLE >
>>> [x+10 for x in makeRange(5)]
[10, 11, 12, 13, 14] 
```

为了更好地了解生成器，您可以使用该`itertools`模块（确保使用`chain.from_iterable`而不是`chain`在有保证的情况下使用）。例如，您甚至可以使用生成器来实现无限长的惰性列表，例如`itertools.count()`. 您可以实现自己的`def enumerate(iterable): zip(count(), iterable)`，或者`yield`在 while 循环中使用关键字来实现。

请注意：生成器实际上可以用于更多的事情，例如[实现协程](http://www.dabeaz.com/coroutines/index.html)或非确定性编程或其他优雅的事情。但是，我在这里提出的“惰性列表”观点是您会发现的最常见的用途。

* * *

## 在幕后

这就是“Python 迭代协议”的工作原理。也就是说，当你这样做时发生了什么`list(makeRange(5))`。这就是我之前所说的“惰性、增量列表”。

```
>>> x=iter(range(5))
>>> next(x)  # calls x.__next__(); x.next() is deprecated
0
>>> next(x)
1
>>> next(x)
2
>>> next(x)
3
>>> next(x)
4
>>> next(x)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration 
```

内置函数`next()`只是调用对象`.__next__()`函数，它是“迭代协议”的一部分，在所有迭代器上都可以找到。您可以手动使用该`next()`函数（和迭代协议的其他部分）来实现花哨的东西，通常以牺牲可读性为代价，所以尽量避免这样做......

* * *

## 协程

[协程](https://www.python.org/dev/peps/pep-0342/)示例：

```
def interactiveProcedure():
    userResponse = yield makeQuestionWebpage()
    print('user response:', userResponse)
    yield 'success'

coroutine = interactiveProcedure()
webFormData = next(coroutine)  # same as .send(None)
userResponse = serveWebForm(webFormData)

# ...at some point later on web form submit...

successStatus = coroutine.send(userResponse) 
```

* * *

## 细节

通常，大多数人不会关心以下区别，可能想在这里停止阅读。

在 Python 中，*可迭代*对象是“理解 for 循环的概念”的任何对象，如 list `[1,2,3]`，而*迭代器*是所请求的 for 循环的特定实例，如`[1,2,3].__iter__()`. *生成器*与任何迭代器完全相同，除了它的编写方式（使用函数语法）。

当您从列表中请求迭代器时，它会创建一个新的迭代器。但是，当您从迭代器请求迭代器时（您很少这样做），它只会为您提供自身的副本。

因此，万一你没有做这样的事情......

```
> x = myRange(5)
> list(x)
[0, 1, 2, 3, 4]
> list(x)
[] 
```

...然后记住生成器是*迭代器*；也就是说，它是一次性的。如果你想重用它，你应该`myRange(...)`再次调用。如果您需要使用两次结果，请将结果转换为列表并将其存储在变量`x = list(myRange(5))`中。如果绝对需要，那些绝对需要克隆生成器的人（例如，正在做骇人听闻的元编程的人）可以使用[`itertools.tee`](https://docs.python.org/2/library/itertools.html#itertools.tee)（[仍然在 Python 3 中工作](https://docs.python.org/3/library/itertools.html#itertools.tee)），因为可[复制迭代器 Python PEP 标准提案](https://www.python.org/dev/peps/pep-0323/)已被推迟。

* * *

## 回答 #5

> 赞同：501
> 
> 时间：2015-06-25T06:11:11.867

> **Python中的`yield`关键字有什么作用？**

# 答案大纲/摘要

*   带有 的函数[**`yield`**](https://docs.python.org/reference/expressions.html#yieldexpr)在调用时会**返回一个[Generator](https://docs.python.org/2/tutorial/classes.html#generators)。**
*   生成器是迭代器，因为它们实现了[**迭代器协议**](https://docs.python.org/2/library/stdtypes.html#iterator-types)，因此您可以迭代它们。
*   生成器也可以**发送信息**，使其在概念上成为**协程**。
*   在Python 3 中，您可以**使用****`yield from`**.
*   （附录批评了几个答案，包括最上面的一个，并讨论了`return`在生成器中的使用。）

# 发电机：

**`yield`**仅在函数定义内部是合法的，并且**包含`yield`在函数定义中使其返回生成器。**

生成器的想法来自其他具有不同实现的语言（见脚注 1）。在 Python 的生成器中，代码的执行在 yield 点被[冻结。](https://docs.python.org/3.5/glossary.html#term-generator-iterator)当调用生成器（方法在下面讨论）时，执行恢复，然后在下一个 yield 处冻结。

`yield`提供了一种[实现迭代器协议](https://docs.python.org/2/library/stdtypes.html#generator-types)的简单方法，由以下两种方法定义： `__iter__`和`next`(Python 2) 或`__next__`(Python 3)。这两种方法都使对象成为迭代器，您可以使用模块中的`Iterator`抽象基类进行类型检查`collections`。

```
>>> def func():
...     yield 'I am'
...     yield 'a generator!'
... 
>>> type(func)                 # A function with yield is still a function
<type 'function'>
>>> gen = func()
>>> type(gen)                  # but it returns a generator
<type 'generator'>
>>> hasattr(gen, '__iter__')   # that's an iterable
True
>>> hasattr(gen, 'next')       # and with .next (.__next__ in Python 3)
True                           # implements the iterator protocol. 
```

生成器类型是迭代器的子类型：

```
>>> import collections, types
>>> issubclass(types.GeneratorType, collections.Iterator)
True 
```

如果有必要，我们可以像这样进行类型检查：

```
>>> isinstance(gen, types.GeneratorType)
True
>>> isinstance(gen, collections.Iterator)
True 
```

an 的一个特点`Iterator` [是一旦用尽](https://docs.python.org/2/glossary.html#term-iterator)，就不能重用或重置它：

```
>>> list(gen)
['I am', 'a generator!']
>>> list(gen)
[] 
```

如果你想再次使用它的功能，你必须再做一个（见脚注 2）：

```
>>> list(func())
['I am', 'a generator!'] 
```

可以以编程方式生成数据，例如：

```
def func(an_iterable):
    for item in an_iterable:
        yield item 
```

上面的简单生成器也等价于下面的 - 从 Python 3.3 开始（在 Python 2 中不可用），您可以使用[`yield from`](https://www.python.org/dev/peps/pep-0380/)：

```
def func(an_iterable):
    yield from an_iterable 
```

但是，`yield from`也允许委派给子生成器，这将在下一节关于与子协程的协作委派中进行解释。

# 协程：

`yield`形成一个允许将数据发送到生成器的表达式（见脚注 3）

这是一个例子，注意`received`变量，它将指向发送到生成器的数据：

```
def bank_account(deposited, interest_rate):
    while True:
        calculated_interest = interest_rate * deposited 
        received = yield calculated_interest
        if received:
            deposited += received

>>> my_account = bank_account(1000, .05) 
```

首先，我们必须将生成器与内置函数[`next`](https://docs.python.org/2/library/functions.html#next). 它将调用适当的`next`或`__next__`方法，具体取决于您使用的 Python 版本：

```
>>> first_year_interest = next(my_account)
>>> first_year_interest
50.0 
```

现在我们可以将数据发送到生成器中。（[发送`None`与调用相同`next`](https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators)。）：

```
>>> next_year_interest = my_account.send(first_year_interest + 1000)
>>> next_year_interest
102.5 
```

## 与子协程的合作委派`yield from`

现在，回想一下`yield from`Python 3 中提供的。这允许我们将协程委托给子协程：

```
 def money_manager(expected_rate):
    # must receive deposited value from .send():
    under_management = yield                   # yield None to start.
    while True:
        try:
            additional_investment = yield expected_rate * under_management 
            if additional_investment:
                under_management += additional_investment
        except GeneratorExit:
            '''TODO: write function to send unclaimed funds to state'''
            raise
        finally:
            '''TODO: write function to mail tax info to client'''

def investment_account(deposited, manager):
    '''very simple model of an investment account that delegates to a manager'''
    # must queue up manager:
    next(manager)      # <- same as manager.send(None)
    # This is where we send the initial deposit to the manager:
    manager.send(deposited)
    try:
        yield from manager
    except GeneratorExit:
        return manager.close()  # delegate? 
```

现在我们可以将功能委托给子生成器，它可以被生成器使用，就像上面一样：

```
my_manager = money_manager(.06)
my_account = investment_account(1000, my_manager)
first_year_return = next(my_account) # -> 60.0 
```

现在模拟向帐户添加另外 1,000 加上帐户的回报 (60.0)：

```
next_year_return = my_account.send(first_year_return + 1000)
next_year_return # 123.6 
```

您可以阅读更多关于[PEP 380](https://www.python.org/dev/peps/pep-0380/#formal-semantics)`yield from`中的精确语义的信息。

## 其他方法：关闭并抛出

该方法在函数执行被冻结时`close`引发。`GeneratorExit`这也将被调用，`__del__`因此您可以将任何清理代码放在您处理的位置`GeneratorExit`：

```
my_account.close() 
```

您还可以抛出异常，该异常可以在生成器中处理或传播回用户：

```
import sys
try:
    raise ValueError
except:
    my_manager.throw(*sys.exc_info()) 
```

提高：

```
Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
  File "<stdin>", line 6, in money_manager
  File "<stdin>", line 2, in <module>
ValueError 
```

# 结论

我相信我已经涵盖了以下问题的所有方面：

> **Python中的`yield`关键字有什么作用？**

事实证明，这`yield`做了很多。我确信我可以为此添加更详尽的示例。如果您想要更多或有一些建设性的批评，请通过下面的评论告诉我。

* * *

# 附录：

## 对最佳/接受答案的批评**

*   仅以列表为例，对什么使**iterable感到困惑。**请参阅上面的参考资料，但总而言之：可迭代对象有一个`__iter__`返回**迭代器**的方法。**迭代器**提供了一个( `.next`Python 2 或`.__next__`(Python 3) 方法，它被`for`循环隐式调用，直到它 raise `StopIteration`，一旦它调用，它将继续这样做。
*   然后它使用生成器表达式来描述生成器是什么。由于生成器只是一种创建**迭代器**的便捷方式，它只会使事情变得混乱，我们还没有深入到这一`yield`部分。
*   在**控制生成器耗尽**中，他调用了该`.next`方法，而他应该使用内置函数`next`. 这将是一个适当的间接层，因为他的代码在 Python 3 中不起作用。
*   迭代工具？这与做什么完全无关`yield`。
*   没有讨论与Python 3 中`yield`的新功能一起提供的方法**。顶部/接受的答案是一个非常不完整的答案。**`yield from`

 **## `yield`对生成器表达式或理解中的答案建议的批评。

该语法目前允许列表推导中的任何表达式。

```
expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
                     ('=' (yield_expr|testlist_star_expr))*)
...
yield_expr: 'yield' [yield_arg]
yield_arg: 'from' test | testlist 
```

由于 yield 是一个表达式，因此有人吹捧在推导式或生成器表达式中使用它很有趣——尽管没有引用特别好的用例。

CPython 核心开发人员正在[讨论弃用它的津贴](https://mail.python.org/pipermail/python-dev/2017-January/147301.html)。这是邮件列表中的相关帖子：

> 2017 年 1 月 30 日 19:05，Brett Cannon 写道：
> 
> > 2017 年 1 月 29 日星期日 16:39，Craig Rodrigues 写道：
> > 
> > > 两种方法我都可以。恕我直言，让它们在 Python 3 中保持原样是不好的。
> > 
> > 我的投票是它是一个 SyntaxError，因为你没有从语法中得到你所期望的。
> 
> 我同意这对我们来说是一个明智的选择，因为任何依赖于当前行为的代码都非常聪明，无法维护。
> 
> 就到达那里而言，我们可能希望：
> 
> *   3.7 中的 SyntaxWarning 或 DeprecationWarning
> *   2.7.x 中的 Py3k 警告
> *   3.8 中的语法错误
> 
> 干杯，尼克。
> 
> ——尼克·科格兰 | gmail.com 上的 ncoghlan | 澳大利亚布里斯班

此外，还有一个[悬而未决的问题 (10544)](http://bugs.python.org/issue10544)似乎指向这*永远*不是一个好主意的方向（PyPy，一个用 Python 编写的 Python 实现，已经引发了语法警告。）

底线，直到 CPython 的开发人员告诉我们：**不要放入`yield`生成器表达式或理解。**

## 生成器中的`return`语句

在[Python 2](https://docs.python.org/2/reference/simple_stmts.html#the-return-statement)中：

> 在生成器函数中，`return`语句不允许包含`expression_list`. 在这种情况下，一个bare`return`表示生成器已经完成并将导致`StopIteration`被提升。

An`expression_list`基本上是由逗号分隔的任意数量的表达式 - 本质上，在 Python 2 中，您可以使用 停止生成器`return`，但不能返回值。

在[Python 3](https://docs.python.org/3/reference/simple_stmts.html#the-return-statement)中：

> 在生成器函数中，该`return`语句指示生成器已完成并将导致`StopIteration`被引发。返回的值（如果有）用作构造的参数`StopIteration`并成为`StopIteration.value`属性。

## 脚注

1.  [提案中引用了 CLU、Sather 和 Icon 语言，以将生成器的概念引入 Python。一般的想法是，一个函数可以维护内部状态并根据用户的需要产生中间数据点。这承诺[在性能上优于其他方法，包括 Python 线程](https://www.python.org/dev/peps/pep-0255/)，这在某些系统上甚至不可用。]

2.  [这意味着，例如，`range`对象不是`Iterator`s，即使它们是可迭代的，因为它们可以被重用。像列表一样，它们的`__iter__`方法返回迭代器对象。]

`yield`最初是作为语句引入的，这意味着它只能出现在代码块中的行首。现在`yield`创建一个 yield 表达式。 [https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt](https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt)[提出](https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators) 此更改是为了允许用户将数据发送到生成器，就像人们可能收到它一样。要发送数据，必须能够将其分配给某物，而为此，一条语句是行不通的。

* * *

## 回答 #6

> 赞同：414
> 
> 时间：2008-10-23T22:24:03.757

`yield`就像`return`- 它返回你告诉它的任何东西（作为生成器）。不同的是，下次调用生成器时，会从最后一次调用`yield`语句开始执行。与 return 不同，**当 yield 发生时堆栈帧不会被清理，而是将控制权转移回调用者，因此它的状态将在下一次调用函数时恢复。**

对于您的代码，该函数`get_child_candidates`的作用类似于迭代器，因此当您扩展列表时，它一次将一个元素添加到新列表中。

`list.extend`调用迭代器，直到它耗尽。对于您发布的代码示例，只返回一个元组并将其附加到列表中会更清楚。

* * *

## 回答 #7

> 赞同：294
> 
> 时间：2008-10-24T08:44:08.123

还有一件事要提一下：产生的函数实际上不必终止。我写过这样的代码：

```
def fib():
    last, cur = 0, 1
    while True: 
        yield cur
        last, cur = cur, last + cur 
```

然后我可以在其他代码中使用它，如下所示：

```
for f in fib():
    if some_condition: break
    coolfuncs(f); 
```

它确实有助于简化一些问题，并使一些事情更容易处理。

* * *

## 回答 #8

> 赞同：283
> 
> 时间：2013-01-18T17:25:17.497

对于那些喜欢最小工作示例的人，请沉思这个交互式 Python 会话：

```
>>> def f():
...   yield 1
...   yield 2
...   yield 3
... 
>>> g = f()
>>> for i in g:
...   print(i)
... 
1
2
3
>>> for i in g:
...   print(i)
... 
>>> # Note that this time nothing was printed 
```

* * *

## 回答 #9

> 赞同：263
> 
> 时间：2016-03-25T13:21:44.003

**TL;博士**

# 而不是这个：

```
def square_list(n):
    the_list = []                         # Replace
    for x in range(n):
        y = x * x
        the_list.append(y)                # these
    return the_list                       # lines 
```

# 做这个：

```
def square_yield(n):
    for x in range(n):
        y = x * x
        yield y                           # with this one. 
```

每当您发现自己从头开始构建列表时，请`yield`改为使用每个部分。

这是我的第一个“啊哈”时刻。

* * *

`yield`是一种[含糖](https://en.wikipedia.org/wiki/Syntactic_sugar)的说法

> 构建一系列东西

相同的行为：

```
>>> for square in square_list(4):
...     print(square)
...
0
1
4
9
>>> for square in square_yield(4):
...     print(square)
...
0
1
4
9 
```

不同的行为：

产量是**单次通过**：您只能迭代一次。当一个函数中有一个 yield 时，我们称它为[生成器函数](https://stackoverflow.com/a/1756342/673991)。它返回的是一个[迭代器。](https://stackoverflow.com/a/9884501/673991)这些条款很有启发性。我们失去了容器的便利性，但获得了根据需要计算且任意长度的序列的能力。

产量是**懒惰**的，它推迟了计算。当你调用一个带有 yield 的函数时，它*实际上根本不会执行。*它返回一个[迭代器对象](https://docs.python.org/3/reference/expressions.html#yieldexpr)，该对象记住它停止的位置。每次调用`next()`迭代器（这发生在 for 循环中）时，执行都会向前推进到下一个 yield。`return`引发 StopIteration 并结束系列（这是 for 循环的自然结束）。

产量是**多才多艺**的。数据不必全部存储在一起，可以一次提供一个。它可以是无限的。

```
>>> def squares_all_of_them():
...     x = 0
...     while True:
...         yield x * x
...         x += 1
...
>>> squares = squares_all_of_them()
>>> for _ in range(4):
...     print(next(squares))
...
0
1
4
9 
```

* * *

如果您需要**多次通过**并且系列不太长，只需调用`list()`它：

```
>>> list(square_yield(4))
[0, 1, 4, 9] 
```

* * *

这个词的绝妙选择，`yield`因为[两种含义都](https://www.google.com/search?q=yield+meaning)适用：

> **产量**——生产或提供（如农业）

...提供系列中的下一个数据。

> **yield** - 让位或放弃（如在政治权力中）

...放弃 CPU 执行，直到迭代器前进。

* * *

## 回答 #10

> 赞同：231
> 
> 时间：2013-01-16T06:42:09.097

Yield 给你一个发电机。

```
def get_odd_numbers(i):
    return range(1, i, 2)
def yield_odd_numbers(i):
    for x in range(1, i, 2):
       yield x
foo = get_odd_numbers(10)
bar = yield_odd_numbers(10)
foo
[1, 3, 5, 7, 9]
bar
<generator object yield_odd_numbers at 0x1029c6f50>
bar.next()
1
bar.next()
3
bar.next()
5 
```

如您所见，在第一种情况下，`foo`一次将整个列表保存在内存中。对于一个有 5 个元素的列表来说这没什么大不了的，但是如果你想要一个 500 万的列表呢？这不仅是一个巨大的内存消耗者，而且在调用该函数时还需要花费大量时间来构建。

在第二种情况下，`bar`只给你一个生成器。生成器是可迭代的——这意味着您可以在`for`循环等中使用它，但每个值只能访问一次。所有值也不会同时存储在内存中；生成器对象“记住”你上次调用它时它在循环中的位置——这样，如果你使用一个迭代来（比如说）计数到 500 亿，你不必全部计数到 500 亿立即存储 500 亿个数字以供计数。

同样，这是一个非常人为的例子，如果你真的想数到 500 亿，你可能会使用 itertools。:)

这是生成器最简单的用例。正如您所说，它可用于编写有效的排列，使用 yield 通过调用堆栈向上推，而不是使用某种堆栈变量。生成器也可以用于专门的树遍历，以及其他各种方式。

* * *

## 回答 #11

> 赞同：224
> 
> 时间：2008-10-23T22:26:06.810

它正在返回一个生成器。我对 Python 不是特别熟悉，但如果你熟悉的话，我相信它与[C# 的迭代器块是同一种东西。](http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx)

关键思想是编译器/解释器/任何东西都会做一些诡计，以便就调用者而言，他们可以继续调用 next() 并且它将继续返回值 -*就好像生成器方法被暂停一样*。现在显然你不能真正“暂停”一个方法，所以编译器为你构建一个状态机来记住你当前的位置以及局部变量等的样子。这比自己编写迭代器要容易得多。

* * *

## 回答 #12

> 赞同：201
> 
> 时间：2013-04-04T14:56:19.677

在描述如何使用生成器的许多很好的答案中，有一种我觉得还没有给出的答案。这是编程语言理论的答案：

Python 中的`yield`语句返回一个生成器。Python 中的生成器是一个返回*延续*的函数（特别是一种协程，但延续代表了更通用的机制来理解正在发生的事情）。

编程语言理论中的延续是一种更为基础的计算，但它们并不经常使用，因为它们极难推理，也很难实现。但是关于什么是延续的想法很简单：它是尚未完成的计算状态。在这种状态下，变量的当前值、尚未执行的操作等都被保存下来。然后在程序稍后的某个时间点可以调用延续，以便程序的变量被重置为该状态并执行保存的操作。

延续，在这种更一般的形式中，可以通过两种方式实现。顺便说`call/cc`一句，程序的堆栈是按字面意思保存的，然后当调用延续时，堆栈被恢复。

在延续传递风格 (CPS) 中，延续只是程序员显式管理并传递给子例程的普通函数（仅在函数是第一类的语言中）。在这种风格中，程序状态由闭包（以及恰好编码在其中的变量）表示，而不是驻留在堆栈中某处的变量。管理控制流的函数接受延续作为参数（在 CPS 的某些变体中，函数可以接受多个延续）并通过调用它们来操纵控制流，只需调用它们并随后返回。延续传递样式的一个非常简单的示例如下：

```
def save_file(filename):
  def write_file_continuation():
    write_stuff_to_file(filename)

  check_if_file_exists_and_user_wants_to_overwrite(write_file_continuation) 
```

在这个（非常简单的）示例中，程序员将实际写入文件的操作保存到一个延续中（这可能是一个非常复杂的操作，需要写出许多细节），然后传递该延续（即，作为第一个-类闭包）到另一个执行更多处理的运算符，然后在必要时调用它。（我在实际的 GUI 编程中经常使用这种设计模式，或者是因为它节省了我的代码行，或者更重要的是，在 GUI 事件触发后管理控制流。）

这篇文章的其余部分将在不失一般性的情况下将延续概念化为 CPS，因为它更容易理解和阅读。

现在让我们谈谈 Python 中的生成器。生成器是延续的特定子类型。虽然**延续通常能够保存*计算***的状态（即程序的调用堆栈），但**生成器只能保存迭代器的*迭代***状态。虽然，对于生成器的某些用例，这个定义有点误导。例如：

```
def f():
  while True:
    yield 4 
```

这显然是一个合理的可迭代对象，其行为定义明确——每次生成器迭代它时，它都会返回 4（并且永远如此）。但在考虑迭代器（即`for x in collection: do_something(x)`）时，它可能不是可迭代的原型类型。这个例子说明了生成器的强大功能：如果有任何东西是迭代器，那么生成器可以保存其迭代的状态。

重申一下：延续可以保存程序堆栈的状态，生成器可以保存迭代的状态。这意味着延续比生成器强大得多，而且生成器也容易得多。它们对语言设计者来说更容易实现，对程序员来说也更容易使用（如果你有时间，试着阅读和理解[这个关于 continuations 和 call/cc 的页面](http://www.madore.org/~david/computers/callcc.html)）。

但是您可以轻松地将生成器实现（和概念化）作为延续传递样式的简单、特定情况：

每当`yield`被调用时，它都会告诉函数返回一个延续。当再次调用该函数时，它会从它停止的地方开始。所以，在pseudo-pseudocode（即不是pseudocode，但不是code）中，生成器的`next`方法基本如下：

```
class Generator():
  def __init__(self,iterable,generatorfun):
    self.next_continuation = lambda:generatorfun(iterable)

  def next(self):
    value, next_continuation = self.next_continuation()
    self.next_continuation = next_continuation
    return value 
```

其中`yield`关键字实际上是真正的生成器函数的语法糖，基本上是这样的：

```
def generatorfun(iterable):
  if len(iterable) == 0:
    raise StopIteration
  else:
    return (iterable[0], lambda:generatorfun(iterable[1:])) 
```

请记住，这只是伪代码，Python 中生成器的实际实现更为复杂。但是作为一个了解正在发生的事情的练习，请尝试使用连续传递样式来实现生成器对象而不使用`yield`关键字。

* * *

## 回答 #13

> 赞同：190
> 
> 时间：2008-10-24T00:36:05.190

这是一个简单的例子。我将提供高级人类概念与低级 Python 概念之间的对应关系。

我想对一个数字序列进行操作，但我不想为创建该序列而烦恼，我只想专注于我想做的操作。因此，我执行以下操作：

*   我打电话给你，告诉你我想要一个以特定方式计算的数字序列，我让你知道算法是什么。
    **此步骤对应于`def`生成生成器函数，即包含 a 的函数`yield`。**
*   过了一段时间，我告诉你，“好吧，准备告诉我数字的顺序”。
    **此步骤对应于调用返回生成器对象的生成器函数。**请注意，您还没有告诉我任何数字；你只要拿起你的纸和铅笔。
*   我问你，“告诉我下一个号码”，你告诉我第一个号码；之后，你等我问你下一个号码。你的工作是记住你在哪里，你已经说过什么数字，下一个数字是什么。我不在乎细节。
    **这一步对应于调用`next(generator)`生成器对象。**
    （在 Python 2 中，`.next`是生成器对象的一个​​方法；在 Python 3 中，它被命名为`.__next__`，但调用它的正确方法是使用内置`next()`函数，就像`len()`and一样`.__len__`）
*   …重复上一步，直到…</li>
*   最终，你可能会走到尽头。你不告诉我一个数字；你只需大喊，“抓住你的马！我完了！没有更多的数字了！”
    **此步骤对应于生成器对象结束其工作并引发`StopIteration`异常。**
    生成器函数不需要引发异常。当函数结束或发出`return`.

这就是生成器所做的（包含 a 的函数`yield`）；它从 first 开始执行`next()`，每当它执行 a 时就会暂停`yield`，当被要求输入`next()`值时，它会从最后一个点继续。它在设计上与 Python 的迭代器协议完美契合，该协议描述了如何顺序请求值。

迭代器协议最著名的用户是`for`Python 中的命令。因此，每当您执行以下操作时：

```
for item in sequence: 
```

不管`sequence`是列表、字符串、字典还是生成器*对象*（如上所述）；结果是一样的：你从一个序列中一个一个地读取项目。

请注意，`def`包含`yield`关键字的函数并不是创建生成器的唯一方法。这只是创建一个的最简单方法。

有关更准确的信息，请阅读Python 文档中的[迭代器类型](http://docs.python.org/library/stdtypes.html#iterator-types)、[yield 语句](http://docs.python.org/reference/simple_stmts.html#yield)和[生成器。](http://docs.python.org/glossary.html#term-generator)

* * *

## 回答 #14

> 赞同：159
> 
> 时间：2014-02-04T02:27:35.200

虽然很多答案都说明了为什么要使用 a`yield`创建生成器，但`yield`. 制作协程非常容易，它可以在两个代码块之间传递信息。我不会重复已经给出的关于使用`yield`创建生成器的任何优秀示例。

为了帮助理解 a`yield`在以下代码中的作用，您可以用手指在任何具有`yield`. 每次您的手指点击 时`yield`，您都必须等待输入 a`next`或 a `send`。当 a`next`被调用时，你会跟踪代码直到你点击`yield`……右侧的代码`yield`被评估并返回给调用者……然后你等待。再次`next`调用时，您将通过代码执行另一个循环。但是，您会注意到，在协程中，`yield`也可以与`send`... 一起使用，这会将值从调用者发送*到*屈服函数。如果`send`给定a，那么`yield`接收发送的值，并将其吐出左侧......然后通过代码的跟踪继续进行，直到您`yield`再次点击（返回最后的值，就像`next`被调用一样）。

例如：

```
>>> def coroutine():
...     i = -1
...     while True:
...         i += 1
...         val = (yield i)
...         print("Received %s" % val)
...
>>> sequence = coroutine()
>>> sequence.next()
0
>>> sequence.next()
Received None
1
>>> sequence.send('hello')
Received hello
2
>>> sequence.close() 
```

* * *

## 回答 #15

> 赞同：155
> 
> 时间：2014-07-24T21:15:29.810

还有另一个`yield`用途和含义（从 Python 3.3 开始）：

```
yield from <expr> 
```

来自*[PEP 380 - 委派给子生成器的语法](http://www.python.org/dev/peps/pep-0380/)*：

> 为生成器提出了一种语法，以将其部分操作委托给另一个生成器。这允许将包含“yield”的一段代码分解并放置在另一个生成器中。此外，允许子生成器返回一个值，并且该值可供委托生成器使用。
> 
> 当一个生成器重新生成另一个生成器生成的值时，新语法还为优化提供了一些机会。

此外[，这](https://www.python.org/dev/peps/pep-0492/)将介绍（从 Python 3.5 开始）：

```
async def new_coroutine(data):
   ...
   await blocking_action() 
```

避免协程与常规生成器混淆（今天`yield`两者都使用）。

* * *

## 回答 #16

> 赞同：143
> 
> 时间：2017-11-14T12:02:47.543

所有很好的答案，但是对于新手来说有点困难。

我假设你已经学会了这个`return`陈述。

打个比方，`return`而且`yield`是双胞胎。`return`表示“返回并停止”，而“yield”表示“返回，但继续”

> 1.  尝试使用 num_list 获取`return`。

```
def num_list(n):
    for i in range(n):
        return i 
```

运行：

```
In [5]: num_list(3)
Out[5]: 0 
```

看，你只得到一个数字而不是它们的列表。`return`永远不会让你快乐得胜，只执行一次就退出。

> 2.  来了`yield`

替换`return`为`yield`：

```
In [10]: def num_list(n):
    ...:     for i in range(n):
    ...:         yield i
    ...:

In [11]: num_list(3)
Out[11]: <generator object num_list at 0x10327c990>

In [12]: list(num_list(3))
Out[12]: [0, 1, 2] 
```

现在，您赢取所有号码。

比较`return`运行一次和停止，`yield`运行您计划的时间。您可以解释`return`为`return one of them`和。这被称为。`yield``return all of them``iterable`

> 3.  再一步，我们可以重写`yield`语句`return`

```
In [15]: def num_list(n):
    ...:     result = []
    ...:     for i in range(n):
    ...:         result.append(i)
    ...:     return result

In [16]: num_list(3)
Out[16]: [0, 1, 2] 
```

这是关于 的核心`yield`。

`return`列表输出和对象输出之间的区别`yield`是：

您将始终从列表对象中获取 [0, 1, 2] ，但只能从“对象`yield`输出”中检索它们一次。因此，它有一个新的名称`generator`对象，如`Out[11]: <generator object num_list at 0x10327c990>`.

总之，作为一个比喻来理解它：

*   `return`并且`yield`是双胞胎
*   `list`并且`generator`是双胞胎

* * *

## 回答 #17

> 赞同：129
> 
> 时间：2013-08-21T19:01:25.917

从编程的角度来看，迭代器被实现为[thunk](http://en.wikipedia.org/wiki/Thunk_(functional_programming))。

为了实现迭代器、生成器和用于并发执行的线程池等作为 thunk，使用[发送到](https://wiki.c2.com/?ClosuresAndObjectsAreEquivalent)具有分派器的闭包对象的消息，并且[分派器响应“消息”](http://en.wikipedia.org/wiki/Message_passing)。

[“ *next* ”](https://docs.python.org/3/library/functions.html#next)是发送到闭包的消息，由“ *iter* ”调用创建。

有很多方法可以实现这种计算。我使用了变异，但是可以通过返回当前值和下一个 yielder（使其[引用透明](https://en.wikipedia.org/wiki/Referential_transparency)）来进行这种没有变异的计算。Racket 在某些中间语言中使用了初始程序的一系列转换，其中一种重写使得 yield 运算符可以用更简单的运算符转换为某种语言。

这是一个如何重写 yield 的演示，它使用 R6RS 的结构，但语义与 Python 的相同。它是相同的计算模型，只需要更改语法即可使用 Python 的 yield 重写它。

> ```
> Welcome to Racket v6.5.0.3.
> 
> -> (define gen
>      (lambda (l)
>        (define yield
>          (lambda ()
>            (if (null? l)
>                'END
>                (let ((v (car l)))
>                  (set! l (cdr l))
>                  v))))
>        (lambda(m)
>          (case m
>            ('yield (yield))
>            ('init  (lambda (data)
>                      (set! l data)
>                      'OK))))))
> -> (define stream (gen '(1 2 3)))
> -> (stream 'yield)
> 1
> -> (stream 'yield)
> 2
> -> (stream 'yield)
> 3
> -> (stream 'yield)
> 'END
> -> ((stream 'init) '(a b))
> 'OK
> -> (stream 'yield)
> 'a
> -> (stream 'yield)
> 'b
> -> (stream 'yield)
> 'END
> -> (stream 'yield)
> 'END
> -> 
> ```

* * *

## 回答 #18

> 赞同：125
> 
> 时间：2012-10-03T20:38:16.153

以下是一些 Python 示例，说明如何实际实现生成器，就好像 Python 没有为它们提供语法糖一样：

**作为 Python 生成器：**

```
from itertools import islice

def fib_gen():
    a, b = 1, 1
    while True:
        yield a
        a, b = b, a + b

assert [1, 1, 2, 3, 5] == list(islice(fib_gen(), 5)) 
```

**使用词法闭包代替生成器**

```
def ftake(fnext, last):
    return [fnext() for _ in xrange(last)]

def fib_gen2():
    #funky scope due to python2.x workaround
    #for python 3.x use nonlocal
    def _():
        _.a, _.b = _.b, _.a + _.b
        return _.a
    _.a, _.b = 0, 1
    return _

assert [1,1,2,3,5] == ftake(fib_gen2(), 5) 
```

**使用对象闭包而不是生成器**（因为[ClosuresAndObjectsAreEquivalent](http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent)）

```
class fib_gen3:
    def __init__(self):
        self.a, self.b = 1, 1

    def __call__(self):
        r = self.a
        self.a, self.b = self.b, self.a + self.b
        return r

assert [1,1,2,3,5] == ftake(fib_gen3(), 5) 
```

* * *

## 回答 #19

> 赞同：114
> 
> 时间：2013-01-28T01:37:10.057

我打算发布“阅读 Beazley 的“Python：基本参考”的第 19 页，以快速描述生成器”，但许多其他人已经发布了很好的描述。

另外，请注意，它`yield`可以在协程中用作它们在生成器函数中的双重用途。虽然它与您的代码片段的用途不同，`(yield)`但可以用作函数中的表达式。当调用者使用该`send()`方法向该方法发送值时，协程将执行直到`(yield)`遇到下一条语句。

生成器和协程是设置数据流类型应用程序的好方法。我认为了解`yield`函数中语句的其他用途是值得的。

* * *

## 回答 #20

> 赞同：99
> 
> 时间：2013-12-20T13:07:18.597

这是一个简单的例子：

```
def isPrimeNumber(n):
    print "isPrimeNumber({}) call".format(n)
    if n==1:
        return False
    for x in range(2,n):
        if n % x == 0:
            return False
    return True

def primes (n=1):
    while(True):
        print "loop step ---------------- {}".format(n)
        if isPrimeNumber(n): yield n
        n += 1

for n in primes():
    if n> 10:break
    print "wiriting result {}".format(n) 
```

输出：

```
loop step ---------------- 1
isPrimeNumber(1) call
loop step ---------------- 2
isPrimeNumber(2) call
loop step ---------------- 3
isPrimeNumber(3) call
wiriting result 3
loop step ---------------- 4
isPrimeNumber(4) call
loop step ---------------- 5
isPrimeNumber(5) call
wiriting result 5
loop step ---------------- 6
isPrimeNumber(6) call
loop step ---------------- 7
isPrimeNumber(7) call
wiriting result 7
loop step ---------------- 8
isPrimeNumber(8) call
loop step ---------------- 9
isPrimeNumber(9) call
loop step ---------------- 10
isPrimeNumber(10) call
loop step ---------------- 11
isPrimeNumber(11) call 
```

我不是 Python 开发人员，但在我看来，它`yield`占据了程序流的位置，下一个循环从“yield”位置开始。似乎它正在那个位置等待，就在此之前，在外面返回一个值，下一次继续工作。

这似乎是一种有趣且不错的能力：D

* * *

## 回答 #21

> 赞同：83
> 
> 时间：2013-06-14T16:36:59.193

这是做什么的心理形象`yield`。

我喜欢将线程视为具有堆栈（即使它没有以这种方式实现）。

当调用普通函数时，它会将其局部变量放入堆栈，进行一些计算，然后清除堆栈并返回。其局部变量的值再也见不到了。

对于一个`yield`函数，当它的代码开始运行时（即在函数被调用后，返回一个生成器对象，`next()`然后调用其方法），它同样将其局部变量放入堆栈并计算一段时间。但是，当它到达`yield`语句时，在清除它的堆栈部分并返回之前，它会对其局部变量进行快照并将它们存储在生成器对象中。它还在其代码（即特定`yield`语句）中记下它当前所在的位置。

所以这是生成器所依赖的一种冻结函数。

当`next()`随后被调用时，它将函数的所有物检索到堆栈中并重新对其进行动画处理。该函数继续从它停止的地方开始计算，忘记了它刚刚在冷库中度过了永恒的事实。

比较以下示例：

```
def normalFunction():
    return
    if False:
        pass

def yielderFunction():
    return
    if False:
        yield 12 
```

当我们调用第二个函数时，它的行为与第一个函数非常不同。该`yield`语句可能无法访问，但如果它出现在任何地方，它就会改变我们正在处理的内容的性质。

```
>>> yielderFunction()
<generator object yielderFunction at 0x07742D28> 
```

调用`yielderFunction()`不会运行它的代码，而是从代码中生成一个生成器。`yielder`（为了便于阅读，用前缀命名这些东西可能是个好主意。）

```
>>> gen = yielderFunction()
>>> dir(gen)
['__class__',
 ...
 '__iter__',    #Returns gen itself, to make it work uniformly with containers
 ...            #when given to a for loop. (Containers return an iterator instead.)
 'close',
 'gi_code',
 'gi_frame',
 'gi_running',
 'next',        #The method that runs the function's body.
 'send',
 'throw'] 
```

`gi_code`和`gi_frame`字段是存储冻结状态的位置。用 探索它们`dir(..)`，我们可以确认我们上面的心智模型是可信的。

* * *

## 回答 #22

> 赞同：74
> 
> 时间：2017-01-02T12:09:28.120

一个简单的例子来理解它是什么：`yield`

```
def f123():
    for _ in range(4):
        yield 1
        yield 2

for i in f123():
    print (i) 
```

输出是：

```
1 2 1 2 1 2 1 2 
```

* * *

## 回答 #23

> 赞同：73
> 
> 时间：2015-07-29T06:11:25.643

就像每个答案所暗示的那样，`yield`用于创建序列生成器。它用于动态生成一些序列。例如，在网络上逐行读取文件时，可以使用`yield`如下函数：

```
def getNextLines():
   while con.isOpen():
       yield con.read() 
```

您可以在代码中使用它，如下所示：

```
for line in getNextLines():
    doSomeThing(line) 
```

***执行控制转移陷阱***

执行 yield 时，执行控制将从 getNextLines() 转移到`for`循环。因此，每次调用 getNextLines() 时，都会从上次暂停的点开始执行。

因此，简而言之，具有以下代码的函数

```
def simpleYield():
    yield "first time"
    yield "second time"
    yield "third time"
    yield "Now some useful value {}".format(12)

for i in simpleYield():
    print i 
```

将打印

```
"first time"
"second time"
"third time"
"Now some useful value 12" 
```

* * *

## 回答 #24

> 赞同：72
> 
> 时间：2019-03-23T13:55:51.537

![](https://i.stack.imgur.com/AJZlN.png)

想象一下，你创造了一台非凡的机器，它每天能够产生成千上万个灯泡。机器在具有唯一序列号的盒子中生成这些灯泡。您没有足够的空间同时存储所有这些灯泡，因此您希望对其进行调整以按需生成灯泡。

Python 生成器与这个概念没有太大区别。想象一下，您有一个名为的函数`barcode_generator`，它为盒子生成唯一的序列号。显然，您可以通过该函数返回大量此类条形码，但受硬件 (RAM) 限制。更明智且节省空间的选项是按需生成这些序列号。

机器代码：

```
def barcode_generator():
    serial_number = 10000  # Initial barcode
    while True:
        yield serial_number
        serial_number += 1

barcode = barcode_generator()
while True:
    number_of_lightbulbs_to_generate = int(input("How many lightbulbs to generate? "))
    barcodes = [next(barcode) for _ in range(number_of_lightbulbs_to_generate)]
    print(barcodes)

    # function_to_create_the_next_batch_of_lightbulbs(barcodes)

    produce_more = input("Produce more? [Y/n]: ")
    if produce_more == "n":
        break 
```

注意`next(barcode)`位。

如您所见，我们有一个独立的“功能”，可以每次生成下一个唯一的序列号。这个函数返回一个*生成器*！如您所见，我们不是每次需要新序列号时都调用该函数，而是使用`next()`给定的生成器来获取下一个序列号。

# 惰性迭代器

更准确地说，这个生成器是一个*惰性迭代器*！迭代器是帮助我们遍历对象序列的对象。之所以称为*惰性*，是因为它在需要时才将序列中的所有项目加载到内存中。`next`上例中使用的是从迭代器中获取下一项的*显式方式。**隐式*方法是使用for 循环：

```
for barcode in barcode_generator():
    print(barcode) 
```

这将无限打印条形码，但您不会耗尽内存。

**换句话说，生成器*看起来像*一个函数，但*行为却像*一个迭代器。**

# 现实世界的应用？

最后，现实世界的应用？当您处理大序列时，它们通常很有用。想象一下从磁盘读取一个包含数十亿条记录的*巨大文件。*在您可以使用其内容之前读取内存中的整个文件可能是不可行的（即，您将耗尽内存）。

* * *

## 回答 #25

> 赞同：70
> 
> 时间：2016-03-25T05:40:24.543

（我下面的回答只是从使用Python生成器的角度讲，而不是[生成器机制的底层实现](https://stackoverflow.com/questions/8389812/how-are-generators-and-coroutines-implemented-in-cpython)，其中涉及到一些栈和堆操作的技巧。）

在python 函数`yield`中使用 when 代替 a`return`时，该函数会变成特殊的东西，称为`generator function`. 该函数将返回一个`generator`类型的对象。**关键字是一个标志，`yield`通知python编译器特别对待这样的函数。**一旦从它返回一些值，普通函数将终止。但是在编译器的帮助下，生成器函数**可以被认为**是可恢复的。也就是说，将恢复执行上下文，并从上次运行继续执行。直到您显式调用 return，这将引发`StopIteration`异常（这也是迭代器协议的一部分），或者到达函数的末尾。我找到了很多关于`generator`但这个[的参考资料](https://docs.python.org/dev/howto/functional.html#generators)从`functional programming perspective`是最易消化的。

（现在我想谈谈背后的基本原理`generator`，以及`iterator`基于我自己的理解。我希望这可以帮助你理解迭代器和生成器的***本质动机***。这样的概念也出现在其他语言中，例如C#。）

据我了解，当我们要处理一堆数据时，我们通常会先将数据存储在某个地方，然后逐个处理。但是这种*幼稚*的方法是有问题的。如果数据量很大，那么预先将它们作为一个整体存储起来会很昂贵。**因此，与其`data`直接存储自身，不如间接存储某种方式`metadata`，即`the logic how the data is computed`**.

有两种方法可以包装此类元数据。

1.  OO 方法，我们包装元数据`as a class`。这就是所谓`iterator`谁实现了迭代器协议（即`__next__()`, 和`__iter__()`方法）。这也是常见的[迭代器设计模式](https://en.wikipedia.org/wiki/Iterator_pattern#Python)。
2.  函数式方法，我们包装元数据`as a function`。这就是所谓的`generator function`。但在底层，返回的`generator object`仍然是`IS-A`迭代器，因为它也实现了迭代器协议。

无论哪种方式，都会创建一个迭代器，即一些可以为您提供所需数据的对象。OO 方法可能有点复杂。无论如何，使用哪一个取决于您。

* * *

## 回答 #26

> 赞同：70
> 
> 时间：2016-10-13T13:43:40.877

总之，该`yield`语句将您的函数转换为一个工厂，该工厂生成一个名为 a 的特殊对象，该对象`generator`环绕您的原始函数的主体。当`generator`被迭代时，它会执行你的函数，直到它到达下一个`yield`然后暂停执行并评估传递给的值`yield`。它在每次迭代中重复这个过程，直到执行路径退出函数。例如，

```
def simple_generator():
    yield 'one'
    yield 'two'
    yield 'three'

for i in simple_generator():
    print i 
```

简单地输出

```
one
two
three 
```

力量来自使用带有计算序列的循环的生成器，生成器每次执行循环停止以“产生”计算的下一个结果，这样它就可以动态计算列表，好处是内存为特别大的计算而保存

假设你想创建一个你自己的`range`函数来产生一个可迭代的数字范围，你可以这样做，

```
def myRangeNaive(i):
    n = 0
    range = []
    while n < i:
        range.append(n)
        n = n + 1
    return range 
```

并像这样使用它；

```
for i in myRangeNaive(10):
    print i 
```

但这是低效的，因为

*   您创建了一个只使用一次的数组（这会浪费内存）
*   这段代码实际上在该数组上循环了两次！:(

幸运的是 Guido 和他的团队足够慷慨地开发生成器，所以我们可以这样做；

```
def myRangeSmart(i):
    n = 0
    while n < i:
       yield n
       n = n + 1
    return

for i in myRangeSmart(10):
    print i 
```

现在，在每次迭代中，被调用的生成器上的一个函数都会`next()`执行该函数，直到它到达一个“yield”语句，在该语句中它停止并“yield”值或到达函数的末尾。在这种情况下，在第一次调用时，`next()`执行到 yield 语句和 yield 'n'，在下一次调用时，它将执行增量语句，跳回 'while'，评估它，如果为真，它将停止并再次 yield 'n' ，它将继续这种方式，直到 while 条件返回 false 并且生成器跳转到函数的末尾。

* * *

## 回答 #27

> 赞同：66
> 
> 时间：2015-09-01T12:42:19.250

**产量是一个对象**

函数中的A`return`将返回单个值。

如果您希望**函数返回大量值**，请使用`yield`.

更重要的是，`yield`是**一道屏障**。

> 就像 CUDA 语言中的屏障一样，它在完成之前不会转移控制权。

也就是说，它会从头开始运行你的函数中的代码，直到它到达`yield`. 然后，它将返回循环的第一个值。

然后，每个其他调用将再次运行您在函数中编写的循环，返回下一个值，直到没有任何值可以返回。

* * *

## 回答 #28

> 赞同：63
> 
> 时间：2016-09-10T11:37:25.087

许多人使用`return`而不是`yield`，但在某些情况下`yield`可以更高效且更易于使用。

这是一个`yield`绝对最适合的示例：

> **返回**（在函数中）

```
import random

def return_dates():
    dates = [] # With 'return' you need to create a list then return it
    for i in range(5):
        date = random.choice(["1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th"])
        dates.append(date)
    return dates 
```

> **产量**（在函数中）

```
def yield_dates():
    for i in range(5):
        date = random.choice(["1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th"])
        yield date # 'yield' makes a generator automatically which works
                   # in a similar way. This is much more efficient. 
```

> **调用函数**

```
dates_list = return_dates()
print(dates_list)
for i in dates_list:
    print(i)

dates_generator = yield_dates()
print(dates_generator)
for i in dates_generator:
    print(i) 
```

这两个函数做同样的事情，但`yield`使用三行而不是五行，并且少了一个需要担心的变量。

> > **这是代码的结果：**

[![输出](https://i.stack.imgur.com/iUFNJ.png)](https://i.stack.imgur.com/iUFNJ.png)

正如你所看到的，这两个函数都做同样的事情。唯一的区别是`return_dates()`给出了一个列表并`yield_dates()`给出了一个生成器。

一个现实生活中的例子就像一行一行地读取文件，或者你只是想制作一个生成器。

* * *

## 回答 #29

> 赞同：54
> 
> 时间：2015-11-18T19:37:29.577

`yield`关键字只是收集返回的结果。想像`yield`_`return +=`

* * *

## 回答 #30

> 赞同：51
> 
> 时间：2015-05-20T06:19:32.417

`yield`就像函数的返回元素。不同之处在于，该`yield`元素将函数转换为生成器。生成器的行为就像一个函数，直到“产生”某些东西。生成器停止直到下一次被调用，并从与它开始的完全相同的点继续。您可以通过调用`list(generator())`.

* * *

## 回答 #31

> 赞同：50
> 
> 时间：2016-06-22T09:40:15.943

又一个 TL;DR

**列表上的迭代器**：`next()`返回列表的下一个元素

**迭代器生成器**：`next()`将即时计算下一个元素（执行代码）

您可以将 yield/generator 视为一种从外部手动运行**控制流**的方式（如继续循环一步），通过调用`next`，无论流程多么复杂。

**注意**：生成器**不是**正常功能。它像局部变量（堆栈）一样记住以前的状态。有关详细说明，请参阅其他答案或文章。生成器只能**迭代一次**。你可以没有`yield`，但它不会那么好，所以它可以被认为是“非常好的”语言糖。

* * *

## 回答 #32

> 赞同：46
> 
> 时间：2016-02-20T17:41:32.807

这是一种基于简单`yield`的方法来计算斐波那契数列，解释说：

```
def fib(limit=50):
    a, b = 0, 1
    for i in range(limit):
       yield b
       a, b = b, a+b 
```

当你将它输入到你的 REPL 中然后尝试调用它时，你会得到一个神秘的结果：

```
>>> fib()
<generator object fib at 0x7fa38394e3b8> 
```

这是因为存在`yield`向 Python 发出信号表明您要创建*生成器*，即按需生成值的对象。

那么，如何生成这些值呢？这可以通过使用内置函数直接完成`next`，或者通过将其提供给消耗值的构造间接完成。

使用内置`next()`函数，您直接调用`.next`/ `__next__`，强制生成器产生一个值：

```
>>> g = fib()
>>> next(g)
1
>>> next(g)
1
>>> next(g)
2
>>> next(g)
3
>>> next(g)
5 
```

间接地，如果您向`fib`循环`for`、`list`初始化程序、`tuple`初始化程序或任何其他期望生成/产生值的对象提供，您将“消耗”生成器，直到它不能产生更多值（并且它返回） ：

```
results = []
for i in fib(30):       # consumes fib
    results.append(i) 
# can also be accomplished with
results = list(fib(30)) # consumes fib 
```

同样，使用`tuple`初始化程序：

```
>>> tuple(fib(5))       # consumes fib
(1, 1, 2, 3, 5) 
```

生成器与函数的不同之处在于它是惰性的。它通过维护其本地状态并允许您在需要时恢复来实现这一点。

当您第一次调用`fib`它时：

```
f = fib() 
```

Python 编译函数，遇到`yield`关键字并简单地返回一个生成器对象给你。看起来不是很有帮助。

然后，当您请求它直接或间接生成第一个值时，它会执行它找到的所有语句，直到遇到 a `yield`，然后它会返回您提供的值`yield`并暂停。为了更好地演示这一点，让我们使用一些调用（在 Python 2 上`print`用 if 替换）：`print "text"`

```
def yielder(value):
    """ This is an infinite generator. Only use next on it """ 
    while 1:
        print("I'm going to generate the value for you")
        print("Then I'll pause for a while")
        yield value
        print("Let's go through it again.") 
```

现在，输入 REPL：

```
>>> gen = yielder("Hello, yield!") 
```

您现在有一个生成器对象正在等待一个命令来生成一个值。使用`next`并查看打印的内容：

```
>>> next(gen) # runs until it finds a yield
I'm going to generate the value for you
Then I'll pause for a while
'Hello, yield!' 
```

未引用的结果是打印的结果。引用的结果是从`yield`. `next`现在再次调用：

```
>>> next(gen) # continues from yield and runs again
Let's go through it again.
I'm going to generate the value for you
Then I'll pause for a while
'Hello, yield!' 
```

生成器记得它被暂停`yield value`并从那里恢复。`yield`打印下一条消息，并再次执行对要暂停的语句的搜索（由于`while`循环）。

* * *

## 回答 #33

> 赞同：41
> 
> 时间：2017-04-29T17:22:22.743

**收益率**类似于回报。区别在于：

**yield**使函数可迭代（在以下示例中，`primes(n = 1)`函数变为可迭代）。
它本质上的意思是下次调用该函数时，它将从它离开的地方继续（在 行之后`yield expression`）。

```
def isprime(n):
    if n == 1:
        return False
    for x in range(2, n):
        if n % x == 0:
            return False
    else:
        return True

def primes(n = 1):
   while(True):
       if isprime(n): yield n
       n += 1 

for n in primes():
    if n > 100: break
    print(n) 
```

在上面的例子中，如果`isprime(n)`为真，它将返回素数。在下一次迭代中，它将从下一行继续

```
n += 1 
```

* * *

## 回答 #34

> 赞同：30
> 
> 时间：2018-09-09T13:25:57.443

在 Python`generators`中（一种特殊类型`iterators`）用于生成一系列值，`yield`关键字就像`return`生成器函数的关键字一样。

**`yield`关键字所做的另一个有趣的事情是保存`state`生成器函数**。

因此，我们可以在`number`每次`generator`收益率时将 a 设置为不同的值。

这是一个例子：

```
def getPrimes(number):
    while True:
        if isPrime(number):
            number = yield number     # a miracle occurs here
        number += 1

def printSuccessivePrimes(iterations, base=10):
    primeGenerator = getPrimes(base)
    primeGenerator.send(None)
    for power in range(iterations):
        print(primeGenerator.send(base ** power)) 
```

* * *

## 回答 #35

> 赞同：30
> 
> 时间：2019-02-22T12:11:45.597

`yield`产生一些东西。就像有人要你做 5 个纸杯蛋糕。如果您完成了至少一个纸杯蛋糕，您可以在制作其他蛋糕时将其给他们吃。

```
In [4]: def make_cake(numbers):
   ...:     for i in range(numbers):
   ...:         yield 'Cake {}'.format(i)
   ...:

In [5]: factory = make_cake(5) 
```

这里`factory`被称为生成器，它可以为您制作蛋糕。如果你调用`make_function`，你会得到一个生成器而不是运行那个函数。这是因为当`yield`关键字出现在函数中时，它就变成了生成器。

```
In [7]: next(factory)
Out[7]: 'Cake 0'

In [8]: next(factory)
Out[8]: 'Cake 1'

In [9]: next(factory)
Out[9]: 'Cake 2'

In [10]: next(factory)
Out[10]: 'Cake 3'

In [11]: next(factory)
Out[11]: 'Cake 4' 
```

他们吃光了所有的蛋糕，但他们又要了一个。

```
In [12]: next(factory)
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
<ipython-input-12-0f5c45da9774> in <module>
----> 1 next(factory)

StopIteration: 
```

他们被告知不要再问了。因此，一旦您使用了生成器，您就完成了它。`make_cake`如果您想要更多蛋糕，您需要再次致电。这就像再次订购纸杯蛋糕一样。

```
In [13]: factory = make_cake(3)

In [14]: for cake in factory:
    ...:     print(cake)
    ...:
Cake 0
Cake 1
Cake 2 
```

您还可以将 for 循环与上述生成器一起使用。

再举一个例子：假设您在要求时想要一个随机密码。

```
In [22]: import random

In [23]: import string

In [24]: def random_password_generator():
    ...:     while True:
    ...:         yield ''.join([random.choice(string.ascii_letters) for _ in range(8)])
    ...:

In [25]: rpg = random_password_generator()

In [26]: for i in range(3):
    ...:     print(next(rpg))
    ...:
FXpUBhhH
DdUDHoHn
dvtebEqG

In [27]: next(rpg)
Out[27]: 'mJbYRMNo' 
```

这`rpg`是一个生成器，它可以生成无限数量的随机密码。所以我们也可以说，当我们不知道序列的长度时，生成器很有用，不像列表有有限数量的元素。

* * *

## 回答 #36

> 赞同：22
> 
> 时间：2017-10-03T11:30:17.890

这里的所有答案都很棒；但其中只有一个（投票最多的一个）与**您的代码的工作方式**有关。其他的则与一般的*发电机*有关，以及它们是如何工作的。

所以我不会重复生成器是什么或产量是什么。我认为这些都被现有的很好的答案所涵盖。但是，在花了几个小时试图理解与您的类似代码之后，我将分解它是如何工作的。

您的代码遍历二叉树结构。让我们以这棵树为例：

```
 5
   / \
  3   6
 / \   \
1   4   8 
```

另一个更简单的二叉搜索树遍历实现：

```
class Node(object):
..
def __iter__(self):
    if self.has_left_child():
        for child in self.left:
            yield child

    yield self.val

    if self.has_right_child():
        for child in self.right:
            yield child 
```

执行代码在`Tree`对象上，实现`__iter__`如下：

```
def __iter__(self):

    class EmptyIter():
        def next(self):
            raise StopIteration

    if self.root:
        return self.root.__iter__()
    return EmptyIter() 
```

该`while candidates`语句可以替换为`for element in tree`; Python将其翻译为

```
it = iter(TreeObj)  # returns iter(self.root) which calls self.root.__iter__()
for element in it: 
    .. process element .. 
```

因为`Node.__iter__`函数是一个生成器，所以**它里面**的代码每次迭代都会执行。所以执行看起来像这样：

1.  根元素是第一个；检查它是否留下了孩子并`for`迭代它们（我们称它为it1，因为它是第一个迭代器对象）
2.  它有一个孩子，所以`for`被执行了。从 中`for child in self.left`创建一个**新的迭代器**，`self.left`它本身就是一个 Node 对象 (it2)
3.  与2相同的逻辑，并`iterator`创建一个新的（it3）
4.  现在我们到达了树的左端。`it3`没有左孩子，所以它继续，`yield self.value`
5.  在下一次调用`next(it3)`它时引发`StopIteration`并存在，因为它没有正确的孩子（它到达函数的末尾而不产生任何东西）
6.  `it1`并且`it2`仍然活跃 - 他们没有筋疲力尽，跟注`next(it2)`会产生价值，而不是加注`StopIteration`
7.  现在我们回到`it2`上下文，并`next(it2)`在它停止的地方继续调用：就在`yield child`语句之后。由于它没有更多的左孩子，它继续并产生它`self.val`。

这里的问题是每次迭代**都会创建子迭代器**来遍历树，并保存当前迭代器的状态。一旦它到达末尾，它就会返回堆栈，并以正确的顺序返回值（首先产生最小的值）。

您的代码示例以不同的技术做了类似的事情：它为每个孩子填充了**一个元素列表**，然后在下一次迭代中弹出它并在当前对象上运行函数代码（因此是`self`）。

我希望这对这个传奇话题有所贡献。我花了好几个小时绘制这个过程来理解它。

* * *

## 回答 #37

> 赞同：15
> 
> 时间：2020-08-22T06:48:15.620

## 也可以将数据发送回生成器！

事实上，正如这里的许多答案所解释的那样，使用`yield`创建一个`generator`.

您可以使用`yield`关键字**将数据发送回“实时”生成器**。

### 例子：

假设我们有一种将英语翻译成其他语言的方法。在它开始的时候，它做了一些很重的事情，应该做一次。我们希望这个方法永远运行（真的不知道为什么.. :)），并接收要翻译的单词。

```
def translator():
    # load all the words in English language and the translation to 'other lang'
    my_words_dict = {'hello': 'hello in other language', 'dog': 'dog in other language'}

    while True:
        word = (yield)
        yield my_words_dict.get(word, 'Unknown word...') 
```

跑步：

```
my_words_translator = translator()

next(my_words_translator)
print(my_words_translator.send('dog'))

next(my_words_translator)
print(my_words_translator.send('cat')) 
```

将打印：

```
dog in other language
Unknown word... 
```

### 总结一下：

使用`send`生成器内部的方法将数据发送回生成器。为此，`(yield)`使用了 a。

* * *

## 回答 #38

> 赞同：12
> 
> 时间：2020-01-17T10:17:34.020

python中的yield与return语句类似，除了一些不同之处。如果必须从函数返回多个值，return 语句会将所有值作为列表返回，并且必须存储在调用者块的内存中。但是如果我们不想使用额外的内存怎么办？相反，我们希望在需要时从函数中获取值。这就是 yield 的用武之地。考虑以下函数：-

```
def fun():
   yield 1
   yield 2
   yield 3 
```

来电者是：-

```
def caller():
   print ('First value printing')
   print (fun())
   print ('Second value printing')
   print (fun())
   print ('Third value printing')
   print (fun()) 
```

上述代码段（调用者函数）在调用时输出：-

```
First value printing
1
Second value printing
2
Third value printing
3 
```

从上面可以看出，yield 会返回一个值给它的调用者，但是当再次调用该函数时，它并不是从第一条语句开始，而是从yield 之后的语句开始。在上面的示例中，打印了“First value printing”并调用了该函数。1 被退回并打印。然后打印“第二值打印”并再次调用 fun()。它没有打印 1（第一条语句），而是返回 2，即紧接在 yield 1 之后的语句。同样的过程被进一步重复。

* * *

## 回答 #39

> 赞同：6
> 
> 时间：2021-09-13T15:40:21.553

**简单来说**

yield 语句暂停函数的执行并将值发送回调用者，但保留足够的状态以使函数能够从中断的地方恢复。恢复后，函数会在最后一次 yield 运行后立即继续执行。这允许它的代码随着时间的推移产生一系列值，而不是一次计算它们并将它们像列表一样发送回来。

**让我们看一个例子：**

```
# A Simple Python program to demonstrate working
# of yield

# A generator function that yields 1 for the first time,
# 2 second time and 3 third time
def simpleGeneratorFun():
    yield 1
    yield 2
    yield 3 
```

**用于检查上述生成器功能的驱动程序代码**

```
for value in simpleGeneratorFun(): 
    print(value)

Output:

1
2
3 
```

Return 将指定的值发送回其调用者，而 Yield 可以生成一系列值。当我们想要迭代一个序列但又不想将整个序列存储在内存中时，我们应该使用 yield。

**产量**用于 Python 生成器。生成器函数的定义与普通函数一样，但每当需要生成值时，它都会使用 yield 关键字而不是 return。如果 def 的主体包含 yield，则该函数自动成为生成器函数。

* * *

## 回答 #40

> 赞同：6
> 
> 时间：2021-10-03T17:18:22.087

# 简单的答案

当函数包含至少一条`yield`语句时，该函数自动成为生成器函数。当您调用生成器函数时，python 会执行生成器函数中的代码，直到`yield`语句发生。`yield`语句冻结函数及其所有内部状态。当您再次调用生成器函数时，python 会从冻结位置继续执行生成器函数中的代码，直到`yield`语句一次又一次地出现。`yield`生成器函数执行代码，直到生成器函数在没有语句的情况下用完。

# 基准

创建一个列表并返回它：

```
def my_range(n):
    my_list = []
    i = 0
    while i < n:
        my_list.append(i)
        i += 1
    return my_list

@profile
def function():
    my_sum = 0
    my_values = my_range(1000000)
    for my_value in my_values:
        my_sum += my_value

function() 
```

结果：

```
Total time: 1.07901 s
Timer unit: 1e-06 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     9                                           @profile
    10                                           def function():
    11         1          1.1      1.1      0.0      my_sum = 0
    12         1     494875.0 494875.0     45.9      my_values = my_range(1000000)
    13   1000001     262842.1      0.3     24.4      for my_value in my_values:
    14   1000000     321289.8      0.3     29.8          my_sum += my_value

Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
     9   40.168 MiB   40.168 MiB           1   @profile
    10                                         def function():
    11   40.168 MiB    0.000 MiB           1       my_sum = 0
    12   78.914 MiB   38.746 MiB           1       my_values = my_range(1000000)
    13   78.941 MiB    0.012 MiB     1000001       for my_value in my_values:
    14   78.941 MiB    0.016 MiB     1000000           my_sum += my_value 
```

动态生成值：

```
def my_range(n):
    i = 0
    while i < n:
        yield i
        i += 1

@profile
def function():
    my_sum = 0

    for my_value in my_range(1000000):
        my_sum += my_value

function() 
```

结果：

```
Total time: 1.24841 s
Timer unit: 1e-06 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     7                                           @profile
     8                                           def function():
     9         1          1.1      1.1      0.0      my_sum = 0
    10
    11   1000001     895617.3      0.9     71.7      for my_value in my_range(1000000):
    12   1000000     352793.7      0.4     28.3          my_sum += my_value

Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
     7   40.168 MiB   40.168 MiB           1   @profile
     8                                         def function():
     9   40.168 MiB    0.000 MiB           1       my_sum = 0
    10
    11   40.203 MiB    0.016 MiB     1000001       for my_value in my_range(1000000):
    12   40.203 MiB    0.020 MiB     1000000           my_sum += my_value 
```

# 概括

生成器函数需要比返回列表的函数多一点的时间来执行，但它使用的内存要少得多。

* * *

## 回答 #41

> 赞同：6
> 
> 时间：2021-11-09T06:28:11.517

一个简单的用例：

```
>>> def foo():
    yield 100
    yield 20
    yield 3

>>> for i in foo(): print(i)

100
20
3
>>> 
```

它是如何工作的：当被调用时，该函数立即返回一个对象。该对象可以传递给 next() 函数。每当调用 next() 函数时，您的函数都会运行到下一个 yield 并为 next() 函数提供返回值。

在底层，for 循环识别出该对象是一个生成器对象并使用 next() 来获取下一个值。

在一些像 ES6 和更高版本的语言中，它的实现略有不同，因此 next 是生成器对象的成员函数，您可以在每次获取下一个值时从调用者传递值。因此，如果 result 是生成器，那么您可以执行类似 y = result.next(555) 的操作，并且产生值的程序可以说类似 z = yield 999。y 的值将是下一个从 yield 获得的 999，并且z 的值将是 555，yield 从下一个获得。Python 的 get 和 send 方法具有类似的效果。

* * *

## 回答 #42

> 赞同：5
> 
> 时间：2021-06-14T19:26:23.460

通常，它用于创建函数外的迭代器。将“yield”视为函数的 append()，将函数视为数组。如果满足某些条件，您可以在函数中添加该值以使其成为迭代器。

```
arr=[]
if 2>0:
   arr.append(2)

def func():
   if 2>0:
      yield 2 
```

两者的输出将相同。

使用 yield 的主要优点是创建迭代器。迭代器在实例化时不会计算每个项目的值。他们仅在您要求时才计算它。这称为惰性求值。

* * *

## 回答 #43

> 赞同：3
> 
> 时间：2021-06-14T12:27:36.803

功能 - 返回。

生成器 - 收益（包含一个或多个收益和零个或多个收益）。

```
names = ['Sam', 'Sarah', 'Thomas', 'James']

# Using function
def greet(name) :
    return f'Hi, my name is {name}.'

for each_name in names:
    print(greet(each_name))

# Output:   
>>>Hi, my name is Sam.
>>>Hi, my name is Sarah.
>>>Hi, my name is Thomas.
>>>Hi, my name is James.

# using generator
def greetings(names) :
    for each_name in names:
        yield f'Hi, my name is {each_name}.'

for greet_name in greetings(names):
    print (greet_name)

# Output:    
>>>Hi, my name is Sam.
>>>Hi, my name is Sarah.
>>>Hi, my name is Thomas.
>>>Hi, my name is James. 
```

生成器看起来像一个函数，但行为却像一个迭代器。

生成器从它离开（或产生）的地方继续执行。恢复后，函数会在最后一次 yield 运行后立即继续执行。这允许它的代码随着时间的推移产生一系列值，而不是一次计算它们并像列表一样将它们发送回来。

```
def function():
    yield 1 # return this first
    yield 2 # start continue from here (yield don't execute above code once executed)
    yield 3 # give this at last (yield don't execute above code once executed)

for processed_data in function(): 
    print(processed_data)

#Output:

>>>1
>>>2
>>>3 
```

注意：yield 不应该在 try...finally 中构造。

* * *

## 回答 #44

> 赞同：2
> 
> 时间：2021-12-05T11:14:02.787

生成器允许立即获取单个已处理的项目（无需等待整个集合被处理）。这在下面的示例中进行了说明。

```
import time

def get_gen():
    for i in range(10):
        yield i
        time.sleep(1)

def get_list():
    ret = []
    for i in range(10):
        ret.append(i)
        time.sleep(1)
    return ret

start_time = time.time()
print('get_gen iteration (individual results come immediately)')
for i in get_gen():
    print(f'result arrived after: {time.time() - start_time:.0f} seconds')
print()

start_time = time.time()
print('get_list iteration (results come all at once)') 
for i in get_list():
    print(f'result arrived after: {time.time() - start_time:.0f} seconds') 
```

```
get_gen iteration (individual results come immediately)
result arrived after: 0 seconds
result arrived after: 1 seconds
result arrived after: 2 seconds
result arrived after: 3 seconds
result arrived after: 4 seconds
result arrived after: 5 seconds
result arrived after: 6 seconds
result arrived after: 7 seconds
result arrived after: 8 seconds
result arrived after: 9 seconds

get_list iteration (results come all at once)
result arrived after: 10 seconds
result arrived after: 10 seconds
result arrived after: 10 seconds
result arrived after: 10 seconds
result arrived after: 10 seconds
result arrived after: 10 seconds
result arrived after: 10 seconds
result arrived after: 10 seconds
result arrived after: 10 seconds
result arrived after: 10 seconds 
```

* * *

## 回答 #45

> 赞同：2
> 
> 时间：2022-01-07T05:40:30.933

该`yield`关键字用于枚举/迭代，其中函数预计返回一个以上的输出。我想引用这个非常简单**的例子 A**：

```
# example A
def getNumber():
    for r in range(1,10):
        return r 
```

上面的函数即使被多次调用也只会返回**1 。**现在，如果我们替换`return`为`yield`示例**B**：

```
# example B
def getNumber():
    for r in range(1,10):
        yield r 
```

它会在第一次调用时返回**1 ，当再次调用时返回****2**，然后是**3**、**4**并且它会递增到 10。

尽管**示例 B**在概念上是正确的，但要在**python 3**中调用它，我们必须执行以下操作：

```
 g = getNumber() #instance
print(next(g)) #will print 1
print(next(g)) #will print 2
print(next(g)) #will print 3

# so to assign it tot variables
v = getNumber()
v1 = next(v) #v1 will have 1
v2 = next(v) #v2 will have 2
v3 = next(v) #v3 will have 3 
```

* * *

## 回答 #46

> 赞同：1
> 
> 时间：2021-12-29T16:02:06.150

python中的yield关键字用于在不干扰局部变量状态的情况下退出代码，并且当再次调用该函数时，执行从我们离开代码的最后一点开始。

下面的例子演示了它的工作原理：

```
def counter():
    x=2
    while x < 5:
        yield x
        x += 1

print("Initial value of x: ", counter()) 

x=2
x=x+1

for y in counter():
    print(y) 
```

上面的代码生成下面的输出：

x 的初始值：<generator object counter at 0x7f0263020ac0>

2

3

4

* * *

## 回答 #47

> 赞同：0
> 
> 时间：2021-12-29T08:32:50.220

要了解它的产量函数，必须了解什么是生成器。此外，在了解生成器之前，您必须了解*iterables*。Iterable: iterable 要创建一个列表，自然需要能够一个一个地读取每个元素。逐一读取其项的过程称为迭代：

```
>>> mylist = [1, 2, 3]
>>> for i in mylist:
...    print(i)
1
2
3 
```

mylist 是一个可迭代的。当你使用列表推导时，你创建了一个列表，因此是可迭代的：</p>

```
>>> mylist = [x*x for x in range(3)]
>>> for i in mylist:
...    print(i)
0
1
4 
```

所有可用于... in... 的数据结构都是可迭代的；列表、字符串、文件...

这些可迭代的方法很方便，因为您可以随意读取它们，但是您将所有值都存储在内存中，当您有很多值时，这并不总是可取的。生成器：生成器 生成器也是迭代器的一种，一种特殊的迭代，只能迭代一次。生成器不会将所有值存储在内存中，而是动态生成值：

发电机：发电机，发电机，发电机发电但不储存能量；）

```
>>> mygenerator = (x*x for x in range(3))
>>> for i in mygenerator:
...    print(i)
0
1
4 
```

只要使用 () 代替 []，列表推导就成为生成器推导。但是，由于生成器只能使用一次，所以不能第二次执行 mygenerator 中的 for i：生成器计算 0，然后丢弃，然后计算 1，最后一次计算 4。典型的黑瞎子掰玉米.

yield 关键字的使用方式与 return 相同，只是该函数将返回生成器。

```
>>> def createGenerator():
...    mylist = range(3)
...    for i in mylist:
...        yield i*i
...
>>> mygenerator = createGenerator() 
>>> print(mygenerator) 
<generator object createGenerator at 0xb7555c34>
>>> for i in mygenerator:
...     print(i)
0
1
4 
```

这个例子本身没什么用，但是当你需要一个函数返回大量的值并且只需要读取一次时，使用yield就变得方便了。

要掌握yield，需要明确一点，当一个函数被调用时，写在函数体中的代码是不会运行的。该函数仅返回生成器对象。初学者可能会对此感到困惑。

其次，了解代码每次使用生成器时都会从中断处继续。

现在最困难的部分是：

第一次 for 调用从你的函数创建的生成器对象，它会从头开始运行函数中的代码，直到它达到 yield，然后它会返回循环的第一个值。然后，每个后续调用将运行您在函数中编写的循环的下一次迭代并返回下一个值。这将一直持续到生成器被认为是空的，当函数运行时没有命中时产生。那可能是因为循环已经结束，或者因为您不再对“if/else”感到满意。

个人理解希望对你有所帮助！

# cross-browser - 最好先开发跨浏览器代码，还是为一个浏览器开发，然后再回去让它在其他浏览器中工作？

> ID：231773
> 
> 赞同：7
> 
> 时间：2008-10-23T22:22:57.610
> 
> 标签：cross-browser

我正在寻找有关开发跨浏览器工作网站的人们体验的反馈。在我看来，至少有两种明显的方法可以让您的网站/网络应用程序跨浏览器工作：

1.  每一步都在所有支持的浏览器上不断测试；或者
2.  选择一个浏览器，让所有在其中工作的东西作为参考实现，然后让所有其他浏览器与参考实现相匹配。

每种方法都有一个明显的缺点——#1 的问题是你最终会做很多不必要的工作——特别是如果你正在开发一个经历大量迭代/原型设计/尖峰等的 web 应用程序。你会做一堆东​​西可以跨浏览器工作，随后将被丢弃/删除。

方法 #2 的缺点是，虽然它使初始开发变得更快、更痛苦，但它使找出某些特定错误出现的位置变得更加困难，尤其是对于更复杂的问题——而如果你一直在为所有人开发浏览器您应该立即抓住它并知道是什么变化引入了问题。

一个有点明显的第三种选择是混合方法，但在我看来，你最终会因为遇到#1 和#2 的两个问题而失去更多，而不是从两者中获得的好处。

您发现应对这一挑战的最有效方法是什么？

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-10-23T22:28:59.050

我发现，如果您在开发网站时过于深入而没有查看其他浏览器，您将很快到达一个令人头疼的地方，无法调试。我一直在我关心的所有浏览器中打开我的网页。

我强烈建议您在每次对网站进行重大更改时验证所有浏览器。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-23T22:29:38.220

使其与所有浏览器一起工作。这将意味着在开发过程中进行额外的测试，但会在以后减少您的痛苦。我发现如果我刚刚开发了这个东西，通常更容易诊断问题，而不是稍后再回来尝试找出它......以及其他问题的列表。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-23T22:26:19.320

这部分取决于您是否知道它必须预先在所有浏览器中工作。如果你这样做了，那么你最好从一开始就让它跨浏览器。您*无需*在每一步都测试所有内容是否 100% 兼容，但您应该为此编写代码。

真的，这并不难，尤其是 jQuery 和 Dojo 等 JS 框架围绕着这些框架来处理这些工作。如果您发现自己不断地与一种或另一种浏览器作斗争，您可能需要重新考虑您的设计，因为当跨浏览器兼容性很重要时，您可能选择了一种本质上更难做的事情。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-24T08:26:23.930

好吧，你做#1，但你在做*风格指南*的同时做这件事。有点像这样：[http](http://www.sitefromscratch.com/content/html-xhtml-css-testing) ://www.sitefromscratch.com/content/html-xhtml-css-testing 。

因此，在设计新网站或设计时，您创建的页面包含将在您的网站上使用的所有视觉元素所需的 HTML。现在忽略样式，只使用最有意义的 HTML。

然后你设计它。最好，您的样式指南都在一个页面上，因此它可以在您支持的每个浏览器中打开，您需要做的就是在更改之间点击刷新，（避免选择多个页面，因为检查需要更长的时间商场）。

当您构建您的网站时，请根据样式指南进行构建。如果它不在样式指南中，请先添加并在那里进行测试。如果您在构建站点时发现问题（例如，可能在包装时没有考虑特定元素），请在样式指南中复制并修复问题。

这是杀手锏：您支持的浏览器的一个新版本发布了，您希望测试什么，您的整个网站，还是样式指南？

这就是 CSS 的处理，现在你需要用你的通用 JS 函数（如果有的话）来做这件事。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-23T22:32:46.187

我在浏览器和我的代码之间创建了一个接口兼容层——基本上，我包装了某些功能并让包装器确定需要什么 javascript/html。

随着浏览器的变化，您可以更改此兼容性层，您可以不理会其余代码。

如果您的架构中有这一层，那么您的问题的答案将变为“随时随地”。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-23T22:34:07.870

如果您可以获得企业锁定，那么多浏览器支持就不会成为问题，例如，如果您的客户都是使用 Internet Explorer 的公司，那么为什么要构建在 Safari 或 Chrome 中看起来不错的网站？

如果您正在为公众制作东西，那么我会使用一种混合方法，即我使用一个浏览器来获取所有功能并正常工作，然后在我处于“美化”阶段时跨浏览器进行测试的项目。最初的关键是让它工作，然后它必须看起来不错。

当我最初填写表格或执行一些其他基本功能时，我认为我看不到在所有浏览器上进行测试的逻辑，因为在至少几个浏览器上进行测试可能会极大地消耗生产力，例如 IE 6 和 7 , Firefox 2 和 3, Opera 9.5, Safari, 和 Chrome，如果你想得到所有的大男孩，至少有几个操作系统，因为 Mac 上的 Safari 可能与 Windows 上的 Safari 不同，这是很多测试即使只有一两页。另一方面，在接近尾声的时候，我可以重构我的 CSS 和内联样式，并使代码更好地移交给其他人维护，存档直到计划服务包项目，或者保留一些文档以防万一有些事必须得完成。还有，等着收拾东西，

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-23T22:38:33.227

我通常开始确保我编写/使用的所有 HTML 和控件都符合规范。

工具-->选项-->文本编辑器-->HTML-->验证-->检查显示错误并选择您的目标

这让我有了坚实的基础。我在单个浏览器中对新功能进行功能测试，然后每天大约一次/两次在所有浏览器中测试它们的全部集。

使用这种方法时，CSS 和 JS 是不正确的常见嫌疑人，它很少是实际的 HTML 标记。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-10-23T23:24:28.343

如果你第一次就做对了。就这么办。以后可能永远不会对了。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-23T22:38:23.070

主要取决于您的经验，这可以应用于任何编程活动，包括这个。如果您事先知道您将不得不避免哪些可能的陷阱（例如，在跨浏览器开发中，请不要尝试在不同的浏览器中做一些麻烦的事情来让自己变得困难） ，那么您可能可以在一个浏览器中安全地开发所有内容，然后在完成后进入并进行调整以使其在任何地方都能正常工作。

我通常建议初级开发人员在开发过程中保持所有浏览器打开，并在进行更改时刷新每个浏览器，但我自己倾向于使用 Firebug 编写所有内容以获得支持，然后再回去看看它在 IE7（等）中的表现。因为我已经这样做了好几年了，所以大多数时候我可以预测会导致头痛的原因，并且通常会立即知道在哪里解决它。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-10-23T23:52:40.393

如果您是 Web 设计/开发的新手，那么在不同的浏览器中做正确的事情有时可能是一件苦差事。

然而，让一个网站在所有主流浏览器中运行并按照 W3C 标准进行编码并不难。在我看来，**每个**设计师/开发人员都应该这样做，否则他们不会比 IE 时代更好。

开发跨浏览器代码，确保它经过验证，不再考虑为一个浏览器设计。

# .net - .NET 紧凑型框架和 ActiveSync

> ID：231780
> 
> 赞同：5
> 
> 时间：2008-10-23T22:24:10.120
> 
> 标签：.net, windows-mobile, activesync, handhelddevice

有没有办法让我在 Windows CE 设备上运行的 .NET CF 应用程序知道设备何时与 PC 对接/同步？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-23T22:47:36.297

我相信这会有所帮助[http://msdn.microsoft.com/en-us/library/microsoft.windowsmobile.status.aspx](http://msdn.microsoft.com/en-us/library/microsoft.windowsmobile.status.aspx)

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2009-07-08T17:00:49.790

请参阅以下内容：Microsoft.WindowsMo​​bile.Status 和 ConnectionsDesktopCount。如果 ConnectionsDesktopCount > 0，那么您将连接到 PC。

有关如何使用 Microsoft.WindowsMo​​bile.Status 的演示，请参阅此处的 SDK 示例[http://msdn.microsoft.com/en-us/library/bb158637.aspx 。](http://msdn.microsoft.com/en-us/library/bb158637.aspx)

谢谢，迈克

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2009-10-15T13:17:21.940

我不认为这是它。也许，对于 WM 5.0 设备，这可以工作，那么旧设备呢？他们不支持此解决方案。

# oracle - Oracle 会淘汰 10gAS 以支持 WebLogic 吗？

> ID：231812
> 
> 赞同：6
> 
> 时间：2008-10-23T22:31:07.610
> 
> 标签：oracle, jakarta-ee, weblogic, application-server

Oracle 购买了 BEA 及其 WebLogic 工具套件。他们在自己的 10gAS 应用服务器中仍然有竞争产品。两者都是[Java EE](http://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition)，企业级，服务器。虽然由于维护协议需要一些时间，但他们在同一建筑空间内继续生产两种产品是不寻常的。所以...

1.  他们会淘汰以前的应用程序服务器以支持 WebLogic 吗？
2.  WebLogic 会被淘汰吗？
3.  这可能需要多长时间？年？

* * *

他们对 PeopleSoft 与 Oracle 应用程序做了什么？可能会遵循相同的模式。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-23T22:48:03.927

您可以阅读 Oracle 提供的（相当长的）[PDF 战略简报](http://download.oracle.com/products/middleware/oracle-middleware-strategy-briefing-072008.pdf)。不过，关键的幻灯片可能是#48。Oracle 已将 BEA Weblogic 列入“战略产品”名单，并将 Oracle 应用服务器列入“继续与融合”名单。所以甲骨文表示甲骨文应用服务器将消失（在营销方面，它将与 BEA 产品融合），而 BEA Weblogic 是未来的战略方向。

至于问题3，我相信至少要几年，这取决于你对“退休”的定义。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T22:47:26.953

是的。他们已经宣布了他们的立场。OC4J/Orion 将继续得到支持，但是 weblogic 版本是该平台的未来。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-23T22:38:11.887

正如你所说，他们在同一个建筑空间内维护两种产品是不寻常的。我不了解 Java 应用程序服务器，但考虑到金融市场的气候，并且维护两台这样的应用程序服务器可能需要大量资金，我会说其中一个产品将被削减已成定局，并且早点而不是晚点（一旦解决维护合同违约的成本低于维护即将推出的产品的成本）。至于哪个会去，我的赌注是 WebLogic，因为它“不是在这里发明的”......

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T22:48:25.483

是的，这是事实。甲骨文在今年早些时候的产品路线图中解释了这一点。“新”产品称为 Oracle Weblogic Server，从现在开始，这就是所有销售人员都应该为新客户提供的产品。Justin 发布的 PDF 文件显示了这一点。

看看 Oracle Weblogic 10g :S :S [alt text http://img266.imageshack.us/img266/2200/oracleweblogic10guk4.png](http://img266.imageshack.us/img266/2200/oracleweblogic10guk4.png)

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-31T12:04:09.437

在 Oracle 术语中，“Oracle 应用服务器”产品不仅仅包含 J2EE 服务器。一个组件是 J2EE 服务器，它曾经是 OC4J。Oracle 宣布他们新的战略 J2EE 服务器是 WebLogic。

因此仍然会有一个名为“Oracle Application Server”的产品，但从 11g 版本开始，J2EE 服务器将是 WebLogic。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2009-01-02T19:57:14.113

Oracle will release a 11g version oc4j, but after that [Oracle WebLogic Server](https://en.wikipedia.org/wiki/Oracle_WebLogic_Server) (WLS) will be the preferred [Java EE](http://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition) server. WLS is much better with clustering and has a lot of [JMS](https://en.wikipedia.org/wiki/Java_Message_Service) / [JDBC](http://en.wikipedia.org/wiki/Java_Database_Connectivity) options.

# vb.net - 什么是“DefInstance”，我应该从 WinForms 应用程序中删除它吗？

> ID：231821
> 
> 赞同：3
> 
> 时间：2008-10-23T22:33:50.523
> 
> 标签：vb.net, winforms, vb6, vb6-migration

我正在开发一个 VB.NET WinForms 应用程序，它是由 Visual Studio（最初是 1.0 或 1.1）从 VB6 代码（它本身是从 VB5 升级的）“升级”的。除了我在接管这个应用程序的维护后创建的几个新表单之外，应用程序中的所有表单都有一个名为 DefInstance 的方法，如果有的话，它允许您获取表单的内存副本。我不知道为什么：当它不在我工作的范围内时，我什么时候需要引用内存中的表单对象。在我看来，这违反了各种合理的编程原则，并且似乎是内存泄漏或更糟的邀请。

问题：（1）这个 DefInstance 东西仅仅是这个应用程序的 VB6 遗产的不幸残余，以及（2）我应该在整个应用程序中删除 DefInstance 方法吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-28T14:28:34.597

我从 Microsoft 员工那里收到了这个答案：

[http://msdn.microsoft.com/en-us/library/aa289529(VS.71,printer).aspx](http://msdn.microsoft.com/en-us/library/aa289529%28VS.71,printer%29.aspx)

In short, DefInstance is a "not best practices" compatibility method for older apps that haven't been made into true .NET WinForms apps. Being a web programmer until earlier this year I had never worked with VB6 "WinForms" applications nor had to deal with the compatibility compromises that the upgrade wizard makes in forcing them into .NET.

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-11-10T01:55:19.693

Yes, the default instance is a terrible byproduct of importing the application through the upgrade wizard. Using the default instance was a VB habit in pre dot net versions because forms were always resident in memmory as a default instance, although you could also g=create additional instances.

As Parvenu74 said, it is not a best practise. That being said, you should be very careful when removing it from an imported application because of side affects and references where it might be being used. Your best bet is to not use it in new code that you develop and slowly migrate yourself away from the "converted" code over time. As was mentioned above the default instance stuff was re-instroduced in VB 2005, but it's use is highly discouraged.

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T22:48:00.557

正如您所提到的，它可以让您获得对表单的引用。

我见过很多这样写的VB：

```
Private Sub Command_Click()
   Call DoStuff
End Sub

Private Sub DoStuff()
   Form1.myTextbox.Text = "Bad Idea"
End Sub 
```

DefInstance 允许 DoStuff() 在不传递控件的情况下继续工作。

请参阅此处：[http](http://social.msdn.microsoft.com/Forums/en-US/vbgeneral/thread/6d7985b5-6db6-47a8-9e11-cbf114a48d37/) ://social.msdn.microsoft.com/Forums/en-US/vbgeneral/thread/6d7985b5-6db6-47a8-9e11-cbf114a48d37/了解更多信息。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-25T04:10:17.770

可悲的是，VB8 (VS2005) 中添加了一些有毒的语法糖。现在，当 VB.NET 程序员无法理解每个线程都有一个单独的“Form1”实例时，他们会感到非常困惑。好消息：现在您绝对不再需要 DefInstance。

# java - 如何处理来自数据库的大量结果集

> ID：231827
> 
> 赞同：6
> 
> 时间：2008-10-23T22:35:06.697
> 
> 标签：java, database, web-applications, lazy-loading, resultset

我正在设计一个多层数据库驱动的 Web 应用程序——SQL 关系数据库、用于中间服务层的 Java、用于 UI 的 Web。语言真的不重要。

中间服务层执行数据库的实际查询。UI 只是要求某些数据，并且不知道它是由数据库支持的。

问题是如何处理大型数据集？UI 要求提供数据，但结果可能很大，可能太大而无法放入内存。例如，路牌应用程序可能具有以下服务层：

```
StreetSign getStreetSign(int identifier)
Collection<StreetSign> getStreetSigns(Street street)
Collection<StreetSign> getStreetSigns(LatLonBox box) 
```

UI 层要求让所有街道标志符合某些标准。根据标准，结果集可能很大。UI 层可能会将结果分成单独的页面（用于浏览器）或将它们全部呈现（服务于 Goolge Earth）。潜在的巨大结果集可能是性能和资源问题（内存不足）。

一种解决方案是不返回完全加载的对象（StreetSign 对象）。而是返回某种延迟加载每个单独对象的结果集或迭代器。

另一种解决方案是更改服务 API 以返回请求数据的子集：

```
Collection<StreetSign> getStreetSigns(LatLonBox box, int pageNumber, int resultsPerPage) 
```

当然 UI 仍然可以请求一个巨大的结果集：

```
getStreetSigns(box, 1, 1000000000) 
```

我很好奇这种场景的标准行业设计模式是什么？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-23T23:39:05.040

第一个问题应该是：

¿ 用户需要或有能力管理这些数据量吗？

虽然结果集应该被分页，但如果它的潜在大小如此巨大，答案将是“可能不会”，所以 UI 不应该尝试显示它。

我在医疗保健系统上从事 J2EE 项目，该项目处理大量存储数据，数以百万计的患者、访问、表格等，一般规则是任何用户搜索不显示超过 100 或 200 行，建议那些标准集产生更多他可以理解的信息的用户。

实现这一点的方式因项目而异，可以强制 UI 在启动查询之前询问服务层查询的大小，或者如果结果集增长，可以从服务层抛出异常太多（但是这种方式将服务层与有限的 UI 实现结合在一起）。

当心！这并不意味着服务层上的每个方法都必须在其结果大小超过 100 时抛出异常，此一般规则仅适用于直接向用户显示的结果集，这是将控件放置在 UI 中的更好理由而是在服务层上。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T23:33:55.503

我在这种情况下看到的最常见的模式是某种分页，通常在服务器端完成以减少通过网络发送的信息量。

这是一个使用表变量（通常比临时表快）的 SQL Server 2000 示例以及您的街道标志示例：

```
CREATE PROCEDURE GetPagedStreetSigns
(
  @Page int = 1,
  @PageSize int = 10
)
AS
  SET NOCOUNT ON

  -- This memory-variable table will control paging
  DECLARE @TempTable TABLE (RowNumber int identity, StreetSignId int)

  INSERT INTO @TempTable
  (
     StreetSignId
  )
  SELECT [Id]
  FROM   StreetSign
  ORDER BY [Id]

  -- select only those rows belonging to the requested page
  SELECT SS.*
  FROM   StreetSign SS
         INNER JOIN @TempTable TT ON TT.StreetSignId = SS.[Id]
  WHERE  TT.RowNumber BETWEEN ((@Page - 1) * @PageSize + 1) 
                      AND (@Page * @PageSize) 
```

在 SQL Server 2005 中，您可以更聪明地使用 Common Table Expressions 和新的 SQL Ranking 函数之类的东西。但总的主题是您使用服务器只返回属于当前页面的信息。

请注意，如果您允许最终用户将即时过滤器应用于她/他所看到的数据，这种方法可能会变得混乱。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T22:41:13.220

我会说，如果存在大量数据的潜力，那么就走寻呼路线。

您仍然可以设置不希望他们超过的 MAX。

EG SO 使用的页面大小为 15、30、50...

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-23T23:56:30.153

在使用像您（显然）拥有的本土行包装类时要警惕的一件事是，在您（开发人员）不知道的情况下对数据库进行额外调用的代码。例如，您可能会调用一个返回 Person 对象集合的方法，并认为在后台发生的唯一事情是单个“SELECT * FROM PERSONS”调用。实际上，您调用的方法可能会遍历返回的 Person 对象集合，并进行额外的 DB 调用来填充每个 Person 的 Orders 集合。

正如您所说，您的解决方案之一是不返回完全加载的对象，因此您可能已经意识到这个潜在的问题。我倾向于避免使用行包装器的原因之一是它们总是难以调整您的应用程序并最小化数据库流量的大小和频率。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-24T19:40:33.667

从数据检索层来看，标准设计模式是有两个方法接口，一个用于所有，一个用于块大小。

如果您愿意，您可以对在其上进行分页的组件进行分层。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-23T22:39:37.670

在 ASP.NET 中，我将使用服务器端分页，您只检索用户从数据存储中请求的数据页面。这与检索整个结果集、将其放入内存并根据请求对其进行分页相反。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-23T22:39:46.343

JSF 或 JavaServerFaces 具有用于将大型结果集分块到浏览器的小部件。它可以按照您的建议进行参数化。无论如何，我都不会称其为“标准行业设计模式”，但值得看看其他人如何解决这个问题。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-23T22:50:05.090

当我处理这种类型的问题时，我通常将发送到浏览器（或瘦/胖客户端，以更适合您的情况）的数据分块，而不管满足某些特定标准的数据的实际总大小，仅一小部分确实可以一次在任何 UI 中使用。

我生活在微软的世界里，所以我的主要环境是带有 SQL Server 的 ASP.Net。这里有两篇关于分页的文章（其中提到了一些通过结果集进行分页的技术），它们可能会有所帮助：

[使用 ASP.NET 2.0 高效地（并以 Ajax 方式）分页大量数据](http://weblogs.asp.net/scottgu/archive/2006/01/01/434314.aspx) [使用 ASP.NET 2.0 DataList 控件和 ObjectDataSource 的高效数据分页](http://weblogs.asp.net/scottgu/archive/2006/01/07/434787.aspx)

微软最近发布的另一种机制是他们的“[动态数据](http://msdn.microsoft.com/en-us/library/cc668159.aspx)”理念——你可能可以查看它的核心内容，以获得关于他们如何处理这个问题的一些指导。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-23T22:51:27.913

我在两种不同的产品上做过类似的事情。在一种情况下，数据源可以选择分页——对于 java，实现类似于以下的 Pageable 接口：

```
public interface Pageable
{
    public void setStartIndex( int index );
    public int getStartIndex();
    public int getRowsPerPage() throws Exception;
    public void setRowsPerPage( int rowsPerPage );
} 
```

数据源实现了另一种获取项目的方法，分页数据源的实现只返回当前页面。所以你可以设置你的起始索引，并在你的控制器中抓取一个页面。

要考虑的一件事是缓存您的游标服务器端。对于网络应用程序，您必须使它们过期，但它们确实有助于提高性能。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-10-23T23:25:12.557

[fedora 数字存储库](http://fedora.info/)项目使用结果集 ID 返回最大数量的结果。然后，您通过在后续查询中请求提供 result-set-id 的下一个块来获得其余的结果。只要您不想在查询之外进行任何搜索或排序，它就可以正常工作。

# sql - MySQL 条件语句

> ID：231838
> 
> 赞同：1
> 
> 时间：2008-10-23T22:39:49.370
> 
> 标签：sql, mysql, conditional

好的，所以我有一个如下所示的查询：

```
SELECT 
    `orders`.*,
    GROUP_CONCAT(
        CONCAT(
            `menu_items`.`name`, 
            ' ($',
            FORMAT(`menu_items`.`price`,2),
            ')'
        ) SEPARATOR '<br>'
    ) as `items`,
    SUM(`menu_items`.`price`) as `additional`,
    `children`.`first_name`,
    `children`.`last_name`,
    `organizations`.`base_price`
FROM 
    `orders`, `order_items`, `menu_items`, `children`, `organizations`
WHERE 
    `order_items`.`menu_item_id` = `menu_items`.`id` AND 
    `order_items`.`order_id` = `orders`.`id` AND
    `orders`.`added_by` = {$user_id} AND
    `orders`.`date` > '{$cutoff}' AND
    `children`.`id` = `orders`.`child_id` AND
    `organizations`.`id` = `children`.`organization_id`
GROUP BY 
    `orders`.`id` 
```

我知道这是一个怪物，有些人会在不使用显式连接之前死去。然而，忽略这一点，我想做的是只使用`CONCAT`内部`GROUP_CONCAT`if`menu_items.price`大于 0，否则只使用 return `menu_items.name`。然而，我没有成功尝试`IF`在那里扔一个。我已经阅读了手册，但我尝试过的所有方法都不起作用，我很确定我在整个条件语句的事情上遗漏了一些东西。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-23T22:45:37.207

你试过用这样的东西吗？

```
CASE WHEN 'menu_items'.'price' = 0 THEN 'menu.items'.'name' ELSE CONCAT (etc) END 
```

当然是替换`CONCAT`语句。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T23:32:38.330

像这样的东西应该可以工作（但我没有测试它，抱歉）：

```
GROUP_CONCAT(
  CONCAT(
    `menu_items`.`name`, 
    IF(`menu_items`.`price` > 0,                          -- <condition>
      CONCAT(' ($', FORMAT(`menu_items`.`price`,2), ')'), -- <true-expr>
      ''                                                  -- <false-expr>
    )
  )
  SEPARATOR '<br>'
) as `items`, 
```

`IF()`功能非常简单：

```
IF( <condition>, <true-expr>, <false-expr> ) 
```

该函数有三个参数：第一个是`<condition>`. 如果条件计算结果为真，则函数返回 的结果`<true-expr>`。否则该函数返回的结果`<false-expr>`。

当您使用包含括号和逗号等的非常长的多行表达式时，事情会变得更难。你只需要小心翼翼地去做。我建议从更简单的表达式开始，然后建立。

# python - Python继承 - 如何禁用函数

> ID：231839
> 
> 赞同：38
> 
> 时间：2008-10-23T22:40:55.780
> 
> 标签：python, inheritance, interface, private

在 C++ 中，您可以通过在子类中将其声明为私有来禁用父类中的函数。如何在 Python 中做到这一点？IE 如何从孩子的公共界面隐藏父母的功能？

* * *

## 回答 #1

> 赞同：31
> 
> 时间：2008-10-23T22:52:51.513

Python 中确实没有任何真正的“私有”属性或方法。您可以做的一件事是简单地覆盖子类中不需要的方法，并引发异常：

```
>>> class Foo( object ):
...     def foo( self ):
...         print 'FOO!'
...         
>>> class Bar( Foo ):
...     def foo( self ):
...         raise AttributeError( "'Bar' object has no attribute 'foo'" )
...     
>>> b = Bar()
>>> b.foo()
Traceback (most recent call last):
  File "<interactive input>", line 1, in <module>
  File "<interactive input>", line 3, in foo
AttributeError: 'Bar' object has no attribute 'foo' 
```

* * *

## 回答 #2

> 赞同：19
> 
> 时间：2008-10-25T00:05:19.717

kurosch 解决问题的方法并不完全正确，因为您仍然可以`b.foo`在没有`AttributeError`. 如果您不调用该函数，则不会发生错误。以下是我能想到的两种方法：

```
import doctest

class Foo(object):
    """
    >>> Foo().foo()
    foo
    """
    def foo(self): print 'foo'
    def fu(self): print 'fu'

class Bar(object):
    """
    >>> b = Bar()
    >>> b.foo()
    Traceback (most recent call last):
    ...
    AttributeError
    >>> hasattr(b, 'foo')
    False
    >>> hasattr(b, 'fu')
    True
    """
    def __init__(self): self._wrapped = Foo()

    def __getattr__(self, attr_name):
        if attr_name == 'foo': raise AttributeError
        return getattr(self._wrapped, attr_name)

class Baz(Foo):
    """
    >>> b = Baz()
    >>> b.foo() # doctest: +ELLIPSIS
    Traceback (most recent call last):
    ...
    AttributeError...
    >>> hasattr(b, 'foo')
    False
    >>> hasattr(b, 'fu')
    True
    """
    foo = property()

if __name__ == '__main__':
    doctest.testmod() 
```

Bar 使用“包装”模式来限制对包装对象的访问。[Martelli 对此进行了很好的讨论](http://www.aleax.it/gdd_pydp.pdf)。Baz 使用[内置的属性](http://docs.python.org/library/functions.html?highlight=property#property)来实现要覆盖的属性的描述符协议。

* * *

## 回答 #3

> 赞同：14
> 
> 时间：2014-04-17T06:41:17.613

kurosch 答案的一个变体：

```
class Foo( object ):
    def foo( self ):
        print 'FOO!'

class Bar( Foo ):
    @property
    def foo( self ):
        raise AttributeError( "'Bar' object has no attribute 'foo'" )

b = Bar()
b.foo 
```

这会在属性上引发 an `AttributeError`，而不是在调用方法时引发。

我会在评论中建议它，但不幸的是还没有它的声誉。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-10-23T22:49:22.863

```
class X(object):
    def some_function(self):
        do_some_stuff()

class Y(object):
    some_function = None 
```

这可能会导致一些令人讨厌且难以找到的异常被抛出，所以你可以试试这个：

```
class X(object):
    def some_function(self):
        do_some_stuff()

class Y(object):
    def some_function(self):
        raise NotImplementedError("function some_function not implemented") 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2014-04-17T06:32:24.403

这是我知道的最干净的方法。

覆盖这些方法并让每个被覆盖的方法调用您的 disabledmethods() 方法。像这样：

```
class Deck(list):
...
@staticmethod
    def disabledmethods():
        raise Exception('Function Disabled')
    def pop(self): Deck.disabledmethods()
    def sort(self): Deck.disabledmethods()
    def reverse(self): Deck.disabledmethods()
    def __setitem__(self, loc, val): Deck.disabledmethods() 
```

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2019-06-26T10:59:19.673

那可能更简单。

```
@property
def private(self):
    raise AttributeError

class A:
    def __init__(self):
        pass
    def hello(self):
        print("Hello World")

class B(A):
    hello = private # that short, really
    def hi(self):
        A.hello(self)

obj = A()
obj.hello()
obj = B()
obj.hi() # works
obj.hello() # raises AttributeError 
```

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2020-08-25T18:49:20.873

另一种方法是定义一个访问错误的描述符。

```
 class NotHereDescriptor:
        def __get__(self, obj, type=None):
            raise AttributeError

    class Bar:
        foo = NotHereDescriptor() 
```

这在本质上类似于一些人在上面使用的属性方法。但是，如果该函数确实不存在，它的优点是`hasattr(Bar, 'foo')`可以按预期返回。`False`这进一步减少了奇怪错误的机会。虽然它仍然出现在`dir(Bar)`.

如果您对它的作用及其工作原理感兴趣，请查看数据模型页面[https://docs.python.org/3/reference/datamodel.html#descriptors](https://docs.python.org/3/reference/datamodel.html#descriptors)的描述符部分以及如何使用[https:/的描述符/docs.python.org/3/howto/descriptor.html](https://docs.python.org/3/howto/descriptor.html)

# httpwebrequest - 为什么我从 HttpWebResponse 收到“双重响应”？

> ID：231848
> 
> 赞同：1
> 
> 时间：2008-10-23T22:46:09.297
> 
> 标签：httpwebrequest, asp.net-2.0, httpwebresponse

下面的代码（在 ASP.Net 2.0 中运行）**两次**显示请求的 URL 的内容。我只希望它显示一次请求的 URL 的内容。我无法弄清楚我做错了什么。请求的 URL 正在返回 XML，如果我直接访问该 URL，它可以正常工作。

```
HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
byte[] postDataBytes = Encoding.UTF8.GetBytes(postData);
request.Method = "POST";
request.ContentType = "application/xml";
request.ContentLength = postDataBytes.Length;
Stream requestStream = request.GetRequestStream();
requestStream.Write(postDataBytes, 0, postDataBytes.Length);
requestStream.Close();

// get response and write to console
response = (HttpWebResponse) request.GetResponse();
StreamReader responseReader = new StreamReader(response.GetResponseStream(), Encoding.UTF8);
try {
   Response.Write(responseReader.ReadToEnd());
}
finally {
   responseReader.Close();
}
response.Close(); 
```

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2008-10-24T10:12:32.937

您的代码看起来不错，所以我认为问题不存在......但我建议如下：

1) 也许错误在 URL 的另一端...所以尝试点击 Google 并查看返回的内容是否良好。

2) 在“responseReader.ReadToEnd()”处放一个断点，看看那里的结果是否好。

3) 如果上面的代码在 ASPX 页面中……你确定要调用“Response.End();”吗？在你最后一行代码之后？（不是“resposne.close()”，而是“Response.End()”）。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-24T14:36:57.243

我发现了问题。它根本不是上面的代码，而是被调用的页面。我调用的页面继承自一个类，该类的 Page_OnInit 方法包含以下行：“MyBase.OnLoad(e)”，这导致 Page_OnLoad 方法被执行两次。显然，它应该是 MyBase.OnInit(e) 。我没有抓住它，因为当我直接测试页面时，我不得不暂时从类中删除继承，因为其他一些代码会阻止我直接测试页面。

我现在要戴上我的“笨蛋”帽子，然后退到角落里休息一会儿。无论如何感谢您的帮助。

# mysql - 如何让 MySQL 以不同的用户身份写入输出文件？

> ID：231862
> 
> 赞同：12
> 
> 时间：2008-10-23T22:50:38.007
> 
> 标签：mysql, sql, into-outfile

我正在使用写入输出文件的 MySQL 查询。我每隔一两天运行一次此查询，因此我希望能够删除输出文件，而不必求助于 su 或 sudo。我能想到的唯一方法是让输出文件由 mysql 用户以外的人拥有。这可能吗？

编辑：我没有将输出重定向到文件，我正在使用选择查询的 INTO OUTFILE 部分输出到文件。

如果有帮助：

```
mysql --版本
mysql Ver 14.12 Distrib 5.0.32，适用于使用 readline 5.2 的 pc-linux-gnu (x86_64)

```

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2008-10-23T23:55:35.787

输出文件由 mysqld 进程创建，而不是由您的客户端进程创建。因此，输出文件必须由 mysqld 进程的 uid 和 gid 拥有。

如果您从可以访问该文件的 uid 或 gid 下的进程访问该文件，则可以避免使用 sudo 访问该文件。换句话说，如果mysqld创建了uid和gid“mysql”/“mysql”拥有的文件，那么将你自己的帐户添加到组“mysql”中。然后您应该能够访问该文件，前提是该文件的权限模式包括组访问。

**编辑：**

您正在删除 /tmp 中的文件，目录权限模式为 rwxrwxrwt。粘性位 ('t') 意味着只有当您的 uid 与文件的所有者相同时，您才能删除文件，而不管文件或目录的权限如何。

如果您将输出文件保存在另一个没有设置粘性位的目录中，您应该能够正常删除该文件。

阅读 sticky(8) 手册页的摘录：

**粘性目录**

一个设置了“sticky bit”的目录变成了一个只追加目录，或者更准确地说，一个限制删除文件的目录。只有当用户具有目录的写权限并且用户是文件的所有者、目录的所有者或超级用户时，用户才能删除或重命名粘性目录中的文件。此功能适用于 /tmp 等目录，该目录必须是可公开写入的，但应拒绝用户任意删除或重命名彼此文件的许可。

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-10-24T02:03:42.127

不使用“SELECT...INTO OUTFILE”语法，不。

您需要以另一个用户身份运行查询（即客户端），并重定向输出。例如，编辑您的 crontab 以随时运行以下命令：

```
mysql db_schema -e 'SELECT col,... FROM table' > /tmp/outfile.txt 
```

这将创建 /tmp/outfile.txt 作为您已将命令添加到的 crontab 用户。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T22:54:18.000

如果您有另一个用户从 cron 运行查询，它将以该用户的身份创建文件。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2010-06-12T11:58:11.150

我只是做

```
sudo gedit /etc/apparmor.d/usr.sbin.mysqld 
```

并添加

```
 /var/www/codeigniter/assets/download/* w, 
```

和

```
sudo service mysql restart 
```

就是这样，我可以轻松地做`SELECT INTO OUTFILE`任何文件名

# c++ - 声明中的 C++ 两种或多种数据类型

> ID：231868
> 
> 赞同：6
> 
> 时间：2008-10-23T22:52:18.097
> 
> 标签：c++, templates, g++

我`g++`在以下代码中从 3.3 收到一个奇怪的错误：

```
#include <bitset>
#include <string>

using namespace std;

template <int N, int M>
bitset<N> slice_bitset(const bitset<M> &original, size_t start) {
    string str = original.to_string<char, char_traits<char>, allocator<char> >();
    string newstr = str.substr(start, N);
    return bitset<N>(newstr);
}

int main() {
    bitset<128> test;
    bitset<12> result = slice_bitset<12, 128>(test, 0);
    return 0;
} 
```

错误如下：

```
在函数 `std::bitset slice_bitset(const std::bitset&, unsigned int)' 中：
',' 标记前的语法错误
`char_traits' 指定为 declarator-id
`char_traits' 声明中的两个或多个数据类型
`allocator' 指定为 declarator-id
`allocator' 声明中的两个或多个数据类型
`>' 标记前的语法错误

```

这一定是一件非常愚蠢的事情，但我已经把它告诉了我的橡皮鸭和一个朋友，但无济于事。

谢谢，懒人网。

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-10-27T11:53:42.117

上面从[CAdaker](https://stackoverflow.com/questions/231868/c-two-or-more-data-types-in-declaration#231904)选择的答案解决了问题，但没有解释**为什么**它解决了问题。

解析函数模板时，不会在依赖类型中进行查找。因此，可以解析如下结构：

```
template <typename T>
class B;

template <typename T>
void foo (B<T> & b) {
  // Use 'b' here, even though 'B' not defined
}

template <typename T>
class B
{
  // Define 'B' here.
}; 
```

然而，这个“特性”是有代价的，在这种情况下，“foo”的定义需要对模板“B”的内容进行提示。如果“foo”使用嵌套类型“B”，则`typename`需要关键字来告诉编译器该名称是一种类型：

```
template <typename T>
void foo (B<T> & b)
{
  typename B<T>::X t1;    // 'X' is a type - this declares t1
  B<T>::Y * t1;           // 'Y' is an object - this is multiplication
} 
```

上面没有'typename'，编译器将假定它`X`是一个对象（或函数）。

类似地，如果调用成员函数并且调用具有显式模板参数，则编译器需要知道将`<`视为模板参数列表的开头，而不是小于运算符：

```
template <typename T>
void foo (B<T> & b)
{
  b.template bar<int> (0); // 'bar' is a template, '<' is start of arg list
  b.Y < 10;                // 'Y' is an object, '<' is less than operator
} 
```

如果没有`template`，编译器会假定它`<`是小于运算符，因此当它看到时会生成语法错误，`int>`因为它不是表达式。

*即使*模板的定义可见，也需要这些提示。原因是显式特化可能会在以后更改实际选择的定义：

```
template <typename T>
class B
{
  template <typename S>
  void a();
};

template <typename T>
void foo (B<T> & b)
{
  b.a < 10;            // 'B<int>::a' is a member object
}

template <>
class B<int>
{
  int a;
}; 
```

* * *

## 回答 #2

> 赞同：7
> 
> 时间：2008-10-23T23:12:09.773

使用任何一个

```
original.to_string(); 
```

或者，如果您真的需要类型说明符，

```
original.template to_string<char, char_traits<char>, allocator<char> >(); 
```

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-23T23:20:12.533

以下为我编译（使用 gcc 3.4.4）：

```
#include <bitset>
#include <string>

using namespace std;

template <int N, int M> 
bitset<N> slice_bitset(const bitset<M> &original, size_t start) 
{   
  string str = original.to_string();
  string newstr = str.substr(start, N);    
  return bitset<N>(newstr);
}

int main() 
{ 
  return 0; 
} 
```

# web-services - WS* 与 REST = 课程的马匹……与否？

> ID：231869
> 
> 赞同：2
> 
> 时间：2008-10-23T22:52:31.513
> 
> 标签：web-services, rest, soap

好的，所以我已经实现了 REST 和 SOAP 服务，并且我喜欢这两种服务，具体取决于上下文。对我来说，当我希望在服务器和客户端之间建立明确的合同（例如敏感信息或关键任务的东西）时，WS* 非常有用。另一方面，REST 虽然在模式定义方面很灵活，但在我看来，它更适合不需要经过任何严肃业务逻辑的内容服务或数据。

REST 似乎非常流行，当来自 Thoughworks 的 Martin Fowler 等人提供这个播客时，我有点失望：[http](http://www.thoughtworks.com/what-we-say/podcasts.html) ://www.thoughtworks.com/what-we-say/podcasts.html on REST并对 WS* 嗤之以鼻。虽然这个人自己很受尊重，但我认为肥皂还有很多地方需要放盐，我是对的吗？有人在严肃的业务应用程序中使用过 REST 吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-24T01:37:45.377

您能否通过向某人​​提供您使用的媒体类型的描述和单个 URL 来记录您的 REST api？

如果您发现自己提供了一个 URL 列表以及可以在这些 URL 上使用哪些动词，那么您可能没有[REST api](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)。

一旦您创建了一个真正的 REST api，然后返回并将其与 WS* api 进行比较。你会发现它们非常不同。

REST api 可以轻松处理“严重的业务逻辑”，是的，我在一个严肃的业务应用程序中使用过 REST。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-27T14:12:57.170

[SOA Geek 的围栏日记 - Mark Little 博士](http://www.infoq.com/presentations/mark-little-soa-rest)

演示文稿是最近的 - 非常有启发性的东西。

REST 确实有效。对于重复业务而言，它不如 SOAP 好。如此多的顾问在此基础上为拯救 SOAP 而奋斗。随着 RESTful 架构的工具和框架的改进，企业将朝着这个方向发展。治理也是当下的热门话题。

新版本的 JAX-RS 是一个非常有趣的 RESTful 开发新工具，Mark Little 在他的演讲中提到了这一点。

您可能最好将 SOAP 视为遗留技术，它将更好地为您服务。;)

# windows - 强制 windows 刷新磁盘 FAT

> ID：231870
> 
> 赞同：2
> 
> 时间：2008-10-23T22:52:34.087
> 
> 标签：windows, winapi

我的磁盘上有一个用 FAT32 格式化的单独分区。当我休眠 Windows 时，我希望能够加载另一个操作系统，创建/修改该分区上的文件，然后让 Windows 退出休眠状态并能够看到我所做的更改。

我知道你要输入什么，“好吧，你不应该那样做！” 然后将我链接到一些关于我正在尝试做的事情是错误的/不可能的/会破坏一切的规范。但是，我确信有一些方法可以解决这个问题。:)

我不需要 Windows 中的 FAT32 分区，除了读取写入那里的文件，然后我就完成了 - 所以无论解决方案是什么，磁盘在一段时间内完全无法访问是可以接受的。不幸的是，我不能使整个物理磁盘脱机，因为它只是安装 Windows 的同一物理设备的一个分区——只是分区。

这些是我到目前为止尝试过的事情......

1.  去谷歌上查询。我至少得到了一个“这永远不会发生”的答案。不能接受！:)
2.  休眠前卸载磁盘。休眠后挂载。这似乎没有任何效果。Windows 仍然认为 FAT 和以前一样，所以我写入磁盘的任何数据都会丢失，并且我调整大小的所有文件都已损坏。如果任何文件被缓存，那就更糟了。
3.  使用 DeviceIoControl 调用 IOCTL_DISK_UPDATE_PROPERTIES 来尝试刷新磁盘（但分区表没有改变，所以这并没有真正做任何事情）。

有什么方法可以使磁盘/卷读取缓存无效以强制 Windows 返回磁盘？

我想过通过使用 libfat 并绕过缓存来打开分区并直接读/写，否则就有些过分了。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-31T19:59:51.270

所以我终于找到了解决我的问题的方法。在我看来，我将 Mount Point 与 Mount 相关联。这些不是一回事。删除所有卷安装点不会使卷卸载。它仍然已安装，但在某种意义上说您没有可以在资源管理器中访问的路径。

[这是](http://msdn.microsoft.com/en-us/library/dd143253.aspx)开始这一切的文章。它还表明，搜索你的确切问题，而不是感知问题可以有很大帮助！

所以有几个解决方案，一个是在一个紧密的循环中不断调用 NtSetSystemInformation() 来设置“SYSTEMCACHEINFORMATION”属性，以便在系统进入休眠状态时基本上清空/清除缓存。然后当你出来时停止循环。在我看来，这似乎会影响系统性能。所以我把它丢弃了。

更好的是，这篇 MSDN 文章中提出的稍微不同的问题的推荐解决方案，它为该问题的更好解决方案提供了方向：[在 Hibernate Once/Resume Many Configuration 中卸载卷](http://msdn.microsoft.com/en-us/library/dd143253.aspx)

现在我有一个服务，它将刷新写入缓存，然后在系统进入休眠/睡眠状态时锁定和卸载卷，并在卷上的锁一出来就释放它。

这里有一点代码。休眠>

```
volumeHandle = CreateFile(volumePath,
                          GENERIC_READ|GENERIC_WRITE, 
                          FILE_SHARE_READ|FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING, 
                          FILE_ATTRIBUTE_NORMAL,
                          0 );
FlushFileBuffers( volumeHandle );
DeviceIoControl( volumeHandle, FSCTL_LOCK_VOLUME, NULL, 0, NULL, 0, &cbReturned, NULL ) ;
DeviceIoControl( volumeHandle, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0, &cbReturned, NULL );
//Keep the handle open here.
//System hibernates. 
```

简历>

```
DeviceIoControl( volumeHandle, FSCTL_UNLOCK_VOLUME, NULL, 0, NULL, 0, &cbReturned, NULL )
CloseHandle(volumeHandle) 
```

希望这可以帮助其他人在未来:)

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T23:45:03.467

好吧，你不应该那样做！;-)

由于操作系统（本例中为 Windows，但 Linux 相同）在休眠映像中写入了一些内部文件系统结构，如果磁盘内容在“运行”时发生变化（将休眠视为只是操作系统执行中的长时间停顿）。

我可以建议您完全绕过这个问题：将分区格式化为 ext2。有 Windows 程序可以读取 ext2 分区，您可以使用它从中获取数据，并且大多数现代操作系统应该能够读取/写入它（因为它是一个非常常见的 Unix 风格的文件系统）。避免使用 ext2 IFS 驱动程序；您想将文件系统访问权从内核中取出并放入可以随意打开和关闭的程序中。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T23:50:52.660

使用 Linux 将分区创建为隐藏的 FAT32 分区。Linux 将允许您挂载分区并写入文件。Windows 不会让您挂载分区和读取文件，Windows 也不会损坏分区。但是有第三方库会在 Windows 运行时读取分区。

澄清一下，隐藏意味着分区类型不同于普通的 FAT32 分区类型。如果你的普通分区类型是 0x0C，那么对应的隐藏类型就是 0x1C。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2011-05-05T08:09:19.273

在一个相关但不同的问题上，我使用了以下内容：

以管理员身份运行 cmd（从批处理文件工作）
 `DISKPART
  SELECT G
  REMOVE
  ASSIGN LETTER=G
EXIT`

这将卸载卷 (G:)，然后重新安装它。对磁盘的任何读取（在我的情况下，设备伪装成格式化为 FAT16 的 USB 大容量存储设备）实际上会读取设备，因此读取缓存被有效地刷新。

缺点是启动 DISKPART 大约需要 4 秒，但在休眠情况下这可能不是问题。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-27T23:58:19.220

据我所知，Windows 在磁盘级别进行缓存。但是，如果一个分区的类型是 Windows 拒绝读取或写入的（ext2、隐藏的 FAT32 等），那么该分区的内容一开始就不应该进入 Windows 缓存。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2013-05-05T03:06:55.437

With DOS, it was typing `ctrl`+`c`, twice if I recall well.

With Linux, `sync; echo 3 > /proc/sys/vm/drop_caches` or a script thereof, of course ;-)

With Windows, interpolate ;-) Or install VirtualBox and Ubuntu+Wine to develop compatibly.

Well, I vaguely remember that former Windows used a diskcache program to start a process and that diskcache could be used to send the process a signal to flush and purge the whole cache. If things have evolved gently, you might be able to send such a signal to a Windows process. Sorry I'm no longer using Windows partly because of such obscurity.

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-23T23:38:59.593

我的记忆是在操作系统启动和安装卷期间读取 FAT 表。你不能关机，然后修改FAT，然后重新启动Windows吗？

# c# - 复杂模型绑定到列表

> ID：231878
> 
> 赞同：12
> 
> 时间：2008-10-23T22:55:20.103
> 
> 标签：c#, asp.net-mvc, binding

我一直在尝试来自 MVCContrib 的 NameValueDeserializer，它将 IList 作为控制器的参数并将表单及其元素绑定到它，但我只是想知道 MVC Beta 是否有任何方法可以做到这一点？

我知道您可以绑定强类型对象，但我想为一些批量编辑情况绑定这些对象的列表。

例如。

```
public void Save(IList<Item> items)
{
    foreach (Item i in items)
    {
        //Save item
    }
} 
```

这在 MVC Beta 中可能吗？提前致谢。

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2008-10-24T05:51:49.310

是的，我[在这里写了一篇详细的博客文章](http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx)。对于简单的类型来说真的很容易。对于复杂类型，您需要执行以下操作：

```
<input type="hidden" name="products.Index" value="0" />
<input type="text" name="products[0].Name" value="Beer" />
<input type="text" name="products[0].Price" value="7.32" />

<input type="hidden" name="products.Index" value="1" />
<input type="text" name="products[1].Name" value="Chips" />
<input type="text" name="products[1].Price" value="2.23" />

<input type="hidden" name="products.Index" value="2" />
<input type="text" name="products[2].Name" value="Salsa" />
<input type="text" name="products[2].Price" value="1.23" /> 
```

# c++ - std::map operator[] 中的违规读取位置

> ID：231885
> 
> 赞同：7
> 
> 时间：2008-10-23T23:00:08.223
> 
> 标签：c++, multithreading, exception, stl

我在运行一些传给我的旧代码时遇到了问题。它在 99% 的时间内都有效，但有时我注意到它会抛出“违反读取位置”异常。我有可变数量的线程可能在整个进程的生命周期内执行此代码。低发生频率可能​​表明存在竞争条件，但我不知道为什么在这种情况下会导致异常。这是有问题的代码：

```
MyClass::Dostuff()
{
    static map<char, int> mappedChars;
    if (mappedChars.empty())
    {
       for (char c = '0'; c <= '9'; ++c)
       {
          mappedChars[c] = c - '0';
       }
    }
    // More code here, but mappedChars in not changed.
} 
```

在地图的 operator[] 实现中抛出异常，在第一次调用 operator[] 时（使用 STL 的 VS2005 实现。）

```
 mapped_type& operator[](const key_type& _Keyval)
{
    iterator _Where = this->lower_bound(_Keyval); //exception thrown on the first line
    // More code here
} 
```

我已经尝试在 operator[] 中冻结线程并尝试让它们同时运行，但我无法使用该方法重现异常。

你能想出为什么会抛出的任何原因，而且只是在某些时候？

（是的，我知道 STL 不是线程安全的，我需要在这里进行更改。我很好奇为什么我会看到上面描述的行为。）

根据要求，此处提供有关异常的更多详细信息：
app15-51-02-0944_2008-10-23.mdmp 中 0x00639a1c (app.exe) 处的未处理异常：0xC0000005：访问冲突读取位置 0x00000004。

感谢大家提出多线程问题的解决方案，但这不是这个问题要解决的问题。是的，我理解所提供的代码没有得到正确的保护，并且在它试图完成的事情上是矫枉过正的。我已经实现了它的修复。我只是想更好地理解为什么会引发这个异常。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-23T23:19:37.217

给定地址“4”，“this”指针可能为空或迭代器错误。您应该能够在调试器中看到这一点。如果这是 null，那么问题不在于该函数，而在于调用该函数的人。如果迭代器不好，那么它就是你提到的竞争条件。大多数迭代器不能容忍列表被更新。

好的等等 - 这里没有调频。静态在第一次使用时被初始化。执行此操作的代码不是多线程安全的。一个线程正在进行初始化，而第二个线程认为它已经完成但仍在进行中。结果是使用了未初始化的变量。您可以在下面的程序集中看到这一点：

```
static x y;
004113ED  mov         eax,dword ptr [$S1 (418164h)] 
004113F2  and         eax,1 
004113F5  jne         wmain+6Ch (41141Ch) 
004113F7  mov         eax,dword ptr [$S1 (418164h)] 
004113FC  or          eax,1 
004113FF  mov         dword ptr [$S1 (418164h)],eax 
00411404  mov         dword ptr [ebp-4],0 
0041140B  mov         ecx,offset y (418160h) 
00411410  call        x::x (4111A4h) 
00411415  mov         dword ptr [ebp-4],0FFFFFFFFh 
```

$S1 在初始化时设置为 1。如果设置，(004113F5) 它将跳过初始化代码 - 冻结 fnc 中的线程将无济于事，因为此检查是在进入函数时完成的。这不是 null，但其中一个成员是。

通过将地图移出方法并作为静态进入类来修复。然后它将在启动时初始化。否则，您必须在调用 doStuff() 周围放置一个 CR。您可以通过在地图本身的使用周围放置一个 CR（例如，DoStuff 使用 operator[] 的地方）来防止剩余的 MT 问题。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-23T23:09:35.753

mappedChars 是静态的，因此它由执行 DoStuff() 的所有线程共享。仅此一项就可能是您的问题。

如果您必须使用静态映射，那么您可能需要使用互斥锁或临界区来保护它。

就个人而言，我认为为此目的使用地图是矫枉过正的。我会编写一个辅助函数，它接受一个字符并从中减去“0”。函数不会有任何线程安全问题。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-23T23:09:03.727

如果多个线程正在调用该函数`DoStuff`，这将意味着初始化代码

```
if (mappedChars.empty()) 
```

可以进入竞态条件。这意味着线程 1 进入函数，发现映射为空并开始填充它。然后线程 2 进入函数并发现映射非空（但未完全初始化），因此愉快地开始读取它。因为两个线程现在都在争用，但一个正在修改映射结构（即插入节点），将导致未定义的行为（崩溃）。

如果在检查映射之前使用同步原语`empty()`，并在保证映射完全初始化后释放，一切都会好起来的。

我通过[谷歌](http://blogs.msdn.com/oldnewthing/archive/2004/03/08/85901.aspx)看了一下，确实静态初始化**不是**线程安全的。因此，声明`static mappedChars`立即成为一个问题。正如其他人所提到的，最好在初始化的生命周期内保证只有 1 个线程处于活动状态时完成初始化。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-23T23:26:48.793

当你进入多线程时，通常有太多的事情来确定事情变坏的确切位置，因为它总是在变化。有很多地方在多线程情况下使用静态映射可能会变坏。

有关保护静态变量的一些方法，请参阅[此线程](https://stackoverflow.com/questions/164496/how-can-i-create-a-thread-safe-singleton-pattern-in-windows#164640)。您最好的选择可能是在启动多个线程以对其进行初始化之前调用该函数一次。要么，要么将静态地图移出，并创建一个单独的初始化方法。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-24T04:40:11.517

您是否曾经`operator[]`使用不在范围内的参数进行调用`0..9`？如果是这样，那么您无意中修改了地图，这可能会导致其他线程中发生错误。如果您`operator[]`使用映射中尚未存在的参数调用，它将将该键插入映射中，其值等于值类型的默认值（在 的情况下为 0 `int`）。

# c# - 对未触发的 BackgroundWorker 事件感到困惑

> ID：231886
> 
> 赞同：2
> 
> 时间：2008-10-23T23:01:40.560
> 
> 标签：c#, .net, winforms, backgroundworker

这似乎是一个有点做作的例子，但我只能摸不着头脑。

好的，我有一个控制台应用程序，它实例化一个 WindowsForm 并在表单上调用一个名为 DoSomeWork() 的方法。

```
class Program
  { 
    static void Main(string[] args)
    {
      Form1 form = new Form1();         
      form.DoSomeWork();   
    }
  } 
```

Form1 看起来像这样...

```
public partial class Form1 : Form
  {
    public Form1()
    {
      InitializeComponent();
    }

    public void DoSomeWork()
    {
      OuterClass outerClass = new OuterClass();
      outerClass.DoSomeWork();
    }    
  } 
```

反过来，外面的班级看起来像这样......

```
public class OuterClass
  {
    public void DoSomeWork()
    {
      InnerClass innerClass = new InnerClass();
      innerClass.DoSomeWork();
    }
  } 
```

最后 InnerClass 看起来像这样......

```
public class InnerClass
  {
    private BackgroundWorker _backgroundWorker = new BackgroundWorker();

    public InnerClass()
    {
      _backgroundWorker.WorkerReportsProgress = true;
      _backgroundWorker.DoWork += new DoWorkEventHandler(BackgroundWorker_DoWork);
      _backgroundWorker.ProgressChanged += new ProgressChangedEventHandler(BackgroundWorker_ProgressChanged);
    }

    void BackgroundWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
    {
      int i = 0; //I've placed a break point here. But it's never hit
    }

    void BackgroundWorker_DoWork(object sender, DoWorkEventArgs e)
    {
      BackgroundWorker worker = sender as BackgroundWorker;

      worker.ReportProgress(42);
    }

    public void DoSomeWork()
    {
      _backgroundWorker.RunWorkerAsync();
    }
  } 
```

由于未知的原因（对我而言），InnerClass 中的 BacgroundWorker 似乎从未触发**ProgressChanged**事件。如果我更换

```
Form1 form = new Form1(); 
```

和

```
OuterClass outerClass = new OuterClass() 
```

在类程序中，它工作正常。那么，当我通过表单调用相同的方法时，为什么我的事件不会触发呢？

谢谢！

编辑：我似乎通过将 ProgressChanged 事件处理程序作为抛出 NotImplementedException 来让人们失望，所以为了清楚起见，我已经删除了它。

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-24T00:16:24.963

您忘记启动消息循环，需要调用 Application.Run()。如果没有消息循环，BackgroundWorker 事件将无法工作。修理：

```
static void Main(string[] args)
{
  Application.Run(new Form1());   
} 
```

在表单的构造函数中调用 DoSomeWork() 或它的 Load 事件。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T23:08:54.477

你真的`throw NotImplementedException();`在处理程序中吗？或者你只是在快速模拟它而忘记删除它？

我的猜测是它与正在使用的不同线程单元模型有关。

根据我的经验，如果单线程公寓*非 UI*线程在主 UI 线程之外抛出异常，则该线程将简单地死掉而没有任何警告。

如果我没记错的话，Windows 窗体需要与控制台应用程序不同的公寓模型。这可能是问题的根源。

我可能是错的，但这应该给出一些指示。

# asp.net-mvc - ASP.Net MVC 是否在 ASP.NET 2.0 之上运行？

> ID：231891
> 
> 赞同：6
> 
> 时间：2008-10-23T23:06:01.783
> 
> 标签：asp.net-mvc

ASP.Net 2.0 和 Visual Studio 2005 是否有可能使用 MVC 或者我必须迁移到 VS2008 和 asp.net 3.5？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-24T05:57:01.953

It's definitely not supported. The post that Scott wrote might be outdated. Even following that post, it might not work now due to some recent changes. You're best off upgrading to .NET 3.5 as who knows what might break trying to build an ASP.NET MVC site for 2.0

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-27T00:45:20.373

事实上，我要求 Scott Hanselman 更新他的博客，说明他的技术不再有效。您必须升级到 ASP.NET 3.5 才能使用 ASP.NET MVC。（ASP.NET 3.5 Service Pack 1 不是必需的，尽管它可以正常工作。）

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-23T23:09:48.530

它不受支持，但您可以在此处阅读如何操作...

[http://www.hanselman.com/blog/DeployingASPNETMVCONASPNET20.aspx](http://www.hanselman.com/blog/DeployingASPNETMVCOnASPNET20.aspx)

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-23T23:09:25.113

它不打算工作，但我记得从 Scott Hanselman 那里读过一些东西，说它可能通过一些黑客攻击来实现。好像很狡猾。

# c# - "yield break" 是什么意思？在 C# 中做？

> ID：231893
> 
> 赞同：556
> 
> 时间：2008-10-23T23:07:02.700
> 
> 标签：c#, .net, yield

我在 MSDN: 中看到过这种语法[`yield break`](https://msdn.microsoft.com/en-us/library/9k7k7cf0.aspx)，但我不知道它的作用。有人知道吗？

* * *

## 回答 #1

> 赞同：590
> 
> 时间：2008-10-23T23:27:22.053

它指定迭代器已经结束。您可以将其`yield break`视为`return`不返回值的语句。

例如，如果您将函数定义为迭代器，则函数的主体可能如下所示：

```
for (int i = 0; i < 5; i++)
{
    yield return i;
}

Console.Out.WriteLine("You will see me"); 
```

请注意，循环完成所有循环后，将执行最后一行，您将在控制台应用程序中看到该消息。

或者像这样`yield break`：

```
int i = 0;
while (true)
{
    if (i < 5)
    {
        yield return i;
    }
    else
    {
        // note that i++ will not be executed after this
        yield break;
    }
    i++;
}

Console.Out.WriteLine("Won't see me"); 
```

在这种情况下，最后一条语句永远不会执行，因为我们提前离开了函数。

* * *

## 回答 #2

> 赞同：63
> 
> 时间：2008-10-23T23:09:09.577

结束一个迭代器块（例如，表示 IEnumerable 中没有更多元素）。

* * *

## 回答 #3

> 赞同：33
> 
> 时间：2008-10-23T23:17:00.623

告诉迭代器它已经到达终点。

举个例子：

```
public interface INode
{
    IEnumerable<Node> GetChildren();
}

public class NodeWithTenChildren : INode
{
    private Node[] m_children = new Node[10];

    public IEnumerable<Node> GetChildren()
    {
        for( int n = 0; n < 10; ++n )
        {
            yield return m_children[ n ];
        }
    }
}

public class NodeWithNoChildren : INode
{
    public IEnumerable<Node> GetChildren()
    {
        yield break;
    }
} 
```

* * *

## 回答 #4

> 赞同：26
> 
> 时间：2009-06-26T20:33:37.653

`yield`基本上使`IEnumerable<T>`方法的行为类似于协作（而不是抢占式）调度线程。

`yield return`就像一个线程调用“调度”或“睡眠”函数来放弃对 CPU 的控制。就像线程一样，该`IEnumerable<T>`方法在之后立即重新获得控制权，所有局部变量的值与放弃控制权之前的值相同。

`yield break`就像一个线程到达其功能的末尾并终止。

人们谈论“状态机”，但状态机实际上就是“线程”。一个线程有一些状态（即局部变量的值），每次调度它都会采取一些动作来达到一个新的状态。关键`yield`在于，与我们习惯的操作系统线程不同，使用它的代码会及时冻结，直到手动推进或终止迭代。

* * *

## 回答 #5

> 赞同：13
> 
> 时间：2018-07-24T15:13:03.043

yield break 只是表示最后一次返回并且不返回任何值的一种方式

例如

```
// returns 1,2,3,4,5
IEnumerable<int> CountToFive()
{
    yield return 1;
    yield return 2;
    yield return 3;
    yield return 4;
    yield return 5;
    yield break;
    yield return 6;
    yield return 7;
    yield return 8;
    yield return 9;
 } 
```

* * *

## 回答 #6

> 赞同：12
> 
> 时间：2016-11-26T01:22:56.780

该`yield break`语句导致枚举停止。实际上，`yield break`完成枚举而不返回任何其他项目。

考虑一下实际上有两种方法可以让迭代器方法停止迭代。在一种情况下，方法的逻辑可以在返回所有项目后自然退出方法。这是一个例子：

```
IEnumerable<uint> FindPrimes(uint startAt, uint maxCount)
{
    for (var i = 0UL; i < maxCount; i++)
    {
        startAt = NextPrime(startAt);
        yield return startAt;
    }

    Debug.WriteLine("All the primes were found.");
} 
```

在上面的例子中，一旦`maxCount`找到素数，迭代器方法自然会停止执行。

该`yield break`语句是迭代器停止枚举的另一种方式。是一种提早破除枚举的方法。这是与上面相同的方法。这一次，该方法对该方法可以执行的时间量有限制。

```
IEnumerable<uint> FindPrimes(uint startAt, uint maxCount, int maxMinutes)
{
    var sw = System.Diagnostics.Stopwatch.StartNew();
    for (var i = 0UL; i < maxCount; i++)
    {
        startAt = NextPrime(startAt);
        yield return startAt;

        if (sw.Elapsed.TotalMinutes > maxMinutes)
            yield break;
    }

    Debug.WriteLine("All the primes were found.");
} 
```

注意对 的调用`yield break`。实际上，它提前退出了枚举。

还要注意，这些`yield break`作品与普通的`break`. 在上面的示例中，`yield break`退出方法而不调用`Debug.WriteLine(..)`.

* * *

## 回答 #7

> 赞同：8
> 
> 时间：2010-04-04T08:59:27.263

这里[http://www.alteridem.net/2007/08/22/the-yield-statement-in-c/](http://www.alteridem.net/2007/08/22/the-yield-statement-in-c/)是一个很好的例子：

```
公共静态 IEnumerable<int> Range(int min, int max)
{
   而（真）
   {
      如果 ( 最小值 >= 最大值 )
      {
         产量中断；
      }
      收益返回 min++;
   }
}

```

和解释，如果一个`yield break`语句在一个方法中被命中，该方法的执行将停止并且没有返回。有一些时间情况，当你不想给出任何结果时，你可以使用yield break。

* * *

## 回答 #8

> 赞同：-3
> 
> 时间：2012-01-07T16:32:05.797

yield 关键字与 return 关键字一起使用，为枚举器对象提供值。**yield return**指定返回的一个或多个值。当到达 yield return 语句时，存储当前位置。下次调用迭代器时，将从该位置重新开始执行。

用一个例子来解释含义：

> ```
>  public IEnumerable<int> SampleNumbers()
>     {
>         int counter = 0;
>         yield return counter;
> 
>         counter = counter + 2;
> 
>         yield return counter;
> 
>         counter = counter + 3;
> 
>         yield return counter ;
>     } 
> ```

迭代时返回的值为：0、2、5。

**需要注意的是，此示例中的*计数器*变量是一个局部变量。**在返回值 2 的第二次迭代之后，第三次迭代从它之前离开的地方开始，同时保留名为*counter*的局部变量的先前值，即 2。

# .net - 在应用程序中记录多少，多少是太多？

> ID：231903
> 
> 赞同：7
> 
> 时间：2008-10-23T23:10:52.867
> 
> 标签：.net, logging, log4net, complexity-theory

只是想知道有多少人在他们的应用程序中登录？？？

我见过这个：

> “我通常喜欢使用 ERROR 日志级别来记录应用程序捕获的任何异常。我将使用 INFO 日志级别作为“第一级”调试方案，以便在我进入或退出方法时显示。从那里我使用DEBUG 日志级别来跟踪详细信息。FATAL 日志级别用于我在基于 Web 的应用程序中未能捕获的任何异常。

其中有这个代码示例：

```
Public Class LogSample

   Private Shared ReadOnly Log As log4net.ILog = log4net.LogManager.GetLogger(GetType(LogSample))

   Public Function AddNumbers(ByVal Number1 As Integer, ByVal Number2 As Integer) As Integer

      Dim intResults As Integer

      Log.Info("Starting AddNumbers Method...")
      Log.Debug("Number1 Specified: " & Number1)
      Log.Debug("Number2 Specified: " & Number2)

      intResults = Number1 + Number2

      Try

         intResults = Number1 + Number2

      Catch ex As Exception

         Log.Error("Error Adding Nubmers.", ex)

      End Try

      Log.Info("AddNumbers Method Complete.")

      Return intResults

   End Function

End Class 
```

但这似乎给方法增加了很多。例如，一个通常可能是 7 行代码的类突然变成了 12 行代码。该方法也失去了一些清晰性和简单性。

但话说回来，进行日志记录的好处可能是好的。例如，生产系统中的性能监控，追踪生产中的异常错误（并不是说您会一直打开所有这些日志记录。

因此，我想知道人们在做什么？干杯安东尼

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-23T23:26:20.620

它更像是编程的*艺术*方面。

您不想记录所有内容。但是您会想要记录系统中最关键的部分。

只需从广义上考虑您的程序，并尝试确定您需要哪些信息，以防生产中出现问题。

首先，应用程序的所有核心逻辑模块都应该具有日志记录功能。UI/动画等装饰部分不需要记录。

恕我直言，记录每个方法的进入/退出是多余的，而且还会产生噪音，尤其是因为您可以嵌入堆栈跟踪。

为了提高性能，请使用*profiler*。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-23T23:41:34.037

...嘿，我会因为在 SO 问题中被引用为主题而获得徽章吗？8^D

但说真的，关于上面的日志记录，我想澄清的一件事是，我对“详细”日志记录的部分理由是基于我正在利用 log4net 本身的特性这一事实。

在我提供的示例中，该方法每天以 WARN 模式登录。这意味着“默认”记录的唯一事情是发生异常。如果我接到一位客户关于应用程序出错的电话，他们不必在屏幕上给我读一些神秘的消息，我会跳入日志并查看发生了什么。大多数时候，答案就在那里。

如果没有现成的答案会发生什么？Log4net 允许我更新我的配置文件（无需重新编译，无需通过系统管理员的批准访问 Web 服务器上的某些特殊系统文件）并进入 INFO 模式。现在您开始看到第二层日志记录。也许代码从未进入某个循环。也许数据检索有一个空记录集。这第二级调试很有帮助，日志只会稍微变大一点。完成此操作后，我可以再次更改配置并返回到光照日志。

当然，如果事情真的很疯狂，那么我会进入完整的调试级别，我想知道每个变量正在报告什么，我正在处理什么 DataRows，以及应用程序中发生了什么。在我目前的工作地点，我们没有能力对我们的 Web 应用程序进行远程调试，而且我们不能总是在没有潜在增加数据的情况下进入生产数据库，因此进行完整的调试是下一个最好的事情。

我同意大多数人的观点，过多的日志记录确实会导致应用程序崩溃并导致比其价值更多的问题。If 也不会推荐在应用程序中使用这种详细日志记录，除非应用程序出于安全原因需要这样做。但是，在我看来，能够在需要时利用详细日志记录并且不必重新编译我的代码**是一个巨大的**好处，如果你有一个可以轻松实现它的框架（例如 log4net），那么我会说变得很好和详细并且如果您不得不回到代码本身，那么在心理上过滤掉日志代码引用是很容易的。

如果我听起来很防御或咆哮，我深表歉意，在任何方面我都不是这个意思。我只是想提供更多背景知识，说明我在上述方法中使用 log4net 设置日志记录的方式和原因。8^D

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-23T23:20:28.150

你是对的，这确实使代码更难阅读和维护。一项建议是考虑使用 AOP（面向方面​​的编程）工具将日志记录逻辑与应用程序逻辑分开。Castle Windsor 和 Spring 是 .Net 社区中您可能想要研究的两个。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-23T23:20:49.350

从安全的角度来看，日志记录可能是一个有趣的话题。在几次 DDOS 攻击之后，我在 CSO Online 上写了[一篇博客文章。](http://blogs.csoonline.com/when_ddos_attacks_become_personal)这是我谈到日志记录的部分，希望对您有所帮助：

> 日志限制、只写日志和使用日志服务器等技术可以增强系统的追溯安全性。在发生可能的 DDoS 攻击后，该公司无疑会想要调查该攻击。只有使用了正确的日志记录级别，才能进行调查。太多了，日志很快就会被填满，这首先可能是 DoS 的原因。太少，日志将毫无价值，因为它们不包含足够的信息来抓捕罪犯。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-24T01:23:46.793

至少您应该记录错误和对外部组件的调用...您提供的示例是我所说的太多日志记录...没有必要记录您处于方法的开始，或者方法的结尾，甚至是传递给方法的参数......这是浪费磁盘空间，你的日志文件很快就会变得非常大......

[温迪](http://www.rwendi.com "温迪")

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2016-05-20T20:17:55.110

决定多少日志记录就足够了并不容易。在您的示例中，函数中太多的日志记录代码会掩盖实际的逻辑代码。太多的日志条目会使日志变得嘈杂。但是太少的日志不是很有帮助！

对于 .NET，您可以使用 AOP 库 PostSharp 来帮助记录函数的进入和退出以及参数的值等等。

有关确定应用程序记录多少的帮助，请查看 Marcus Ranum 撰写的这篇文章[“系统日志记录和日志分析](http://ranum.com/security/computer_security/archives/logging-notes.pdf)”。

希望这可以帮助。

# c - sigaction 和 signal 有什么区别？

> ID：231912
> 
> 赞同：152
> 
> 时间：2008-10-23T23:15:14.760
> 
> 标签：c, signals, posix

我正准备向我们这里的应用程序添加一个额外的信号处理程序，我注意到作者曾经`sigaction()`设置过其他信号处理程序。我打算用`signal()`. 为了遵循约定，我应该使用`sigaction()`，但如果我从头开始编写，我应该选择哪个？

* * *

## 回答 #1

> 赞同：183
> 
> 时间：2008-10-24T07:13:05.357

[`sigaction()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaction.html)除非您有非常令人信服的理由不这样做，否则请使用。

该[`signal()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html)接口有利于它的古老（因此可用性），它是在 C 标准中定义的。然而，它有一些`sigaction()`可以避免的不良特征——除非你使用明确添加的标志`sigaction()`来让它忠实地模拟旧的`signal()`行为。

1.  当当前处理程序正在执行时，该`signal()`函数不会（必然）阻止其他信号到达；`sigaction()`可以阻塞其他信号，直到当前处理程序返回。
2.  该`signal()`功能（通常）将几乎所有信号的信号操作重置回`SIG_DFL`（默认）。这意味着`signal()`处理程序必须重新安装自身作为其第一个操作。它还会在检测到信号和重新安装处理程序之间打开一个漏洞窗口，在此期间，如果信号的第二个实例到达，则会发生默认行为（通常终止，有时带有偏见 - 也称为核心转储）。
3.  系统之间的确切行为`signal()`不同——标准允许这些变化。

这些通常是使用`sigaction()`而不是`signal()`. 然而，`sigaction()`不可否认的界面更加繁琐。

无论您使用这两者中的哪一个，都不要被替代信号接口所诱惑， 例如 [`sighold()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sighold.html)、 和 。它们名义上是. 请注意，POSIX 标准表示它们在多线程程序中的行为是未定义的。[`sigignore()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigignore.html)[`sigpause()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigpause.html)[`sigrelse()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigrelse.html)`sigaction()`

多线程程序和信号是另一个复杂的故事。 ~~AFAIK，在多线程应用程序中都可以`signal()`。`sigaction()`~~

[Cornstalks](https://stackoverflow.com/users/1287251/cornstalks) [观察到](https://stackoverflow.com/questions/231912/what-is-the-difference-between-sigaction-and-signal/232711?noredirect=1#comment43835195_232711)：

> Linux手册页[`signal()`](http://man7.org/linux/man-pages/man2/signal.2.html)说：
> 
> ***`signal()`**在多线程进程中的影响是未指定的。*
> 
> 因此，我认为`sigaction()`是唯一可以在多线程进程中安全使用的。

那很有意思。在这种情况下，Linux 手册页比 POSIX 更严格。POSIX 指定[`signal()`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html)：

> 如果进程是多线程的，或者如果进程是单线程的并且执行了信号处理程序，而不是作为以下结果：
> 
> *   进程调用`abort()`, `raise()`, `kill()`, `pthread_kill()`, 或`sigqueue()`生成未被阻塞的信号
> *   一个挂起的信号在解除阻塞的调用返回之前被解除阻塞并被传递
> 
> 如果信号处理程序引用的对象不是`errno`具有静态存储持续时间的任何对象，而不是通过将值分配给声明为的对象`volatile sig_atomic_t`，或者如果信号处理程序调用本标准中定义的任何函数而不是列出的函数之一，则行为未定义[信号概念](http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04)。

因此 POSIX 明确规定`signal()`了多线程应用程序中的行为。

尽管如此，`sigaction()`基本上在所有情况下都是首选——并且应该使用可移植的多线程代码，`sigaction()`除非有压倒性的理由不能这样做（例如“只使用标准 C 定义的函数”——是的，C11 代码可以是多线程的-线程）。这基本上也是这个答案的开头段落所说的。

* * *

## 回答 #2

> 赞同：10
> 
> 时间：2019-11-12T09:16:39.167

## 简而言之：

`sigaction()`很好并且定义明确，但它是一个 Linux 函数，因此它只能在 Linux 上运行。`signal()`不好且定义不明确，但它是 C 标准函数，因此它适用于任何东西。

## Linux 手册页对此有何评论？

`man 2 signal`（[在这里在线查看](http://man7.org/linux/man-pages/man2/signal.2.html)）状态：

> signal() 的行为因 UNIX 版本而异，并且在历史上因 Linux 的不同版本而异。避免使用：`sigaction(2)`改为使用。请参阅下面的可移植性。

> 可移植性 signal() 的唯一可移植用途是将信号的处置设置为 SIG_DFL 或 SIG_IGN。使用 signal() 建立信号处理程序时的语义因系统而异（POSIX.1 明确允许这种变化）；**不要将其用于此目的。**

换句话说：不要使用`signal()`. 改用`sigaction()`！

## 海合会怎么想？

> 兼容性说明：如上所述`signal`，应尽可能避免使用此功能。`sigaction`是首选方法。

来源：[https ://www.gnu.org/software/libc/manual/html_node/Basic-Signal-Handling.html#Basic-Signal-Handling](https://www.gnu.org/software/libc/manual/html_node/Basic-Signal-Handling.html#Basic-Signal-Handling)

所以，如果 Linux 和 GCC 都说不使用`signal()`，而是使用`sigaction()`，这就引出了一个问题：我们到底是如何使用这个令人困惑`sigaction()`的东西的！？

## 用法示例：

在此处阅读 GCC 的优秀`signal()`示例：[https ://www.gnu.org/software/libc/manual/html_node/Basic-Signal-Handling.html#Basic-Signal-Handling](https://www.gnu.org/software/libc/manual/html_node/Basic-Signal-Handling.html#Basic-Signal-Handling)

他们的优秀`sigaction()`例子在这里：[https ://www.gnu.org/software/libc/manual/html_node/Sigaction-Function-Example.html](https://www.gnu.org/software/libc/manual/html_node/Sigaction-Function-Example.html)

在阅读了这些页面后，我想出了以下技术`sigaction()`：

### 1\. `sigaction()`，因为这是附加信号处理程序的正确方法，如上所述：

```
#include <errno.h>  // errno
#include <signal.h> // sigaction()
#include <stdio.h>  // printf()
#include <string.h> // strerror()

#define LOG_LOCATION __FILE__, __LINE__, __func__ // Format: const char *, unsigned int, const char *
#define LOG_FORMAT_STR "file: %s, line: %u, func: %s: "

/// @brief      Callback function to handle termination signals, such as Ctrl + C
/// @param[in]  signal  Signal number of the signal being handled by this callback function
/// @return     None
static void termination_handler(const int signal)
{
    switch (signal)
    {
    case SIGINT:
        printf("\nSIGINT (%i) (Ctrl + C) signal caught.\n", signal);
        break;
    case SIGTERM:
        printf("\nSIGTERM (%i) (default `kill` or `killall`) signal caught.\n", signal);
        break;
    case SIGHUP:
        printf("\nSIGHUP (%i) (\"hang-up\") signal caught.\n", signal);
        break;
    default:
        printf("\nUnk signal (%i) caught.\n", signal);
        break;
    }

    // DO PROGRAM CLEANUP HERE, such as freeing memory, closing files, etc.

    exit(signal);
}

/// @brief      Set a new signal handler action for a given signal
/// @details    Only update the signals with our custom handler if they are NOT set to "signal ignore" (`SIG_IGN`),
///             which means they are currently intentionally ignored. GCC recommends this "because non-job-control
///             shells often ignore certain signals when starting children, and it is important for children
///             to respect this." See
///             https://www.gnu.org/software/libc/manual/html_node/Basic-Signal-Handling.html#Basic-Signal-Handling
///             and https://www.gnu.org/software/libc/manual/html_node/Sigaction-Function-Example.html.
///             Note that termination signals can be found here:
///             https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals
/// @param[in]  signal  Signal to set to this action
/// @param[in]  action  Pointer to sigaction struct, including the callback function inside it, to attach to this signal
/// @return     None
static inline void set_sigaction(int signal, const struct sigaction *action)
{
    struct sigaction old_action;

    // check current signal handler action to see if it's set to SIGNAL IGNORE
    sigaction(signal, NULL, &old_action);
    if (old_action.sa_handler != SIG_IGN)
    {
        // set new signal handler action to what we want
        int ret_code = sigaction(signal, action, NULL);
        if (ret_code == -1)
        {
            printf(LOG_FORMAT_STR "sigaction failed when setting signal to %i;\n"
                   "  errno = %i: %s\n", LOG_LOCATION, signal, errno, strerror(errno));
        }
    }
}

int main(int argc, char *argv[])
{
    //...

    // Register callbacks to handle kill signals; prefer the Linux function `sigaction()` over the C function
    // `signal()`: "It is better to use sigaction if it is available since the results are much more reliable."
    // Source: https://www.gnu.org/software/libc/manual/html_node/Basic-Signal-Handling.html#Basic-Signal-Handling
    // and https://stackoverflow.com/questions/231912/what-is-the-difference-between-sigaction-and-signal/232711#232711.
    // See here for official gcc `sigaction()` demo, which this code is modeled after:
    // https://www.gnu.org/software/libc/manual/html_node/Sigaction-Function-Example.html

    // Set up the structure to specify the new action, per GCC's demo.
    struct sigaction new_action;
    new_action.sa_handler = termination_handler; // set callback function
    sigemptyset(&new_action.sa_mask);
    new_action.sa_flags = 0;

    // SIGINT: ie: Ctrl + C kill signal
    set_sigaction(SIGINT, &new_action);
    // SIGTERM: termination signal--the default generated by `kill` and `killall`
    set_sigaction(SIGTERM, &new_action);
    // SIGHUP: "hang-up" signal due to lost connection
    set_sigaction(SIGHUP, &new_action);

    //...
} 
```

### 2\. 对于`signal()`，即使它不是附加信号处理程序的好方法，如上所述，知道如何使用它仍然很好。

这是复制粘贴的 GCC 演示代码，因为它几乎与它将获得的一样好：

```
#include <signal.h>

void
termination_handler (int signum)
{
  struct temp_file *p;

  for (p = temp_file_list; p; p = p->next)
    unlink (p->name);
}

int
main (void)
{
  …
  if (signal (SIGINT, termination_handler) == SIG_IGN)
    signal (SIGINT, SIG_IGN);
  if (signal (SIGHUP, termination_handler) == SIG_IGN)
    signal (SIGHUP, SIG_IGN);
  if (signal (SIGTERM, termination_handler) == SIG_IGN)
    signal (SIGTERM, SIG_IGN);
  …
} 
```

## 要注意的主要链接：

1.  标准信号：[https ://www.gnu.org/software/libc/manual/html_node/Standard-Signals.html#Standard-Signals](https://www.gnu.org/software/libc/manual/html_node/Standard-Signals.html#Standard-Signals)
2.  终止信号：[https ://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals](https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals)
3.  基本信号处理，包括官方 GCC`signal()`使用示例：[https ://www.gnu.org/software/libc/manual/html_node/Basic-Signal-Handling.html#Basic-Signal-Handling](https://www.gnu.org/software/libc/manual/html_node/Basic-Signal-Handling.html#Basic-Signal-Handling)
4.  官方 GCC`sigaction()`使用示例：[https ://www.gnu.org/software/libc/manual/html_node/Sigaction-Function-Example.html](https://www.gnu.org/software/libc/manual/html_node/Sigaction-Function-Example.html)
5.  信号集，包括`sigemptyset()`和`sigfillset()`；我仍然不完全理解这些，但知道它们很重要：[https ://www.gnu.org/software/libc/manual/html_node/Signal-Sets.html](https://www.gnu.org/software/libc/manual/html_node/Signal-Sets.html)

## 也可以看看：

1.  我对[“如何手动向任何正在运行的进程发送任何信号”和“如何在程序中捕获任何信号”（例如：在 Bash 中）](https://unix.stackexchange.com/a/692443/114401)的回答。
2.  TutorialsPoint C++ 信号处理[带有优秀的演示代码]：[https ://www.tutorialspoint.com/cplusplus/cpp_signal_handling.htm](https://www.tutorialspoint.com/cplusplus/cpp_signal_handling.htm)
3.  [https://www.tutorialspoint.com/c_standard_library/signal_h.htm](https://www.tutorialspoint.com/c_standard_library/signal_h.htm)

* * *

## 回答 #3

> 赞同：9
> 
> 时间：2011-07-03T06:24:08.277

对我来说，下面这行足以决定：

> sigaction() 函数提供了更全面、更可靠的信号控制机制；新应用程序应该使用 sigaction() 而不是 signal()

[http://pubs.opengroup.org/onlinepubs/009695399/functions/signal.html#tag_03_690_07](http://pubs.opengroup.org/onlinepubs/009695399/functions/signal.html#tag_03_690_07)

无论您是从头开始还是修改旧程序，sigaction 都应该是正确的选择。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-10-24T00:24:49.783

它们是操作系统信号设施的不同接口。如果可能的话，应该更喜欢使用 sigaction 来发出信号，因为 signal() 具有实现定义的（通常是竞争倾向）行为，并且在 Windows、OS X、Linux 和其他 UNIX 系统上表现不同。

有关详细信息，请参阅此[安全说明](https://www.securecoding.cert.org/confluence/display/cplusplus/SIG01-CPP.+Understand+implementation-specific+details+regarding+signal+handler+persistence)。

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2014-05-23T07:05:37.233

signal() 是标准 C， sigaction() 不是。

如果您能够使用其中任何一个（也就是说，您在 POSIX 系统上），那么使用 sigaction(); 未指定 signal() 是否重置处理程序，这意味着要便携，您必须在处理程序内再次调用 signal()。更糟糕的是有一场竞赛：如果你连续快速收到两个信号，而第二个是在你重新安装处理程序之前传递的，你将获得默认操作，这可能会终止你的进程。 另一方面，**sigaction()保证使用“可靠”的信号语义。**您无需重新安装处理程序，因为它永远不会被重置。使用 SA_RESTART，您还可以获得一些系统调用以自动重新启动（因此您不必手动检查 EINTR）。 **签名（）**有更多选择并且可靠，因此鼓励使用它。

Psst ...不要告诉任何人我告诉过你这个，但是 POSIX 目前有一个函数 bsd_signal() ，它的作用类似于 signal() 但提供 BSD 语义，这意味着它是可靠的。它的主要用途是移植假设可靠信号的旧应用程序，POSIX 不建议使用它。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-10-23T23:23:04.823

从**`signal(3)`**手册页：

> 描述
> 
> ```
>  This signal() facility is a simplified interface to the more
>  general sigaction(2) facility. 
> ```

两者都调用相同的基础设施。您大概不应该用两个信号来操纵单个信号的响应，但是将它们混合不应导致任何中断...

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2016-03-09T06:49:06.313

我还建议使用 sigaction() 而不是 signal() 并想再补充一点。sigaction() 为您提供更多选项，例如死亡进程的 pid（可能使用 siginfo_t 结构）。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-23T23:22:09.910

我会使用 signal() 因为它更便携，至少在理论上。我会投票支持任何能够提出没有 POSIX 兼容层并支持 signal() 的现代系统的评论者。

引用[GLIBC 文档](http://www.gnu.org/software/libtool/manual/libc/Signal-and-Sigaction.html)：

> 可以在单个程序中同时使用 signal 和 sigaction 函数，但您必须小心，因为它们可能会以稍微奇怪的方式进行交互。
> 
> sigaction 函数比 signal 函数指定了更多的信息，因此 signal 的返回值无法表达 sigaction 的全部可能性。因此，如果您使用信号保存并稍后重新建立操作，它可能无法正确重新建立使用 sigaction 建立的处理程序。
> 
> 为避免出现问题，如果您的程序完全使用 sigaction，请始终使用 sigaction 来保存和恢复处理程序。由于 sigaction 更通用，它可以正确保存和重新建立任何动作，无论它最初是用信号还是 sigaction 建立的。
> 
> 在某些系统上，如果您使用信号建立一个操作，然后使用 sigaction 对其进行检查，那么您获得的处理程序地址可能与您使用信号指定的地址不同。它甚至可能不适合用作带有信号的动作参数。但是您可以依靠将其用作 sigaction 的参数。这个问题在 GNU 系统上永远不会发生。
> 
> 因此，您最好在单个程序中始终如一地使用其中一种机制。
> 
> 可移植性注意：基本信号功能是 ISO C 的一个特性，而 sigaction 是 POSIX.1 标准的一部分。如果您担心对非 POSIX 系统的可移植性，那么您应该改用信号函数。
> 
> > 版权所有 (C) 1996-2008 Free Software Foundation, Inc.
> > 
> > 根据 GNU 自由文档许可证 1.2 版或自由软件基金会发布的任何更高版本的条款，允许复制、分发和/或修改本文档；没有不变的部分，没有封面文本，也没有封底文本。许可证的副本包含在标题为“GNU 自由文档许可证”的部分中。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2018-09-05T08:07:42.170

来自手册页[信号（7）](http://man7.org/linux/man-pages/man7/signal.7.html)

> 进程导向的信号可以被传递到当前没有阻塞信号的任何一个线程。如果多个线程的信号被解除阻塞，那么内核选择一个任意线程来传递信号。

我会说这个“问题”存在于[signal(2)](http://man7.org/linux/man-pages/man2/signal.2.html)和[sigaction(2)](http://man7.org/linux/man-pages/man2/sigaction.2.html)中。所以要小心信号和pthreads。

...并且[signal(2)](http://man7.org/linux/man-pages/man2/signal.2.html)似乎在 Linux 中使用 glibc调用[sigaction(2) 。](http://man7.org/linux/man-pages/man2/sigaction.2.html)

# java - 以数学方式查找数字子字符串，无需字符串比较

> ID：231917
> 
> 赞同：8
> 
> 时间：2008-10-23T23:18:48.950
> 
> 标签：java, performance, integer, substring, contains

这最初是我在工作中遇到的一个问题，但现在我只是为了自己的好奇心而尝试解决的问题。

我想找出 int 'a' 是否以最有效的方式包含 int 'b'。我写了一些代码，但似乎不管我写什么，将它解析成一个字符串，然后使用 indexOf 是数学上的两倍。

内存不是问题（在合理范围内），只是处理速度。

这是我编写的数学代码：

```
private static int[] exponents = {10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

private static boolean findMatch(int a, int b) {
    if (b > a) return false;

    if (a == b) return true;

    int needleLength = getLength(b);

    int exponent = exponents[needleLength];
    int subNum;
    while (a >= 1) {
        subNum = a % exponent;

        if (subNum == b)
            return true;

        a /= 10;
    }
    return false;
}

private static int getLength(int b) {

    int len = 0;

    while (b >= 1) {
        len++;
        b /= 10;
    }

    return len;
} 
```

这是我正在使用的字符串方法，它似乎胜过上面的数学方法：

```
private static boolean findStringMatch(int a, int b) {      
    return String.valueOf(a).indexOf(String.valueOf(b)) != -1;      
} 
```

因此，尽管这并不是我完成工作所必需的，但我只是想知道是否有人可以想出任何方法来进一步优化我的数学方法，或者完全是一种全新的方法。再次记忆是没有问题的，我只是为了纯粹的速度而拍摄。

我真的很想看到或听到任何人在这方面提供的任何东西。

**编辑：** 当我说包含时，我的意思是可以在任何地方，例如 findMatch(1234, 23) == true

**编辑：**对于每个人都说这个废话是不可读和不必要的：你错过了重点。关键是要解决一个有趣的问题，而不是想出一个用于生产代码的答案。

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-10-23T23:50:42.957

它*应该*是更快的字符串方式，因为您的问题是文本的，而不是数学的。请注意，您的“包含”关系没有说明数字，它只说明了它们的*十进制*表示。

另请注意，您要编写的函数将是不可读的——另一个开发人员永远不会理解您在做什么。（看看你在这里遇到了什么麻烦。）另一方面，字符串版本非常清楚。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-24T05:28:00.093

这是 Kibbee 的路线，但在他发布并解决这个问题之前，我对此有点感兴趣：

```
long mask ( long n ) { 
    long m   = n % 10;
    long n_d = n;
    long div = 10;
    int  shl = 0;
    while ( n_d >= 10 ) { 
        n_d /= 10;
        long t = n_d % 10;
        m |= ( t << ( shl += 4 ));
    }
    return m;
}

boolean findMatch( int a, int b ) { 
    if ( b < a  ) return false;
    if ( a == b ) return true;

    long m_a = mask( a );    // set up mask O(n)
    long m_b = mask( b );    // set up mask O(m)

    while ( m_a < m_b ) {
        if (( m_a & m_b ) == m_a ) return true;
        m_a <<= 4;  // shift - fast!
        if ( m_a == m_b ) return true;
    }  // O(p)
    return false;
}       

void testContains( int a, int b ) { 
    print( "findMatch( " + a + ", " + b + " )=" + findMatch( a, b ));
}

testContains( 12, 120 );
testContains( 12, 125 );
testContains( 123, 551241238 );
testContains( 131, 1214124 );
testContains( 131, 1314124 ); 
```

* * *

由于 300 个字符太少，无法进行论证，因此我正在编辑这篇主要帖子以回应 Pyrolistical。

与 OP 不同，本机编译的 indexOf 比带有原语的 Java 代码更快，我并不感到惊讶。因此，我的目标不是在整个 Java 代码中找到我认为比称为无数次的本机方法更快的东西。

OP 明确表示这不是生产问题，更像是一种闲置的好奇心，所以我的回答解决了这种好奇心。我的猜测是，当他试图在生产中解决它时，速度是一个问题，但作为一种空闲的好奇心，“这种方法将被调用数百万次”不再适用。正如他不得不向一张海报解释的那样，它不再作为生产代码来追求，因此复杂性不再重要。

另外，它提供了页面上唯一能够在“551241238”中找到“123”的实现，因此除非正确性是一个无关紧要的问题，否则它提供了这一点。此外，“一种使用 Java 原语以数学方式解决问题但优于优化的本机代码的算法”的解决方案空间可能是*EMPTY*。

另外，从您的评论中不清楚您是否将苹果与苹果进行了比较。功能规范是 f( int, int )-> boolean，而不是 f( String, String )-> boolean （这是`indexOf`) 的域。所以除非你测试了这样的东西（它仍然可以击败我的，我不会感到非常惊讶。）额外的开销*可能会*吃掉一些多余的 40%。

```
boolean findMatch( int a, int b ) { 
    String s_a = "" + a;
    String s_b = "" + b;
    return s_a.indexOf( s_b ) > -1;
} 
```

它执行相同的基本步骤。log [10] ( a ) encoding + log [10] ( b ) encoding + 实际找到匹配，这也是 O( *n* ) 其中*n*是最大对数。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-23T23:36:37.180

我能想到的唯一优化是自己转换为字符串并在转换时比较数字（从右到左）。首先转换 b 的所有数字，然后从 a 的右边开始转换，直到找到 b 的第一个数字（从右边开始）的匹配。比较直到所有 b 匹配或您遇到不匹配。如果您遇到不匹配的问题，请回溯到您开始匹配 b 的第一个数字的点，然后进入 a 并重新开始。

IndexOf 将必须执行基本相同的回溯算法，除了从左侧开始。根据实际数字，这可能会更快。我认为如果数字是随机的，应该是因为应该有很多次不必转换所有 a.

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-23T23:59:16.667

看起来你的功能实际上做得很好，但有一个小改进：

```
private static boolean findMatch(int a, int b) {
        if (b > a) return false;

        if (a == b) return true;

        int needleLength = getLength(b);

        int exponent = exponents[needleLength];
        int subNum;
        while (a > b) {
                subNum = a % exponent;

                if (subNum == b)
                        return true;

                a /= 10;
        }
        return false;
} 
```

仅仅因为一旦a小于b，就不值得一直寻找，不是吗？如果您找到解决方案，祝您好运并发布！

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-10-24T03:23:16.040

这是一个有趣的问题。String.class 的许多函数实际上是原生的，这使得击败 String 成为一个困难的命题。但这里有一些帮手：

**提示 1：**不同的简单整数运算具有不同的速度。

通过示例程序中的快速计算表明：

```
% ~ T
* ~ 4T
/ ~ 7T 
```

因此，您希望使用尽可能少的除法来支持乘法或取模。未显示减法、加法和比较运算符，因为它们会将所有这些都从水中吹走。此外，尽可能使用“final”允许 JVM 进行某些优化。加快你的“getLength”功能：

```
private static int getLength(final int b) {        
   int len = 0;
   while (b > exponents[len]) {
       len++;
   }
   return len + 1
} 
```

这使功能提高了约 7 倍。如果 b > 指数中的最大值，则会出现 indexOutOfBounds 异常。为了解决这个问题，您可以拥有：

```
private static int getLength(final int b) {        
   int len = 0;
   final int maxLen = exponents.length;
   while (len < maxLen && b > exponents[len]) {
       len++;
   }
   return len + 1;
} 
```

如果 b 太大，这会稍微慢一些并且给你一个不正确的长度，但它不会抛出异常。

**提示 2：**不必要的对象/基元创建和方法调用会增加运行时间。

我猜“getLength”不会在其他任何地方被调用，所以虽然拥有一个单独的函数可能会很好，但从优化的角度来看，它是一个不必要的方法调用和对象“len”的创建。我们可以把代码放在我们使用它的地方。

```
private static boolean findMatch(int a, final int b) {
        if (b > a) return false;
        if (a == b) return true;
        int needleLength = 0;
        while (b > exponents[len]) {
            needleLength ++;
        }
        needleLength++;

        final int exponent = exponents[needleLength];
        int subNum;
        while (a >= 1 && a <= b) {
                subNum = a % exponent;
                if (subNum == b)
                        return true;
                a /= 10;
        }
        return false;
} 
```

另外，请注意我将底部的 while 循环更改为还包括“a <= b”。我还没有测试过，并且不确定每次迭代的惩罚是否超过了你不浪费任何迭代的事实。我确信有一种方法可以使用聪明的数学来摆脱除法，但我现在想不出。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-23T23:24:18.983

嗯，我可能完全误解了这个问题，但是......

```
// Check if A is inside B lol
bool Contains (int a, int b)
{
    return (a <= b);
} 
```

除非你想知道一个特定的数字序列是否在另一个数字序列中。

在这种情况下，将其转换为字符串将比进行数学计算更快。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-23T23:28:54.560

无论如何，这绝不会回答您的问题，但无论如何都是建议:-)

方法名称`findMatch`不是很有描述性。在这种情况下，我有一个静态方法`ContainerBuilder.number(int)`，它返回一个`ContainerBuilder`，它上面有方法`contains`。这样你的代码就变成了：

```
boolean b = number(12345).contains(234); 
```

从长远来看，只是一些建议！

哦，是的，我还想说，你应该*定义你所说的“包含”是什么意思*

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-23T23:55:56.893

有没有办法用二进制计算这个？显然，包含另一个字符的二进制整数的整数的二进制值并不意味着十进制的作用相同。但是，是否可以使用某种二进制技巧？也许将像 12345 这样的数字转换为 0001 0010 0011 0100 0101，然后进行一些位移来确定其中是否包含 23 (0010 0011)。因为您的字符集只有 10 个字符，您可以通过在单个字节中存储 2 个字符值来缩短计算时间。

编辑

稍微扩展一下这个想法。如果您有 2 个整数 A 和 B，并且想知道 A 是否包含 B，则首先检查 2 件事。如果 A 小于 B，则 A 不能包含 B。如果 A = B，则 A 包含 B。此时您可以将它们转换为字符串*。如果 A 包含与 B 相同数量的字符数，则 A 不包含 B，除非它们相等，但是如果它们相等，我们就不会在这里，所以如果两个字符串的长度相同，则 a 不包含 b . 此时，A 的长度将比 B 长。因此，现在您可以将字符串转换为其打包的二进制值，正如我在本文第一部分中所指出的那样。将这些值存储在整数数组中。现在对数组中的整数值进行按位与运算，如果结果为 A，则 A 包含 B。现在将 B 的整数数组向左移动 4 位，并再次进行比较。这样做直到你开始从 B 的左边弹出位。

*上一段中的 * 表示您可以跳过此步骤。可能有一种方法可以完全不使用字符串。你可以做一些花哨的二进制技巧来获得我在第一段中讨论的打包二进制表示。应该有一些可以使用的二进制技巧，或者一些快速的数学运算，可以将整数转换为我之前讨论过的十进制值。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-24T08:30:52.313

我能问一下你在代码中哪里使用这个函数吗？也许还有另一种方法可以解决它目前正在解决的问题，这种方法会更快。这可能就像我的朋友要求我完全重新调音他的吉他，而我在意识到我可以将底弦降低一整步并获得相同的结果之前就这样做了。

* * *

## 回答 #10

> 赞同：-1
> 
> 时间：2008-10-24T00:00:59.957

供参考

[http://refactormycode.com/](http://refactormycode.com/)

可以为你工作。

# asp.net - SharePoint - ASP.Net 控件集成

> ID：231920
> 
> 赞同：0
> 
> 时间：2008-10-23T23:19:23.190
> 
> 标签：asp.net, sharepoint

我基本上有两个独立的站点，一个 SharePoint 协作站点和一个 ASP.Net 应用程序站点。两者之间的唯一联系是来回的超链接，以及代表 SharePoint 网站的用户验证。用户将通过 SharePoint 站点进入并通过身份验证，然后可以浏览到 ASP.Net 应用程序。

将两个站点集成在一起的最佳方式是什么？有没有一种简单的方法可以在维护两个站点的同时为用户提供无缝体验？

更新：我听从了你的所有建议，并决定接受克里斯的回答。

Andrew Connel 实际上将页面背后的 .aspx 代码部署为 SharePoint 功能。

他在他的网站上阐述了如何做到这[一点。](http://www.andrewconnell.com/blog/articles/UsingCodeBehindFilesInSharePointSites.aspx)

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-24T00:53:54.437

您可以在 SharePoint 网站上使用 ASP.NET 成员资格提供程序。如果您无法使用 Windows 身份验证，这可能是您的最佳选择。

Andrew Connell 撰写了一篇关于如何为 SharePoint 设置成员资格提供程序的好文章。它是 MOSS 描述的，但实践可以移植到 WSS。

[http://www.andrewconnell.com/blog/articles/HowToConfigPublishingSiteWithDualAuthProvidersAndAnonAccess.aspx](http://www.andrewconnell.com/blog/articles/HowToConfigPublishingSiteWithDualAuthProvidersAndAnonAccess.aspx)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-23T23:20:48.570

Asp.net 应用程序可以存在于 sharepoint 站点上的 Web 部件中吗？

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-24T01:11:52.403

**最小**

您可以创建一个托管路径以允许您的 asp.net 应用程序托管在共享点路径上的虚拟目录中（例如[http://intranet/aspnetsite](http://intranet/aspnetsite)）

您还可以为 asp.net 站点创建一个自定义控件，该控件将从 Sharepoint 读取顶部导航并将其显示给 asp.net 站点。外观和感觉，css 必须为两者应用自定义。

**完全集成**

否则，您可以将 asp.net 应用程序转换为一系列 web 控件，并将它们直接作为 layoutpages 上的控件或由自定义 webpart 托管的控件托管在 sharePoint 中。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-24T01:47:28.447

在我们这边，我们完全更改了 SharePoint 网站的母版页并重新命名了整个网站。除了用户可以在其中创建页面的“目录”或文件夹之外，该应用程序的行为与普通的 ASP.NET 应用程序完全一样。

这允许我们拥有不同的部分，用户可以直接在 SharePoint 中编辑和创建页面，而其他部分是应用程序页面。

因此，您可以将任何页面放在 SharePoint 中的任何位置。SharePoint Designer 可以帮助您完成很多这样的事情。

干杯，

# python - 使用 Amazon Web Services WSDL 的最佳 python 肥皂堆栈是什么？

> ID：231924
> 
> 赞同：14
> 
> 时间：2008-10-23T23:20:38.243
> 
> 标签：python, soap, wsdl, amazon-web-services, amazon

Python 有[许多肥皂栈](https://stackoverflow.com/questions/206154/whats-the-best-soap-client-library-for-python-and-where-is-the-documentation-fo)；据我所知，都存在重大缺陷。

有没有人有幸在 python 中为 S3、EC2 和 SQS使用*和使用 WSDL？*

我的经验是，构建 Client 对象时 suds 失败；经过一番争论，ZSI 生成了不起作用的客户端代码；等等

最后，我知道[boto](http://code.google.com/p/boto/)，但由于它是围绕 AWS 的手动包装器，因此 (1) 不完整且 (2) 永远不会与最新的 AWS WSDL 保持同步。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-25T21:08:14.930

REST 或“查询”API 肯定比 SOAP 更容易使用，但不幸的是，至少有一次服务 (EC2) 没有提供 SOAP 的任何替代方案。正如您已经发现的那样，Python 现有的 SOAP 实现对于大多数用途来说都严重不足。一种解决方法是直接为 SOAP 信封/正文生成 XML，而不是通过中间 SOAP 层。如果您对 XML / SOAP 有点熟悉，那么在大多数情况下这并不难做到，并且允许您使用另一端的 SOAP 实现来解决任何特定的特性；这可能非常重要，因为几乎每个 SOAP 堆栈都有其自己的 bugginess / 怪异风味需要应对。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-25T17:00:01.203

如果我没记错的话，您可以通过 REST 和 SOAP 使用 Amazon Web Services。将 REST 与 python 一起使用会容易*得多*。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2009-02-13T19:03:47.113

查看[http://boto.googlecode.com](http://boto.googlecode.com)。这是在 Python 中使用 AWS 的最佳方式。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2009-11-17T22:06:32.763

FWIW，我让这个 Amazon WSDL 用 Suds 0.3.8 解析：

url = ' [http://s3.amazonaws.com/ec2-downloads/2009-04-04.ec2.wsdl](http://s3.amazonaws.com/ec2-downloads/2009-04-04.ec2.wsdl) '
c = Client(url)
print c

-- snip --
端口 (1):
(AmazonEC2Port)
方法 (43):
--- 为简洁起见删除了更多 ---

-马特

# jquery - 使用 jQuery 为内联元素设置动画

> ID：231937
> 
> 赞同：21
> 
> 时间：2008-10-23T23:24:26.737
> 
> 标签：jquery, css, jquery-animate

我正在尝试使用 jQuery 显示和隐藏内联元素（例如跨度）。

如果我只使用切换（），它会按预期工作，但如果我使用切换（“慢”）给它一个动画，它会将跨度变成一个块元素，因此插入中断。

内联元素可以制作动画吗？如果可能的话，我更喜欢平滑的滑动，而不是淡入。

```
<script type="text/javascript">
    $(function(){
        $('.toggle').click(function() { $('.hide').toggle("slow") });
    });
</script>
<p>Hello <span class="hide">there</span> jquery</p>
<button class="toggle">Toggle</button> 
```

* * *

## 回答 #1

> 赞同：19
> 
> 时间：2008-10-24T00:01:04.183

`toggle()`有很多奇怪的东西，包括有时隐藏或转换奇怪的元素。这是一个类似的解决方案：

```
$('.toggle').click(function() {
  $('.hide').animate({
    'opacity' : 'toggle',
  });
}); 
```

**编辑**：这是一种添加平滑滑动的方法，使用最少的额外 HTML 标记：

```
var hidepos = $('.hide').offset().left;
var slidepos = $('.slide').offset().left;

$('.toggle').click(function() {
    var goto = ($('.slide').offset().left < slidepos) ? slidepos : hidepos;

    $('.slide').css({
        'left' : $('.slide').offset().left,
        'position' : 'fixed',
    }).animate({
        'left' : goto,
    }, function() {
        $(this).css('position', 'static');
    });

    $('.hide').animate({
        'opacity' : 'toggle',
    });
}); 
```

html:

```
<p>Hello <span class="hide">there</span> <span class="slide">jquery</span></p>
<button class="toggle">Toggle</button> 
```

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2010-03-19T11:46:53.323

只有一个 CSS 属性会让你开心：[http ://terion-fallen.livejournal.com/332945.html](http://terion-fallen.livejournal.com/332945.html)

```
#animated-element { display: inline-block!important } 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-23T23:49:25.673

我认为不可能这样。我能想到的唯一方法是将其不透明度设置为 0 和 1 之间的动画，并在动画上使用回调，然后将其打开或关闭。

```
$('.toggle').click(function() {
    $('.hide:visible').animate(
        {opacity : 0},
        function() { $(this).hide(); }
    );
    $('.hide:hidden')
        .show()
        .animate({opacity : 1})
    ;
}); 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-24T00:41:20.030

正如其他答案所示，褪色是可能的。但是，我认为不会“平滑滑动”。简单地说，元素的特定属性必须是动画的。像您提到的内联跨度没有特定的高度或宽度，尽管它确实具有不透明度。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-24T01:43:14.197

在 display:inline-block 在浏览器中得到很好的支持之前，我认为你想做的事情是不可能的。现在，我想我会将背景淡化为红色，然后隐藏元素。

如果 display:inline-block 得到了很好的支持，您可以将样式更改为 inline-block，然后为宽度或高度设置动画，但不幸的是，这些天这不会很好。也许在 2010 年 :)

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2009-07-18T05:01:42.140

如果您尝试向左或向右滑动的内容使用 float:left 定位，并且它旁边的任何内容也使用 float:left 定位，则“动画”将其动画化为块元素的事实不是问题

```
 $('#pnlPopup #btnUpdateButton').assertOne().animate({ width: "toggle" }); 
```

如果#btnUpdateButton 具有以下样式，那么它会很好地滑动并将内容推到右侧。

```
#btnUpdateButton {
    float: left;
    margin-right: 5px;
} 
```

# iphone - 引用 AppDelegate 实例变量

> ID：231947
> 
> 赞同：84
> 
> 时间：2008-10-23T23:27:36.420
> 
> 标签：iphone, cocoa-touch

我有一个基于 Navigation Based Application 模板的项目。AppDelegate 中有方法`-applicationDidFinishLoading:`和`-applicationWillTerminate:`. 在这些方法中，我正在加载和保存应用程序数据，并将其存储在实例变量中（它实际上是一个对象图）。

当应用程序加载时，它会加载 MainWindow.xib，它有一个 NavigationConroller，而后者又具有一个 RootViewController。RootViewController`nibName`属性指向 RootView（我的实际控制器类）。

在我的类中，我希望引用我在`-applicationDidFinishLoading:`方法中创建的对象，以便获得对它的引用。

谁能告诉我该怎么做？我知道如何在我以编程方式创建的对象之间进行引用，但我似乎无法想办法返回，因为中间步骤是从 NIB 文件中完成的。

* * *

## 回答 #1

> 赞同：204
> 
> 时间：2008-10-24T03:14:31.407

对于我需要在应用程序的任何位置访问它的变量（通常是模型数据结构），请在您的 AppDelegate 类中声明它们。当你需要引用它时：

```
YourAppDelegate *appDelegate = (YourAppDelegate *)[[UIApplication sharedApplication] delegate];
//and then access the variable by appDelegate.variable 
```

* * *

## 回答 #2

> 赞同：16
> 
> 时间：2008-10-23T23:51:59.443

如果我理解您的问题，您想在 AppDelegate 对象中引用成员变量/属性吗？最简单的方法是使用 [[UIApplication sharedApplication] delegate] 返回对您的对象的引用。

如果你有一个名为 window 的属性，你可以这样做：

```
UIWindow   *mainWindow = [[[UIApplication sharedApplication] delegate] window];
//do something with mainWindow 
```

* * *

## 回答 #3

> 赞同：11
> 
> 时间：2011-02-27T11:13:34.117

这是 iOS4.0 及更高版本定义明确的便携式替代方案：

```
UIApplication *myApplication = [UIApplication sharedApplication];
UIWindow *mainWindow = [myApplication keyWindow];
UIViewController *rootViewController = [mainWindow rootViewController]; 
```

或者，在一行中，

```
UIViewController *rootViewController = [[[UIApplication sharedApplication] keyWindow] rootViewController]; 
```

不要忘记设置窗口的`rootViewController`属性（比如在 IB 中），否则会出现问题。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2016-12-23T10:31:13.467

## 定义一个宏并在任何地方使用它！

```
#define appDelegateShared ((AppDelegate *)[UIApplication sharedApplication].delegate) 
```

在我的代码中：-

```
UIViewController *rootViewController = appDelegateShared.window.rootViewController; 
```

# c# - AOP for winforms

> ID：231967
> 
> 赞同：2
> 
> 时间：2008-10-23T23:35:32.503
> 
> 标签：c#, winforms, click, aop, instrumentation

How to capture user clicks in a winform application without making the code very complicated? is AOP the answer? How to track instrumentations?

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-24T10:24:11.930

This does depend rather on your actual requirements.

For a simple/sample/prototype winforms app, I'd suggest basic [WinForms Event Handlers](http://msdn.microsoft.com/en-us/library/aa983610(VS.71).aspx), with the code (providing it's not too heavy) in the handler methods. If code is heavy, contains hard business rules and doesn't interact with the form then it's best to move that code to another class and call it from the event handler.

[Aspect Oriented Programming](http://en.wikipedia.org/wiki/Aspect-oriented_programming) takes this futher. It's generally best applied in larger-scale projects. You still need event handlers for your form elements (and I recommend sticking to the control-based event handlers - don't try creating your own global event handling facility), but they should make calls to Command objects (see [Command Pattern](http://www.dofactory.com/patterns/patterncommand.aspx) in GangOfFour). Those command objects can then be invoked from anywhere in your application. If you want instrumentation, the instrumentation should be on those Command objects rather than the WinForms events. You can leverage [Inversion of Control](http://martinfowler.com/articles/injection.html) containers like [Castle Windsor](http://www.castleproject.org/container/index.html) to inject logging/auditing into the commands without having to change your application at all using the [Interceptor pattern](http://www.castleproject.org/container/documentation/trunk/usersguide/interceptors.html). [Here's an example from David Hayden](http://www.davidhayden.com/blog/dave/archive/2007/03/14/CastleWindsorAOPPolicyInjectionApplicationBlock.aspx)

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-24T01:25:48.273

The general method for capturing clicks in winforms is handling [Control.MouseClick](http://msdn.microsoft.com/en-us/library/system.windows.forms.control.mouseclick.aspx). You can also look at [Control.MouseDown](http://msdn.microsoft.com/en-us/library/system.windows.forms.control.mousedown.aspx) and [Control.MouseUp](http://msdn.microsoft.com/en-us/library/system.windows.forms.control.mouseup.aspx) if you want more detailed information.

If you provide more details about what you're trying to do, we can probably come up with a more targeted answer.

# asp.net - 如何从 Web 应用程序进行高级打印？

> ID：231973
> 
> 赞同：16
> 
> 时间：2008-10-23T23:36:35.607
> 
> 标签：asp.net, internet-explorer, printing

我一直在研究通过 Web 应用程序打印类似报告的数据的选项。一些可行的选项是编写 PDF、Excel XML、将 HTML 转储到 Excel，或使用诸如 activePDF webGrabber 之类的工具。我想问题是，有什么解决方案可以控制浏览器（在我的情况下为 IE）的打印但没有大量的开发时间。虽然我自己没有这方面的经验，但我看到了一些用于生成 PDF 的可怕代码。

我特别寻找的功能是在没有用户干预的情况下打印横向或纵向。此外，控制基本样式对于将 Web 应用程序的基本外观/感觉转换为打印格式非常重要。

任何建议（尤其是经验）都值得赞赏。

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-10-23T23:50:18.370

正如我已经[在这里询问过](https://stackoverflow.com/questions/164197/printing-labels-from-aspnet-page)的并且发现了困难的方法，您不会仅仅在浏览器中获得可靠和准确的打印结果。即使它是一个向您承诺只能使用 IE7 的 Intranet 应用程序，IE8 也将很快推出，然后将允许使用 Firefox，并且您对 CSS 的所有细心微管理都将付诸东流（我听起来是不是很痛苦？）。

最具前瞻性的解决方案是硬着头皮去生成 PDF。你提到的工具很好。您还应该查看[iText](http://www.lowagie.com/iText/)和[iTextSharp](http://itextsharp.sourceforge.net/)。一旦掌握了窍门，制作 PDF 布局并不比 HTML 和 CSS 更难，而且您会知道结果将在每个人的计算机、每个人的浏览器和每个人的打印机上正确打印。我目前正在使用 iTextSharp（尚未完成，但仍在学习和试验）。

我也没有找到可靠的方法来控制页面内的打印选项，因此依靠您的用户从纵向更改为横向或设置或调整页边距或关闭打印页眉和页脚在从长远来看 - 当他们不能（或只是不）遵循指示时，你最终会惹恼他们并为自己制造更多的头痛。

“相关问题”侧边栏非常有用。我在网页上看到了有关控制打印机的这些问题（两者的答案都相当于：“你不能”）：

[以编程方式选择横向打印](https://stackoverflow.com/questions/37162/how-do-i-make-an-html-page-print-in-landscape-when-the-user-selects-print)

[打印到特定打印机](https://stackoverflow.com/questions/206880/printing-to-a-specific-printer-from-a-web-app)

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-23T23:48:56.127

您还可以查看设置特定的[CSS 样式表](http://css-discuss.incutio.com/?page=PrintStylesheets)以进行打印。这样做的好处是您可以获取一个显示给用户的现有网页，稍微更改格式以删除任何花哨的横幅或其他耗墨类型的图像，然后打印出他们在屏幕上看到的内容。

一些站点会有一个指向“打印机友好版本”的链接，但是如果用户决定在他们所在的页面上简单地按 CTRL+P，那么即使在 HTML 标题中同时引用显示和打印样式表也将起作用。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-23T23:51:13.533

我在 C# 应用程序中使用过 iTextSharp 并且很幸运。这需要一些工作，但如果您有图形经验，这一切都很有意义，而且 PDF 看起来非常好（并且打印效果很好）。

[http://itextsharp.sourceforge.net/](http://itextsharp.sourceforge.net/)

如果您希望生成 PDF 的代码不可怕，请确保编写好的 PDF 代码！例如，编写具有大量内存类的真正模块化代码，您可以组合这些类（如乐高）来表示将在 PDF 上运行的对象。这些对象只需要知道如何将自己绘制为 PDF。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-23T23:46:37.520

你可以看看 SQL Server Reporting Services。还有许多第三方报告工具，例如[http://www.devexpress.com/Products/NET/Reporting/](http://www.devexpress.com/Products/NET/Reporting/)

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-23T23:49:48.123

我不确定这是否是您正在寻找的东西，但为什么不将 CSS 与 media=print 样式表一起使用。设计您的样式表，使打印的表单具有您想要的特征。或者，您可以通过以 CSV 格式下载数据并让用户根据数据构建自己的报告来导出到 Excel。

对于实际的 PDF 和 Excel，我使用了来自[Aspose.com](http://www.aspose.com)的控件。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-24T00:14:43.813

仅适用于 IE：

[http://www.meadroid.com/scriptx/index.asp](http://www.meadroid.com/scriptx/index.asp)

> 对于那些需要从运行 Microsoft 的 Internet Explorer 浏览器的客户端和服务器计算机打印 html 文档的人来说，这是绝对的控制。
> 
> ScriptX 打印功能的一个基本子集——页眉和页脚设置、打印方向、边距粗略控制和浏览器窗口/框架打印命令——是免费提供的，并且可以免费分发。高级打印功能不是免费的。启用 ScriptX 的文档需要参考有效的发布许可证才能进行高级打印。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-24T00:17:46.070

附和其他人所说的，你永远不会让浏览器按你想要的方式打印。从经验来看，打印媒体类型 CSS*看起来*可以工作，但它确实无法完成工作 - 特别是如果您需要在多个浏览器中工作（并且因为我将多个版本的 IE 包含为不同的浏览器，我认为所有网站最终都需要。）

我认为最好的方法是动态地动态构建 PDF。为您的平台找到您喜欢/负担得起的 PDF 包并使用它运行。相信我，你会很高兴你做到了。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-24T00:45:02.830

这取决于您的预期客户群是已知的还是未知的。如果您想允许“任何人”生成可打印的文档，那么我同意其他人的观点，即 PDF 路线是一个不错的选择。

我们在使用[PDFLib](http://www.pdflib.com/)轻松创建有吸引力的 PDF 文档方面取得了巨大成功。使用他们的服务器端模块，您可以让设计人员在 InDesign 或 Illustrator 中创建您的文档，然后以编程方式将动态字段放在顶部（甚至使用 Acrobat 放置字段）

对于报表和动态行数据来说，这有点棘手，但可以做到。

对于实际打印 - 如果您在用户群已知的情况下创建应用程序（例如办公环境），您可能会考虑使用[BarTender 之](http://www.seagullscientific.com/)类的标签打印应用程序。您可以让 Web 服务器通过 API 调用打印作业，或者让 BarTender 应用程序轮询应用程序以获取新作业。对于您想要在站点上点击“打印”并让打印机开始打印（无需其他用户干预）的 Web 应用程序非常方便，因为服务器实际上正在执行打印，而不是客户端。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2009-02-03T05:00:36.977

主要是分享我处理这个问题的方式，同时也提供另一种选择......

我正在使用导出 Excel XML 的第 3 方网格。为了让它对我有用，我使用 XSLT 和一些代码来调整 XSLT 以便注入打印设置。我敢肯定，它不如 PDF 强大，但它是一个相当不错的折衷方案，不需要对每页进行太多自定义。

因此，基本的解决方案是以 Excel XML 格式导出，并为页面方向、缩放以及您可能喜欢的任何其他内容注入标签。您可以从基本的 Excel 工作表开始并保存为 XML，进行所需的调整。然后你阅读源代码并弄清楚 Excel 是如何做到的。我找不到任何有用的文档。**************