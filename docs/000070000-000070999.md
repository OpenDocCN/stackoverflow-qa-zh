# StackOverflow 问答 000070000-000070999

# c# - 在 C# 中使用 Lisp

> ID：70004
> 
> 赞同：11
> 
> 时间：2008-09-16T07:13:03.240
> 
> 标签：c#, lisp

[正如很多人在这个问题](https://stackoverflow.com/questions/4724/learning-lisp-why)中指出的那样，Lisp 主要用作学习体验。不过，如果我能以某种方式使用我的 Lisp 算法并将它们与我的 C# 程序结合起来，那就太好了。在大学里，我的教授永远不会告诉我如何在程序中使用我的 Lisp 例程（不，不是用 Lisp 编写 GUI，谢谢）。那我该怎么办？

* * *

## 回答 #1

> 赞同：13
> 
> 时间：2008-09-16T07:19:57.920

试试 Lisp 的这些 .Net 实现：

*   [铁计划](https://github.com/leppie/IronScheme)

> IronScheme 的目标是成为基于 Microsoft DLR 的符合 R6RS 的 Scheme 实现。

*   [L 夏普 .NET](https://github.com/RobBlackwell/LSharp)

> L Sharp .NET 是一种功能强大的类似 Lisp 的 .NET 脚本语言。它使用类似于 Arc 的 Lisp 方言，但与提供丰富库集的 .NET Framework 紧密集成。

* * *

## 回答 #2

> 赞同：10
> 
> 时间：2008-09-16T11:31:06.943

[Clojure](http://clojure.org "Clojure")是一种 Lisp-1，可即时**编译为 Java 字节码，从而带来非常好的运行时性能。**[您可以使用 Clojure，并使用IKVM](http://www.ikvm.net "IKVM")的 ikvmc将其交叉编译为 .NET 程序集。当然，在 .NET 中使用时，Clojure 会愉快地生成 .NET IL，从而获得与在 JVM 上使用它时所期望的相同类型的编译代码性能。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-16T07:21:30.770

如果它只是您想要使用的例程，您可以尝试 LSharp，它可以让您在 .NET 中使用 Lisp 表达式：

[http://www.lsharp.org/](http://www.lsharp.org/)

另一种方式（使用 Lisp 中的 .NET）将是 RDNZL：

[http://www.weitz.de/rdnzl/](http://www.weitz.de/rdnzl/)

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T07:22:55.293

.Net 1.1 SDK 包含一个 LISP 编译器示例。请参阅 SDK\v1.1\Tool 开发人员指南\Samples\clisp

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2018-04-02T19:03:56.337

我知道这是一个非常古老的问题。但我会尝试从我自己的经验和角度来提供答案。

对于像我们这样喜欢 Scheme/Lisp 的纯粹、优雅和简单的人，我希望这能给你一些鼓励和启发，让它们在实际生产中非常有用:)

[我最近从名为schemy](https://github.com/Microsoft/schemy)的工作中开源了一个类似于 Scheme 的解释器，它是用 C# 编写的（大约 1500 行代码）。这是动机以及它的用处 -

没有过多的细节，我正在构建一个 Web API 服务器，它的请求处理逻辑需要其他开发人员/数据科学家即插即用。这里有一个明确的关注点分离需求——服务器不太关心请求处理逻辑，但它需要知道它可以处理哪些请求以及在哪里找到和**加载**处理程序的逻辑。

因此，服务器没有将处理程序实现放在服务器应用程序中，而是仅提供可重用的“块”，这些“块”可以根据某些标准和逻辑链接在一起以形成*管道*，即通过**配置**定义的处理程序。我们尝试使用 JSON/XML 来描述这样一个管道，并很快意识到**我实际上是在构建一个抽象语法树解析器**。

那时我意识到这是对轻量级、基于 s 表达式的小型语言的需求。因此，我实现了可嵌入的[schemy](https://github.com/Microsoft/schemy)解释器。

[我在这里](https://github.com/Microsoft/schemy/tree/master/src/examples/command_server)放了一个示例命令处理应用程序，它抓住了我上面提到的 Web 服务器设计理念的精髓。它是这样工作的：

1.  它使用 C# 实现的一些功能扩展了嵌入式 Schemay 解释器。

2.  它`.ss`通过使用那些实现的功能找到定义命令处理管道的脚本。

3.  `EXECUTE`服务器通过查找应该是 type的符号，从脚本中找到并保存 composes 管道`Func<object, object>`。

4.  当一个命令请求进来时，它只是简单地调用相应的命令处理器（由 定义的那个`EXECUTE`），并用结果来响应。

最后，这是一个复杂的示例脚本，它通过这个 TCP 命令服务器提供在线手册页查找：

```
; This script will be load by the server as command `man`. The command
; is consistent of the following functions chained together:
;
; 1\.  An online man-page look up - it detects the current operating system and 
;     decides to use either a linux or freebsd man page web API for the look up.
; 
; 2\.  A string truncator `truncate-string` - it truncates the input string, in
;     this case the output of the man-page lookup, to the specified number of
;     characters.
; 
; The client of the command server connects via raw RCP protocol, and can issue
; commands like:
; 
;     man ls
; 
; and gets response of the truncated corresponding online manpage content.

(define EXECUTE
  (let ((os (get-current-os))
        (max-length 500))
    (chain                                      ; chain functions together
      (cond                                     ; pick a manpage lookup based on OS
        ((equal? os "freebsd") (man-freebsd))
        ((equal? os "linux") (man-linux))
        (else (man-freebsd)))
      (truncate-string max-length))))           ; truncate output string to a max length 
```

通过命令服务器加载此脚本，TCP 客户端可以`man <unix_command>`向服务器发出命令：

```
$ ncat 127.0.0.1 8080

man ls

LS(1)                   FreeBSD General Commands Manual                  LS(1)

NAME
     ls -- list directory contents

SYNOPSIS
     ls [--libxo] [-ABCFGHILPRSTUWZabcdfghiklmnopqrstuwxy1,] [-D format]
        [file ...]

DESCRIPTION
     For each operand that names a file of a type other than directory, ls
     displays its name as well as any requested, associated information.  For
     each operand that names a file of type directory, ls displays the names
     of files contained within that directory, as well as any requested, 
```

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-16T07:22:29.443

也许你应该看看 L#。我不知道它是否是您正在寻找的东西（自大学以来就没有接触过 Lisp），但它可能值得一试。

[http://www.lsharp.org/](http://www.lsharp.org/)

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2010-03-18T14:22:55.177

还有[DotLisp](http://dotlisp.sourceforge.net/dotlisp.htm)。

# c++ - 如何检测我是否正在使用特定的 Visual Studio 版本编译代码？

> ID：70013
> 
> 赞同：271
> 
> 时间：2008-09-16T07:15:43.437
> 
> 标签：c++, visual-studio

有什么方法可以知道我是否在特定的 Microsoft Visual Studio 版本下编译？

* * *

## 回答 #1

> 赞同：530
> 
> 时间：2008-09-16T09:14:11.123

`_MSC_VER`可能`_MSC_FULL_VER`是你需要的。您还可以在任何最近的 boost 安装中检查[visualc.hpp](https://www.boost.org/doc/libs/master/boost/config/compiler/visualc.hpp)以获取一些使用示例。

较新版本的编译器的一些值是：

```
MSVC++ 14.24 _MSC_VER == 1924 (Visual Studio 2019 version 16.4)
MSVC++ 14.23 _MSC_VER == 1923 (Visual Studio 2019 version 16.3)
MSVC++ 14.22 _MSC_VER == 1922 (Visual Studio 2019 version 16.2)
MSVC++ 14.21 _MSC_VER == 1921 (Visual Studio 2019 version 16.1)
MSVC++ 14.2  _MSC_VER == 1920 (Visual Studio 2019 version 16.0)
MSVC++ 14.16 _MSC_VER == 1916 (Visual Studio 2017 version 15.9)
MSVC++ 14.15 _MSC_VER == 1915 (Visual Studio 2017 version 15.8)
MSVC++ 14.14 _MSC_VER == 1914 (Visual Studio 2017 version 15.7)
MSVC++ 14.13 _MSC_VER == 1913 (Visual Studio 2017 version 15.6)
MSVC++ 14.12 _MSC_VER == 1912 (Visual Studio 2017 version 15.5)
MSVC++ 14.11 _MSC_VER == 1911 (Visual Studio 2017 version 15.3)
MSVC++ 14.1  _MSC_VER == 1910 (Visual Studio 2017 version 15.0)
MSVC++ 14.0  _MSC_VER == 1900 (Visual Studio 2015 version 14.0)
MSVC++ 12.0  _MSC_VER == 1800 (Visual Studio 2013 version 12.0)
MSVC++ 11.0  _MSC_VER == 1700 (Visual Studio 2012 version 11.0)
MSVC++ 10.0  _MSC_VER == 1600 (Visual Studio 2010 version 10.0)
MSVC++ 9.0   _MSC_FULL_VER == 150030729 (Visual Studio 2008, SP1)
MSVC++ 9.0   _MSC_VER == 1500 (Visual Studio 2008 version 9.0)
MSVC++ 8.0   _MSC_VER == 1400 (Visual Studio 2005 version 8.0)
MSVC++ 7.1   _MSC_VER == 1310 (Visual Studio .NET 2003 version 7.1)
MSVC++ 7.0   _MSC_VER == 1300 (Visual Studio .NET 2002 version 7.0)
MSVC++ 6.0   _MSC_VER == 1200 (Visual Studio 6.0 version 6.0)
MSVC++ 5.0   _MSC_VER == 1100 (Visual Studio 97 version 5.0) 
```

上面的版本号当然是指您在 about 框中看到的 Visual Studio 的主要版本，而不是名称中的年份。可以在[此处](https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering)找到完整的列表。[从最近开始](https://blogs.msdn.microsoft.com/vcblog/2016/10/05/visual-c-compiler-version/)，Visual Studio 将开始单调更新其范围，这意味着您应该检查范围，而不是精确的编译器值。

`cl.exe /?`将提示使用的版本，例如：

```
c:\program files (x86)\microsoft visual studio 11.0\vc\bin>cl /?
Microsoft (R) C/C++ Optimizing Compiler Version 17.00.50727.1 for x86
..... 
```

* * *

## 回答 #2

> 赞同：49
> 
> 时间：2010-09-24T10:25:06.490

是的 _MSC_VER 是可以为您提供编译器版本的宏。Visual C++ 的最后一个版本的形式`<compiler-major-version>.00.<build-number>`是 ，其中 00 是次要编号。所以`_MSC_VER`将评估为`<major-version><minor-version>`。

你可以使用这样的代码：

```
#if (_MSC_VER == 1500)
   // ... Do VC9/Visual Studio 2008 specific stuff
#elif (_MSC_VER == 1600)
   // ... Do VC10/Visual Studio 2010 specific stuff
#elif (_MSC_VER == 1700)
   // ... Do VC11/Visual Studio 2012 specific stuff
#endif 
```

它似乎在编译器的连续版本之间更新，没有修改`compiler-minor-version`，因此不需要以下代码：

```
#if (_MSC_VER >= 1500 && _MSC_VER <= 1600)
   // ... Do VC9/Visual Studio 2008 specific stuff
#endif 
```

可以使用[此处](http://msdn.microsoft.com/en-us/library/b0084kay.aspx)的其他内置预处理器变量访问更详细的版本控制信息（例如编译器内部版本号） 。

* * *

## 回答 #3

> 赞同：11
> 
> 时间：2008-09-16T07:19:50.527

_MSC_VER 应定义为特定的版本号。您可以对其使用#ifdef，也可以使用实际定义并进行运行时测试。（如果出于某种原因您想根据编译它的编译器运行不同的代码？是的，可能您正在寻找#ifdef。:)）

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2008-09-16T07:21:55.357

通过使用`_MSC_VER`宏。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2013-05-22T18:41:04.033

作为更一般的答案， [http://sourceforge.net/p/predef/wiki/Home/](http://sourceforge.net/p/predef/wiki/Home/)维护了一个用于检测特定编译器、操作系统、体系结构、标准等的宏列表。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-17T08:55:06.340

这有点旧，但应该让你开始：

```
//******************************************************************************
// Automated platform detection
//******************************************************************************

// _WIN32 is used by
// Visual C++
#ifdef _WIN32
#define __NT__
#endif

// Define __MAC__ platform indicator
#ifdef macintosh
#define __MAC__
#endif

// Define __OSX__ platform indicator
#ifdef __APPLE__
#define __OSX__
#endif

// Define __WIN16__ platform indicator 
#ifdef _Windows_
#ifndef __NT__
#define __WIN16__
#endif
#endif

// Define Windows CE platform indicator
#ifdef WIN32_PLATFORM_HPCPRO
#define __WINCE__
#endif

#if (_WIN32_WCE == 300) // for Pocket PC
#define __POCKETPC__
#define __WINCE__
//#if (_WIN32_WCE == 211) // for Palm-size PC 2.11 (Wyvern)
//#if (_WIN32_WCE == 201) // for Palm-size PC 2.01 (Gryphon)  
//#ifdef WIN32_PLATFORM_HPC2000 // for H/PC 2000 (Galileo)
#endif 
```

* * *

## 回答 #7

> 赞同：-9
> 
> 时间：2008-09-16T07:18:16.007

在visual studio中，去帮助| 关于并查看您用于编译应用程序的 Visual Studio 版本。

# unit-testing - 有跨语言的 TDD 解决方案吗？

> ID：70053
> 
> 赞同：7
> 
> 时间：2008-09-16T07:24:25.367
> 
> 标签：unit-testing, tdd, cross-language

我想用 C#、Java 和 AS3 编写一个简单的颜色管理框架。我只想编写一次单元测试，而不是在 JUnit、FlexUnit 和 NUnit 中重新创建单元测试。

我想到了一个 xml 文件的想法，该文件通过设置、拆卸和一组测试定义了基于“实例”状态的“实例”和断言的操作。然后有一个实用程序可以将该 XML 转换为 xUnit 代码，用于任意数量的 xUnit。不过，在我开始浪费时间开发这样的解决方案之前，我想确保不存在类似的解决方案。

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-16T07:46:26.360

FIT/ [Fitnesse](http://fitnesse.org/)是否适合您的需求？

FIT 是一个验收测试框架而不是单元测试框架，但是根据您的描述，您希望确保这三个实现具有相同的行为而不是相同的设计。

FIT 有[多种语言的链接](http://fitnesse.org/FitServers)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T07:27:11.757

我认为您使事情过于复杂...您可能会考虑一种可以针对所有 3 种使用的脚本语言。我知道 Ruby 可用于通过 JRuby 测试 Java，并通过 IronRuby 测试 C#，但我不了解 AS3。

我自己从来不需要这样做，但我想像 Ruby 这样的动态语言真的可以让你在没有大量额外工作的情况下做到这一点。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T07:29:18.677

附带说明一下，您还可以尝试编写某种编译器，就像 FogCreek 著名的 Wasabi 语言一样，然后您可以用该语言编写代码和测试，并让编译器完成您的工作....当然可能会过于复杂，但我认为这比尝试定义 XML 测试语言要好得多......并且可能更具可读性。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2009-05-05T12:26:10.300

[您还可以使用Slim](http://www.fitnesse.org/FitNesse.SliM)查看 Fitnesse ，因为 Slim 对于新语言 (AS3) 的实现应该更加轻量级。我想这更多的是关于验收/集成测试而不是单元测试，但它可能值得研究。

# java - 什么时候应该在 Oracle 数据库中使用 java 存储过程……有什么缺点？

> ID：70072
> 
> 赞同：13
> 
> 时间：2008-09-16T07:29:04.543
> 
> 标签：java, oracle, stored-procedures, plsql

PL/SQL 不是我的母语。Oracle 支持用 Java 编写存储过程。与在 PL/SQL 中编写存储过程相比，这样做有什么优势

* * *

## 回答 #1

> 赞同：19
> 
> 时间：2008-09-16T09:22:05.647

在甲骨文世界中，一般的发展顺序应该是：

尽可能纯粹使用 SQL 来完成。如果您需要的不仅仅是 SQL，请使用 PL/SQL。如果您需要一些 PL/SQL 不能做的事情，那么请使用 Java。如果所有其他方法都失败了，请使用 C。如果你不能用 C 来做，请慢慢远离问题......

PL/SQL 存储过程是将业务逻辑移动到任何集成技术都可以访问的层的绝佳方式。包中的业务逻辑（不要编写独立的函数和过程——它们会随着时间的推移以无法管理的方式增长）可以通过 Java、C#、PL/SQL、ODBC 等执行。

PL/SQL 是在纯 SQL 之外处理大量数据的最快方法。“批量绑定”功能意味着它可以很好地与 SQL 引擎配合使用。

Java 存储过程最适合创建与网络或操作系统交互的功能。例如，发送电子邮件、FTP 数据、输出到文本文件并将其压缩、执行主机命令行。

在使用 Oracle 时，我从来不需要编写任何 C 语言，但大概它可以用于与遗留应用程序集成。

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2008-09-16T11:26:42.680

只有当你不能在 PL/SQL 中做到这一点时（或者 PL/SQL 被证明太慢，我相信这将是非常罕见的）。

作为一个案例研究......我们在生产中运行了一个 java 存储过程（Oracle 9i），它最初是用 java 编写的，因为当时我们认为 java 很酷，我早就改变了主意。反正。有一天，数据库崩溃了，它重新启动后 java SP 不起作用。在与 oracle 支持反复来回之后，他们并不真正知道问题出在哪里，他们提出的唯一建议涉及很多停机时间。这不是一个选择。30 分钟后，我用 PL/SQL 重写了 java SP。

现在，它运行得更快，是 oracle “本机”，与其他对象共享相同的部署过程，并且更易于调试。

PL/SQL 是一种非常强大的语言。如果您正在编写存储过程，请花时间学习它，而不是仅仅在 java 中做事，因为这就是您所知道的。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-16T21:52:22.783

主要优点是可以访问 PL/SQL 中没有的 API 和语言功能。例如，我将它们用于正则表达式处理、文件/目录操作和 XML 解析。

有很多缺点：

*   工具支持差
*   缺乏对 JVM 的控制
*   DBA 通常没有接受过 Java 培训。为了支持您的生产代码，您要么需要对 DBA 进行更多培训，要么聘请受过 Java 培训的支持人员

将 Java 移至应用程序服务器通常是一种更好的方法，因为这可以抵消这些缺点。有出色的工具支持，对 JVM 的出色控制，并且有大量人员在流行的应用程序服务器上接受过培训，因此很容易找到支持人员。远离数据库的性能损失是有机会成本的，但是让 Java 靠近数据库并不会给您带来很大的性能提升。

您绝对需要一个理由在数据库中使用 Java，而不是 a) PL/SQL 存储过程或 b) 数据库外部的 Java。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-16T09:22:22.523

Java 使编写与数据库无关的代码成为可能。它允许您重用现有代码并显着提高生产力。

我发现 Java 存储过程有用的一件事是文件 IO。与 Oracle 的 UTL_FILE 包相比，Java 具有更丰富的文件 IO 功能集，允许开发人员删除文件、添加目录等。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T09:03:33.787

**优点：**

*   可以在客户端和数据库中共享相同的应用程序逻辑
*   访问 Java API。注意每个数据库支持的 java 版本——我相信 10g 只支持 1.4（这意味着在我的工作中我们必须非常小心，因为我们的主要代码库最近已经迁移到 1.5）。

**缺点：**

*   执行大量数据库访问的 Java 存储过程可能非常慢
*   更难部署你的代码

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-16T07:42:22.470

我使用 Oracle embedded java 解决了两个问题：

1) 执行一个 PLSQL 过程，将查询结果批量存储在文本文件中并通过 FTP 发送。这个文件非常大，我使用 Java 压缩它。

2）在与数据库直接连接的客户端-服务器应用程序中，比较用户发送给应用程序的密码（不是数据库用户密码）用MD5散列，这样密码就不会以明文形式通过网络传播。我不确定这是否是解决此问题的更好解决方案，我现在要问它。:)

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2011-07-21T18:30:07.963

当您在 PL/SQL 中绝对无法做到这一点时，**或者**如果 Java 可以让您获得更高的性能，请使用 Java。

例如，如果您希望在 PL/SQL 程序（日志记录、外部调用等）中使用套接字，您可以：

1.  编写一个使用 UTL_TCP 的 PL/SQL 客户端。但是，没有办法仅使用本机 PL/SQL 来执行 UDP。
2.  编写一个使用 TCP 或 UDP 套接字的 Java 客户端。

在第一种情况下，如果远程服务出现问题，您有一个同步套接字可以备份您的 PL/SQL 调用。此外，如果您使用 dbms_session.reset_package（如在 OWA 中），则必须为每个请求重新连接套接字，这非常昂贵。

在第二种情况下，TCP 仍然是同步的，但如果您需要异步、非阻塞行为，您可以使用 UDP。此外，reset_package 不会重置 Java TCP 或 UDP 套接字，因此您无需处理拆卸/重新连接的痛苦。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-17T17:02:03.380

答案是*从不*。如果您需要编写程序来加载或处理数据，则需要在网络上的另一台计算机的数据层之外进行。

直接在您的数据层上运行外部应用程序，或者上帝禁止在您的数据层的进程内运行，或者当本机查询语言更适合手头的工作时错误应用外部语言对于小规模的内部定制是完全可以接受的应用。他们在那个舞台之外根本没有立足之地。

# ruby - Ruby 异常继承与动态生成的类

> ID：70074
> 
> 赞同：3
> 
> 时间：2008-09-16T07:29:10.847
> 
> 标签：ruby, exception, metaprogramming

我是 Ruby 的新手，所以我在理解我遇到的这个奇怪的异常问题时遇到了一些麻烦。我正在使用 ruby​​-aaws gem 访问 Amazon ECS： http: [//www.caliban.org/ruby/ruby-aws/](http://www.caliban.org/ruby/ruby-aws/)。这定义了一个类 Amazon::AWS:Error：

```
module Amazon
  module AWS
    # All dynamically generated exceptions occur within this namespace.
    #
    module Error
      # An exception generator class.
      #
      class AWSError
        attr_reader :exception

        def initialize(xml)
          err_class = xml.elements['Code'].text.sub( /^AWS.*\./, '' )
          err_msg = xml.elements['Message'].text

          unless Amazon::AWS::Error.const_defined?( err_class )
            Amazon::AWS::Error.const_set( err_class,
                    Class.new( StandardError ) )
          end

          ex_class = Amazon::AWS::Error.const_get( err_class )
          @exception = ex_class.new( err_msg )
        end
      end
    end
  end
end 
```

这意味着如果您收到类似的错误代码`AWS.InvalidParameterValue`，这将产生（在其异常变量中）一个新类`Amazon::AWS::Error::InvalidParameterValue`，该类是`StandardError`.

现在这就是奇怪的地方。我有一些看起来像这样的代码：

```
begin
  do_aws_stuff
rescue Amazon::AWS::Error => error
  puts "Got an AWS error"
end 
```

现在，如果`do_aws_stuff`抛出 a `NameError`，我的救援块就会被触发。似乎 Amazon::AWS::Error 不是生成错误的超类 - 我想既然它是一个模块，那么一切都是它的子类？当然，如果我这样做：

```
irb(main):007:0> NameError.new.kind_of?(Amazon::AWS::Error)
=> true 
```

它说`true`，我觉得很困惑，特别是考虑到这一点：

```
irb(main):009:0> NameError.new.kind_of?(Amazon::AWS)
=> false 
```

发生了什么，我应该如何将 AWS 错误与其他类型的错误区分开来？我应该做类似的事情：

```
begin
  do_aws_stuff
rescue => error
  if error.class.to_s =~ /^Amazon::AWS::Error/
    puts "Got an AWS error"
  else
    raise error
  end
end 
```

这似乎异常笨拙。抛出的错误也不是类 AWSError - 它们是这样引发的：

```
error = Amazon::AWS::Error::AWSError.new( xml )
raise error.exception 
```

因此，我要查找`rescue`的异常是仅从 StandardError 继承的生成的异常类型。

为了澄清，我有两个问题：

1.  为什么 NameError 是一个 Ruby 内置异常，a`kind_of?(Amazon::AWS::Error)`是一个模块？
    **答：**`include Amazon::AWS::Error`我在文件顶部说过，认为它有点像 Java 导入或 C++ 包含。这实际上所做的是将`Amazon::AWS::Error`（现在和将来）中定义的所有内容添加到隐式内核类中，该类是每个类的祖先。这意味着**任何事情**都会过去`kind_of?(Amazon::AWS::Error)`。

2.  如何最好地将动态创建的异常与`Amazon::AWS::Error`来自其他地方的随机其他异常区分开来？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T08:00:17.450

好的，我会在这里提供帮助：

首先，模块不是类，它允许您在类中混合行为。第二个看下面的例子：

```
module A
  module B
    module Error
      def foobar
        puts "foo"
      end
    end
  end
end

class StandardError
  include A::B::Error
end

StandardError.new.kind_of?(A::B::Error)
StandardError.new.kind_of?(A::B)
StandardError.included_modules #=> [A::B::Error,Kernel] 
```

有点儿？告诉你是的，Error 确实拥有 A::B::Error 的所有行为（这是正常的，因为它包括 A::B::Error）但是它不包括 A::B 的所有行为，因此不是A::B 类型的。（鸭打字）

现在，ruby-aws 很有可能重新打开 NameError 的超类之一，并在其中包含 Amazon::AWS:Error。（猴子补丁）

您可以通过以下方式以编程方式找出模块包含在层次结构中的位置：

```
class Class
  def has_module?(module_ref)
    if self.included_modules.include?(module_ref) and not self.superclass.included_modules.include?(module_ref)                      
        puts self.name+" has module "+ module_ref.name          
    else
      self.superclass.nil? ? false : self.superclass.has_module?(module_ref)
    end        
  end
end
StandardError.has_module?(A::B::Error)
NameError.has_module?(A::B::Error) 
```

关于你的第二个问题，我看不出比

```
begin 
#do AWS error prone stuff
rescue Exception => e
  if Amazon::AWS::Error.constants.include?(e.class.name)
    #awsError
  else
    whatever
  end 
end 
```

（编辑——上面的代码不能按原样工作：名称包括模块前缀，这不是常量数组的情况。你绝对应该联系 lib 维护者 AWSError 类在我看来更像是一个工厂类：/）

我这里没有 ruby​​-aws 并且 caliban 站点被公司的防火墙阻止，所以我无法进一步测试。

关于 include ：这可能是在 StandardError 层次结构上做猴子修补的事情。我不再确定，但很可能在每个上下文之外的文件根目录中执行此操作，包括 Object 或 Object 元类上的模块。（这是在 IRB 中会发生的情况，其中默认上下文是对象，不确定在文件中）

从[模块上的镐](http://www.rubycentral.com/pickaxe/tut_modules.html)：

`A couple of points about the include statement before we go on. First, it has nothing to do with files. C programmers use a preprocessor directive called #include to insert the contents of one file into another during compilation. The Ruby include statement simply makes a reference to a named module. If that module is in a separate file, you must use require to drag that file in before using include.`

（编辑——我似乎无法使用此浏览器发表评论：/ 是的，锁定平台）

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T07:40:51.817

好吧，据我所知：

```
Class.new( StandardError ) 
```

正在创建一个以 StandardError 作为基类的新类，因此它根本不会是 Amazon::AWS::Error。它只是在那个模块中定义的，这可能就是为什么它是 kind_of 的原因？亚马逊::AWS::错误。它可能不是一种？Amazon::AWS 因为也许模块不是出于 kind_of 的目的而嵌套的？?

抱歉，我不太了解 Ruby 中的模块，但最肯定的基类将是 StandardError。

**更新**：顺便说一句，[来自 ruby​​ 文档](http://www.ruby-doc.org/core/classes/Object.html#M000370)：

> obj.kind_of?(class) => true or false
> 
> 如果 class 是 obj 的类，或者 class 是 obj 的超类之一或 obj 中包含的模块，则返回 true。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T11:54:52.517

只是想插话：我同意这是 lib 代码中的一个错误。它可能应该是：

```
 unless Amazon::AWS::Error.const_defined?( err_class )
        kls = Class.new( StandardError )
        Amazon::AWS::Error.const_set(err_class, kls)
        kls.include Amazon::AWS::Error
      end 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2009-10-05T00:39:53.927

您遇到的一个问题是这`Amazon::AWS::Error::AWSError`实际上并不是一个例外。当`raise`被调用时，它会查看第一个参数是否响应该`exception`方法，并将使用该方法的结果。任何属于 的子类的东西在被调用`Exception`时都会返回自己，`exception`这样你就可以做类似`raise Exception.new("Something is wrong")`.

在这种情况下，`AWSError`已`exception`设置为属性读取器，它在初始化时将值定义为`Amazon::AWS::Error::SOME_ERROR`. 这意味着当您调用`raise Amazon::AWS::Error::AWSError.new(SOME_XML)`Ruby 时，最终调用`Amazon::AWS::Error::AWSError.new(SOME_XML).exception`which 将返回`Amazon::AWS::Error::SOME_ERROR`. 正如其他响应者之一所指出的，此类是直接子类，`StandardError`而不是常见 Amazon 错误的子类。在此问题得到纠正之前，Jean 的解决方案可能是您最好的选择。

我希望这有助于解释更多幕后实际发生的事情。

# autocomplete - 在 Wicket 中可视化自定义自动完成功能

> ID：70090
> 
> 赞同：4
> 
> 时间：2008-09-16T07:34:01.223
> 
> 标签：autocomplete, wicket

如何在 Wicket 中直观地自定义自动完成字段（更改颜色、字体等）？

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-09-16T21:24:35.627

您可以使用 CSS 来修改此组件的外观。对于 1.3 中的 Ajax 自动完成组件，您要覆盖的元素是 div.wicket-aa，因此例如您可以这样做：

```
div.wicket-aa {
    background-color:white;
    border:1px solid #CCCCCC;
    color:black;
}
div.wicket-aa ul {
   list-style-image:none;
   list-style-position:outside;
   list-style-type:none;
   margin:0pt;
   padding:5px;
}
div.wicket-aa ul li.selected {
    background-color:#CCCCCC;
} 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T21:30:13.180

Perilandmishap 可能是满足您需求的最有用的答案。就个人而言，我总是发现 Wicket 中默认的 Ajax 自动完成控件严重不足以满足我的需求。如果您真的想要一种专业的“感觉”来自动完成，请使用 Wicket 的 Ajax 库来滚动您的。

# ruby - 如何以编程方式将 mp3 转换为 iTunes 可播放的 aac/m4a 文件？

> ID：70096
> 
> 赞同：5
> 
> 时间：2008-09-16T07:35:16.837
> 
> 标签：ruby, mp3, aac, m4a

我一直在寻找一种以编程方式或通过命令行将 mp3 转换为 aac 的方法，但没有成功。理想情况下，我有一段代码可以从我的 rails 应用程序中调用，将 mp3 转换为 aac。我安装了 ffmpeg 和 libfaac 并能够使用以下命令创建一个 aac 文件：

`ffmpeg -i test.mp3 -acodec libfaac -ab 163840 dest.aac`

当我将输出文件的名称更改为 dest.m4a 时，它不会在 iTunes 中播放。

谢谢！

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-09-16T07:42:33.683

[FFmpeg](http://en.wikipedia.org/wiki/Ffmpeg)提供 AAC 编码工具，如果你已经编译了它们。如果你使用的是 Windows，你可以从[这里获取完整的二进制文件](http://arrozcru.no-ip.org/ffmpeg_builds/)

```
ffmpeg -i source.mp3 -acodec libfaac -ab 128k dest.aac 
```

我不确定你会如何从 ruby​​ 中调用它。

此外，请务必正确设置比特率。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T07:39:36.967

据我所知，只有三个免费的 AAC 编码器可以通过命令行界面获得：

1.  FAAC (LPGL)，老实说非常糟糕（在相同的比特率下，质量会比 LAME 差很多）。如果您愿意追求更高的比特率 (>>128kbps) 并且需要 AAC 以实现兼容性，而不是质量原因，那也可以。使用 FAAC 的最常见方式是通过 ffmpeg，如 libfaac。

2.  Nero AAC，命令行编码器可在 Windows 和 Linux 下免费使用，但仅用于非商业用途（并且相应地是封闭源代码）。

3.  ffmpeg 的 AAC 编码器，仍在开发中，虽然我相信它在技术上确实有效，但它一点也不稳定，也不是很好，甚至不是很快，因为它仍处于初始阶段。据我所知，它在后备箱中也不可用。

（编辑：似乎 iTunes 也可能有一个，我怀疑它的使用条款与 Nero 的相似。AFAIK 它的质量是可比的。）

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-30T19:38:30.643

我意识到我参加这个聚会迟到了，但我质疑这个问题的前提。为什么您甚至想将 MP3 转换为“iTunes 可播放”格式？iTunes 已经原生处理 MP3。

似乎您正在进行不必要的转换，并且由于您正在从一种有损格式转换为另一种格式，因此您在此过程中失去了一些质量。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2010-03-25T19:09:02.610

在 ffmpeg 0.5 或更高版本中使用 ffmpeg -i source.mp3 target.m4a

为了获得更好的结果以传输元数据并覆盖默认比特率 ffmpeg 应用

ffmpeg -i "input.mp3" -ab 256k -map_meta_data input.mp3:output.m4a output.m4a

最好不要转换，因为 ipod 播放 mp3 很好（我知道有这样的答案，但我的地位低不允许投票）

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T07:40:15.017

在运行 Rails 应用程序的 linux/window 机器上安装转换应用程序后，使用 Ruby 中的“system()”命令调用系统上的转换应用程序。系统（“command_here”）；

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T14:10:08.293

我在使用 mplayer （我相信它使用 ffmpeg ...）和跛脚时很幸运。我已经将它包装在一个脚本中：

```
#!/bin/sh

TARGET=$1

BASE=`basename "${TARGET}"`
echo TARGET: "${TARGET}"
echo BASE:   "${BASE}" .m4a

# Warning! Race condition vulnerability here! Should use a mktemp
# variant or something...
mkfifo encode
mplayer -quiet -ao pcm -aofile encode "${TARGET}" &
lame --silent encode "${BASE}".mp3
rm encode 
```

抱歉，安全问题，我有一天在火车上撞了这个......

我的mplayer和la脚来自[fink](http://www.finkproject.org/)

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2014-04-25T20:21:56.120

实际上，语法是 ffmpeg -i input.mp3 -c:a aac -strict -2 -b:a 256k output.m4a; 如果模拟“正确”比特率，则更正确。cf.：编译方案的[链接。](http://ffmpeg.gusari.org/viewtopic.php?f=25&t=38)（rpmfusion 包也可以正常工作：

配置： --prefix=/usr --bindir=/usr/bin --datadir=/usr/share/ffmpeg --incdir=/usr/include/ffmpeg --libdir=/usr/lib64 --mandir=/usr /share/man --arch=x86_64 --optflags='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord -gcc-switches -m64 -mtune=generic'--enable-bzlib --disable-crystalhd --enable-frei0r --enable-gnutls --enable-libass --enable-libcdio --enable-libcelt --enable-libdc1394 --disable-indev=jack --enable -libfreetype --enable-libgsm --enable-libmp3lame --enable-openal --enable-libopencv --enable-libopenjpeg --enable-libopus --enable-libpulse --enable-libschroedinger --enable-libsoxr --enable -libspeex --enable-libtheora --enable-libvorbis --enable-libv4l2 --enable-libvpx --enable-libx264 --enable-libxvid --enable-x11grab --enable-avfilter --enable-avresample --enable -postproc --enable-pthreads --disable-static --enable-shared --enable-gpl --disable-debug --disable-stripping --shlibdir=/usr/lib64 --enable-runtime-cpudetect

# c# - 在不使用任何类型的情况下加载许多托管 DLL 是不是很糟糕？

> ID：70098
> 
> 赞同：3
> 
> 时间：2008-09-16T07:35:55.307
> 
> 标签：c#, .net, dll, inversion-of-control, spring.net

背景：在我的公司，我们正在开发一堆使用相同核心 dll 的应用程序。这些 dll 使用 Spring.net 的 IoC 容器来连接（自动连接）。所有应用程序都使用相同的 spring 配置文件，并且该配置文件指向许多不同 dll 中的许多类。但并非所有应用程序都需要每个 dll 的功能。但是由于 IoC 容器的工作方式，所有的 dll 都为 Spring.net 加载以检查类型并检查它们实现的接口等等。

核心问题：我知道最好只加载您真正使用的dll。但是仅仅加载一个托管的dll对内存使用真的很糟糕吗？还是首先您在 dll 中使用类，并且它们正在 JIT 中使用最多的内存？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T07:42:16.323

我不认为这很糟糕。唯一的问题是，由于元数据和应用程序占用的内存量很大，应用程序的某些正在使用的部分更有可能位于不同的内存页面，这可能会导致一些性能泄漏，但这是应用程序的非常低的部分，其中这类事情很关键。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T07:43:24.103

真的很糟糕是一个难以量化的术语，我想这取决于事情的规模，总的来说，我会说如果你可以避免加载你不需要的东西，那么你应该这样做。但是当然如果你使用反射来确定你是否*可以*使用它，你首先必须加载它......鸡和鸡蛋的问题。

但是需要注意的是，一旦将程序集加载到应用程序域中，您就无法从该应用程序域中卸载它，但是可以动态创建应用程序域将程序集加载到其中并在您卸载整个应用程序域时完毕。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T08:06:36.857

如果程序集中的任何代码都没有被使用过，那么最终来自该程序集的页面将从内存移动到页面文件中，以支持活跃使用的页面。在这种情况下，整体的长期影响可能很小。虽然，会对启动时间产生负面影响。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2009-01-04T15:05:32.580

当然，由于从磁盘读取程序集和证据/安全检查，不使用它们加载 dll 会导致启动时间变慢。但是，如果内存是您关心的问题，您至少可以确定，如果您真的不使用任何类型的内存，那么您浪费的内存不会超过程序集的大小。当然，如果在 spring 配置中指定了这些类型，至少这些类型会被加载到内存中，并且它们的静态初始化程序（如果有的话）将被执行。在极少数情况下，这可能是一个问题。JITing 由 CLR 在每个方法的基础上完成，因此您不使用的方法不会浪费 cpu+内存。

在任何情况下，您都可以将配置文件拆分为多个分区，例如，将模块 A 的所有对象定义放入文件 moduleA.config，将模块 B 的所有定义放入文件 moduleB.config，并仅指定您的特定应用程序真正需要的那些模块。

hth，埃里希

PS：我还想建议您将 Spring for .NET 相关问题发布到我们的[社区论坛](http://forum.springframework.net/)——那里更有可能回答您的问题。

# asp.net - DropDownList 不会在 SelectedIndexChanged 上回发

> ID：70109
> 
> 赞同：12
> 
> 时间：2008-09-16T07:38:48.483
> 
> 标签：asp.net, drop-down-menu

我正在编写一个带有一些 DropDownList 控件的 ASP.Net 网络表单。然后用户更改下拉列表之一中的选定项目，ASP.Net 似乎没有处理 SelectedIndexChanged 事件，直到通过单击“提交”按钮提交表单。如何让我的下拉列表立即处理 SelectedIndexChanged？

PS 这是一个经典问题，我已经回答了太多次了，但似乎没有人在 stackoverflow 上问过这个问题。

* * *

## 回答 #1

> 赞同：25
> 
> 时间：2008-09-16T07:40:51.880

将[AutoPostback](http://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.listcontrol.autopostback(VS.71).aspx)属性设置为 true 将导致它在选择更改时回发。请注意，这需要启用 javascript。

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2008-09-16T07:46:00.870

您需要将`AutoPostBack`列表的属性设置为 true。

此外，如果您要从后面的代码中填充下拉列表的内容（例如，从数据库中获取列表的内容），请确保您没有在每次回发中重新绑定数据。

有时人们会因为在页面加载事件中绑定下拉菜单而不将其放入`If Not IsPostBack`. 这将导致事件不触发。

`ItemCommand`中继器和事件也是如此。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2011-10-05T21:30:25.707

如果您在页面加载期间填充下拉列表，那么每次页面回发时它都会重新加载列表，从而否定您的回发方法。您需要确保仅在 (!ispostback) 时加载下拉列表

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T07:41:30.473

将 DropDownList 的 AutoPostBack 属性设置为 true。

# database-design - 重用软删除记录

> ID：70123
> 
> 赞同：3
> 
> 时间：2008-09-16T07:40:18.107
> 
> 标签：database-design, soft-delete

如果我有一个表结构是：

```
code, description, isdeleted 
```

`code`主键在哪里。

用户创建一条记录，然后将其删除。因为我使用的是软删除，所以`isdeleted`将设置为 true。然后在我的查询中，我将使用 where 子句进行选择`and not isdeleted`

现在，如果用户去创建一条新记录，他们可能会看到代码“ABC”不存在，因此他们尝试重新创建它。由于 where 子句，select 语句不会找到它。但是会出现主键索引错误。

是否应该允许用户重新使用记录？我认为不会，因为软删除的想法是保留对旧数据的查询记录，以便连接到“已删除”记录仍然有效。如果允许用户重新使用代码，那么他们可以更改描述，这可能会改变历史数据的视图。但是完全阻止他们使用该代码是否太苛刻了？

或者我应该使用完全隐藏的主键，然后可以重复使用“代码”字段？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-16T07:44:51.167

我知道很多人认为数据应该是自然的，但是如果您要支持软删除而不打算总是重用以前的记录，那么您应该使用与数据完全分开的主键出现这种情况。

拥有一个分离的主键将允许您拥有多个具有相同“代码”值的记录，并且它将允许您“取消删除”（否则，为什么要使用软删除？）一个值而不必担心覆盖其他内容。

就个人而言，我更喜欢数字自动递增的 ID 样式，但 GUID 的支持者很多。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T07:45:10.370

> 或者我应该使用完全隐藏的主键，然后可以重复使用“代码”字段？

我认为您自己已经很好地回答了这个问题。如果您希望用户能够重新使用已删除的代码，那么您应该有一个用户不可见的单独主键。如果代码的唯一性很重要，那么用户通常不应该输入它们。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T07:55:17.257

我认为这取决于您正在谈论的具体数据。

如果用户试图重新创建代码“ABC”，是上次使用的相同“ABC”现在已经退出，还是完全不同的“ABC”？

如果它实际上指的是同一个现实世界的“事物”，那么简单地“取消删除”它可能没有害处。毕竟 - 这是同一件事，所以从逻辑上讲，它应该在历史查询和新查询中显示为同一件事。如果您的用户决定不再需要它，那么他们可以删除它并且它会消失。如果在将来的某个时候他们再次需要它，他们可以通过再次添加它来有效地取消删除它。

但是，如果新的“ABC”指的是（在现实世界中）与旧的“ABC”不同的东西，那么您可以争辩说“代码”*实际上*不是主键，在这种情况下，如果您的数据不提供任何其他自然选择，您也可以创建任意键。

这样做的一个很大的缺点是你必须非常小心，当然不要让用户创建两个具有相同“代码”的活动记录。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T08:00:17.107

当您选择记录（不包括软删除）以在用户界面/输出文件中显示它们时，请使用 where not isdeleted。

但是当用户请求插入操作时，执行两个查询。

1.  查找所有记录（忽略 isdeleted 值）。

2.  根据第一个查询结果，如果存在则执行 UPDATE（并反转 isdeleted 标志），如果不存在则执行真正的 INSERT。

业务逻辑的细微差别取决于您。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T08:02:51.093

我已经使用用户表完成了此操作，其中电子邮件是唯一约束。如果有人取消了那里的帐户，他们的信息仍然需要参考完整性，所以我要设置 is_deteled 为 true，并在电子邮件字段中添加“_deleted”。这样，如果用户决定以后再次注册，对用户来说没有问题，唯一性约束也不会被打破。

我认为软删除在某些情况下很好。例如，如果有人从该站点删除了他们的帐户，而您删除了他们的用户，那么他们的所有帖子和答案都会丢失。我认为软删除并将他们的用户显示为“已删除用户”或类似的东西要好得多......哦，我也相信分离的主键

# imap - Maildir 消息文件名中的标志是什么意思？

> ID：70140
> 
> 赞同：12
> 
> 时间：2008-09-16T07:43:07.210
> 
> 标签：imap, maildir

我正在清理一些旧的 Maildir 文件夹，并查找名称如下的邮件：

1095812260.M625118P61205V0300FF04I002DC537_0.redoak.cise.ufl.edu,S=2576:2,ST

它们没有出现在我的 IMAP 客户端中，所以我认为有一些信号量表明消息已经移动到其他地方。是这样吗，能不后悔就删掉文件吗？

* * *

## 回答 #1

> 赞同：16
> 
> 时间：2008-09-16T07:49:37.163

“M”只是唯一文件名的一部分，与邮件未显示在邮件客户端这一事实无关。

但是，文件名末尾的“T”在“:”符号之后告诉 IMAP 服务器该邮件已被删除。

见[http://cr.yp.to/proto/maildir.html](http://cr.yp.to/proto/maildir.html)

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T07:49:39.707

IMAP，是一种与消息存储进行通信的协议，实际存储以其他方式标准化。文件名看起来像[Maildir](http://en.wikipedia.org/wiki/Maildir)文件名，我认为文件名的第一部分没有任何意义，但您必须查看您的软件手册。

# xslt - 合并多个 xslt 样式表

> ID：70143
> 
> 赞同：8
> 
> 时间：2008-09-16T07:43:49.843
> 
> 标签：xslt

我有一个带有多个`xsl:import`s 的 xslt 样式表，我想将它们全部合并到一个 xslt 文件中。

这是我们使用的系统的一个限制，它作为存储在内存中的字符串对象传递 xsl 样式表。这被传输到执行转换的远程机器。由于它不是从磁盘加载的，因此 href 链接已损坏，因此我们需要`xsl:import`从样式表中删除 s。

有没有可以做到这一点的工具？

* * *

## 回答 #1

> 赞同：16
> 
> 时间：2008-09-16T09:10:21.273

您可以使用 XSL 样式表来合并样式表。但是，这相当于使用 xsl:include 元素，而不是 xsl:import（正如 Azat Razetdinov 已经指出的那样）。[您可以在此处](http://www.w3.org/TR/xslt#section-Combining-Stylesheets)阅读差异。

因此，您应该首先将 xsl:import 替换为 xsl:include，解决任何冲突并测试您是否仍然得到正确的结果。之后，您可以使用以下样式表将现有样式表合并为一个。只需将其应用于您的主样式表：

```
<?xml version="1.0" ?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
                version="1.0">

<xsl:template match="xsl:include">
  <xsl:copy-of select="document(@href)/xsl:stylesheet/*"/>
</xsl:template>

<xsl:template match="@*|node()">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>
  </xsl:copy>
</xsl:template>

</xsl:stylesheet> 
```

第一个模板通过使用 document 函数将所有 xsl:include 替换为包含的样式表，该函数读取 href 属性中引用的文件。第二个模板是[身份转换](https://stackoverflow.com/questions/56837/how-can-i-make-an-exact-copy-of-a-xml-nodes-children-with-xslt)。

我已经用 Xalan 对其进行了测试，它似乎工作正常。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T08:28:30.003

[在不破坏导入优先级](http://www.w3.org/TR/xslt#dt-import-precedence)的情况下，不可能将导入的样式表包含到主文件中。例如，您在导入的样式表中定义一个顶级变量并在主文件中重新定义它。如果将两个文件合并为一个，则会得到两个具有相同名称和导入优先级的变量，这将导致错误。

解决方法是两个用 xsl:include's 替换 xsl:import's 并解决任何[冲突](http://www.w3.org/TR/xslt#conflict)。之后，您可以安全地将 xsl:include 指令替换为相应文件的内容，因为这是[XSLT 处理器所做的](http://www.w3.org/TR/xslt#include)：

> 包含在 XML 树级别工作。通过 href 属性值定位的资源被解析为 XML 文档，并且该文档中 xsl:stylesheet 元素的子元素替换了包含文档中的 xsl:include 元素。包含模板规则或定义的事实不会影响它们的处理方式。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T08:13:06.200

手动合并可能是最好的选择。

主要考虑因素可能是确保匹配模板的逻辑在组合样式表中有效。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T07:50:18.860

你为什么想要？毕竟它们通常是分开的（通常是可维护性）

您始终可以自己编写合并 - 读取 XSL 文件，选择您感兴趣的模板项并写入新的主 XSL 文件...

* * *

## 回答 #5

> 赞同：-1
> 
> 时间：2009-06-23T11:12:49.200

```
 import multiple xsl in single xsl

      <xsl:import href="FpML_FXOption_Trade_Template1.xsl"/>
      <xsl:apply-imports/>

<calypso:keyword>
                <calypso:name>DisplayOptionStyle</calypso:name>
<calypso:value>Vanilla</calypso:value>
</calypso:keyword>

           <xsl:import href="FpML_FXOption_Trade_Template2.xsl"/>
           <xsl:apply-imports/> 
```

# .net - 哪些属性有助于运行时 .Net 性能？

> ID：70150
> 
> 赞同：14
> 
> 时间：2008-09-16T07:44:52.760
> 
> 标签：.net, performance, runtime

我正在寻找可用于通过向加载程序、JIT 编译器或 ngen 提供提示来确保我的 .Net 应用程序的最佳运行时性能的属性。

例如，我们有[DebuggableAttribute](http://msdn.microsoft.com/en-us/library/k2wxda47.aspx)应该设置为不调试并且不禁用优化以获得最佳性能。

```
[Debuggable(false, false)] 
```

还有其他我应该知道的吗？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T23:14:42.087

Ecma-335 在附件 F“不精确的错误”中为宽松的异常处理（所谓的 e-relaxed 调用）指定了更多的 CompilationRelaxations，但它们尚未被 Microsoft 公开。

其中特别提到了 CompilationRelaxations.RelaxedArrayExceptions 和 CompilationRelaxations.RelaxedNullReferenceException。

当您在 CompilationRelaxationsAttribute 的 ctor 中尝试一些整数时会发生什么会很有趣；）

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T17:39:18.650

另一个：文字字符串（在源代码中声明的字符串）默认情况下[被](http://msdn.microsoft.com/en-us/library/system.string.intern.aspx)嵌入到一个池中以节省内存。

```
string s1 = "MyTest"; 
string s2 = new StringBuilder().Append("My").Append("Test").ToString(); 
string s3 = String.Intern(s2); 
Console.WriteLine((Object)s2==(Object)s1); // Different references.
Console.WriteLine((Object)s3==(Object)s1); // The same reference. 
```

尽管在多次使用相同的文字字符串时它可以节省内存，但维护池会花费一些 cpu，并且一旦将字符串放入池中，它就会一直留在那里直到进程停止。

使用[CompilationRelaxationsAttribute](http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.compilationrelaxationsattribute.aspx)您可以告诉 JIT 编译器您真的不希望它实习所有文字字符串。

```
[assembly: CompilationRelaxations(CompilationRelaxations.NoStringInterning)] 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T07:48:37.913

我发现了另一个：[NeutralResourcesLanguageAttribute](http://msdn.microsoft.com/en-us/library/system.resources.neutralresourceslanguageattribute.aspx)。根据[这篇](http://blogs.msdn.com/bclteam/archive/2005/10/11/479330.aspx)博客文章，它通过指定当前（中性）程序集的区域性来帮助加载程序更快地找到正确的附属程序集。

```
[NeutralResourcesLanguageAttribute("nl", UltimateResourceFallbackLocation.MainAssembly)] 
```

# .net - 使用 sql server 数据库和 .NET 框架存储和检索邮政地址的最佳方法是什么？

> ID：70153
> 
> 赞同：3
> 
> 时间：2008-09-16T07:45:23.507
> 
> 标签：.net, sql-server, regex, street-address, postal-code

我正在寻找一种在数据库中存储和访问全局地址的通用模式。可以使用组件或其他技术。必须遵守以下标准...

*   地址的每一行都为每个国家/地区保存
*   [邮政编码](http://en.wikipedia.org/wiki/List_of_postal_codes)在保存之前使用正则表达式进行测试
*   原始国家/地区保存在其自己的字段中显示数据时，该国家/地区样式的[地址被格式化]（ [http://en.wikipedia.org/wiki/Postal_address ）](http://en.wikipedia.org/wiki/Postal_address)
*   当使用表单输入数据时，标签字段尽可能具有描述性，因此标签必须是动态的，以适用于原产国。
*   地址占用尽可能少的空间

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2008-09-16T07:52:32.787

如何将地址存储为文本（允许换行）。邮政编码必须使用正则表达式从地址中提取（根据国家下拉菜单选择），并且应该存储在单独的列中。

这不涉及“尽可能描述性”的要求，但一般来说，对数据格式实施更多限制将导致一定百分比的有效地址被拒绝。它也将比单个 varchar 列占用更多空间。因此，您列出的要求之间总会存在折衷。

# algorithm - 如何从写成单词的数字中读取值？

> ID：70161
> 
> 赞同：51
> 
> 时间：2008-09-16T07:47:36.760
> 
> 标签：algorithm, language-agnostic, parsing, numbers, nlp

众所周知，数字可以写成数字，也可以用它们的名字来称呼。虽然可以找到很多将 123 转换为 123 的示例，但我找不到如何将其反过来转换的好示例。

一些警告：

1.  基数/名义或序数：“一”和“第一”
2.  常见拼写错误：“四十”/“四十”
3.  百/千：2100 -> “2100”和“2010”
4.  分隔符：“十一百五十二”，还有“十一百五十二”或“十一百五十二”等等
5.  俗语：“三十多岁”
6.  分数：'三分之一'，'五分之二'
7.  常用名称：“一打”、“半”

可能还有更多尚未列出的警告。假设算法需要非常健壮，甚至可以理解拼写错误。

我应该阅读哪些领域/论文/研究/算法来学习如何编写所有这些？信息在哪里？

> PS：我的最终解析器实际上应该理解 3 种不同的语言，英语、俄语和希伯来语。也许在稍后阶段会添加更多语言。希伯来语也有男性/女性数字，例如“one man”和“one woman”有不同的“one”——“ehad”和“ahat”。俄语也有其自身的一些复杂性。

谷歌在这方面做得很好。例如：

[http://www.google.com/search?q=two+thousand+and+one+hundred+plus+5+dozen+and+four+fifths+in+decimal](http://www.google.com/search?q=two+thousand+and+one+hundred+plus+five+dozen+and+four+fifths+in+decimal)

（反过来也可以[http://www.google.com/search?q=999999999999+in+english](http://www.google.com/search?q=999999999999+in+english)）

* * *

## 回答 #1

> 赞同：46
> 
> 时间：2009-03-17T05:28:46.030

当我注意到有一个非常简单的算法可以很好地处理英语、西班牙语和德语，至少。

例如，使用英语时，您需要一个字典，以显而易见的方式将单词映射到值：

```
"one" -> 1, "two" -> 2, ... "twenty" -> 20,
"dozen" -> 12, "score" -> 20, ...
"hundred" -> 100, "thousand" -> 1000, "million" -> 1000000 
```

...等等

该算法只是：

```
total = 0
prior = null
for each word w
    v <- value(w) or next if no value defined
    prior <- case
        when prior is null:       v
        when prior > v:     prior+v
        else                prior*v
        else
    if w in {thousand,million,billion,trillion...}
        total <- total + prior
        prior <- null
total = total + prior unless prior is null 
```

例如，这进展如下：

```
total    prior      v     unconsumed string
    0      _              four score and seven 
                    4     score and seven 
    0      4              
                   20     and seven 
    0     80      
                    _     seven 
    0     80      
                    7 
    0     87      
   87

total    prior      v     unconsumed string
    0        _            two million four hundred twelve thousand eight hundred seven
                    2     million four hundred twelve thousand eight hundred seven
    0        2
                  1000000 four hundred twelve thousand eight hundred seven
2000000      _
                    4     hundred twelve thousand eight hundred seven
2000000      4
                    100   twelve thousand eight hundred seven
2000000    400
                    12    thousand eight hundred seven
2000000    412
                    1000  eight hundred seven
2000000  412000
                    1000  eight hundred seven
2412000     _
                      8   hundred seven
2412000     8
                     100  seven
2412000   800
                     7
2412000   807
2412807 
```

等等。我并不是说它是完美的，但对于快速和肮脏的它来说，它做得很好。

* * *

在编辑时处理您的特定列表：

1.  基数/名义或序数：“一个”和“第一”——**只要把它们放在字典里**
2.  英语/英国语：“fourty”/“forty”——**同上**
3.  数百/千：2100 -> “2100”和“2010”——**按原样工作**
4.  分隔符：“十一五十二”，还有“十一百五十二”或“十一百五十二”等等——**只需将“下一个单词”定义为与定义的单词匹配的最长前缀，或者直到下一个非词如果没有，首先**
5.  口语：“三十多岁”——**作品**
6.  片段：“三分之一”，“五分之二”——**呃，还没有……**
7.  常用名称：“一打”、“半”——**有效；你甚至可以做“半打”之类的事情**

6 号是唯一一个我没有现成答案的，这是因为序数和分数之间的歧义（至少在英语中）加上我最后一杯咖啡是*几个*小时前的事实。

* * *

## 回答 #2

> 赞同：12
> 
> 时间：2008-09-18T00:26:19.363

这不是一个容易的问题，而且我知道没有图书馆可以做到这一点。我可能会坐下来尝试写一些类似的东西。不过，我会在 Prolog、Java 或 Haskell 中执行此操作。据我所知，有几个问题：

*   标记化：有时，数字写成 1152，但我见过 1152 或 1152 等等。人们必须对实际使用的表格进行调查。这对希伯来语来说可能特别棘手。
*   拼写错误：这并不难。你的单词数量有限，一点 Levenshtein 距离魔法应该可以解决问题。
*   就像您已经提到的那样，存在替代形式。这包括序数/基数，以及四十/四十和...
*   ... 常用名称或常用短语和 NE（命名实体）。你想从三十年战争中提取 30 个还是从二战中提取 2 个？
*   罗马数字也行？
*   “三十多岁”、“三欧弹片”之类的口语，不知如何对待。

如果你对此感兴趣，我可以在这个周末试一试。我的想法可能是使用 UIMA 并用它进行标记，然后继续进一步标记/消除歧义并最终翻译。可能还有更多的问题，让我们看看我能不能想出一些更有趣的东西。

抱歉，这还不是一个真正的答案，只是对您的问题的扩展。如果我找到/写一些东西，我会告诉你的。

顺便说一句，如果你对数字的语义感兴趣，我刚刚发现了 Friederike Moltmann 的一篇[有趣的论文](http://semanticsarchive.net/Archive/WVlYTRkO/)，讨论了一些关于数字逻辑解释的问题。

* * *

## 回答 #3

> 赞同：11
> 
> 时间：2008-09-16T07:52:42.817

我有一些我不久前写的代码：[text2num](https://github.com/ghewgill/text2num)。这可以满足您的一些需求，但它不处理序数。我实际上并没有将这段代码用于任何事情，所以它在很大程度上未经测试！

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2011-08-03T11:39:30.363

使用 Python [pattern-en](http://www.clips.ua.ac.be/pages/pattern-en)库：

```
>>> from pattern.en import number
>>> number('two thousand fifty and a half') => 2050.5 
```

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2009-03-17T14:06:00.437

您应该记住，欧洲和美国的计算方式不同。

### 欧洲标准：

```
One Thousand
One Million
One Thousand Millions (British also use Milliard)
One Billion
One Thousand Billions
One Trillion
One Thousand Trillions 
```

[这](http://www.jimloy.com/math/billion.htm)是关于它的一个小参考。

* * *

查看差异的简单方法如下：

```
(American counting Trillion) == (European counting Billion) 
```

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2009-03-14T00:56:06.637

序数不适用，因为它们不能以有意义的方式与语言中的其他数字连接（......至少在英语中）

比如一百零一秒，十一秒等等……

但是，还有另一个关于“和”这个词的英语/美国警告

IE

一百零一（英语） 一百一（美国）

此外，在英语中使用“a”表示一个

一千=一千

...在旁注中，Google 的计算器在这方面做得非常出色。

[13000倍光速](http://www.google.co.uk/search?hl=en&rlz=1C1GGLS_en-GBGB316GB316&ei=jAC7SbzoCYzFjAfNsPClCA&sa=X&oi=spell&resnum=0&ct=result&cd=1&q=one%20hundred%20and%20three%20thousand%20times%20the%20speed%20of%20light&spell=1)

乃至...

[两千一百加一打](http://www.google.co.uk/search?hl=en&rlz=1C1GGLS_en-GBGB316GB316&ei=OAG7SaGmONzFjAeHjpCVCA&sa=X&oi=spell&resnum=0&ct=result&cd=1&q=two%20thousand%20and%20one%20hundred%20plus%20a%20dozen&spell=1)

……呜呜呜？！？[一个分数加上十几个罗马数字](http://www.google.co.uk/search?hl=en&rlz=1C1GGLS_en-GBGB316GB316&q=a%20score%20plus%20a%20dozen%20in%20roman%20numerals&btnG=Search&meta=)

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2011-11-13T14:16:12.323

这是 Clojure 中一个非常强大的解决方案。

AFAIK 这是一种独特的实现方法。

```
;----------------------------------------------------------------------
; numbers.clj
; written by: Mike Mattie codermattie@gmail.com
;----------------------------------------------------------------------
(ns operator.numbers
  (:use compojure.core)

  (:require
    [clojure.string     :as string] ))

(def number-word-table {
  "zero"          0
  "one"           1
  "two"           2
  "three"         3
  "four"          4
  "five"          5
  "six"           6
  "seven"         7
  "eight"         8
  "nine"          9
  "ten"           10
  "eleven"        11
  "twelve"        12
  "thirteen"      13
  "fourteen"      14
  "fifteen"       15
  "sixteen"       16
  "seventeen"     17
  "eighteen"      18
  "nineteen"      19
  "twenty"        20
  "thirty"        30
  "fourty"        40
  "fifty"         50
  "sixty"         60
  "seventy"       70
  "eighty"        80
  "ninety"        90
})

(def multiplier-word-table {
  "hundred"       100
  "thousand"      1000
})

(defn sum-words-to-number [ words ]
  (apply + (map (fn [ word ] (number-word-table word)) words)) )

; are you down with the sickness ?
(defn words-to-number [ words ]
  (let
    [ n           (count words)

      multipliers (filter (fn [x] (not (false? x))) (map-indexed
                                                      (fn [ i word ]
                                                        (if (contains? multiplier-word-table word)
                                                          (vector i (multiplier-word-table word))
                                                          false))
                                                      words) )

      x           (ref 0) ]

    (loop [ indices (reverse (conj (reverse multipliers) (vector n 1)))
            left    0
            combine + ]
      (let
        [ right (first indices) ]

        (dosync (alter x combine (* (if (> (- (first right) left) 0)
                                      (sum-words-to-number (subvec words left (first right)))
                                      1)
                                    (second right)) ))

        (when (> (count (rest indices)) 0)
          (recur (rest indices) (inc (first right))
            (if (= (inc (first right)) (first (second indices)))
              *
              +))) ) )
    @x )) 
```

这里有些例子

```
(operator.numbers/words-to-number ["six" "thousand" "five" "hundred" "twenty" "two"])
(operator.numbers/words-to-number ["fifty" "seven" "hundred"])
(operator.numbers/words-to-number ["hundred"]) 
```

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2009-03-17T05:43:39.130

我的 LPC 实现了您的一些要求（仅限美式英语）：

```
internal mapping inordinal = ([]);
internal mapping number = ([]);

#define Numbers ([\
    "zero"        : 0, \
    "one"         : 1, \
    "two"         : 2, \
    "three"       : 3, \
    "four"        : 4, \
    "five"        : 5, \
    "six"         : 6, \
    "seven"       : 7, \
    "eight"       : 8, \
    "nine"        : 9, \
    "ten"         : 10, \
    "eleven"      : 11, \
    "twelve"      : 12, \
    "thirteen"    : 13, \
    "fourteen"    : 14, \
    "fifteen"     : 15, \
    "sixteen"     : 16, \
    "seventeen"   : 17, \
    "eighteen"    : 18, \
    "nineteen"    : 19, \
    "twenty"      : 20, \
    "thirty"      : 30, \
    "forty"       : 40, \
    "fifty"       : 50, \
    "sixty"       : 60, \
    "seventy"     : 70, \
    "eighty"      : 80, \
    "ninety"      : 90, \
    "hundred"     : 100, \
    "thousand"    : 1000, \
    "million"     : 1000000, \
    "billion"     : 1000000000, \
])

#define Ordinals ([\
    "zeroth"        : 0, \
    "first"         : 1, \
    "second"        : 2, \
    "third"         : 3, \
    "fourth"        : 4, \
    "fifth"         : 5, \
    "sixth"         : 6, \
    "seventh"       : 7, \
    "eighth"        : 8, \
    "ninth"         : 9, \
    "tenth"         : 10, \
    "eleventh"      : 11, \
    "twelfth"       : 12, \
    "thirteenth"    : 13, \
    "fourteenth"    : 14, \
    "fifteenth"     : 15, \
    "sixteenth"     : 16, \
    "seventeenth"   : 17, \
    "eighteenth"    : 18, \
    "nineteenth"    : 19, \
    "twentieth"     : 20, \
    "thirtieth"     : 30, \
    "fortieth"      : 40, \
    "fiftieth"      : 50, \
    "sixtieth"      : 60, \
    "seventieth"    : 70, \
    "eightieth"     : 80, \
    "ninetieth"     : 90, \
    "hundredth"     : 100, \
    "thousandth"    : 1000, \
    "millionth"     : 1000000, \
    "billionth"     : 1000000000, \
])

varargs int denumerical(string num, status ordinal) {
    if(ordinal) {
        if(member(inordinal, num))
            return inordinal[num];
    } else {
        if(member(number, num))
            return number[num];
    }
    int sign = 1;
    int total = 0;
    int sub = 0;
    int value;
    string array parts = regexplode(num, " |-");
    if(sizeof(parts) >= 2 && parts[0] == "" && parts[1] == "-")
        sign = -1;
    for(int ix = 0, int iix = sizeof(parts); ix < iix; ix++) {
        string part = parts[ix];
        switch(part) {
        case "negative" :
        case "minus"    :
            sign = -1;
            continue;
        case ""         :
            continue;
        }
        if(ordinal && ix == iix - 1) {
            if(part[0] >= '0' && part[0] <= '9' && ends_with(part, "th"))
                value = to_int(part[..<3]);
            else if(member(Ordinals, part))
                value = Ordinals[part];
            else
                continue;
        } else {
            if(part[0] >= '0' && part[0] <= '9')
                value = to_int(part);
            else if(member(Numbers, part))
                value = Numbers[part];
            else
                continue;
        }
        if(value < 0) {
            sign = -1;
            value = - value;
        }
        if(value < 10) {
            if(sub >= 1000) {
                total += sub;
                sub = value;
            } else {
                sub += value;
            }
        } else if(value < 100) {
            if(sub < 10) {
                sub = 100 * sub + value;
            } else if(sub >= 1000) {
                total += sub;
                sub = value;
            } else {
                sub *= value;
            }
        } else if(value < sub) {
            total += sub;
            sub = value;
        } else if(sub == 0) {
            sub = value;
        } else {
            sub *= value;
        }
    }
    total += sub;
    return sign * total;
} 
```

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2009-03-20T23:33:46.087

好吧，我在回答这个问题时为时已晚，但我正在研究一个似乎对我来说效果很好的小测试场景。我使用了一个（简单但丑陋且大的）正则表达式来为我定位所有单词。表达式如下：

```
(?<Value>(?:zero)|(?:one|first)|(?:two|second)|(?:three|third)|(?:four|fourth)|
(?:five|fifth)|(?:six|sixth)|(?:seven|seventh)|(?:eight|eighth)|(?:nine|ninth)|
(?:ten|tenth)|(?:eleven|eleventh)|(?:twelve|twelfth)|(?:thirteen|thirteenth)|
(?:fourteen|fourteenth)|(?:fifteen|fifteenth)|(?:sixteen|sixteenth)|
(?:seventeen|seventeenth)|(?:eighteen|eighteenth)|(?:nineteen|nineteenth)|
(?:twenty|twentieth)|(?:thirty|thirtieth)|(?:forty|fortieth)|(?:fifty|fiftieth)|
(?:sixty|sixtieth)|(?:seventy|seventieth)|(?:eighty|eightieth)|(?:ninety|ninetieth)|
(?<Magnitude>(?:hundred|hundredth)|(?:thousand|thousandth)|(?:million|millionth)|
(?:billion|billionth))) 
```

此处显示用于格式化目的的换行符..

无论如何，我的方法是用 PCRE 之类的库执行这个 RegEx，然后读回命名的匹配项。它适用于这个问题中列出的所有不同示例，减去“一半”类型，因为我没有添加它们，但正如你所看到的，这样做并不难。这解决了很多问题。例如，它解决了原始问题和其他答案中的以下项目：

1.  基数/名义或序数：“一”和“第一”
2.  常见的拼写错误：“forty”/“fourty”（请注意，它没有明确解决这个问题，这将是您在将字符串传递给此解析器之前想要做的事情。此解析器将此示例视为“FOUR”。 ..)
3.  百/千：2100 -> “2100”和“2010”
4.  分隔符：“十一百五十二”，还有“十一百五十二”或“十一百五十二”等等
5.  colloqialisms：“三十多岁”（这也没有完全解决，因为什么是“某事”？好吧，这段代码发现这个数字只是“30”）。**

现在，我没有将这个正则表达式的怪物存储在您的源代码中，而是考虑在运行时构建这个 RegEx，使用类似以下内容：

```
char *ones[] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve",
  "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"};
char *tens[] = {"", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
char *ordinalones[] = { "", "first", "second", "third", "fourth", "fifth", "", "", "", "", "", "", "twelfth" };
char *ordinaltens[] = { "", "", "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth", "seventieth", "eightieth", "ninetieth" };
and so on... 
```

这里最简单的部分是我们只存储重要的单词。在 SIXTH 的情况下，您会注意到它没有条目，因为它只是带有 TH 的普通数字......但是像 TWELVE 这样的需要不同的注意。

好的，现在我们有了构建（丑陋的）RegEx 的代码，现在我们只需在我们的数字字符串上执行它。

我会推荐的一件事是过滤或吃掉“AND”这个词。这没有必要，只会导致其他问题。

因此，您要做的是设置一个函数，将“幅度”的命名匹配传递给一个查看所有可能幅度值的函数，并将当前结果乘以该幅度值。然后，您创建一个函数来查看名为“值”的匹配项，并根据在那里发现的值返回一个 int（或您正在使用的任何内容）。

所有 VALUE 匹配都会添加到您的结果中，而 magnitutde 匹配将结果乘以 mag 值。所以，二十五万变成了“2”，然后是“2 * 100”，然后是“200 + 50”，然后是“250 * 1000”，最后是250000……

只是为了好玩，我为此编写了一个 vbScript 版本，它与提供的所有示例配合得很好。现在，它不支持命名匹配，所以我不得不更加努力地获得正确的结果，但我明白了。底线是，如果它是“价值”匹配，请将其添加到您的累加器中。如果是幅度匹配，请将您的累加器乘以 100、1000、1000000、1000000000 等...这将为您提供一些非常惊人的结果，而您所要做的调整“一半”之类的事情就是将它们相加到你的正则表达式，为它们输入一个代码标记，然后处理它们。

好吧，我希望这篇文章能帮助一些人。如果有人愿意，我可以通过我用来测试它的 vbScript 伪代码发布，但是，它不是漂亮的代码，也不是生产代码。

如果可以的话.. 这将用什么语言编写？C++，还是类似脚本语言的东西？Greg Hewgill 的消息来源将大大有助于理解所有这些是如何结合在一起的。

让我知道我是否可以提供任何其他帮助。抱歉，我只懂英语/美语，所以无法帮助您了解其他语言。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2016-12-29T21:29:39.090

我正在将早期现代书籍（例如“第 2 版”、“Editio quarta”）中的序数版本语句转换为整数，并且需要支持英语中的序数 1-100 和一些罗曼语语言中的序数 1-10。这是我在 Python 中提出的：

```
def get_data_mapping():
  data_mapping = {
    "1st": 1,
    "2nd": 2,
    "3rd": 3,

    "tenth": 10,
    "eleventh": 11,
    "twelfth": 12,
    "thirteenth": 13,
    "fourteenth": 14,
    "fifteenth": 15,
    "sixteenth": 16,
    "seventeenth": 17,
    "eighteenth": 18,
    "nineteenth": 19,
    "twentieth": 20,

    "new": 2,
    "newly": 2,
    "nova": 2,
    "nouvelle": 2,
    "altera": 2,
    "andere": 2,

    # latin
    "primus": 1,
    "secunda": 2,
    "tertia": 3,
    "quarta": 4,
    "quinta": 5,
    "sexta": 6,
    "septima": 7,
    "octava": 8,
    "nona": 9,
    "decima": 10,

    # italian
    "primo": 1,
    "secondo": 2,
    "terzo": 3,
    "quarto": 4,
    "quinto": 5,
    "sesto": 6,
    "settimo": 7,
    "ottavo": 8,
    "nono": 9,
    "decimo": 10,

    # french
    "premier": 1,
    "deuxième": 2,
    "troisième": 3,
    "quatrième": 4,
    "cinquième": 5,
    "sixième": 6,
    "septième": 7,
    "huitième": 8,
    "neuvième": 9,
    "dixième": 10,

    # spanish
    "primero": 1,
    "segundo": 2,
    "tercero": 3,
    "cuarto": 4,
    "quinto": 5,
    "sexto": 6,
    "septimo": 7,
    "octavo": 8,
    "noveno": 9,
    "decimo": 10
  }

  # create 4th, 5th, ... 20th
  for i in xrange(16):
    data_mapping[str(4+i) + "th"] = 4+i

  # create 21st, 22nd, ... 99th
  for i in xrange(79):
    last_char = str(i)[-1]

    if last_char == "0":
      data_mapping[str(20+i) + "th"] = 20+i

    elif last_char == "1":
      data_mapping[str(20+i) + "st"] = 20+i

    elif last_char == "2":
      data_mapping[str(20+i) + "nd"] = 20+i

    elif last_char == "3":
      data_mapping[str(20+i) + "rd"] = 20+i

    else:
      data_mapping[str(20+i) + "th"] = 20+i

  ordinals = [
    "first", "second", "third", 
    "fourth", "fifth", "sixth", 
    "seventh", "eighth", "ninth"
  ]

  # create first, second ... ninth
  for c, i in enumerate(ordinals):
    data_mapping[i] = c+1

  # create twenty-first, twenty-second ... ninty-ninth
  for ci, i in enumerate([
    "twenty", "thirty", "forty", 
    "fifty", "sixty", "seventy", 
    "eighty", "ninety"
  ]):
    for cj, j in enumerate(ordinals):
      data_mapping[i + "-" + j] = 20 + (ci*10) + (cj+1)
    data_mapping[i.replace("y", "ieth")] = 20 + (ci*10)

  return data_mapping 
```

* * *

## 回答 #11

> 赞同：-2
> 
> 时间：2009-03-17T14:00:02.540

一个开始寻找的地方是[gnu get_date lib](http://www.gnu.org/software/tar/manual/html_node/Date-input-formats.html)，它可以将[几乎任何](http://php-date.com/#strtotime)英文文本日期解析为时间戳。虽然不完全是您正在寻找的东西，但他们对类似问题的解决方案可以提供很多有用的线索。

* * *

## 回答 #12

> 赞同：-2
> 
> 时间：2009-03-19T19:42:52.483

尝试

1.  打开一个 HTTP 请求到“ [http://www.google.com/search?q=](http://www.google.com/search?q=) ” + number + “+in+decimal”。

2.  解析您的号码的结果。

3.  缓存数字/结果对以随着时间的推移对请求进行培训。

# html - 如何在 HTML 中突出显示源代码？

> ID：70169
> 
> 赞同：26
> 
> 时间：2008-09-16T07:48:51.563
> 
> 标签：html, syntax-highlighting

我想在我的网站中突出显示 C/C++/Java/C# 等源代码。

我怎样才能做到这一点？

突出显示源代码是一项 CPU 密集型工作吗？

* * *

## 回答 #1

> 赞同：27
> 
> 时间：2008-09-16T07:53:41.037

您可以在服务器端或客户端执行此操作。它不是非常密集的处理器，但如果你在客户端（使用 Javascript）这样做，将会有明显的延迟。大多数客户端解决方案都围绕着 Google Code 的语法高亮引擎。这似乎是最受欢迎的一个：[SyntaxHighlighter](http://alexgorbatchev.com/SyntaxHighlighter/)

服务器端解决方案往往更加灵活，尤其是在定义新语言和配置它们的突出显示方式（例如使用的颜色）方面。我使用 GeSHi，这是一个 PHP 解决方案，带有一个相当不错的 Wordpress 插件。还有一些为 Java 构建的库，甚至一些基于 VIM（通常需要从 CPAN 安装 Perl 模块）。

简而言之：您有很多选择，您的标准是什么？在不了解您的要求的情况下很难做出可靠的建议。

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2008-09-16T07:52:12.273

我在[pastebin.com上使用](http://pastebin.com)[GeSHi](http://qbnz.com/highlighter/)（“通用语法荧光笔”）

pastebin 的流量很大，所以我会缓存转换的结果，这肯定会减少负载。

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2009-10-24T16:04:33.900

就个人而言，我更喜欢离线工具：我看不到在每个浏览器（对于 JS 库）上一遍又一遍地解析代码（尤其是大代码）的意义，因为如上所述，这些库经常滞后（您经常会在格式化之前看到原始源代码）。

有许多工具可以完成这项工作，其中一些已在上面指出。我只是使用我最喜欢的编辑器 (SciTE) 的导出功能，因为它只尊重我精心设置的颜色选择... :-) 它也可以输出 XML、PDF、RTF 和 LaTeX。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-09-16T08:04:37.050

我使用[google-code-prettify](https://github.com/google/code-prettify)。它是最简单的设置并且适用于所有 C 风格的语言。

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2008-09-16T08:06:19.913

[Pygment](http://pygments.org/)是一个很好的 Python 库，用于生成 HTML、RTF、ANSI（终端样式）或 LaTeX 代码。它支持[多种语言](http://pygments.org/languages/)（C、C++、Lua、Erlang...），您甚至可以编写自己的输出格式化程序。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2012-02-21T17:58:02.607

如果您使用[jEdit](http://jedit.org/)，您可能想要使用[Code2HTML](http://plugins.jedit.org/plugins/?Code2HTML)插件。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T07:50:29.983

我在[我的博客](http://bradwilson.typepad.com)上使用[SyntaxHighligher](http://code.google.com/p/syntaxhighlighter/wiki/Usage)。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-16T07:50:53.727

只需通过以下工具运行它：[http ://www.gnu.org/software/src-highlite/](http://www.gnu.org/software/src-highlite/)

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T07:54:31.177

如果您使用的是 PHP，您可以使用[GeSHi](http://qbnz.com/highlighter/)来突出显示许多不同的语言。我以前用过，效果很好。快速谷歌搜索还将发现用于[wordpress](http://wordpress.org/extend/plugins/wp-syntax/)和[drupal](http://drupal.org/project/geshifilter)的 GeSHi 插件。

我不会认为突出显示是 CPU 密集型的，除非您打算一次显示所有兆字节。即使这样，CPU 负载也将是最小的，而您的主要问题将是传输速度。

# java - 在客户端-服务器应用程序中：如何将用户的应用程序密码发送到数据库？

> ID：70170
> 
> 赞同：2
> 
> 时间：2008-09-16T07:49:07.023
> 
> 标签：java, oracle, security, passwords

我有一个直接与数据库（Oracle）连接的 Java 桌面应用程序。该应用程序有多个用户帐户。通过网络发送用户密码（不是数据库密码）的正确方法是什么？我不想以纯文本形式发送它。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T07:51:02.540

您可以通过安全套接字连接进行连接，或者在将密码发送到数据库之前在本地对密码进行哈希处理（或者更好的是，两者都可以） - 理想情况下，密码应该以纯文本形式存在的唯一时间是在哈希处理之前。如果您可以在客户端完成所有这些操作，那就更好了。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-16T08:51:53.783

您可以在 Oracle 客户端和 Oracle 数据库之间使用 SSL 连接。要使用 JDBC 在 oracle 客户端和服务器之间配置 SSL：

在服务器端：

1）首先，监听器必须配置为使用TCPS协议：

```
LISTENER = (ADDRESS_LIST= (ADDRESS=(PROTOCOL=tcps)(HOST=servername)(PORT=2484)))

WALLET_LOCATION=(SOURCE=(METHOD=FILE)(METHOD_DATA=(DIRECTORY=/server/wallet/path/))) 
```

在客户端：

1）以下罐子需要是类 路径`ojdb14.jar`，，，`oraclepki.jar``ojpse.jar`

2) 用于连接的 URL 应为：

```
jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS=(PROTOCOL=tcps)(HOST=servername)(PORT=2484))(CONNECT_DATA=(SERVICE_NAME=servicename))) 
```

3）需要设置以下属性（作为系统属性（-D选项）或连接属性）

```
javax.net.ssl.trustStore, 
javax.net.ssl.trustStoreType, 
javax.net.ssl.trustStorePassword 
```

参考：[http ://www.oracle.com/technology/tech/java/sqlj_jdbc/pdf/wp-oracle-jdbc_thin_ssl_2007.pdf](http://www.oracle.com/technology/tech/java/sqlj_jdbc/pdf/wp-oracle-jdbc_thin_ssl_2007.pdf)

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-16T07:51:41.977

同意，永远不要以明文形式发送用户选择的密码。但是，如果不使用公钥加密，如果您通过电子邮件向他们发送密码，它将是明文形式。我经常看到的一件事是，当用户忘记密码并请求将其发送给他们时，系统会生成一个新密码并将其发送*给*用户。然后用户可以更改密码。

这样，用户选择的密码（用户可能在其他地方使用）永远不会发送，而他们的临时密码以明文形式发送，他们应该尽快更改它。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T07:50:39.937

如果您不想以纯文本形式发送数据，请使用加密！

使用一些加密算法，如 AES、Twofish 等。

您还必须考虑客户端和服务器的位置。如果它们都在同一台机器上，那么使用加密是没有用的。如果它们在不同的机器上，使用一些加密算法来发送敏感数据。

如果您正在检查密码的有效性，您可以发送密码的哈希值。请注意，此方法仅在您自己比较密码时才有效。如果其他应用程序（您无法控制）正在执行验证工作，则您无法对密码进行哈希处理。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T18:59:23.760

如果你直接连接到没有中间层的数据库，你应该考虑为每个真实用户使用一个数据库用户，因为否则你不能真正保护应用程序的访问。

如果您使用 ORa*Net 连接到 Oracle，则用户密码会自动加密（从 Oracle 8 开始），但在某些情况下它可能会退回到未加密的密码。这可以`ORA_ENCRYPT_LOGIN=true`在客户端环境中禁用。

# vb.net - Visual Basic 6.0 到 VB.NET 的声明

> ID：70197
> 
> 赞同：2
> 
> 时间：2008-09-16T07:52:36.017
> 
> 标签：vb.net, vb6, declaration, vb6-migration

如何在 VB.NET 中声明“任意”，或者什么是等价的？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-16T07:58:35.300

您可以获得的最接近的是：

`Dim var as Object`

它与 VB6 的 Any（将值存储在 Variant 中）并不完全相同，但您可以将任何类型的变量存储为 Object，尽管是装箱的。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T08:03:33.183

VB.NET 不支持 as any 关键字，VB.NET 是一种强类型语言，但是您可以（使用 .NET 3.5）在 VB 中使用隐式类型

Dim fred = "Hello World" 将隐式类型 fred 作为字符串变量。如果您只想保存一个在设计时不知道类型的值，那么您可以简单地将变量声明为对象（所有对象的母亲）注意，这通常是代码审查者的危险信号，因此请确保你有充分的理由准备好:-)

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-17T11:38:26.730

As Any 必须引用 Windows API 声明，因为它不能用于变量声明。您可以使用重载：只需为您希望传递的每种不同数据类型重复声明。VB.NET 挑选出与您在调用中传递的参数相匹配的那个。

这比 VB6 中的 As Any 要好，因为编译器仍然可以进行类型检查。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-16T12:40:43.827

我想您在转换 WinAPI 声明时遇到问题。有时，如果您将变量声明为字符串或整数，您就可以逃脱惩罚，因为这是返回值的真实类型。

您也可以尝试编组：

```
<MarshalAsAttribute(UnmanagedType.AsAny)> ByRef buff 作为对象

```

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T07:54:31.037

[VB.NET](http://en.wikipedia.org/wiki/Visual_Basic_.NET)不支持“As Any”关键字。您需要明确指定类型。

# java - META-INF 的目的是什么？

> ID：70216
> 
> 赞同：331
> 
> 时间：2008-09-16T07:55:20.720
> 
> 标签：java, meta-inf

在 Java 中，您经常会看到一个 META-INF 文件夹，其中包含一些元文件。这个文件夹的用途是什么，我可以放什么？

* * *

## 回答 #1

> 赞同：175
> 
> 时间：2008-09-16T07:57:14.757

来自[官方 JAR 文件规范](http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html)（链接到 Java 7 版本，但至少从 v1.3 开始文本没有改变）：

> ## META-INF 目录
> 
> META-INF 目录中的以下文件/目录被 Java 2 平台识别和解释，以配置应用程序、扩展、类加载器和服务：
> 
> *   `MANIFEST.MF`
> 
> 用于定义扩展和包相关数据的清单文件。
> 
> *   `INDEX.LIST`
> 
> 此文件由`-i`jar 工具的新“”选项生成，其中包含在应用程序或扩展中定义的包的位置信息。它是 JarIndex 实现的一部分，并被类加载器用来加速其类加载过程。
> 
> *   `x.SF`
> 
> JAR 文件的签名文件。“x”代表基本文件名。
> 
> *   `x.DSA`
> 
> 与具有相同基本文件名的签名文件关联的签名块文件。该文件存储了对应签名文件的数字签名。
> 
> *   `services/`
> 
> 该目录存储所有服务提供者配置文件。

自 Java 9 以来实现[JEP 238](https://openjdk.java.net/jeps/238)的新功能是多版本 JAR。将看到一个子文件夹`versions`。这是一项允许将用于不同 Java 版本的类打包到一个 jar 中的功能。

* * *

## 回答 #2

> 赞同：72
> 
> 时间：2008-09-16T08:05:30.120

一般来说，您不应该自己在 META-INF 中添加任何内容。相反，您应该依赖于您用来打包 JAR 的任何东西。这是我认为 Ant 真正擅长的领域之一：指定 JAR 文件清单属性。说这样的话很容易：

```
<jar ...>
    <manifest>
        <attribute name="Main-Class" value="MyApplication"/>
    </manifest>
</jar> 
```

至少，我认为这很容易...... :-)

关键是 META-INF 应该被认为是一个内部 Java*元*目录。不要惹它！您想要包含在 JAR 中的任何文件都应该放在其他一些子目录或 JAR 本身的根目录中。

* * *

## 回答 #3

> 赞同：28
> 
> 时间：2008-11-24T21:38:40.633

我注意到一些 Java 库已经开始使用 META-INF 作为目录，其中包含应该与 JAR 一起打包并包含在 CLASSPATH 中的配置文件。例如，Spring 允许您使用以下方法导入类路径上的 XML 文件：

```
<import resource="classpath:/META-INF/cxf/cxf.xml" />
<import resource="classpath:/META-INF/cxf/cxf-extensions-*.xml" /> 
```

在这个例子中，我直接引用了[Apache CXF 用户指南](http://docs.huihoo.com/apache/cxf/2.0/configuration.html)。在我从事的一个项目中，我们必须允许通过 Spring 进行多级配置，我们遵循这个约定并将我们的配置文件放在 META-INF 中。

当我反思这个决定时，我不知道将配置文件简单地包含在特定的 Java 包中而不是 META-INF 中究竟有什么问题。但它似乎是一个新兴的事实上的标准。无论是那个，还是一个新兴的反模式:-)

* * *

## 回答 #4

> 赞同：15
> 
> 时间：2008-09-16T08:00:55.933

META-INF 文件夹是[MANIFEST.MF](http://java.sun.com/developer/Books/javaprogramming/JAR/basics/manifest.html)文件的主目录。此文件包含有关 JAR 内容的元数据。例如，有一个名为 Main-Class 的条目，它使用可执行 JAR 文件的静态 main() 指定 Java 类的名称。

* * *

## 回答 #5

> 赞同：13
> 
> 时间：2015-01-12T15:48:14.720

## Maven 中的 META-INF

在 Maven 中，可以理解**META-INF**文件夹是因为[Standard Directory Layout](http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html)，它按照名称约定将您的项目资源打包到 JAR 中：放置在*${basedir}/src/main/resources*目录中的任何目录或文件都打包到您的 JAR 中从 JAR 的底部开始具有完全相同的结构。

文件夹*${basedir}/src/main/resources/META-INF*通常包含*.properties*文件，而 jar 中包含生成的**MANIFEST.MF**、**pom.properties**、 **pom.xml**等文件。[像Spring](https://spring.io/blog/2013/12/19/serving-static-web-content-with-spring-boot)这样的框架也用于`classpath:/META-INF/resources/`提供 Web 资源。

有关更多信息，请参阅[如何将资源添加到我的 Maven 项目](http://maven.apache.org/guides/getting-started/#How_do_I_add_resources_to_my_JAR)。

* * *

## 回答 #6

> 赞同：12
> 
> 时间：2013-01-15T14:50:03.123

您也可以在其中放置静态资源。

例如：

```
META-INF/resources/button.jpg 
```

并通过 web3.0-container 获取它们

```
http://localhost/myapp/button.jpg 
```

[> 阅读更多](https://web.archive.org/web/20150918224750/https://blogs.oracle.com/alexismp/entry/web_inf_lib_jar_meta)

/META-INF/MANIFEST.MF 具有特殊含义：

1.  如果您使用 jar 运行，`java -jar myjar.jar org.myserver.MyMainClass`您可以将主类定义移动到 jar 中，这样您就可以将调用缩小到`java -jar myjar.jar`.
2.  如果您使用`java.lang.Package.getPackage("org.myserver").getImplementationTitle()`.
3.  您可以参考您喜欢在 Applet/Webstart 模式下使用的数字证书。

* * *

## 回答 #7

> 赞同：7
> 
> 时间：2016-04-22T18:21:31.420

在此处添加信息，META-INF 是一个特殊文件夹，其`ClassLoader`处理方式与 jar 中的其他文件夹不同。嵌套在 META-INF 文件夹中的元素不会与它之外的元素混合。

把它想象成另一个根。从`Enumerator<URL> ClassLoader#getSystemResources(String path)`方法等角度来看：

*当给定路径以“META-INF”开头时，该方法搜索嵌套在类路径中所有 jar 的 META-INF 文件夹内的资源。*

当给定路径不以“META-INF”开头时，该方法在类路径中所有 jar 和目录的所有其他文件夹（META-INF 之外）中搜索资源。

如果您知道该`getSystemResources`方法特别对待的另一个文件夹名称，请评论它。

* * *

## 回答 #8

> 赞同：5
> 
> 时间：2009-10-21T15:21:18.890

只是补充一下这里的信息，如果是 WAR 文件，META-INF/MANIFEST.MF 文件为开发人员提供了一个工具来启动容器的部署时间检查，以确保容器可以找到您的应用程序的所有类取决于。这确保了万一您错过了一个 JAR，您不必等到您的应用程序在运行时崩溃才意识到它丢失了。

* * *

## 回答 #9

> 赞同：5
> 
> 时间：2011-10-11T03:45:10.437

我最近一直在思考这个问题。似乎对 META-INF 的使用没有任何限制。当然，关于将清单放在那里的必要性有一定的限制，但似乎没有任何禁止将其他东西放在那里。

为什么会这样？

cxf 案可能是合法的。这是另一个建议使用此非标准来解决 JBoss-ws 中的一个讨厌的错误的地方，该错误会阻止服务器端对 wsdl 的模式进行验证。

[http://community.jboss.org/message/570377#570377](http://community.jboss.org/message/570377#570377)

但似乎真的没有任何标准，任何你不应该。通常这些东西是非常严格的定义，但由于某种原因，这里似乎没有标准。奇怪的。似乎 META-INF 已成为任何无法以其他方式轻松处理的所需配置的包罗万象的地方。

* * *

## 回答 #10

> 赞同：3
> 
> 时间：2009-10-22T20:42:29.727

如果您使用的是 JPA1，则可能必须`persistence.xml`在其中放置一个文件，该文件指定您可能要使用的持久性单元的名称。持久性单元提供了一种方便的方法来指定一组元数据文件、类和包含要在一个分组中持久化的所有类的 jar。

```
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

// ...

EntityManagerFactory emf =
      Persistence.createEntityManagerFactory(persistenceUnitName); 
```

在此处查看更多信息： [http ://www.datanucleus.org/products/datanucleus/jpa/emf.html](http://www.datanucleus.org/products/datanucleus/jpa/emf.html)

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2015-01-13T15:04:35.507

所有答案都是正确的。Meta-inf 有很多用途。另外，这里是一个关于使用tomcat容器的例子。

转到 [Tomcat Doc](http://tomcat.apache.org/tomcat-7.0-doc/config/context.html)并检查“**标准实现 > copyXML** ”属性。

说明如下。

> 如果您希望在部署应用程序时将嵌入在应用程序中的上下文 XML 描述符（位于 /META-INF/context.xml）复制到拥有主机的 xmlBase，则设置为 true。在随后的启动中，复制的上下文 XML 描述符将优先于嵌入在应用程序中的任何上下文 XML 描述符使用，即使嵌入在应用程序中的描述符是更新的。该标志的值默认为 false。注意如果拥有 Host 的 deployXML 属性为 false 或拥有 Host 的 copyXML 属性为 true，则该属性将不起作用。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2015-11-10T21:45:58.057

您的 META-INF 文件夹中有 MANIFEST.MF 文件。您可以定义必须有权访问的**可选或外部依赖项。**

**例子：**

考虑您已经部署了您的应用程序并且您的容器（在运行时）发现您的应用程序需要一个不在 lib 文件夹内的库的较新版本，在这种情况下，如果您在其中定义了可选的较新版本，`MANIFEST.MF`那么您的应用程序将引用从那里依赖（并且不会崩溃）。

`Source:`Head First Jsp & Servlet

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2021-12-18T23:38:17.093

此外，META-INF 文件夹现在也用于[多版本 jars](https://openjdk.java.net/jeps/238)。这是一个允许将用于不同 Java 版本的类打包在一个 jar 中的功能，例如，在一个 jar 中包含一个用于 Java 11 的类，该类具有 Java 11 提供的新功能，也适用于 Java 8，其中 Java 8 的不同类包含的功能较少。例如，如果较新的 Java 版本提供了增强的、不同的或新的 API 方法，这些方法由于 API 违规而在早期版本中不起作用。然后会看到一个子文件夹`versions`。

# multithreading - actionscript 中的多线程还是绿色线程？

> ID：70232
> 
> 赞同：3
> 
> 时间：2008-09-16T08:00:20.443
> 
> 标签：multithreading, actionscript

我想知道是否有关于如何在 ActionScript 中实现多线程或“绿色线程”的代码或类库。

正如您可能已经看到的，Scott Peterson 正在开发某种工具集，但除了他在 Adob​​e MAX Chicago 活动中的表现之外，我没有找到更多关于此的信息。

问候尼古拉斯

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2009-01-12T01:42:01.330

这是 Drew Cummins 的绿色线程库：

[http://blog.generalrelativity.org/?p=29](http://blog.generalrelativity.org/?p=29)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2009-04-30T01:25:29.590

[It's an old article](http://www.quasimondo.com/archives/000071.php), but [quasimondo](http://www.quasimondo.com/ "quasimondo")'s method of launching multiple swfs and then sharing the data over a LocalConnection may also be of interest. They were saying that the back and forth of using the LocalConnection may eat up a few cycles, but if the iterations being processed are complex enough it shouldn't be too much of a problem.

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T08:23:47.360

在 ActionScript 中没有内置的方式来执行绿色线程。您必须编写代码来处理它。

制作一个函数，对您想要执行的任何操作执行一次迭代。它应该返回 true 或 false 取决于它的工作是否完成。现在，您必须计算 ENTER_FRAME 事件下一次屏幕更新的时间间隔。这可以使用 flash.utils.getTimer 来完成。

```
start = getTimer();
//thread is a ui component added to system manager that is redrawn each frame
var fr:Number = Math.floor(1000 / thread.systemManager.stage.frameRate);
due = start + fr; 
```

继续执行你的函数，同时每次检查函数的返回值，并通过比较 getTimer() 和到期时间来检查是否超过了到期时间。

这已由 Alex Harui 在博客条目 - [ActionScript 中的线程中实现为一个可用的类](http://blogs.adobe.com/aharui/2008/01/threads_in_actionscript_3.html "ActionScript 中的线程")

* * *

## 回答 #4

> 赞同：-3
> 
> 时间：2008-09-16T23:49:40.740

我是图形专家，而不是程序员，所以我不确定这会对您有所帮助。但！

我制作了我所有的 GUI 多帧“电影”，并将每个 gui 线程写在不同的帧上。确保您只有 1-3 个线程，并将 FPS 设置为 30 或 60。

这对于小型项目很有用，因为它的错误抗性和实现是为您完成的。

# gdb - 为 armv6 编译 gdb

> ID：70258
> 
> 赞同：2
> 
> 时间：2008-09-16T08:06:21.583
> 
> 标签：gdb

我正在尝试为 armv6 架构构建 gdb。我将在 Fedora Linux-Intel x86 机器上编译这个包。我阅读了安装 gdb 的过程，例如

1.  下载源包

2.  跑`configure -host`

3.  `make`

但我在这个过程中迷失了方向，因为我无法确定`configure`脚本所需的主机、目标。

我需要基本上能够调试在运行 linux 内核 2.6.21.5-cfs-v19 的 armv6 架构板上运行的程序。我打算在编译源代码后获得的 gdb 可执行文件也需要能够在上述配置上运行。

现在要为这个配置获得一个有效的 gdb 可执行文件，我应该遵循哪些步骤？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T08:33:01.037

我们 (www.rockbox.org) 将 arm 目标用于我们当前工作的一整批 DAPS。我们指定的目标通常是 arm-elf，而不是 arm-linux。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2012-02-08T17:17:33.747

小心`arm-linux`vs. `arm-elf`，例如。

*   [http://sources.redhat.com/ml/crossgcc/2005-11/msg00028.html](http://sources.redhat.com/ml/crossgcc/2005-11/msg00028.html)

    > arm-elf 是一个独立的工具链，不需要底层操作系统。所以你可以用它来使用newlib生成程序
    > 
    > arm-linux 是一个工具链，旨在为在 ARM 机器上运行的 linux 操作系统生成代码

我们有时说`arm-elf`的是“裸机”。不幸的是，还有另一个“裸机”目标`arm-eabi`，没有人知道这两者之间到底有什么区别。

顺便提一句，

> 我打算在编译源代码后获得的 gdb 可执行文件也需要能够在上述配置上运行。

真的吗？在 ARM 板上运行 GDB 可能会很慢。我推荐你

1.  从 x86 PC 远程调试 ARM 板
2.  在 ARM 板上保存一个内存核心，将其传输到 x86 PC，然后在那里进行检查

参照。

*   [http://elinux.org/GDB](http://elinux.org/GDB)
*   [跨平台、多线程调试（x86 到 ARM），gdb 和 gdbserver 无法识别线程](http://old.nabble.com/Cross-platform,-multithreaded-debugging-%28x86-to-ARM%29-with-gdb-and-gdbserver-not-recognizing-threads-td26820064.html)
*   [http://www.chromium.org/chromium-os/how-tos-and-troubleshooting/remote-debugging](http://www.chromium.org/chromium-os/how-tos-and-troubleshooting/remote-debugging)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T08:12:46.357

target/host 通常是您将使用的目标工具链（主要是 arm-linux）

# silverlight - Silverlight 2 拖放教程

> ID：70269
> 
> 赞同：5
> 
> 时间：2008-09-16T08:10:04.070
> 
> 标签：silverlight

我想知道人们是否可以建议最好的教程，它将引导我使用 MS Silverlight V2 进行拖放控制碰撞检测等的最佳方法。

我在 Silverlight.net 上完成了[Jesse Liberty 教程](http://silverlight.net/learn/tutorials.aspx)，它们是一个很好的介绍，但我正在寻找更深入的东西。

建议？

更新：为方便起见，这是答案列表的摘要：

1.  [http://www.adefwebserver.com/DotNetNukeHELP/Misc/Silverlight/DragAndDropTest/](http://www.adefwebserver.com/DotNetNukeHELP/Misc/Silverlight/DragAndDropTest/)
2.  [李家一角](http://leeontech.wordpress.com/2008/04/11/drag-and-drop-in-silverlight/)
3.  [科里·舒曼](http://simplesilverlight.wordpress.com/2008/08/13/drag-and-drop-silverlight-example/)
4.  [马丁·格雷森：“开发者”的冒险](http://blogs.msdn.com/mgrayson/archive/2008/08/18/silverlight-2-samples-dragging-docking-expanding-panels-part-2.aspx)
5.  [http://www.codeplex.com/silverlightdragdrop](http://www.codeplex.com/silverlightdragdrop)
6.  [Nick Polyak 的软件博客](http://nickssoftwareblog.com/2008/10/07/silverlight-20-in-examples-part-drag-and-drop-inside-out/)

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-16T10:12:42.187

这是一个解释我使用的解决方案的页面。

[Silverlight 2 拖放和导入内容示例](http://www.adefwebserver.com/DotNetNukeHELP/Misc/Silverlight/DragAndDropTest/)

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T13:17:45.050

以下是另外三个包含示例和代码的页面：

[http://leeontech.wordpress.com/2008/04/11/drag-and-drop-in-silverlight/](http://leeontech.wordpress.com/2008/04/11/drag-and-drop-in-silverlight/)

[http://simplesilverlight.wordpress.com/2008/08/13/drag-and-drop-silverlight-example/](http://simplesilverlight.wordpress.com/2008/08/13/drag-and-drop-silverlight-example/)

[http://blogs.msdn.com/mgrayson/archive/2008/08/18/silverlight-2-samples-dragging-docking-expanding-panels-part-2.aspx](http://blogs.msdn.com/mgrayson/archive/2008/08/18/silverlight-2-samples-dragging-docking-expanding-panels-part-2.aspx)

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2009-03-04T19:51:30.013

一个用于拖放的 codeplex 项目[http://www.codeplex.com/silverlightdragdrop](http://www.codeplex.com/silverlightdragdrop)

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2009-05-06T14:06:45.620

以下教程很有帮助，作者已发布代码，包括一个拖放控件，您可以下载： http: [//nickssoftwareblog.com/2008/10/07/silverlight-20-in-examples-part-drag-and -从里到外/](http://nickssoftwareblog.com/2008/10/07/silverlight-20-in-examples-part-drag-and-drop-inside-out/)

我目前在一个新的 Silverlight 应用程序中使用这个控件。

# c# - 启动时隐藏单一表单

> ID：70272
> 
> 赞同：77
> 
> 时间：2008-09-16T08:10:53.773
> 
> 标签：c#, vb.net, winforms

我有一个包含一个表单的应用程序，在 Load 方法上我需要隐藏表单。

表单会在需要时自行显示（按照 Outlook 2003 样式弹出窗口的思路思考），但我无法弄清楚如何在加载时隐藏表单而不会造成混乱。

有什么建议么？

* * *

## 回答 #1

> 赞同：113
> 
> 时间：2008-09-16T08:16:36.100

我来自 C#，但在 vb.net 中应该非常相似。

在您的主程序文件中，在 Main 方法中，您将拥有如下内容：

```
Application.Run(new MainForm()); 
```

这会创建一个新的主窗体并将应用程序的生命周期限制为主窗体的生命周期。

但是，如果您删除 Application.Run() 的参数，则应用程序将在不显示任何表单的情况下启动，您可以随意显示和隐藏表单。

与其在 Load 方法中隐藏表单，不如在调用 Application.Run() 之前初始化表单。我假设表单上会有一个 NotifyIcon 以在任务栏中显示一个图标 - 即使表单本身尚不可见，也可以显示该图标。调用`Form.Show()`或`Form.Hide()`从 NotifyIcon 事件的处理程序将分别显示和隐藏表单。

* * *

## 回答 #2

> 赞同：108
> 
> 时间：2010-11-17T22:56:59.813

通常，您只会在稍后使用托盘图标或其他方法显示表单时这样做，但即使您从不显示主表单，它也会很好地工作。

在您的 Form 类中创建一个默认为 false 的 bool：

```
private bool allowshowdisplay = false; 
```

然后重写 SetVisibleCore 方法

```
protected override void SetVisibleCore(bool value)
{            
    base.SetVisibleCore(allowshowdisplay ? value : allowshowdisplay);
} 
```

因为 Application.Run() 在加载表单后设置表单 .Visible = true ，这将拦截该表单并将其设置为 false。在上述情况下，它将始终将其设置为 false，直到您通过将 allowhowdisplay 设置为 true 来启用它。

现在这将使表单在启动时不显示，现在您需要通过设置 allowhowdisplay = true 重新启用 SetVisibleCore 以正常运行。您将希望在显示表单的任何用户界面功能上执行此操作。在我的示例中，它是我的 notiyicon 对象中的左键单击事件：

```
private void notifyIcon1_MouseClick(object sender, MouseEventArgs e)
{
    if (e.Button == System.Windows.Forms.MouseButtons.Left)
    {
        this.allowshowdisplay = true;
        this.Visible = !this.Visible;                
    }
} 
```

* * *

## 回答 #3

> 赞同：36
> 
> 时间：2008-10-09T20:20:46.707

我用这个：

```
private void MainForm_Load(object sender, EventArgs e)
{
    if (Settings.Instance.HideAtStartup)
    {
        BeginInvoke(new MethodInvoker(delegate
        {
            Hide();
        }));
    }
} 
```

显然，您必须用您的条件更改 if 条件。

* * *

## 回答 #4

> 赞同：21
> 
> 时间：2012-08-06T16:02:10.397

```
 protected override void OnLoad(EventArgs e)
    {
        Visible = false; // Hide form window.
        ShowInTaskbar = false; // Remove from taskbar.
        Opacity = 0;

        base.OnLoad(e);
    } 
```

* * *

## 回答 #5

> 赞同：15
> 
> 时间：2011-03-17T16:47:57.170

在表单构建时（设计器、程序 Main 或表单构造器，取决于您的目标），

```
 this.WindowState = FormWindowState.Minimized;
 this.ShowInTaskbar = false; 
```

当您需要显示表单时，大概是您的 NotifyIcon 事件，必要时反转，

```
 if (!this.ShowInTaskbar)
    this.ShowInTaskbar = true;

 if (this.WindowState == FormWindowState.Minimized)
    this.WindowState = FormWindowState.Normal; 
```

连续的显示/隐藏事件可以更简单地使用表单的可见属性或显示/隐藏方法。

* * *

## 回答 #6

> 赞同：6
> 
> 时间：2016-10-28T05:10:55.580

尝试从任务栏中隐藏应用程序。

为此，请使用此代码。

```
 protected override void OnLoad(EventArgs e)
  {
   Visible = false; // Hide form window.
   ShowInTaskbar = false; // Remove from taskbar.
   Opacity = 0;

   base.OnLoad(e);
   } 
```

谢谢。鲁胡尔

* * *

## 回答 #7

> 赞同：5
> 
> 时间：2008-12-31T19:45:14.367

用这个扩展你的主要形式：

```
using System.Windows.Forms;

namespace HideWindows
{
    public class HideForm : Form
    {
        public HideForm()
        {
            Opacity = 0;
            ShowInTaskbar = false;
        }

        public new void Show()
        {
            Opacity = 100;
            ShowInTaskbar = true;

            Show(this);
        }
    }
} 
```

例如：

```
namespace HideWindows
{
    public partial class Form1 : HideForm
    {
        public Form1()
        {
            InitializeComponent();
        }
    }
} 
```

本文中的更多信息（西班牙语）：

[http://codelogik.net/2008/12/30/primer-form-oculto/](http://codelogik.net/2008/12/30/primer-form-oculto/)

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2012-12-09T07:56:24.873

我一直在努力解决这个问题，但解决方案比我简单得多。我首先在这里尝试了所有建议，但后来我对结果不满意并对其进行了更多调查。我发现如果我添加：

```
 this.visible=false;
 /* to the InitializeComponent() code just before the */
 this.Load += new System.EventHandler(this.DebugOnOff_Load); 
```

它工作得很好。但我想要一个更简单的解决方案，事实证明，如果你添加：

```
this.visible=false;
/* to the start of the load event, you get a
simple perfect working solution :) */ 
private void
DebugOnOff_Load(object sender, EventArgs e)
{
this.Visible = false;
} 
```

* * *

## 回答 #9

> 赞同：3
> 
> 时间：2016-03-15T11:56:49.967

您将希望将窗口状态设置为最小化，并在任务栏中显示为 false。然后在表单的末尾加载设置窗口状态以最大化并在任务栏中显示为true

```
 public frmMain()
    {
        Program.MainForm = this;
        InitializeComponent();

        this.WindowState = FormWindowState.Minimized;
        this.ShowInTaskbar = false;
    }

private void frmMain_Load(object sender, EventArgs e)
    {
        //Do heavy things here

        //At the end do this
        this.WindowState = FormWindowState.Maximized;
        this.ShowInTaskbar = true;
    } 
```

* * *

## 回答 #10

> 赞同：3
> 
> 时间：2018-10-11T15:05:42.703

把它放在你的 Program.cs 中：

```
FormName FormName = new FormName ();

FormName.ShowInTaskbar = false;
FormName.Opacity = 0;
FormName.Show();
FormName.Hide(); 
```

当你想显示表单时使用它：

```
var principalForm = Application.OpenForms.OfType<FormName>().Single();
principalForm.ShowInTaskbar = true;
principalForm.Opacity = 100;
principalForm.Show(); 
```

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2017-03-03T07:45:48.117

这对我来说非常有效：

```
[STAThread]
    static void Main()
    {
        try
        {
            frmBase frm = new frmBase();               
            Application.Run();
        } 
```

当我启动项目时，一切都被隐藏了，包括在任务栏中，除非我需要显示它..

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2017-06-06T07:59:05.260

覆盖表单中的 OnVisibleChanged

```
protected override void OnVisibleChanged(EventArgs e)
{
    this.Visible = false;

    base.OnVisibleChanged(e);
} 
```

如果您可能需要在某些时候显示它，您可以添加触发器

```
public partial class MainForm : Form
{
public bool hideForm = true;
...
public MainForm (bool hideForm)
    {
        this.hideForm = hideForm;
        InitializeComponent();
    }
...
protected override void OnVisibleChanged(EventArgs e)
    {
        if (this.hideForm)
            this.Visible = false;

        base.OnVisibleChanged(e);
    }
...
} 
```

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-16T08:50:04.053

在没有表单的情况下启动应用程序意味着您将不得不自己管理应用程序的启动/关闭。

从不可见的形式开始是一个更好的选择。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-12-29T16:30:14.933

此示例支持完全不可见以及仅系统托盘中的 NotifyIcon 和无点击等等。

更多信息：http: [//code.msdn.microsoft.com/TheNotifyIconExample](http://code.msdn.microsoft.com/TheNotifyIconExample)

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2010-03-15T12:56:51.760

```
static void Main()
{
    Application.EnableVisualStyles();
    Application.SetCompatibleTextRenderingDefault(false);
    MainUIForm mainUiForm = new MainUIForm();
    mainUiForm.Visible = false;
    Application.Run();
} 
```

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2011-04-01T17:31:30.910

作为对[Groky 响应](https://stackoverflow.com/questions/70272/single-form-hide-on-startup/70296#70296)的补充（在我看来，这实际上是迄今为止最好的响应），我们还可以提到[ApplicationContext](http://msdn.microsoft.com/en-us/library/system.windows.forms.applicationcontext.aspx?appId=Dev10IDEF1&l=EN-US&k=k%28%22SYSTEM.WINDOWS.FORMS.APPLICATIONCONTEXT.#CTOR%22%29;k%28APPLICATIONCONTEXT%29;k%28SOLUTIONITEMSPROJECT%29;k%28TargetFrameworkMoniker-%22.NETFRAMEWORK&k=VERSION=V4.0%22%29;k%28DevLang-CSHARP%29&rd=true)类，它还允许（如文章示例中所示）打开两个（甚至更多）表单的能力在应用程序启动时，并与所有这些控制应用程序的生命周期。

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2019-03-18T23:45:51.110

我遇到了一个类似于海报的问题，其中在表单完全加载完成之前触发了在 form_Load 事件中隐藏表单的代码，导致 Hide() 方法失败（没有崩溃，只是没有按预期工作）。

其他答案很好而且很有效，但我发现一般来说，form_Load 事件经常有这样的问题，你想放在那里的东西可以很容易地进入构造函数或 form_Shown 事件。

无论如何，当我移动检查某些内容的相同代码然后在不需要时隐藏表单（单点登录失败时的登录表单）时，它按预期工作。

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2019-06-21T06:49:01.183

```
 static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Form1 form1 = new Form1();
            form1.Visible = false;
            Application.Run();

        }
 private void ExitToolStripMenuItem_Click(object sender, EventArgs e)
        {
            this.Close();
            Application.Exit();
        } 
```

* * *

## 回答 #19

> 赞同：-1
> 
> 时间：2008-09-16T08:13:51.737

这是一个简单的方法：
它在 C# 中（我目前没有 VB 编译器）

```
public Form1()
{
    InitializeComponent();
    Hide(); // Also Visible = false can be used
}

private void Form1_Load(object sender, EventArgs e)
{
    Thread.Sleep(10000);
    Show(); // Or visible = true;
} 
```

* * *

## 回答 #20

> 赞同：-2
> 
> 时间：2008-09-16T08:13:57.370

在设计器中，将表单的 Visible 属性设置为 false。然后避免调用 Show() 直到你需要它。

一个更好的范例是在您需要之前不要创建表单的实例。

* * *

## 回答 #21

> 赞同：-2
> 
> 时间：2009-07-23T17:40:39.420

根据各种建议，我所要做的就是：

要隐藏表单：

```
Me.Opacity = 0
Me.ShowInTaskbar = false 
```

要显示表格：

```
Me.Opacity = 100
Me.ShowInTaskbar = true 
```

* * *

## 回答 #22

> 赞同：-3
> 
> 时间：2008-12-29T20:06:05.620

为什么会这样呢？

为什么不像控制台应用程序一样开始并在必要时显示表单？除了一些将控制台应用程序与表单应用程序分开的参考资料外，什么都没有。

当您甚至可能不需要表格时，无需贪婪并占用表格所需的内存。

* * *

## 回答 #23

> 赞同：-3
> 
> 时间：2013-06-27T11:51:06.487

我这样做 - 从我的角度来看最简单的方法：

将表单的“StartPosition”设置为“Manual”，并将其添加到表单的设计器中：

```
Private Sub InitializeComponent()
.
.
.
Me.Location=New Point(-2000,-2000)
.
.
.
End Sub 
```

确保该位置设置为超出或低于屏幕尺寸。稍后，当您想要显示表单时，将位置设置为屏幕尺寸内的某个值。

# c# - 什么时候应该使用标准的 html 标签/输入，什么时候应该使用 asp.net 控件？

> ID：70292
> 
> 赞同：2
> 
> 时间：2008-09-16T08:15:45.010
> 
> 标签：c#, asp.net, html, visual-studio, webforms

当我将每个 asp.net 页面放在一起时，很明显，大多数时候我可以像使用 Web 表单控件一样轻松地使用标准 HTML 标记。在这种情况下，Webforms 控件的诱惑是什么？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T08:55:52.200

HTML 控件的输出速度将比服务器控件快得多，因为服务器部分不需要任何内容​​。它只是从字面上复制 ASPX 页面中的标记。

然而，服务器控件需要实例化。解析回发数据等，这显然是服务器的工作所在。

一般的经验法则是：

**如果它是静态的（即您不需要编程支持），请将其设为 HTML 控件。HTML 控件可以很容易地“升级”为服务器控件，因此以后不存在*真正*的维护问题。**

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T08:25:08.573

Webform 控件具有更多的服务器端预建功能（服务器端挂钩、方法和属性），我倾向于仅在需要高度格式化（样式）时才使用 HTML 控件，因为它绕过了 .Net 呈现它的控件的方式（有时，这可能很奇怪）。

# c# - 当两个字符串可以互换时，如何为具有两个字符串的结构实现 GetHashCode

> ID：70303
> 
> 赞同：71
> 
> 时间：2008-09-16T08:17:43.553
> 
> 标签：c#, hashtable

我在 C# 中有一个结构：

```
public struct UserInfo
{
   public string str1
   {
     get;
     set;
   }

   public string str2
   {
     get;
     set;
   }   
} 
```

唯一的规则是 `UserInfo(str1="AA", str2="BB").Equals(UserInfo(str1="BB", str2="AA"))`

如何覆盖此结构的 GetHashCode 函数？

* * *

## 回答 #1

> 赞同：70
> 
> 时间：2008-09-16T08:32:00.213

[MSDN](http://msdn.microsoft.com/en-us/library/system.object.gethashcode.aspx)：

哈希函数必须具有以下属性：

> *   如果两个对象比较相等，则`GetHashCode`每个对象的方法必须返回相同的值。但是，如果两个对象比较不相等，则`GetHashCode`两个对象的方法不必返回不同的值。
> *   `GetHashCode`只要确定对象方法的返回值的对象状态没有修改，对象的方法就必须始终返回相同的哈希码`Equals`。请注意，这仅适用于应用程序的当前执行，并且如果再次运行应用程序，则可以返回不同的哈希码。
> *   为了获得最佳性能，散列函数必须为所有输入生成随机分布。

考虑到正确的方法是：

```
return str1.GetHashCode() ^ str2.GetHashCode() 
```

`^`可以用其他交换操作代替

* * *

## 回答 #2

> 赞同：27
> 
> 时间：2009-06-22T15:16:58.030

请参阅[Jon Skeet 的回答](https://stackoverflow.com/questions/263400/what-is-the-best-algorithm-for-an-overridden-system-object-gethashcode)- 像这样的二进制操作`^`并不好，它们经常会产生碰撞哈希！

* * *

## 回答 #3

> 赞同：16
> 
> 时间：2008-09-16T09:33:42.483

```
public override int GetHashCode()
{
    unchecked
    {
        return (str1 ?? String.Empty).GetHashCode() +
            (str2 ?? String.Empty).GetHashCode();
    }
} 
```

使用 '+' 运算符可能比使用 '^' 更好，因为尽管您明确希望 ('AA', 'BB') 和 ('BB', 'AA') 明确相同，但您可能不希望 ( 'AA', 'AA') 和 ('BB', 'BB') 相同（或所有相等的对）。

此解决方案并未完全遵守“尽可能快”规则，因为在空字符串的情况下，它会在空字符串上执行“GetHashCode()”，而不是立即返回已知常量，但即使没有明确测量，我也愿意冒险猜测差异不会大到足以担心，除非您期望有很多空值。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-09-16T17:29:15.647

1.  作为一般规则，为类生成哈希码的一种简单方法是异或所有可以参与生成哈希码的数据字段（小心检查其他人指出的空值）。这也满足了 UserInfo("AA", "BB") 和 UserInfo("BB", "AA") 的哈希码相同的（人为？）要求。

2.  如果你可以对你的类的使用做出假设，你也许可以改进你的散列函数。例如，如果 str1 和 str2 通常相同，则 XOR 可能不是一个好的选择。但是，如果 str1 和 str2 代表名字和姓氏，XOR 可能是一个不错的选择。

虽然这显然不是一个真实世界的例子，但可能值得指出的是： - 这可能是使用结构的一个糟糕的例子：一个结构通常应该具有值语义，这似乎不是这里的情况。- 使用带有 setter 的属性来生成哈希码也是自找麻烦。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2014-02-06T13:21:00.227

按照 ReSharper 的建议：

```
public int GetHashCode()
{
    unchecked
    {
        int hashCode;

        // String properties
        hashCode = (hashCode * 397) ^ (str1!= null ? str1.GetHashCode() : 0);
        hashCode = (hashCode * 397) ^ (str2!= null ? str1.GetHashCode() : 0);

        // int properties
        hashCode = (hashCode * 397) ^ intProperty;
        return hashCode;
    }
} 
```

397 是一个足以导致结果变量溢出并在一定程度上混合散列位的素数，从而提供更好的散列码分布。否则 397 没有什么特别之处可以将它与其他相同大小的素数区分开来。

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2014-05-08T14:44:37.003

一个简单的*通用*方法是这样做：

```
return string.Format("{0}/{1}", str1, str2).GetHashCode(); 
```

除非您有严格的性能要求，否则这是我能想到的最简单的方法，并且当我需要复合键时，我经常使用此方法。它可以很好地处理这些`null`情况，并且不会导致（m）任何哈希冲突（通常）。如果您希望字符串中有“/”，只需选择另一个您不希望的分隔符。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-16T09:12:44.467

```
public override int GetHashCode()   
{       
    unchecked      
    {           
        return(str1 != null ? str1.GetHashCode() : 0) ^ (str2 != null ? str2.GetHashCode() : 0);       
    }   
} 
```

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-16T08:33:56.230

啊，是的，正如 Gary Shutler 指出的那样：

```
return str1.GetHashCode() + str2.GetHashCode(); 
```

可以溢出。您可以尝试按照 Artem 的建议强制转换为 long，或者您可以将语句括在 unchecked 关键字中：

```
return unchecked(str1.GetHashCode() + str2.GetHashCode()); 
```

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-16T08:23:56.613

试试这个：

```
(((long)str1.GetHashCode()) + ((long)str2.GetHashCode())).GetHashCode() 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T08:22:27.893

很多可能性。例如

`return str1.GetHashCode() ^ str1.GetHashCode()`

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-16T08:22:49.423

也许类似于 str1.GetHashCode() + str2.GetHashCode()？或 (str1.GetHashCode() + str2.GetHashCode()) / 2？这样，无论 str1 和 str2 是否交换，它都是一样的......

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-09-16T08:27:14.170

对它们进行排序，然后将它们连接起来：

```
返回 ((str1.CompareTo(str2) < 1) ? str1 + str2 : str2 + str1)
    .GetHashCode();

```

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-16T08:31:56.267

GetHashCode 的结果应该是：

1.  尽可能快。
2.  尽可能独特。

考虑到这些，我会选择这样的东西：

```
if (str1 == null)
    if (str2 == null)
        return 0;
    else
       return str2.GetHashCode();
else
    if (str2 == null)
        return str1.GetHashCode();
    else
       return ((ulong)str1.GetHashCode() | ((ulong)str2.GetHashCode() << 32)).GetHashCode(); 
```

**编辑：**忘记空值。代码已修复。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2021-05-10T11:48:17.053

从 C# 7 开始，我们可以利用 ValueTuple：

```
return (str1, str2).GetHashCode(); 
```

* * *

## 回答 #15

> 赞同：-1
> 
> 时间：2008-09-16T08:56:48.157

太复杂了，忘记了空值等。这用于分桶之类的事情，所以你可以摆脱类似的事情

```
if (null != str1) {
    return str1.GetHashCode();
}
if (null != str2) {
    return str2.GetHashCode();
}
//Not sure what you would put here, some constant value will do
return 0; 
```

假设 str1 在异常大比例的实例中不太常见，这是有偏见的。

# xcode - 集成 TFS 版本控制的最佳方法是什么

> ID：70313
> 
> 赞同：19
> 
> 时间：2008-09-16T08:21:04.280
> 
> 标签：xcode, version-control, tfs

致力于在整个组织中实施 TFS。它很容易与`.NET`项目和任何使用 Eclipse 或 Eclipse 衍生产品进行编辑的平台集成。
将 TFS 版本控制与 Xcode 一起使用的最佳方式是什么（现在我发现我们需要编写一些 iPhone 应用程序）？

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2008-09-16T10:37:00.630

Xcode 集成是我们[Teamprise](http://www.teamprise.com)一直在研究的东西。对我们来说主要问题之一是 Apple 没有提供一个版本控制 API，我们可以使用它来向 Xcode 添加一个新的版本控制系统——对于集成的版本控制，它要么是 Apple 提供的系统访问权限，要么是什么都没有。片刻。

也就是说，我们确实有许多使用 Xcode for TFS 开发的客户。他们要么使用[Teamprise Explorer](http://www.teamprise.com/products/explorer/)（它是编译为通用二进制文件的 TFS 的独立 GUI 客户端），要么在 Xcode 中使用宏来执行基本的检出并与[TFS 命令行 (tf)](http://www.teamprise.com/products/clc/)结合使用。这显然不是理想的体验，但对他们来说是可以接受的。独立 GUI 的优点是您也可以在那里进行所有工作项跟踪，并将其与您的签到集成。

抱歉，如果这是一个非常“营销”类型的答案 - 只是想让您知道我们当前的客户使用 Xcode 做了什么。如果您想了解有关宏方法的更多详细信息，请告诉我。

希望有帮助，

马丁。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2012-08-25T09:46:18.300

几周前，codeplex宣布[Git-tf](http://gittf.codeplex.com/)可以完成这项工作。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2009-01-19T15:46:23.437

也许 SVNBridge 可以解决问题，它是 CodePlex（微软的开源托管）使用的开源。在这里查看：http: [//www.codeplex.com/SvnBridge](http://www.codeplex.com/SvnBridge)

除了简单地使用它连接到 CodePlex 之外，我对它的经验有限。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T08:39:03.220

一种方法是在 VMWare 中的 Windows 下使用 Team Foundation System 客户端，然后将源代码检出（或任何 TFS 名称）到 Mac 上与虚拟机共享的目录中。看起来[Teamprise](http://www.teamprise.com/)有一个基于 Eclipse 构建的适用于 Mac OS X 的 Team Foundation 客户端，值得研究。

就是说，我强烈建议您使用像 Subversion 或 Perforce 这样的**本机**跨平台源代码管理系统，而不是像 Team Foundation System 这样的平台特定孤岛来管理您公司的源代码，尤其是因为您将成为做多平台开发。

虽然您不太可能在 .NET 应用程序和 iPhone 应用程序之间共享代码，但拥有对设计文档等内容的完全跨平台访问权限可能非常重要。Mac OS X 10.5 及更高版本包括 Subversion，Perforce 很容易获得，并且 Xcode IDE 原生支持 Perforce 和 Subversion。经验丰富的 Mac 和 iPhone 开发人员更可能熟悉 Subversion，您可能会在升级时将其带入您的项目。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2013-10-10T09:57:58.450

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2011-09-29T00:24:00.720

最大的问题是 Xcode 只能在 OS X 上运行，而 TFS 客户端工具只能在 Windows 上运行。如果您是 OS X 中的主机操作系统，并且您有一个本地运行的 Windows 虚拟环境（如 Parallels 或 VMFusion），那么您可以使用 Team Explorer 或命令行工具来使用存储库。

但这只是为了使用一个真正过时的版本控制系统而做的大量工作。如果您不必使用 TFS，我可能会使用 SVN 或其他支持本机 OS X 的东西。

# ruby-on-rails - rake db:migrate 没有检测到新的迁移？

> ID：70318
> 
> 赞同：6
> 
> 时间：2008-09-16T08:22:03.527
> 
> 标签：ruby-on-rails, activerecord, migration

熟悉 Rails / ActiveRecord 2.1.1

*   您使用（例如）ruby script\generate scaffold product title:string description:text image_url:string 创建第一个版本
*   这将创建（例如）一个名为 20080910122415_create_products.rb 的迁移文件
*   您使用 rake db:migrate 应用迁移
*   现在，您使用 ruby​​ script\generate migration add_price_to_product price:decimal 在产品表中添加一个字段
*   这将创建一个名为 20080910125745_add_price_to_product.rb 的迁移文件
*   如果您尝试运行 rake db:migrate，它实际上会还原第一次迁移，而不是应用下一次！所以你的产品表会被破坏！
*   但是如果你单独运行 rake，它会告诉你有一个迁移正在等待

请注意，应用 rake db:migrate（一旦表被销毁）将按顺序应用所有迁移。

我发现的唯一解决方法是指定新迁移的版本，如下所示：

```
rake db:migrate version=20080910125745 
```

所以我想知道：这是一种预期的新行为吗？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T09:39:54.230

你应该可以使用

```
rake db:migrate:up 
```

迫使它继续前进，但是您可能会错过团队中其他人的交错迁移

如果你跑

```
rake db:migrate 
```

两次，它将重新应用您的所有迁移。

我在使用 SQLite 的 Windows 上遇到了相同的行为，这可能是特定于这种环境的错误。

**编辑**——我找到了原因。在 railstie database.rake 任务中，您有以下代码：

```
desc "Migrate the database through scripts in db/migrate. Target specific version with VERSION=x. Turn off output with VERBOSE=false."
task :migrate => :environment do
  ActiveRecord::Migration.verbose = ENV["VERBOSE"] ? ENV["VERBOSE"] == "true" : true
  ActiveRecord::Migrator.migrate("db/migrate/", ENV["VERSION"] ? ENV["VERSION"].to_i : nil)
  Rake::Task["db:schema:dump"].invoke if ActiveRecord::Base.schema_format == :ruby
end 
```

然后在我的环境变量中我有

```
echo %Version% #=> V3.5.0f 
```

在红宝石

```
ENV["VERSION"] # => V3.5.0f
ENV["VERSION"].to_i #=>0 not nil ! 
```

因此 rake 任务调用

```
ActiveRecord::Migrator.migrate("db/migrate/", 0) 
```

在 ActiveRecord::Migrator 我们有：

```
class Migrator#:nodoc:
  class << self
    def migrate(migrations_path, target_version = nil)
      case
        when target_version.nil?              then up(migrations_path, target_version)
        when current_version > target_version then down(migrations_path, target_version)
        else                                       up(migrations_path, target_version)
      end
    end 
```

是的，`rake db:migrate VERSION=0`是长版`rake db:migrate:down`

**编辑**- 我会去更新灯塔错误，但我的超级公司代理禁止我在那里连接

同时，您可以尝试在调用 migrate 之前取消设置 Version ...

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T09:50:29.977

这不是预期的行为。我本来建议将此报告为灯塔上的错误，但我看到您[已经这样做了](http://rails.lighthouseapp.com/projects/8994/tickets/1021-rake-dbmigrate-doesnt-detect-new-migration)！如果您提供更多信息（包括操作系统/数据库/ruby 版本），我会看一下。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T10:25:53.557

我恭敬地不同意汤姆！这*是*一个错误！V3.5.0f 不是 rake 迁移的有效版本。Rake 不应该仅仅因为 ruby​​ 选择考虑 "V3.5.0f".to_i 是 0 就使用它来迁移：down ...

Rake 应该大声抱怨 VERSION 无效，以便用户知道发生了什么（在你我之间，通过转换为整数来检查版本是否是 YYYYMMDD 格式的时间戳有点轻）

[该死的IE6不允许我发表评论！不，我不能更改浏览器感谢公司]

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T10:41:03.473

让，

非常感谢您的调查。你是对的，实际上我认为你发现了一个更严重的错误，即物种“设计错误”。

正在发生的事情是 rake 将获取您传递给命令行的任何值并将它们存储为环境变量。最终将被调用的 rake 任务只会从环境变量中提取这些值。当 db:migrate 查询 ENV["VERSION"] 时，它实际上请求您设置调用 rake 的版本参数。当您调用 rake db:migrate 时，您不会传递任何版本。

但是我们确实有一个名为 VERSION 的环境变量，它已被其他程序设置用于其他目的（我还不知道是哪一个）。而 rake 背后的人（或 database.rake 背后的人）并没有想到会发生这种情况。这是一个设计错误。至少，他们可以使用更具体的变量名称，例如“RAKE_VERSION”或“RAKE_PARAM_VERSION”，而不仅仅是“VERSION”。

汤姆，我绝对不会关闭，而是编辑我关于灯塔的错误报告以反映这些新发现。

再次感谢让的帮助。我已经像 5 天前在灯塔上发布了这个错误，但仍然没有答案！

罗洛

# java - Java内部类和静态嵌套类

> ID：70324
> 
> 赞同：1955
> 
> 时间：2008-09-16T08:22:35.727
> 
> 标签：java, inner-classes, static-classes

Java中内部类和静态嵌套类之间的主要区别是什么？设计/实施是否在选择其中之一时发挥作用？

* * *

## 回答 #1

> 赞同：1840
> 
> 时间：2008-09-16T08:28:34.090

来自[Java 教程](http://java.sun.com/docs/books/tutorial/java/javaOO/nested.html)：

> 嵌套类分为两类：静态和非静态。声明为静态的嵌套类简称为静态嵌套类。非静态嵌套类称为内部类。

使用封闭类名访问静态嵌套类：

```
OuterClass.StaticNestedClass 
```

例如，要为静态嵌套类创建对象，请使用以下语法：

```
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass(); 
```

作为内部类实例的对象存在于外部类的实例中。考虑以下类：

```
class OuterClass {
    ...
    class InnerClass {
        ...
    }
} 
```

InnerClass 的实例只能存在于 OuterClass 的实例中，并且可以直接访问其封闭实例的方法和字段。

要实例化内部类，您必须先实例化外部类。然后，使用以下语法在外部对象中创建内部对象：

```
OuterClass outerObject = new OuterClass()
OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 
```

请参阅：[Java 教程 - 嵌套类](http://download.oracle.com/javase/tutorial/java/javaOO/nested.html)

为了完整起见，还有一个[*没有*](https://stackoverflow.com/questions/20468856/is-it-true-that-every-inner-class-requires-an-enclosing-instance)[封闭实例的](https://stackoverflow.com/questions/20468856/is-it-true-that-every-inner-class-requires-an-enclosing-instance)[内部类](https://stackoverflow.com/questions/20468856/is-it-true-that-every-inner-class-requires-an-enclosing-instance)*：*

 *```
class A {
  int t() { return 1; }
  static A a =  new A() { int t() { return 2; } };
} 
```

这里，`new A() { ... }`是*在静态上下文中定义的内部类*，没有封闭实例。

* * *

## 回答 #2

> 赞同：653
> 
> 时间：2008-09-16T09:24:23.143

[Java教程](http://java.sun.com/docs/books/tutorial/java/javaOO/nested.html)说：

> 术语：嵌套类分为两类：静态和非静态。声明为静态的嵌套类简称为静态嵌套类。非静态嵌套类称为内部类。

通俗地说，术语“嵌套”和“内部”被大多数程序员互换使用，但我将使用正确的术语“嵌套类”，它涵盖了内部和静态。

类可以*无限*嵌套，例如 A 类可以包含 B 类，B 类包含 C 类，C 类包含 D 类等。但是，多于一级的类嵌套很少见，因为它通常是糟糕的设计。

创建嵌套类的原因有以下三个：

*   组织：有时将一个类分类到另一个类的命名空间中似乎是最明智的，尤其是当它不会在任何其他上下文中使用时
*   访问：嵌套类对其包含类的变量/字段具有特殊访问权限（确切地说，哪些变量/字段取决于嵌套类的类型，无论是内部类还是静态类）。
*   便利性：必须为每种新类型创建一个新文件很麻烦，尤其是当该类型仅在一个上下文中使用时

Java中有**四种嵌套类**。简而言之，它们是：

*   **静态类**：声明为另一个类的静态成员
*   **内部类**：声明为另一个类的实例成员
*   **本地内部类**：在另一个类的实例方法中声明
*   **匿名内部类**：类似于本地内部类，但写成返回一次性对象的表达式

让我详细说明一下。

## 静态类

静态类是最容易理解的，因为它们与包含类的实例无关。

静态类是声明为另一个类的静态成员的类。就像其他静态成员一样，这样的类实际上只是一个使用包含类作为其命名空间的衣架，*例如*，在包*Pizza*中声明为类 Rhino 的静态成员的*Goat**类*称为*Pizza.Rhino.Goat* .

 ***```
package pizza;

public class Rhino {

    ...

    public static class Goat {
        ...
    }
} 
```

坦率地说，静态类是一个非常没有价值的特性，因为类已经被包划分为命名空间。创建静态类的唯一真正可以想象的原因是这样的类可以访问其包含类的私有静态成员，但我发现这是存在静态类功能的非常蹩脚的理由。

## 内部类

内部类是声明为另一个类的非静态成员的类：

```
package pizza;

public class Rhino {

    public class Goat {
        ...
    }

    private void jerry() {
        Goat g = new Goat();
    }
} 
```

与静态类一样，内部类通过其包含类名称来限定，*pizza.Rhino.Goat*，但在包含类内部，它可以通过其简单名称来识别。然而，内部类的每个实例都与它的包含类的一个特定实例相关联：上面，在*jerry*中创建的*Goat*隐式地​​与在*jerry中的**Rhino*实例*this*相关联。否则，我们在实例化*Goat时明确关联的**Rhino*实例：

 ***```
Rhino rhino = new Rhino();
Rhino.Goat goat = rhino.new Goat(); 
```

（请注意，您在奇怪的*新语法中将内部类型称为**Goat*：Java 从*rhino*部分推断包含类型。而且，是*的 new rhino.Goat()*对我来说也更有意义。）

 ***那么这对我们有什么好处呢？好吧，内部类实例可以访问包含类实例的实例成员。这些封闭的实例成员在内部类*中仅通过*它们的简单名称而不是*通过* *this*来引用（内部类中的*this*指的是内部类实例，而不是关联的包含类实例）：

```
public class Rhino {

    private String barry;

    public class Goat {
        public void colin() {
            System.out.println(barry);
        }
    }
} 
```

在内部类中，您可以将包含类的 this 称为*Rhino.this* *，*您可以使用*this*来引用其成员，*例如 Rhino.this.barry*。

## 本地内部类

本地内部类是在方法体中声明的类。这样的类仅在其包含方法中是已知的，因此只能在其包含方法中对其进行实例化并访问其成员。好处是本地内部类实例被绑定到并且可以访问其包含方法的最终局部变量。当实例使用其包含方法的 final 局部变量时，该变量将保留它在实例创建时所持有的值，即使该变量已超出范围（这实际上是 Java 粗略的、有限的闭包版本）。

因为本地内部类既不是类的成员也不是包的成员，所以它没有用访问级别声明。（但是要清楚，它自己的成员具有与普通类一样的访问级别。）

*如果在实例方法中声明了本地内部类，则内部类的实例化与创建实例时包含方法的this*所持有的实例相关联，因此包含类的实例成员可以像在实例中一样访问内部阶级。本地内部类仅*通过*其名称进行实例化，*例如*本地内部类*Cat*被实例化为*new Cat()*，而不是您可能期望的 new this.Cat() 。

## 匿名内部类

匿名内部类是编写本地内部类的一种语法方便的方法。最常见的是，每次运行其包含方法时，本地内部类最多只实例化一次。那么，如果我们可以将本地内部类定义和它的单个实例化组合成一种方便的语法形式，那就太好了，如果我们不必为类想一个名字（越少无用您的代码包含的名称越好）。匿名内部类允许以下两种情况：

```
new *ParentClassName*(*constructorArgs*) {*members*} 
```

*这是一个表达式，返回一个扩展ParentClassName*的未命名类的新实例。您不能提供自己的构造函数；相反，一个是隐式提供的，它只是调用超级构造函数，所以提供的参数必须适合超级构造函数。（如果父级包含多个构造函数，则调用“最简单”的构造函数，“最简单”是由一组相当复杂的规则决定的，不值得费心去详细学习——只需注意 NetBeans 或 Eclipse 告诉你的内容。）

或者，您可以指定要实现的接口：

```
new *InterfaceName*() {*members*} 
```

这样的声明创建了一个未命名类的新实例，它扩展了 Object 并实现了*InterfaceName*。同样，您不能提供自己的构造函数；在这种情况下，Java 隐式提供了一个无参数、什么都不做的构造函数（因此在这种情况下永远不会有构造函数参数）。

即使您不能为匿名内部类提供构造函数，您仍然可以使用初始化程序块（放置在任何方法之外的 {} 块）进行任何设置。

需要明确的是，匿名内部类只是用一个实例创建本地内部类的一种不太灵活的方式。如果您想要一个实现多个接口的本地内部类，或者在扩展*Object*以外的某个类或指定其自己的构造函数的同时实现接口，那么您将无法创建一个常规的命名本地内部类。

* * *

## 回答 #3

> 赞同：162
> 
> 时间：2008-09-16T09:12:43.173

我认为上述答案中的真正区别并不明显。

首先要正确使用条款：

*   嵌套类是在源代码级别包含在另一个类中的类。
*   如果使用**static**修饰符声明它，它是静态的。
*   非静态嵌套类称为内部类。（我留在非静态嵌套类。）

到目前为止，马丁的回答是正确的。然而，实际的问题是：将嵌套类声明为静态的目的是什么？

如果您只想将类放在一起，或者如果嵌套类专门用于封闭类，则可以使用**静态嵌套类。**静态嵌套类和其他所有类之间没有语义差异。

**非静态嵌套类**是另一种野兽。类似于匿名内部类，这样的嵌套类实际上是闭包。这意味着他们捕获了周围的范围和封闭的实例并使其可访问。也许一个例子可以澄清这一点。查看这个容器的存根：

```
public class Container {
    public class Item{
        Object data;
        public Container getContainer(){
            return Container.this;
        }
        public Item(Object data) {
            super();
            this.data = data;
        }

    }

    public static Item create(Object data){
        // does not compile since no instance of Container is available
        return new Item(data);
    }
    public Item createSubItem(Object data){
        // compiles, since 'this' Container is available
        return new Item(data);
    }
} 
```

在这种情况下，您希望获得从子项到父容器的引用。使用非静态嵌套类，这无需任何工作即可工作。您可以使用语法访问 Container 的封闭实例`Container.this`。

更多硬核解释如下：

如果您查看编译器为（非静态）嵌套类生成的 Java 字节码，它可能会变得更加清晰：

```
// class version 49.0 (49)
// access flags 33
public class Container$Item {

  // compiled from: Container.java
  // access flags 1
  public INNERCLASS Container$Item Container Item

  // access flags 0
  Object data

  // access flags 4112
  final Container this$0

  // access flags 1
  public getContainer() : Container
   L0
    LINENUMBER 7 L0
    ALOAD 0: this
    GETFIELD Container$Item.this$0 : Container
    ARETURN
   L1
    LOCALVARIABLE this Container$Item L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 1
  public <init>(Container,Object) : void
   L0
    LINENUMBER 12 L0
    ALOAD 0: this
    ALOAD 1
    PUTFIELD Container$Item.this$0 : Container
   L1
    LINENUMBER 10 L1
    ALOAD 0: this
    INVOKESPECIAL Object.<init>() : void
   L2
    LINENUMBER 11 L2
    ALOAD 0: this
    ALOAD 2: data
    PUTFIELD Container$Item.data : Object
    RETURN
   L3
    LOCALVARIABLE this Container$Item L0 L3 0
    LOCALVARIABLE data Object L0 L3 2
    MAXSTACK = 2
    MAXLOCALS = 3
} 
```

如您所见，编译器创建了一个隐藏字段`Container this$0`。这是在构造函数中设置的，它有一个 Container 类型的附加参数来指定封闭实例。您在源代码中看不到此参数，但编译器为嵌套类隐式生成它。

马丁的例子

```
OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 
```

将被编译为类似（在字节码中）的调用

```
new InnerClass(outerObject) 
```

为了完整起见：

匿名类**是非**静态嵌套类的完美示例，它没有与之关联的名称，以后也无法引用。

* * *

## 回答 #4

> 赞同：102
> 
> 时间：2012-05-27T07:43:32.637

我认为以上答案都没有向您解释嵌套类和静态嵌套类在应用程序设计方面的真正区别：

## 概述

**嵌套类**可以是非静态的或静态的，并且在每种情况下**都是在另一个类中定义的类**。**嵌套类应该只存在于服务封闭类**，如果嵌套类对其他类有用（不仅是封闭类），则应将其声明为顶级类。

## 不同之处

**非静态嵌套类**：与包含类的封闭实例隐式关联，这意味着可以调用封闭实例的方法和访问变量。非静态嵌套类的一种常见用途是定义适配器类。

**静态嵌套类**：无法访问封闭类实例并在其上调用方法，因此应在嵌套类不需要访问封闭类实例时使用。静态嵌套类的一个常见用途是实现外部对象的组件。

## 结论

所以从设计的角度来看，两者的主要区别是：*非静态嵌套类可以访问容器类的实例，而静态不能*。

* * *

## 回答 #5

> 赞同：40
> 
> 时间：2013-10-17T22:35:33.440

简单来说，我们需要嵌套类主要是因为 Java 不提供闭包。

嵌套类是在另一个封闭类的主体内定义的类。它们有两种类型——静态的和非静态的。

它们被视为封闭类的成员，因此您可以指定四个访问说明符中的任何一个 - `private, package, protected, public`。对于只能声明`public`或包私有的顶级类，我们没有这种奢侈。

内部类又名非堆栈类可以访问顶级类的其他成员，即使它们被声明为私有，而静态嵌套类无法访问顶级类的其他成员。

```
public class OuterClass {
    public static class Inner1 {
    }
    public class Inner2 {
    }
} 
```

`Inner1`是我们的静态内部类，并且`Inner2`是我们的非静态内部类。它们之间的主要区别在于，您无法在`Inner2`没有 Outer 的情况下创建实例，因为您可以独立创建`Inner1`对象。

你什么时候使用内部类？

考虑一种情况，其中`Class A`和`Class B`相关，`Class B`需要访问`Class A`成员，并且`Class B`仅与 相关`Class A`。内部类进入图片。

要创建内部类的实例，您需要创建外部类的实例。

```
OuterClass outer = new OuterClass();
OuterClass.Inner2 inner = outer.new Inner2(); 
```

或者

```
OuterClass.Inner2 inner = new OuterClass().new Inner2(); 
```

你什么时候使用静态内部类？

当您知道静态内部类与封闭类/顶级类的实例没有任何关系时，您将定义它。如果你的内部类不使用外部类的方法或字段，那只是浪费空间，所以将其设为静态。

例如，要为静态嵌套类创建对象，请使用以下语法：

```
OuterClass.Inner1 nestedObject = new OuterClass.Inner1(); 
```

静态嵌套类的优点是它不需要包含类/顶级类的对象来工作。这可以帮助您减少应用程序在运行时创建的对象数量。

* * *

## 回答 #6

> 赞同：37
> 
> 时间：2015-12-31T20:53:05.513

这是Java内部类和静态嵌套类之间的主要区别和相似之处。

希望能帮助到你！

### 内部类

*   **可以访问**外部类**的实例和静态**方法和字段
*   **与封闭类的实例相关联，**因此要实例化它首先需要一个外部类的实例（注意*new*关键字 place）：

    ```
    Outerclass.InnerClass innerObject = outerObject.new Innerclass(); 
    ```

*   **不能**定义任何**静态成员**本身

*   **不能**有**类**或**接口**声明

### 静态嵌套类

*   **无法访问**外部类**实例**方法或字段

*   **不与封闭类的任何实例关联**所以要实例化它：

    ```
    OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass(); 
    ```

### 相似之处

*   两个**内部类**甚至可以访问**外部类**的**私有字段和方法**
***   **外部类**也可以访问**内部类**的**私有字段和方法*****   两个类都可以有私有、受保护或公共访问修饰符****

 ****### 为什么使用嵌套类？

根据 Oracle 文档，有几个原因（[完整文档](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html)）：

> *   **这是一种对仅在一个地方使用的类进行逻辑分组的方法：**如果一个类仅对另一个类有用，那么将其嵌入该类并将两者放在一起是合乎逻辑的。嵌套这样的“帮助类”使它们的包更加精简。
>     
>     
> *   **它增加了封装性：**考虑两个顶级类 A 和 B，其中 B 需要访问 A 的成员，否则这些成员将被声明为私有。通过将类 B 隐藏在类 A 中，可以将 A 的成员声明为私有的，并且 B 可以访问它们。此外，B 本身可以对外界隐藏。
>     
>     
> *   **它可以导致代码更易读和更可维护：**在顶级类中嵌套小类可以使代码更接近使用它的位置。

* * *

## 回答 #7

> 赞同：26
> 
> 时间：2010-12-16T11:38:31.063

我认为，通常遵循的约定是这样的：

*   **顶级类中的**静态类是****嵌套类****
***   **顶级类中的**非静态类是****内部类**，它还有另外两种形式：

    *   **本地类**- 在块内声明的命名类，如方法或构造函数主体
    *   **匿名类**- 在表达式和语句中创建实例的未命名类**** 

 ******但是，要记住**的其他几点是：

*   顶级类和静态嵌套类在语义上是相同的，只是在静态嵌套类的情况下，它可以对其外部 [父] 类的私有静态字段/方法进行静态引用，反之亦然。

*   内部类可以访问外部 [父] 类的封闭实例的实例变量。然而，并不是所有的内部类都有封闭的实例，例如静态上下文中的内部类，就像在静态初始化块中使用的匿名类一样，没有。

*   默认情况下，匿名类扩展父类或实现父接口，并且没有进一步的子句来扩展任何其他类或实现更多接口。所以，

    *   `new YourClass(){};` 方法 `class [Anonymous] extends YourClass {}`
    *   `new YourInterface(){};` 方法 `class [Anonymous] implements YourInterface {}`

* * *

我觉得更大的问题仍然悬而未决，使用哪个以及何时使用？好吧，这主要取决于您正在处理的情况，但阅读@jrudolph 给出的回复可能会帮助您做出一些决定。

* * *

## 回答 #8

> 赞同：15
> 
> 时间：2010-04-04T10:14:35.703

嵌套类：类内类

类型：

1.  静态嵌套类
2.  非静态嵌套类[内部类]

不同之处：

**非静态嵌套类[内部类]**

在内部类的非静态嵌套类对象中存在于外部类的对象中。这样外部类的数据成员就可以被内部类访问。所以要创建内部类的对象，我们必须先创建外部类的对象。

```
outerclass outerobject=new outerobject();
outerclass.innerclass innerobjcet=outerobject.new innerclass(); 
```

**静态嵌套类**

在内部类的静态嵌套类对象中不需要外部类的对象，因为“静态”一词表示不需要创建对象。

```
class outerclass A {
    static class nestedclass B {
        static int x = 10;
    }
} 
```

如果你想访问x，那么在里面写下面的方法

```
 outerclass.nestedclass.x;  i.e. System.out.prinltn( outerclass.nestedclass.x); 
```

* * *

## 回答 #9

> 赞同：13
> 
> 时间：2008-09-16T08:58:40.663

内部类的实例是在创建外部类的实例时创建的。因此，内部类的成员和方法可以访问外部类的实例（对象）的成员和方法。当外部类的实例超出范围时，内部类实例也不再存在。

静态嵌套类没有具体实例。它只是在第一次使用时加载（就像静态方法一样）。它是一个完全独立的实体，其方法和变量无法访问外部类的实例。

静态嵌套类不与外部对象耦合，它们速度更快，并且不占用堆/堆栈内存，因为不需要创建此类的实例。因此经验法则是尝试定义静态嵌套类，范围尽可能有限（private >= class >= protected >= public），然后将其转换为内部类（通过删除“静态”标识符）并放松范围，如果真的有必要的话。

* * *

## 回答 #10

> 赞同：11
> 
> 时间：2010-03-26T12:38:19.567

嵌套静态类的使用有一个微妙之处，可能在某些情况下很有用。

虽然静态属性在类通过其构造函数实例化之前被实例化，但嵌套静态类内部的静态属性似乎直到类的构造函数被调用之后才被实例化，或者至少直到属性被首次引用之后才被实例化，即使它们被标记为“最终”。

考虑这个例子：

```
public class C0 {

    static C0 instance = null;

    // Uncomment the following line and a null pointer exception will be
    // generated before anything gets printed.
    //public static final String outerItem = instance.makeString(98.6);

    public C0() {
        instance = this;
    }

    public String makeString(int i) {
        return ((new Integer(i)).toString());
    }

    public String makeString(double d) {
        return ((new Double(d)).toString());
    }

    public static final class nested {
        public static final String innerItem = instance.makeString(42);
    }

    static public void main(String[] argv) {
        System.out.println("start");
        // Comment out this line and a null pointer exception will be
        // generated after "start" prints and before the following
        // try/catch block even gets entered.
        new C0();
        try {
            System.out.println("retrieve item: " + nested.innerItem);
        }
        catch (Exception e) {
            System.out.println("failed to retrieve item: " + e.toString());
        }
        System.out.println("finish");
    }
} 
```

即使 'nested' 和 'innerItem' 都被声明为 'static final'。nested.innerItem 的设置直到类被实例化之后才会发生（或者至少直到嵌套的静态项被第一次引用之后），你可以通过注释和取消注释我所指的行来亲自看到，多于。'outerItem' 的情况并非如此。

至少这是我在 Java 6.0 中看到的。

* * *

## 回答 #11

> 赞同：10
> 
> 时间：2008-09-16T08:25:42.363

这些术语可以互换使用。如果你真的想学究气，那么你*可以*定义“嵌套类”来引用一个没有封闭实例的静态内部类。在代码中，你可能有这样的东西：

```
public class Outer {
    public class Inner {}

    public static class Nested {}
} 
```

不过，这并不是一个被广泛接受的定义。

* * *

## 回答 #12

> 赞同：10
> 
> 时间：2013-11-14T12:29:16.363

在创建实例的情况下，非静态内部类的实例是使用定义它的外部类的对象的引用来创建的。这意味着它有封闭的实例。但是静态内部类的实例是通过外部类的引用创建的，而不是外部类的对象的引用。这意味着它没有封闭实例。

例如：

```
class A
{
  class B
  {
    // static int x; not allowed here…..    
  }
  static class C
  {
    static int x; // allowed here
  }
}

class Test
{
  public static void main(String… str)
  {
    A o=new A();
    A.B obj1 =o.new B();//need of inclosing instance

    A.C obj2 =new A.C();

    // not need of reference of object of outer class….
  }
} 
```

* * *

## 回答 #13

> 赞同：9
> 
> 时间：2015-11-18T13:36:08.773

我认为这里没有太多要补充的，大多数答案都完美地解释了静态嵌套类和内部类之间的区别。但是，在使用嵌套类与内部类时，请考虑以下问题。正如在几个答案中提到的那样，如果没有其封闭类的实例，内部类就无法实例化，这意味着它们**持有****指向**其封闭类实例的指针，这可能导致内存溢出或堆栈溢出异常，因为 GC即使不再使用它们，也无法对封闭类进行垃圾收集。为了清楚起见，请检查以下代码：

```
public class Outer {

    public  class Inner {

    }

    public Inner inner(){
        return new Inner();
    }

    @Override
    protected void finalize() throws Throwable {
    // as you know finalize is called by the garbage collector due to destroying an object instance
        System.out.println("I am destroyed !");
    }
}

public static void main(String arg[]) {

    Outer outer = new Outer();
    Outer.Inner inner = outer.new Inner();

    // out instance is no more used and should be garbage collected !!!
    // However this will not happen as inner instance is still alive i.e used, not null !
    // and outer will be kept in memory until inner is destroyed
    outer = null;

    //
    // inner = null;

    //kick out garbage collector
    System.gc();

} 
```

如果您删除对`// inner = null;`程序的评论，则会输出“**我被摧毁！** ”，但保留此评论不会。
原因是白色的内部实例仍然被引用，GC 无法收集它，因为它引用（有一个指向）外部实例，它也没有被收集。在您的项目中有足够的这些对象并且可能会耗尽内存。
与不指向内部类实例的静态内部类相比，因为它与实例无关，而是与类相关。上面的程序可以打印“**我被摧毁了！** ”如果你让内部类静态并用`Outer.Inner i = new Outer.Inner();`

* * *

## 回答 #14

> 赞同：8
> 
> 时间：2008-09-16T08:24:27.330

嗯...内部类是嵌套类...您的意思是匿名类和内部类吗？

编辑：如果您实际上是指内部与匿名......内部类只是在类中定义的类，例如：

```
public class A {
    public class B {
    }
} 
```

而匿名类是匿名定义的类的扩展，因此没有定义实际的“类”，如：

```
public class A {
}

A anon = new A() { /* you could change behavior of A here */ }; 
```

进一步编辑：

Wikipedia[声称 Java 有所不同](http://en.wikipedia.org/wiki/Inner_class)，但我已经使用 Java 8 年了，这是我第一次听到这样的区别......更不用说那里没有任何引用来支持这种说法......底部行，内部类是在类中定义的类（静态或非静态），而嵌套只是表示同一事物的另一个术语。

静态和非静态嵌套类之间存在细微差别......基本上非静态内部类可以隐式访问封闭类的实例字段和方法（因此它们不能在静态上下文中构造，它将是一个编译器错误）。另一方面，静态嵌套类没有对实例字段和方法的隐式访问，并且可以在静态上下文中构造。

* * *

## 回答 #15

> 赞同：8
> 
> 时间：2008-09-16T08:35:36.663

嵌套类是一个非常笼统的术语：每个不是顶级的类都是嵌套类。内部类是非静态嵌套类。[Joseph Darcy 写了一篇关于Nested、Inner、Member 和 Top-Level Classes](http://blogs.oracle.com/darcy/entry/nested_inner_member_and_top)的非常好的解释。

* * *

## 回答 #16

> 赞同：8
> 
> 时间：2015-07-21T11:02:51.390

*针对不熟悉 Java 和/或嵌套类的学习者*

嵌套类可以是：
1\. 静态嵌套类。
2.非静态嵌套类。（也称为**内部类**）=>请记住这一点

**1.内部类**
示例：

```
class OuterClass  {
/*  some code here...*/
     class InnerClass  {  }
/*  some code here...*/
} 
```

**内部类是嵌套类的子集：**

*   内部类是特定类型的嵌套类
*   内部类是嵌套类的子集
*   你可以说一个*内部类也是一个嵌套类，但你**不能**说一个嵌套类也是一个内部类*。

**内班特长：**

*   内部类的实例可以**访问**外部类的所有成员，即使是那些标记为“私有”的成员</li>

**2.静态嵌套类：**
示例：

```
class EnclosingClass {
  static class Nested {
    void someMethod() { System.out.println("hello SO"); }
  }
} 
```

**案例1：从非封闭类实例化静态嵌套类**

```
class NonEnclosingClass {

  public static void main(String[] args) {
    /*instantiate the Nested class that is a static
      member of the EnclosingClass class:
    */

    EnclosingClass.Nested n = new EnclosingClass.Nested(); 
    n.someMethod();  //prints out "hello"
  }
} 
```

**案例 2：从封闭类实例化静态嵌套类**

```
class EnclosingClass {

  static class Nested {
    void anotherMethod() { System.out.println("hi again"); } 
  }

  public static void main(String[] args) {
    //access enclosed class:

    Nested n = new Nested(); 
    n.anotherMethod();  //prints out "hi again"
  }

} 
```

**静态类的特点：**

*   静态内部类只能访问外部类的静态成员，不能访问非静态成员。

**结论：**
*问题：* Java中内部类和静态嵌套类的主要区别是什么？
*答：*只需浏览上述每个类的细节即可。

* * *

## 回答 #17

> 赞同：6
> 
> 时间：2017-03-22T10:39:26.090

**Java中的内部类**和**嵌套静态类**都是在另一个类中声明的类，在Java中称为顶级类。在 Java 术语中，如果您声明一个嵌套类为静态的，则它在 Java 中将称为嵌套静态类，而非静态嵌套类简称为内部类。

**Java中的内部类是什么？**

任何不是顶级或在另一个类中声明的类都称为嵌套类，在这些嵌套类中，声明为非静态的类在 Java 中称为内部类。Java中有三种Inner类：

1) 本地内部类 - 在代码块或方法内声明。
2) 匿名内部类 - 是一个没有名称可以引用的类，并且在它被创建的同一位置初始化。
3) 成员内部类 - 被声明为外部类的非静态成员。

```
public class InnerClassTest {
    public static void main(String args[]) {      
        //creating local inner class inside method i.e. main() 
        class Local {
            public void name() {
                System.out.println("Example of Local class in Java");

            }
        }      
        //creating instance of local inner class
        Local local = new Local();
        local.name(); //calling method from local inner class

        //Creating anonymous inner class in Java for implementing thread
        Thread anonymous = new Thread(){
            @Override
            public void run(){
                System.out.println("Anonymous class example in java");
            }
        };
        anonymous.start();

        //example of creating instance of inner class
        InnerClassTest test = new InnerClassTest();
        InnerClassTest.Inner inner = test.new Inner();
        inner.name(); //calling method of inner class
    }

     //Creating Inner class in Java
    private class Inner{
        public void name(){
            System.out.println("Inner class example in java");
        }
    }
} 
```

**Java中的嵌套静态类是什么？**

嵌套静态类是另一个类，它在类中声明为成员并设为静态。嵌套的静态类也被声明为外部类的成员，并且可以像任何其他成员一样设为私有、公共或受保护。嵌套静态类相对于内部类的主要好处之一是嵌套静态类的实例不附加到外部类的任何封闭实例。*您也不需要任何 Outer 类的实例来在 Java 中创建嵌套静态类的实例*。

1）它可以访问外部类的*静态数据成员*，包括私有的。
2）静态嵌套类不能访问*非静态（实例）数据成员*或*方法*。

```
public class NestedStaticExample {
    public static void main(String args[]){  
        StaticNested nested = new StaticNested();
        nested.name();
    }  
    //static nested class in java
    private static class StaticNested{
        public void name(){
            System.out.println("static nested class example in java");
        }
    }
} 
```

参考：[Java 中的内部类和嵌套静态类与示例](http://javarevisited.blogspot.in/2012/12/inner-class-and-nested-static-class-in-java-difference.html)

* * *

## 回答 #18

> 赞同：6
> 
> 时间：2019-03-06T01:20:17.853

我认为以上答案都没有为您提供嵌套类和静态嵌套类在应用程序设计方面的区别的真实示例。静态嵌套类和内部类之间的主要区别在于访问外部类实例字段的能力。

让我们看看下面的两个例子。

静态嵌套类：使用静态嵌套类的一个很好的例子是构建器模式（[https://dzone.com/articles/design-patterns-the-builder-pattern](https://dzone.com/articles/design-patterns-the-builder-pattern)）。

对于 BankAccount 我们使用静态嵌套类，主要是因为

1.  静态嵌套类实例可以在外部类之前创建。

2.  在构建器模式中，构建器是一个帮助类，用于创建 BankAccount。

3.  BankAccount.Builder 仅与 BankAccount 相关联。没有其他类与 BankAccount.Builder 相关。所以最好在不使用名称约定的情况下将它们组织在一起。

```
public class BankAccount {

    private long accountNumber;
    private String owner;
    ...

    public static class Builder {

    private long accountNumber;
    private String owner;
    ...

    static public Builder(long accountNumber) {
        this.accountNumber = accountNumber;
    }

    public Builder withOwner(String owner){
        this.owner = owner;
        return this; 
    }

    ...
    public BankAccount build(){
            BankAccount account = new BankAccount(); 
            account.accountNumber = this.accountNumber;
            account.owner = this.owner;
            ...
            return account;
        }
    }
} 
```

内部类：内部类的一个常见用途是定义一个事件处理程序。 [https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html](https://docs.oracle.com/javase/tutorial/uiswing/events/generalrules.html)

对于MyClass，我们使用内部类，主要是因为：

1.  内部类 MyAdapter 需要访问外部类成员。

2.  在示例中，MyAdapter 仅与 MyClass 关联。没有其他类与 MyAdapter 相关。所以最好在不使用名称约定的情况下将它们组织在一起

```
public class MyClass extends Applet {
    ...
        someObject.addMouseListener(new MyAdapter());
    ...
    class MyAdapter extends MouseAdapter {
        public void mouseClicked(MouseEvent e) {
            ...// Event listener implementation goes here...
            ...// change some outer class instance property depend on the event
        }
    }
} 
```

* * *

## 回答 #19

> 赞同：4
> 
> 时间：2012-03-28T09:09:28.190

我认为这里的人们应该注意到海报：静态嵌套类只是第一个内部类。例如：

```
 public static class A {} //ERROR

 public class A {
     public class B {
         public static class C {} //ERROR
     }
 }

 public class A {
     public static class B {} //COMPILE !!!

 } 
```

因此，总而言之，静态类不依赖于它包含的类。所以，他们不能在正常的课堂上。（因为普通类需要一个实例）。

* * *

## 回答 #20

> 赞同：4
> 
> 时间：2016-12-02T17:00:09.227

当我们在类内部声明静态成员类时，它被称为顶级嵌套类或静态嵌套类。可以证明如下：

```
class Test{
    private static int x = 1;
        static class A{
        private static int y = 2;
        public static int getZ(){
            return B.z+x;
        }
    }
    static class B{
        private static int z = 3;
        public static int getY(){
            return A.y;
        }
    }
}

class TestDemo{
     public static void main(String[] args){
        Test t = new Test();
        System.out.println(Test.A.getZ());
        System.out.println(Test.B.getY());
    }
} 
```

当我们在一个类中声明非静态成员类时，它被称为内部类。内部类可以演示如下：

```
 class Test{
        private int i = 10;
        class A{
            private int i =20;
            void display(){
            int i = 30;
            System.out.println(i);
            System.out.println(this.i);
            System.out.println(Test.this.i);
        }
    }
} 
```

* * *

## 回答 #21

> 赞同：4
> 
> 时间：2019-12-06T20:52:24.003

一张图

[![在此处输入图像描述](https://i.stack.imgur.com/4zgFn.png)](https://i.stack.imgur.com/4zgFn.png)

`static nested`和`non-static nested`类之间的主要区别在于`static nested` **它不能**访问非静态外部类成员

* * *

## 回答 #22

> 赞同：3
> 
> 时间：2017-01-03T23:10:14.410

以下是`static nested class`和的示例`inner class`：

**外部类.java**

```
public class OuterClass {
     private String someVariable = "Non Static";

     private static String anotherStaticVariable = "Static";  

     OuterClass(){

     }

     //Nested classes are static
     static class StaticNestedClass{
        private static String privateStaticNestedClassVariable = "Private Static Nested Class Variable"; 

        //can access private variables declared in the outer class
        public static void getPrivateVariableofOuterClass(){
            System.out.println(anotherStaticVariable);
        }
     }

     //non static
     class InnerClass{

         //can access private variables of outer class
         public String getPrivateNonStaticVariableOfOuterClass(){
             return someVariable;
         }
     }

     public static void accessStaticClass(){
         //can access any variable declared inside the Static Nested Class 
         //even if it private
         String var = OuterClass.StaticNestedClass.privateStaticNestedClassVariable; 
         System.out.println(var);
     }

} 
```

**外部类测试：**

```
public class OuterClassTest {
    public static void main(String[] args) {

        //access the Static Nested Class
        OuterClass.StaticNestedClass.getPrivateVariableofOuterClass();

        //test the private variable declared inside the static nested class
        OuterClass.accessStaticClass();
        /*
         * Inner Class Test
         * */

        //Declaration

        //first instantiate the outer class
        OuterClass outerClass = new OuterClass();

        //then instantiate the inner class
        OuterClass.InnerClass innerClassExample =  outerClass. new InnerClass();

        //test the non static private variable
        System.out.println(innerClassExample.getPrivateNonStaticVariableOfOuterClass()); 

    }

} 
```

* * *

## 回答 #23

> 赞同：0
> 
> 时间：2013-09-10T14:06:33.290

首先，没有这样的类称为静态类。与内部类（称为嵌套类）一起使用的静态修饰符表示它是外部类的静态成员，这意味着我们可以像访问其他静态成员一样访问它，而无需任何外部类的实例。（这本来是静态的好处。）

使用嵌套类和常规内部类之间的区别是：

```
OuterClass.InnerClass inner = new OuterClass().new InnerClass(); 
```

首先我们可以实例化 Outerclass 然后我们可以访问 Inner。

但是如果 Class 是嵌套的，那么语法是：

```
OuterClass.InnerClass inner = new OuterClass.InnerClass(); 
```

它使用静态语法作为静态关键字的正常实现。

* * *

## 回答 #24

> 赞同：0
> 
> 时间：2018-12-12T06:28:45.040

Java 编程语言允许您在另一个类中定义一个类。这样的类称为嵌套类，如下所示：

```
class OuterClass {
...
class NestedClass {
    ...
    }
} 
```

嵌套类分为两类：静态和非静态。声明为静态的嵌套类称为静态嵌套类。非静态嵌套类称为内部类。我们应该记住的一件事是非静态嵌套类（内部类）可以访问封闭类的其他成员，即使它们被声明为私有。静态嵌套类只能访问封闭类的其他成员（如果它们是静态的）。它不能访问外部类的非静态成员。与类方法和变量一样，静态嵌套类与其外部类相关联。例如，要为静态嵌套类创建对象，请使用以下语法：

```
OuterClass.StaticNestedClass nestedObject =
 new OuterClass.StaticNestedClass(); 
```

要实例化内部类，您必须先实例化外部类。然后，使用以下语法在外部对象中创建内部对象：

```
OuterClass.InnerClass innerObject = new OuterClass().new InnerClass(); 
```

为什么我们使用嵌套类

1.  这是一种对仅在一个地方使用的类进行逻辑分组的方法。
2.  它增加了封装。
3.  它可以导致更可读和可维护的代码。

资料来源：[Java™ 教程 - 嵌套类](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html)

* * *

## 回答 #25

> 赞同：0
> 
> 时间：2021-04-14T01:06:26.390

除了已经提到的那些，嵌套类的另一个用例是嵌套类具有只能从外部类访问的方法。这是可能的，因为外部类可以访问嵌套类的私有构造函数、字段和方法。

在下面的示例中，`Bank`可以发出具有私有构造函数的 a ，并且可以使用 的私有实例方法`Bank.CreditCard`根据当前银行政策更改信用卡的限额。（在这种情况下，对实例变量的直接字段访问也可以使用）。从任何其他类只能访问公共方法。`setLimit(...)``Bank.CreditCard``limit``Bank.CreditCard`

```
public class Bank {

    // maximum limit as per current bank policy
    // is subject to change
    private int maxLimit = 7000;

    // ------- PUBLIC METHODS ---------

    public CreditCard issueCard(
            final String firstName,
            final String lastName
    ) {
        final String number = this.generateNumber();
        final int expiryDate = this.generateExpiryDate();
        final int CVV = this.generateCVV();
        return new CreditCard(firstName, lastName, number, expiryDate, CVV);
    }

    public boolean setLimit(
            final CreditCard creditCard,
            final int limit
    ) {
        if (limit <= this.maxLimit) {    // check against current bank policy limit
            creditCard.setLimit(limit);  // access private method Bank.CreditCard.setLimit(int)
            return true;
        }
        return false;
    }

    // ------- PRIVATE METHODS ---------

    private String generateNumber() {
        return "1234-5678-9101-1123";   // the numbers should be unique for each card
    }

    private int generateExpiryDate() {
        return 202405;                  // date is YYYY=2024, MM=05
    }

    private int generateCVV() {
        return 123;                     // is in real-life less predictable
    }

    // ------- PUBLIC STATIC NESTED CLASS ---------

    public static final class CreditCard {
        private final String firstName;
        private final String lastName;
        private final String number;
        private final int expiryDate;
        private final int CVV;

        private int balance;
        private int limit = 100; // default limit

        // the constructor is final but is accessible from outer class
        private CreditCard(
                final String firstName,
                final String lastName,
                final String number,
                final int expiryDate,
                final int CVV
        ) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.number = number;
            this.expiryDate = expiryDate;
            this.CVV = CVV;
        }

        // ------- PUBLIC METHODS ---------

        public String getFirstName() {
            return this.firstName;
        }

        public String getLastName() {
            return this.lastName;
        }

        public String getNumber() {
            return this.number;
        }

        public int getExpiryDate() {
            return this.expiryDate;
        }

        // returns true if financial transaction is successful
        // otherwise false
        public boolean charge(final int amount) {
            final int newBalance = this.balance - amount;
            if (newBalance < -this.limit) {
                return false;
            }
            this.balance = newBalance;
            return true;
        }

        // ------- PRIVATE METHODS ---------

        private int getCVV() {
            return this.CVV;
        }

        private int getBalance() {
            return this.balance;
        }

        private void setBalance(final int balance) {
            this.balance = balance;
        }

        private int getLimit() {
            return limit;
        }

        private void setLimit(final int limit) {
            this.limit = limit;
        }
    }
} 
```

* * *

## 回答 #26

> 赞同：0
> 
> 时间：2022-02-13T05:10:57.030

静态嵌套类访问它们定义的类的 PRIVATE 类级静态变量。从体系结构的角度来看，这可能是巨大的（即服务定位器模式在服务中使用嵌套静态帮助器类），并且可以帮助 OP 了解它们为什么存在内部类。

* * *

## 回答 #27

> 赞同：-1
> 
> 时间：2016-09-23T21:40:09.710

不同之处在于，同样是静态的嵌套类声明可以在封闭类之外实例化。

*当您有一个非*静态的嵌套类声明（也称为*内部类*）时，Java 不会让您实例化它，除非通过封闭类。从内部类创建的对象链接到从外部类创建的对象，因此内部类可以引用外部类的字段。

但如果它是静态的，则链接不存在，无法访问外部字段（除了像任何其他对象一样通过普通引用），因此您可以自己实例化嵌套类。

* * *

## 回答 #28

> 赞同：-2
> 
> 时间：2017-10-10T10:25:06.667

我已经说明了 Java 代码中可能发生的各种可能的正确和错误场景。

```
 class Outter1 {

        String OutStr;

        Outter1(String str) {
            OutStr = str;
        }

        public void NonStaticMethod(String st)  {

            String temp1 = "ashish";
            final String  tempFinal1 = "ashish"; 

            //  below static attribute not permitted
            // static String tempStatic1 = "static";    

            //  below static with final attribute not permitted         
            // static final String  tempStatic1 = "ashish";  

            // synchronized keyword is not permitted below          
            class localInnerNonStatic1 {            

                synchronized    public void innerMethod(String str11) {
                    str11 = temp1 +" sharma";
                    System.out.println("innerMethod ===> "+str11);
                }

                /* 
        //  static method with final not permitted
          public static void innerStaticMethod(String str11) { 

                    str11 = temp1 +" india";
                    System.out.println("innerMethod ===> "+str11);
                }*/
            }

            // static class not permitted below
            //  static class localInnerStatic1 {   }                            

        }

        public static  void StaticMethod(String st)     {

            String temp1 = "ashish";
            final String  tempFinal1 = "ashish"; 

            // static attribute not permitted below
            //static String tempStatic1 = "static";     

            //  static with final attribute not permitted below
            // static final String  tempStatic1 = "ashish";                         

            class localInnerNonStatic1 {
                public void innerMethod(String str11) {
                    str11 = temp1 +" sharma";
                    System.out.println("innerMethod ===> "+str11);
                }

                /*
    // static method with final not permitted
    public static void innerStaticMethod(String str11) {  
                    str11 = temp1 +" india";
                    System.out.println("innerMethod ===> "+str11);
                }*/
            }

            // static class not permitted below
            //  static class localInnerStatic1 {   }    

        }

        // synchronized keyword is not permitted
        static  class inner1 {          

            static String  temp1 = "ashish";
            String  tempNonStatic = "ashish";
            // class localInner1 {

            public void innerMethod(String str11) {
                str11 = temp1 +" sharma";
                str11 = str11+ tempNonStatic +" sharma";
                System.out.println("innerMethod ===> "+str11);
            }

            public static void innerStaticMethod(String str11) {
                //  error in below step
                str11 = temp1 +" india";    
                //str11 = str11+ tempNonStatic +" sharma";
                System.out.println("innerMethod ===> "+str11);
            }
            //}
        }

        //synchronized keyword is not permitted below
        class innerNonStatic1 {             

//This is important we have to keep final with static modifier in non
// static innerclass below
            static final String  temp1 = "ashish";  
            String  tempNonStatic = "ashish";
            // class localInner1 {

            synchronized    public void innerMethod(String str11) {
                tempNonStatic = tempNonStatic +" ...";
                str11 = temp1 +" sharma";
                str11 = str11+ tempNonStatic +" sharma";
                System.out.println("innerMethod ===> "+str11);
            }

            /*
            //  error in below step
            public static void innerStaticMethod(String str11) {   
                            //  error in below step
                            // str11 = tempNonStatic +" india";                     
                            str11 = temp1 +" india";
                            System.out.println("innerMethod ===> "+str11);
                        }*/
                    //}
                }
    } 
```

# c# - Zlib 兼容的压缩流？

> ID：70347
> 
> 赞同：13
> 
> 时间：2008-09-16T08:25:33.817
> 
> 标签：c#, compression, zlib

System.IO.Compression.GZipStream 或 System.IO.Compression.Deflate 是否与 zlib 压缩兼容？

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2010-02-25T01:46:52.613

我遇到了 Git 对象的这个问题。在这种特殊情况下，它们将对象存储为带有 Zlib 标头的压缩 blob，该标头记录在[RFC 1950](http://www.ietf.org/rfc/rfc1950.txt)中。您可以通过制作包含以下内容的文件来制作兼容的 blob：

*   带有值的两个标头字节（来自 RFC 1950 的 CMF 和 FLG）`0x78 0x01`
    *   `CM`= 8 = 放气
    *   `CINFO`= 7 = 32Kb 窗口
    *   `FCHECK`= 1 = 此标头的校验和位
*   C#的输出`DeflateStream`
*   输入数据的 Adler32 校验和，`DeflateStream`大端格式（MSB 优先）

我做了自己的 Adler 实现

```
public class Adler32Computer
{
    private int a = 1;
    private int b = 0;

    public int Checksum
    {
        get
        {
            return ((b * 65536) + a);
        }
    }

    private static readonly int Modulus = 65521;

    public void Update(byte[] data, int offset, int length)
    {
        for (int counter = 0; counter < length; ++counter)
        {
            a = (a + (data[offset + counter])) % Modulus;
            b = (b + a) % Modulus;
        }
    }
} 
```

差不多就是这样。

* * *

## 回答 #2

> 赞同：15
> 
> 时间：2009-03-06T16:10:58.407

[DotNetZip](http://dotnetzip.codeplex.com)包括一个 DeflateStream、一个 ZlibStream 和一个 GZipStream，用于处理 RFC 1950、1951 和 1952。它们都使用 DEFLATE 算法，但每个帧和标题字节都不同。

作为一个优势，DotNetZip 中的流在压缩下不会表现出[数据大小扩展的异常，](https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=93930)这是针对内置流报告的。此外，没有内置的 ZlibStream，而 DotNetZip 为您提供了它，以便与 zlib 进行良好的互操作。

* * *

## 回答 #3

> 赞同：10
> 
> 时间：2008-09-16T09:18:21.490

来自[MSDN](http://msdn.microsoft.com/en-us/library/system.io.compression.gzipstream.aspx)关于 System.IO.Compression.GZipStream：

> 此类表示 gzip 数据格式，它使用行业标准算法进行无损文件压缩和解压缩。

从[zlib 常见问题解答](http://www.gzip.org/zlib/zlib_faq.html)：

> 另一方面，zlib 中的 gz* 函数使用 gzip 格式。

所以 zlib 和 GZipStream 应该是可互操作的，但前提是你使用 zlib 函数来处理 gzip 格式。

据报道 System.IO.Compression.Deflate 和 zlib 不可互操作。

如果您需要处理 zip 文件（您可能不需要，但其他人可能需要它），您需要使用[SharpZipLib](http://www.icsharpcode.net/OpenSource/SharpZipLib/Default.aspx)或其他第三方库。

* * *

## 回答 #4

> 赞同：6
> 
> 时间：2008-09-16T14:20:42.917

我使用 GZipStream 压缩来自 .NET XmlSerializer 的输出，并且使用 gunzip（在 cygwin 中）、winzip 和另一个 GZipStream 解压缩结果非常好。

作为参考，这是我在代码中所做的：

```
FileStream fs = new FileStream(filename, FileMode.Create, FileAccess.Write);
using (GZipStream gzStream = new GZipStream(fs, CompressionMode.Compress))
{
  XmlSerializer serializer = new XmlSerializer(typeof(MyDataType));
  serializer.Serialize(gzStream, myData);
} 
```

然后，在c#中解压

```
FileStream fs = new FileStream(filename, FileMode.Open, FileAccess.Read);
using (Stream input = new GZipStream(fs, CompressionMode.Decompress))
{
   XmlSerializer serializer = new XmlSerializer(typeof(MyDataType));
   myData = (MyDataType) serializer.Deserialize(input);
} 
```

在 cygwin 中使用“文件”实用程序表明，使用 GZipStream 和 GNU GZip 压缩的同一文件之间确实存在差异（可能是其他人在此线程中所述的标题信息）。然而，这种差异在实践中似乎并不重要。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-16T08:34:48.693

gzip 是 deflate + 一些页眉/页脚数据，如校验和和长度等。因此，从一种方法可以使用另一种方法的流的意义上说，它们不兼容，但它们采用相同的压缩算法。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-16T08:28:49.877

他们只是使用 zlib 或 deflate 算法压缩数据，但不提供某些特定文件格式的输出。这意味着如果您将流按原样存储到硬盘驱动器，您很可能无法使用某些应用程序（gzip 或 winrar）打开它，因为文件头（幻数等）不包含在流中，您应该自己写。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2015-04-29T07:14:18.923

从 .NET Framework 4.5 开始，`System.IO.Compression.DeflateStream`该类使用 zlib 库。

来自班级的[MSDN 文章](https://msdn.microsoft.com/en-us/library/system.io.compression.deflatestream(v=vs.110).aspx)：

> 该类代表 Deflate 算法，它是无损文件压缩和解压缩的行业标准算法。从 .NET Framework 4.5 开始，DeflateStream 类使用 zlib 库。因此，它提供了更好的压缩算法，并且在大多数情况下，它提供的压缩文件比它在早期版本的 .NET Framework 中提供的更小。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-16T08:31:52.380

我同意安德烈亚斯。您可能无法在外部工具中打开该文件，但如果该工具需要一个流，您或许可以使用它。您还可以使用相同的压缩类将文件放回去。

# asp.net - ASP.NET 自定义控件样式

> ID：70361
> 
> 赞同：3
> 
> 时间：2008-09-16T08:29:06.117
> 
> 标签：asp.net, styles, custom-server-controls

我正在着手处理几个 ASP.NET 自定义控件。我想知道我是否可以就您如何将样式应用于控件的想法获得一些意见。

我宁愿把它推到 CSS 上，所以对于我过去做过的几个控件，我只是简单地粘贴了一个字符串属性，它允许你输入字符串，然后在渲染时将其挂在“*样式”属性中。*我知道我也可以使用“ **CSSClass** ”属性并应用“ *class* ”属性。

**在创建“正确的” Style**属性（您实际保存样式对象并使用设计器指定其值）的方式上，我没有做太多工作。这对我来说似乎需要做很多工作，而且 TBH，我讨厌样式编辑器 UI，更愿意输入 CSS/类名来应用..

## 您对此有何看法？

* * *

**注意：**这是一种主观的 - 所以要清楚：

**接受的答案将是：**

*   提供各种方法的优缺点。
*   欢迎发表意见，但好的答案应该是建设性的。
*   用一些现实世界的知识/经验来支持它。

主观性没有错*。***_** 人们主观*而不*思考，建设性或实际上提供一些洞察力和经验**是有问题**的。

 ******>>不要<<**将此标记为“主观”-该标记是浪费时间。“主观”不是人们会寻找的技术或类别。解决问题而不是刷掉它。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-16T08:41:11.813

这将取决于自定义控件的使用方式 - 商业的、可重新分发的控件应该与 VS IDE 兼容，并且在实现控件时按照用户期望的方式运行。

另一方面，如果您或您的团队是唯一使用该控件的人，那么浪费大量时间来使样式生效是没有意义的，只要它的样式以合理的方式工作即可。

我实现的大多数自定义控件都使用一个属性来定义控件的外观和感觉，或者只是公开控件的成员自己的 CSSClass 属性。

争论归结为一致性与时间 - 任何元素都应使用一致的样式机制，如果时间紧迫，则使用字符串方法，否则，实现更复杂/IDE友好的机制。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T08:44:13.927

我认为您应该考虑自定义控件的“目标市场”，例如，将使用它的人。

如果它是内部自定义控件，您几乎可以强制使用其中一个：如果它是公司内部的，您将有能力强制执行其一致性。

但是，如果它用于商业消费，则需要您提供一个选项以提供一种使用样式或类的方法。恰当的例子：[ASP.NET 站点导航控件](http://msdn.microsoft.com/en-us/library/e468hxky.aspx)，例如，SiteMapPath、Menu、Treeview。它们有一堆属性，允许样式、类或两者的组合出现在控件外观的各个方面。

# version-control - 签入时出现cvs错误

> ID：70366
> 
> 赞同：2
> 
> 时间：2008-09-16T08:30:42.197
> 
> 标签：version-control, cvs

添加新文件后尝试提交到 cvs 分支时出现此错误

```
Assertion failed: key != NULL, file hash.c, line 317 
```

知道如何解决它，以便我可以检查我的代码吗？
服务器和客户端都是 Linux，并且涉及到预提交。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T10:01:47.047

> 睡眠者写道：
> 
> > 不确定问题是什么，但我通过进入服务器并删除存储库中的文件 Attic/newfile.v 并再次添加它来解决它。

“阁楼”是 CVS 中删除文件所在的位置。在过去的某个时候，有人签入了 newfile.v，后来它被删除了，因此搬到了阁楼。

通过从存储库中删除 ,v 文件，您损坏了包含文件“newfile”的旧提交。不要这样做。

正确的方法是恢复被删除的文件，然后用新文件替换它的内容。

根据[http://www.cs.indiana.edu/~machrist/notes/cvs.html](http://www.cs.indiana.edu/~machrist/notes/cvs.html)

> 要恢复已从存储库中删除的文件，您基本上需要将该文件更新到其最新修订号（在实际删除之前）。例如：
> 
> cvs update -r 1.7 已删除文件
> 
> 这将在您的工作存储库中恢复 deleted_file。要查找已删除的文件及其最新修订号，请在命令提示符下发出 cvs log。

编辑回复评论以解释阁楼中的 ,v 文件的含义。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T09:07:59.160

您是否在 Windows 上，您是否将文件重命名为具有不同大小写的相同名称（例如 MAKEFILE vs Makefile vs makefile）？CVS 曾经遇到过这个问题（也许现在仍然存在？）：

OSDir/mailarchive -[主题：回复：hash.c.312：findnode：](http://osdir.com/ml/version-control.cvs.bugs/2003-01/msg00092.html)

> 马努写道：
> 
> > 我尝试在我的 cvs 树中将“makefile”重命名为“Makefile”，然后：

```
cvs: hash.c:312: findnode: Assertion `key != ((void *)0)' failed.
cvs [server aborted]: received abort signal 
```

> CVS 从来没有被设计用来处理不区分大小写的文件系统。它已被修补到它主要工作的地步，但仍有一些地方不能工作。这是其中之一。

您可能还想阅读线程中的其余消息。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T09:30:19.277

不确定问题是什么，但我通过进入服务器并删除存储库中的文件 Attic/newfile.v 并再次添加它来解决它。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T08:44:25.487

也许对您的存储库有某种预提交检查，请参见[此处](http://ximbiot.com/cvs/manual/cvs-1.12.13/cvs_18.html#SEC188)

# asp.net-mvc - Asp.net MVC路由不明确，同一页面的两条路径

> ID：70371
> 
> 赞同：5
> 
> 时间：2008-09-16T08:31:30.743
> 
> 标签：asp.net-mvc, routing

我正在尝试 ASP.NET MVC 路由，当然偶然发现了一个问题。我有一个部分，/Admin/Pages/，这也可以通过 /Pages/ 访问，这是不应该的。我会错过什么？

global.asax 中的路由代码：

```
public static void RegisterRoutes(RouteCollection routes)
{
        routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
        routes.MapRoute(
            "Pages",    // Route name
            "Admin/Pages/{action}/{id}",  // URL with parameters
            // Parameter defaults
            new { controller = "Pages", action = "Index", id = "" }  
        );

        routes.MapRoute(
            "Default",   // Route name
            "{controller}/{action}/{id}",   // URL with parameters
             // Parameter defaults
            new { controller = "Home", action = "Index", id = "" }  
        );

    } 
```

谢谢！

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-16T08:36:06.100

我建议在开头为 /Pages/ 添加一个显式路由。

问题是它由默认路由处理并派生：

控制器 =“页面”操作 =“索引”ID =“”

这与您的 Admin 路由的参数完全相同。

* * *

## 回答 #2

> 赞同：7
> 
> 时间：2008-09-18T16:02:15.293

对于这样的路由问题，您应该尝试我的[Route Debugger](http://haacked.com/archive/2008/03/13/url-routing-debugger.aspx)程序集（仅在测试中使用）。它可以帮助找出这些类型的问题。

PS 如果您尝试保护 Pages 控制器，请确保使用 [Authorize] 属性。不要只依赖 URL 授权。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-16T08:53:07.633

您可以将约束添加到默认规则，以便 {Controller} 标记不能是“页面”。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-17T07:02:18.703

您的第一个路由 {action} 令牌/参数与默认操作的设置相冲突。尝试更改路由中的参数名称，或删除默认操作名称。

# visual-studio - 删除 VSMacros80 目录

> ID：70377
> 
> 赞同：12
> 
> 时间：2008-09-16T08:32:09.463
> 
> 标签：visual-studio, visual-studio-2005

有什么方法可以阻止 Visual Studio 在我的默认项目目录中创建 VSMacros80 文件夹？

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2008-09-16T10:49:29.540

我自己刚刚发现：如果您在*项目文件夹*设置中添加尾部反斜杠，例如将其从 更改`C:\dev`为，则将不再创建`C:\dev\`该目录。`VSMacros80`

我使用 Visual Studio 2005 SP1 对其进行了测试，并安装了所有 Windows 更新。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T09:36:04.987

对不起我错了。将始终创建此目录。您只能在项目位置的选项/项目和解决方案/常规屏幕中设置它的路径。

但要小心，因为这也意味着你的标准项目目录将是这个目录。您无法避免 VS 创建此目录。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2010-11-23T16:18:09.817

将文件标记为“隐藏”。Visual Studio 不会弄乱可见性设置（或者，至少，当我在 2010 年这样做时没有）。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T08:56:06.533

我找不到上一个线程，因为我正在搜索“vsmacros”而不是“vsmacros80”。

目前有5个不同的条目`Tools->Options->Addin/Macro Security`

```
%ALLUSERSPROFILE%\Application Data\Microsoft\MsEnvShared\Addins
%APPDATA%\Microsoft\MsEnvShared\Addins
%VSAPPDATA%\Addins
%VSCOMMONAPPDATA%\Addins
%VSMYDOCUMENTS%\Addins 
```

你能告诉我我必须删除哪一个吗？

# mfc - MFC Feature Pack 类菜单上的图标

> ID：70386
> 
> 赞同：8
> 
> 时间：2008-09-16T08:34:36.460
> 
> 标签：mfc, mfc-feature-pack

在新的 MFC 功能（功能包）中，菜单出现在三个位置：

*   在菜单栏中 (CMFCMenuBar)
*   在弹出菜单中 (CMFCPopupMenu)
*   在 CMFCButton 的“下拉菜单”版本中

我想将图标（高颜色和透明）放在所有菜单中。我找到了 CFrameWndEx::OnDrawMenuImage() ，我可以用它来自定义在菜单栏项目前面绘制图标。这不是很方便，必须在2008年实现图标绘制，但它可以工作。对于其他人，我还没有找到解决方案。是否有一种自动设置菜单图标的方法？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2009-07-31T16:36:14.847

这就是我让它工作的方式：

### 第一的

，正如其他人所说，在主工具栏旁边创建一个不可见的工具栏（我使用基于 AppWizard 名称的常用名称）：

```
MainFrm.h:
class CMainFrame
{
    //...    
    CMFCToolBar m_wndToolBar;
    CMFCToolBar m_wndInvisibleToolBar;
    //...
};

MainFrm.cpp:
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    //...

    // Normal, visible toolbar
    if(m_wndToolBar.Create(this,
        TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC))
    {
        VERIFY( m_wndToolBar.LoadToolBar(
            theApp.m_bHiColorIcons ? IDR_MAINFRAME_256 : IDR_MAINFRAME) );

        // Only the docking makes the toolbar visible
        m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
        DockPane(&m_wndToolBar);
    }

    // Invisible toolbar; simply calling Create(this) seems to be enough
    if(m_wndInvisibleToolBar.Create(this))
    {
        // Just load, no docking and stuff
        VERIFY( m_wndInvisibleToolBar.LoadToolBar(IDR_OTHERTOOLBAR) );
    }
} 
```

### 二：图片和工具栏资源

`IDR_MAINFRAME`并由`IDR_MAINFRAME_256`AppWizard 生成。前者是丑16色版，后者是趣味高彩版。
尽管它的名字，如果我没记错的话，即使是 AppWizard 生成的图像也有 24 位色深。很酷的事情：只需用 32 位图像替换它，这也可以。

有不可见的工具栏`IDR_OTHERTOOLBAR`：我用资源编辑器创建了一个工具栏。只是一些虚拟图标和命令 ID。然后 VS 生成了一个位图，我用我的高彩版本替换了它。完毕！

### 笔记

不要使用资源编辑器打开工具栏：它可能必须先将其转换为 4 位，然后才能对其进行任何操作。即使*你*让它这样做（因为在 Visual Studio 的背后，你会再次用高彩色图像替换结果，哈！），我发现它（有时？）根本无法编辑工具栏。很奇怪。
在这种情况下，我建议直接编辑 .rc 文件。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T14:06:46.757

我相信（但我可能错了）这些类与 Microsoft 购买 BCG 时包含在 MFC 中的 BCGToolbar 类相同。如果是这样，您可以创建一个工具栏，并在工具栏按钮上使用与要为其创建图标的菜单项中相同的 ID，并且它们应该会自动出现。当然，您不必实际显示工具栏。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-18T14:24:04.140

在 BCGToolbar 中，只需在资源中创建工具栏并加载它（但不显示窗口）就足够了，但工具栏按钮必须与您要链接到的菜单项具有相同的 ID。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2009-08-06T16:13:42.730

尝试使用此功能：

```
CMFCToolBar::AddToolBarForImageCollection(UINT uiResID,
   UINT uiBmpResID=0,
   UINT uiColdResID=0,
   UINT uiMenuResID=0,
   UINT uiDisabledResID=0,
   UINT uiMenuDisabledResID=0); 
```

所以例如：

```
CMFCToolBar::AddToolBarForImageCollection(IDR_TOOLBAROWNBITMAP_256); 
```

对我来说效果很好。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2009-04-23T23:09:25.910

令人惊讶的一件事是，对于可定制（即非锁定）工具栏，您制作的第一个工具栏，框架分解并变成程序中所有图标的某种调色板位图。如果您稍后尝试添加更多工具栏（或不同的工具栏），这些工具栏的位图（或 png）的颜色深度与第一个不同，它们似乎会失败，因为它无法将它们添加到同一个调色板中。

# windows - 什么是最简单的 Tomcat/Apache 连接器 (Windows)？

> ID：70389
> 
> 赞同：3
> 
> 时间：2008-09-16T08:34:53.387
> 
> 标签：windows, apache, tomcat, connector

我在 Windows XP 机器上运行 apache 2.2 和 tomcat 5.5。

哪个 tomcat/apache 连接器最容易设置并且有据可查？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T09:03:40.463

`[mod_proxy_ajp](http://httpd.apache.org/docs/2.2/mod/mod_proxy.html)`如果您使用的是 Apache 2.2，这将是最容易使用的。它是 Apache 发行版的一部分，因此您无需安装任何其他软件。

在您的`httpd.conf`中，您需要确保`mod_proxy`并`mod_proxy_ajp`已加载：

```
LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_ajp_module 模块/mod_proxy_ajp.so

```

然后您可以使用[ProxyPass](http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#proxypass)和[ProxyPassReverse](http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#proxypassreverse)指令，如下所示：

```
ProxyPass /portal ajp://localhost:8009/portal
ProxyPassReverse /portal ajp://localhost:8009/portal

```

您应该查阅 Apache 2.2 文档以获取可用指令的完整目录。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T08:43:20.280

`mod_jk`，或者只是使用`mod_proxy`，即使它不是真正的 Tomcat 连接器。

# version-control - 是否有可以管理大文件的分布式 VCS？

> ID：70392
> 
> 赞同：14
> 
> 时间：2008-09-16T08:35:24.337
> 
> 标签：version-control, dvcs, large-files

是否有可以处理大于可用 RAM 的文件的分布式版本控制系统（git、bazaar、mercurial、darcs 等）？

我需要能够提交大型二进制文件（即数据集、源视频/图像、档案），但我不需要能够区分它们，只需能够提交然后在文件更改时更新。

我上次看这个大约是一年前，没有一个明显的候选人允许这样做，因为它们都是为了速度而设计的。这给我留下了一个用于管理代码的 VCS 和用于大文件的其他东西（“资产管理”软件或只是 rsync 和脚本），当两者的目录结构重叠时，这非常难看。

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2011-11-03T08:00:57.900

我问这个问题已经 3 年了，但是，从 2.0 版开始，Mercurial 包括[largefiles 扩展名](https://www.mercurial-scm.org/wiki/LargefilesExtension)，它完成了我最初寻找的内容：

> largefiles 扩展允许在 Mercurial 中跟踪大型、不可压缩的二进制文件，而不需要过多的带宽来进行克隆和拉取。Mercurial 不会直接跟踪作为大文件添加的文件；相反，它们的修订由校验和标识，Mercurial 会跟踪这些校验和。这样，当您克隆存储库或拉入变更集时，不需要存储库旧版本中的大文件，而只下载需要更新到当前版本的文件。这节省了磁盘空间和带宽。

* * *

## 回答 #2

> 赞同：10
> 
> 时间：2008-09-16T11:44:11.733

没有免费的分布式版本控制系统支持这一点。如果你想要这个特性，你必须实现它。

您可以注销 git：他们对 Linux 内核开发用例的原始性能感兴趣。他们不可能接受在扩展到大型二进制文件时的性能权衡。我不了解 Mercurial，但他们似乎做出了与 git 类似的选择，将其操作模型与存储模型耦合以提高性能。

原则上，Bazaar 应该能够使用实现树/分支/存储库格式的插件来支持您的用例，其磁盘存储和实现策略已针对您的用例进行了优化。如果内部架构阻碍了你，而你发布了有用的代码，我希望核心开发人员会帮助修复内部架构。此外，您可以与 Canonical 签订功能开发合同。

不管具体的 DVCS 是什么，可能最实用的方法是构建一个混合系统：实现一个大文件存储，并将对该存储中的 blob 的引用存储到您选择的 DVCS 中。

全面披露：我是 Canonical 的前雇员，与 Bazaar 开发人员密切合作。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2010-03-30T12:48:47.003

是的，[塑料单片机](http://www.plasticscm.com)。它是分布式的，它管理 4Mb 块中的大文件，因此它不受任何时候必须将它们完全加载到内存上的限制。在此处查找有关 DVCS 的教程：http: [//codicesoftware.blogspot.com/2010/03/distributed-development-for-windows.html](http://codicesoftware.blogspot.com/2010/03/distributed-development-for-windows.html)

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2012-06-18T15:41:37.717

BUP 可能是您正在寻找的。它是作为 git 备份功能的扩展而构建的，但这实际上是一回事。它将文件分成块并使用滚动哈希使文件内容可寻址/有效存储。

*   [https://github.com/bup/bup](https://github.com/bup/bup)
*   [http://blogs.kde.org/node/4440](http://blogs.kde.org/node/4440)

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-16T08:45:36.700

我认为在任何形式的版本控制系统中存储二进制文件都是低效的。

更好的想法是将元数据文本文件存储在引用二进制对象的存储库中。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-16T08:50:52.740

一定要分发吗？据推测，颠覆对较新的分布式 VCS 的一大好处是其处理二进制文件的卓越能力。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2017-07-08T02:15:13.800

我得出的结论是，在这种情况下，最好的解决方案是使用 ZFS。

是的，ZFS 不是 DVCS，但是：

*   您可以通过创建新 FS 为存储库分配空间
*   您可以通过创建快照来跟踪更改
*   您可以将快照（提交）发送到另一个 ZFS 数据集

# ruby-on-rails - 包含数据库和非数据库数据源的 Rails 模型应该如何分解？

> ID：70397
> 
> 赞同：2
> 
> 时间：2008-09-16T08:36:12.993
> 
> 标签：ruby-on-rails, ruby

所以我正在开发一个 Rails 应用程序来感受整个事情。我有`Product`一个标准 ActiveRecord 模型的模型。但是，我还想从 Amazon ECS 获得一些额外的产品信息。所以我的完整模型从数据库中获取一些信息，从网络服务中获取一些信息。我的问题是，我应该：

1.  将两个模型制作为 Product 和 ProductAWS，然后在控制器级别将它们绑定在一起。

2.  Product ActiveRecord 模型是否包含执行所有 AWS 工作的 ProductAWS 对象？

3.  只需将所有 AWS 功能添加到我的产品模型中。

4.  ？？？

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2008-09-16T08:49:03.633

您可以使用`composed_of`ActiveRecord 中的关系。您使用您通过 AWS 管理的所有属性创建一个常规类，并指定您的 Product-class 由该类组成。ActiveRecord 将处理映射属性与此类的委托。

请参阅composed_of[的文档](http://api.rubyonrails.org/classes/ActiveRecord/Aggregations/ClassMethods.html#M001265)

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T08:55:11.717

@Menno

将[ActiveResource](http://wiki.rubyonrails.org/rails/pages/ActiveResource)用于 AWS-attributes 类怎么样？

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T19:43:21.207

与大多数事情一样：这取决于。你的每一个想法都有优点。如果是我，我会这样开始：

```
 class Product < ActiveRecord::Base
     has_one :aws_item
  end 
  class AWSItem 
     belongs_to :product
  end 
```

您想问自己的关键问题是：

**您是否只提供 AWS ECS 项目，还是提供其他产品？**如果您的产品与亚马逊无关，不关心 ASIN 等，那么 has_one 可能是您的选择。或者，更好的是，与 :vendable 接口的多态关系，以便您以后可以插入不同的扩展类型。

**仅仅是行为不同，还是数据也会有很大不同？**因为您可能要考虑：

> ```
> class Product < ActiveRecord::Base
> end 
> class AWSItem < Product
>   def do_amazon_stuff
>     ... 
>   end
> end 
> ```

**当 Amazon ECS 不可用时，您希望系统如何运行？**它应该抛出异常吗？还是应该依赖目录的本地缓存版本？

> ```
> class Product < ActiveRecord::Base
> 
> end
> 
> class ItemFetcher < BackgrounDRb::Rails
>    def do_work
>       # .... Make a cached copy of your ECS catalog here. 
>       # Copy the Amazon stuff into your local model
>    end
> end 
> ```

慢慢地走过这些问题，答案会变得更清晰。如果没有，请开始制作原型。祝你好运！

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T22:33:32.030

如果您从两个完全不同的来源（一方面是 ActiveRecord，另一方面是 Internet）检索数据，将这些作为单独的模型有很多好处。正如上面的海报所写，产品 has_one（或 has_many）：aws_item。

# algorithm - 为什么快速排序比归并排序更好？

> ID：70402
> 
> 赞同：392
> 
> 时间：2008-09-16T08:37:52.477
> 
> 标签：algorithm, sorting, language-agnostic, quicksort, mergesort

我在一次采访中被问到这个问题。它们都是 O(nlogn)，但大多数人使用 Quicksort 而不是 Mergesort。这是为什么？

* * *

## 回答 #1

> 赞同：313
> 
> 时间：2008-09-16T09:14:24.870

快速排序具有 O( *n* ² ) 最坏情况运行时间和 O( *n* log *n* ) 平均情况运行时间。但是，在许多情况下它都优于归并排序，因为许多因素会影响算法的运行时间，并且当将它们放在一起时，快速排序会胜出。

特别是，经常引用的排序算法运行时间是指对数据进行排序所需的比较次数或交换次数。这确实是一个很好的性能衡量标准，特别是因为它独立于底层硬件设计。然而，其他的东西——比如引用的局部性（即我们是否读取了很多可能在缓存中的元素？）——也在当前的硬件上扮演着重要的角色。特别是快速排序需要很少的额外空间并且表现出良好的缓存局部性，这使得它在许多情况下比合并排序更快。

此外，通过使用适当的枢轴选择，几乎可以完全避免快速排序的 O( *n* ² ) 最坏情况运行时间——例如随机选择它（这是一个很好的策略）。

在实践中，许多现代的快速排序实现（特别是 libstdc++'s `std::sort`）实际上是[introsort](http://en.wikipedia.org/wiki/Introsort)，其理论上的最坏情况是 O( *n* log *n* )，与归并排序相同。它通过限制递归深度并在超过 log *n*时切换到不同的算法（[堆排序](http://en.wikipedia.org/wiki/Heapsort)）来实现这一点。

 ** * *

## 回答 #2

> 赞同：302
> 
> 时间：2008-09-18T06:19:50.607

正如许多人所指出的，快速排序的平均案例性能比归并排序更快。 **但这**仅在您假设恒定时间按需访问任何内存时才成立。

在 RAM 中，这个假设通常并不算太糟糕（由于缓存的原因并不总是如此，但也不算太糟糕）。但是，如果您的数据结构足够大，可以存储在磁盘上，那么快速排序会因为您的平均磁盘每秒执行 200 次随机搜索而被*扼杀。*但是同一个磁盘可以毫无问题地按顺序读取或写入每秒兆字节的数据。这正是合并排序所做的。

因此，如果必须在磁盘上对数据进行排序，那么您真的非常想在合并排序上使用一些变体。（通常你快速排序子列表，然后开始将它们合并到某个大小阈值以上。）

此外，如果您必须对这种大小的数据集做*任何事情*，请认真考虑如何避免寻找磁盘。例如，这就是为什么标准建议是在数据库中加载大量数据之前删除索引，然后再重建索引。在加载期间维护索引意味着不断地寻找磁盘。相反，如果您删除索引，那么数据库可以通过首先对要处理的信息进行排序（当然使用合并排序！）然后将其加载到索引的 BTREE 数据结构中来重建索引。（BTREE 自然而然地保持有序，因此您可以从已排序的数据集中加载一个，而无需对磁盘进行几次搜索。）

在很多情况下，了解如何避免磁盘寻道使我使数据处理工作需要数小时而不是数天或数周。

* * *

## 回答 #3

> 赞同：96
> 
> 时间：2008-09-16T08:41:02.123

实际上，快速排序是 O(n ² )。它的*平均情况*运行时间是 O(nlog(n))，但*最坏情况*是 O(n ² )，当您在包含很少唯一项的列表上运行它时会发生这种情况。随机化需要 O(n)。当然，这不会改变最坏的情况，它只是防止恶意用户使您的排序花费很长时间。

快速排序更受欢迎，因为它：

1.  就地（MergeSort 需要与要排序的元素数量成线性关系的额外内存）。
2.  有一个小的隐藏常数。

* * *

## 回答 #4

> 赞同：34
> 
> 时间：2009-11-13T04:53:23.077

“然而大多数人使用 Quicksort 而不是 Mergesort。这是为什么呢？”

一个没有给出的心理原因仅仅是 Quicksort 的命名更巧妙。即良好的营销。

是的，具有三重分区的快速排序可能是最好的通用排序算法之一，但无法克服“快速”排序听起来比“合并”排序更强大的事实。

* * *

## 回答 #5

> 赞同：21
> 
> 时间：2008-09-17T02:09:41.417

正如其他人所指出的，快速排序的最坏情况是 O(n^2)，而合并排序和堆排序保持在 O(nlogn)。然而，在平均情况下，这三个都是 O(nlogn)；所以它们在绝大多数情况下都是可比的。

平均而言，使快速排序更好的是内部循环意味着将多个值与一个值进行比较，而在另外两个方面，每次比较时两个术语都不同。换句话说，快速排序的读取次数是其他两种算法的一半。在现代 CPU 上，性能很大程度上取决于访问时间，因此最终 Quicksort 最终成为一个很好的首选。

* * *

## 回答 #6

> 赞同：9
> 
> 时间：2008-09-16T08:47:45.633

我想补充一下到目前为止提到的三种算法（合并排序、快速排序和堆排序），只有合并排序是稳定的。也就是说，对于那些具有相同键的值，顺序不会改变。在某些情况下，这是可取的。

但是，说实话，在实际情况下，大多数人只需要良好的平均性能，而快速排序是......快速=）

所有排序算法都有其起伏。请参阅[Wikipedia 文章以了解排序算法](http://en.wikipedia.org/wiki/Sorting_algorithm#Classification)以获得良好的概述。

* * *

## 回答 #7

> 赞同：7
> 
> 时间：2008-09-16T08:42:10.967

来自[快速排序的维基百科条目](http://en.wikipedia.org/wiki/Quicksort)：

> 快速排序还与合并排序竞争，这是另一种递归排序算法，但具有最坏情况 Θ(nlogn) 运行时间的优势。与快速排序和堆排序不同，合并排序是一种稳定的排序，并且可以很容易地适用于对存储在慢速访问介质（如磁盘存储或网络附加存储）上的链表和非常大的列表进行操作。尽管可以编写快速排序来对链表进行操作，但如果没有随机访问，它通常会受到糟糕的枢轴选择的影响。归并排序的主要缺点是，在对数组进行操作时，它在最佳情况下需要 Θ(n) 辅助空间，而具有就地分区和尾递归的快速排序变体仅使用 Θ(logn) 空间。（请注意，在对链表进行操作时，归并排序只需要少量的、恒定数量的辅助存储。）

* * *

## 回答 #8

> 赞同：7
> 
> 时间：2008-09-16T09:13:40.597

[亩！](http://en.wikipedia.org/wiki/Mu_(negative)) 快速排序并不好，它非常适合于不同类型的应用程序，而不是合并排序。

> 如果速度至关重要，不能容忍最坏情况下的糟糕性能，并且有额外空间可用，则 Mergesort 值得考虑。[1](http://en.wikipedia.org/wiki/Mu_(negative))

你说他们«他们都是 O(nlogn) [...]»。这是错误的。«快速排序在最坏的情况下使用大约 n^2/2 比较。» [1](http://en.wikipedia.org/wiki/Mu_(negative)) .

然而，根据我的经验，最重要的属性是在使用具有命令式范式的编程语言时可以在排序时轻松实现顺序访问。

[1](http://en.wikipedia.org/wiki/Mu_(negative)) Sedgewick，算法

* * *

## 回答 #9

> 赞同：7
> 
> 时间：2015-09-25T03:50:16.243

我想在现有的很好的答案中添加一些关于 QuickSort 在偏离最佳情况时如何执行的数学以及这种情况的可能性有多大，我希望这将帮助人们更好地理解为什么 O(n^2) 情况不是真实的关注更复杂的快速排序实现。

除了随机访问问题之外，还有两个主要因素会影响 QuickSort 的性能，它们都与枢轴与被排序数据的比较方式有关。

1）数据中的少量键。所有相同值的数据集将在普通 2 分区 QuickSort 上以 n^2 次排序，因为除了枢轴位置之外的所有值每次都放在一侧。现代实现通过使用 3 分区排序等方法解决了这个问题。这些方法在 O(n) 时间内在所有相同值的数据集上执行。因此，使用这样的实现意味着具有少量键的输入实际上可以提高性能时间并且不再是问题。

2) 极差的枢轴选择会导致最坏情况的性能。在理想情况下，枢轴将始终使 50% 的数据更小，50% 的数据更大，因此在每次迭代期间输入将被分成两半。这给了我们 n 次比较和交换时间 log​​-2(n) 递归 O(n*logn) 时间。

**非理想枢轴选择对执行时间有多大影响？**

让我们考虑一个始终选择枢轴的情况，使得 75% 的数据位于枢轴的一侧。它仍然是 O(n*logn) 但现在日志的基数已更改为 1/0.75 或 1.33。更改基数时的性能关系始终是由 log(2)/log(newBase) 表示的常数。在这种情况下，该常数为 2.4。因此，这种枢轴选择质量需要的时间是理想值的 2.4 倍。

**这种情况恶化的速度有多快？**

在枢轴选择变得（始终）非常糟糕之前不会很快：

*   一侧 50%：（理想情况）
*   一侧 75%：2.4 倍
*   一侧 90%：6.6 倍
*   一侧 95%：13.5 倍
*   一侧 99%：69 倍

当我们在一侧接近 100% 时，执行的日志部分接近 n，整个执行渐近接近 O(n^2)。

在 QuickSort 的简单实现中，排序数组（对于第一个元素枢轴）或反向排序数组（对于最后一个元素枢轴）等情况将可靠地产生最坏情况的 O(n^2) 执行时间。此外，具有可预测枢轴选择的实现可能会受到旨在产生最坏情况执行的数据的 DoS 攻击。现代实现通过各种方法避免了这种情况，例如在排序前随机化数据，选择 3 个随机选择的索引的中位数等。在混合这种随机化的情况下，我们有 2 种情况：

*   小数据集。最坏的情况是合理的，但 O(n^2) 不是灾难性的，因为 n 足够小，以至于 n^2 也很小。
*   大数据集。理论上最坏的情况是可能的，但在实践中是不可能的。

**我们看到糟糕表现的可能性有多大？**

机会*微乎其微*。让我们考虑一种 5,000 个值：

我们假设的实现将使用 3 个随机选择的索引的中位数来选择一个枢轴。我们将把 25%-75% 范围内的支点视为“好”，将 0%-25% 或 75%-100% 范围内的支点视为“差”。如果您使用 3 个随机索引的中值查看概率分布，则每次递归都有 11/16 的机会以良好的支点结束。让我们做 2 个保守的（和错误的）假设来简化数学：

1.  好的支点总是恰好在 25%/75% 的比例上，并在 2.4*理想情况下运行。我们永远不会得到理想的分割或任何比 25/75 更好的分割。

2.  糟糕的支点总是最坏的情况，基本上对解决方案没有任何帮助。

我们的 QuickSort 实现将在 n=10 处停止并切换到插入排序，因此我们需要 22 个 25%/75% 的枢轴分区才能将 5,000 个值输入分解到那么远。(10*1.333333^22 > 5000) 或者，我们需要 4990 个最坏情况的枢轴。请记住，如果我们在*任何时候*积累了 22 个好的支点，那么排序就会完成，所以最坏的情况或任何接近它的情况都需要*非常*糟糕的运气。如果我们需要 88 次递归才能真正实现排序到 n=10 所需的 22 个良好枢轴，那将是 4*2.4*理想情况或理想情况执行时间的大约 10 倍。在 88 次递归之后，我们*无法*实现所需的 22 个良好枢轴的可能性有多大？

[二项式概率分布](http://vassarstats.net/textbook/ch5apx.html)可以回答这个问题，答案大约是 10^-18。（n 是 88，k 是 21，p 是 0.6875）您的用户在单击 [SORT] 的 1 秒内被闪电击中的可能性大约是他们看到 5,000 个项目排序运行得*更糟*的一千倍超过 10*理想情况。随着数据集变大，这个机会变小。以下是一些数组大小及其运行时间超过 10*ideal 的相应机会：

*   640 个项目的数组：10^-13（需要 60 次尝试中的 15 个好的枢轴点）
*   包含 5,000 个项目的数组：10^-18（需要 88 次尝试中的 22 个好的枢轴）
*   40,000 个项目的数组：10^-23（需要 116 个中的 29 个好的枢轴）

请记住，这是基于 2 个比现实更糟糕的保守假设。所以实际性能更好，剩余概率的平衡比没有更接近理想。

最后，正如其他人所提到的，如果递归堆栈太深，即使是这些极其不可能的情况也可以通过切换到堆排序来消除。所以 TLDR 是，对于 QuickSort 的良好实现，最坏的情况*并不真正存在*，因为它已经被设计出来并且执行在 O(n*logn) 时间内完成。

* * *

## 回答 #10

> 赞同：6
> 
> 时间：2008-09-16T08:41:30.220

快速排序是实践中最快的排序算法，但有许多病态情况可能使其性能与 O(n2) 一样糟糕。

堆排序保证在 O(n*ln(n)) 中运行，并且只需要有限的额外存储空间。但是有许多真实世界测试的引用表明堆排序平均比快速排序慢得多。

* * *

## 回答 #11

> 赞同：5
> 
> 时间：2008-09-16T08:43:02.540

维基百科的解释是：

> 通常，快速排序在实践中比其他 Θ(nlogn) 算法快得多，因为它的内部循环可以在大多数架构上有效地实现，并且在大多数实际数据中，可以做出最小化需要二次时间的概率的设计选择.

[快速排序](http://en.wikipedia.org/wiki/Quicksort)

[合并排序](http://en.wikipedia.org/wiki/Mergesort)

我认为 Mergesort 所需的存储量（即 Ω(n)）也存在快速排序实现所没有的问题。在最坏的情况下，它们的算法时间相同，但归并排序需要更多的存储空间。

* * *

## 回答 #12

> 赞同：4
> 
> 时间：2008-09-16T22:29:46.080

快速排序并不比合并排序好。使用 O(n^2)（很少发生的最坏情况），快速排序可能比合并排序的 O(nlogn) 慢得多。快速排序的开销较小，因此对于 n 小且速度较慢的计算机，它会更好。但是今天的计算机是如此之快，以至于合并排序的额外开销可以忽略不计，并且在大多数情况下，非常慢的快速排序的风险远远超过合并排序的微不足道的开销。

此外，合并排序会以原始顺序保留具有相同键的项目，这是一个有用的属性。

* * *

## 回答 #13

> 赞同：4
> 
> 时间：2013-11-08T07:30:45.160

**为什么快速排序很好？**

*   QuickSort 在最坏情况下采用 N^2，在平均情况下采用 NlogN。最坏的情况发生在数据排序时。这可以通过在开始排序之前随机洗牌来缓解。
*   QuickSort 不会占用合并排序占用的额外内存。
*   如果数据集很大并且有相同的项目，则快速排序的复杂性通过使用 3 路分区来降低。相同项目的数量越多，排序越好。如果所有项目都相同，则按线性时间排序。[这是大多数库中的默认实现]

**快速排序总是比合并排序好吗？**

**并不真地。**

*   Mergesort 是稳定的，但 Quicksort 不是。因此，如果您需要输出稳定性，您将使用 Mergesort。在许多实际应用中都需要稳定性。
*   现在内存很便宜。因此，如果 Mergesort 使用的额外内存对您的应用程序并不重要，那么使用 Mergesort 并没有什么坏处。

**注意：**在 java 中，Arrays.sort() 函数对原始数据类型使用快速排序，对对象数据类型使用 Mergesort。因为对象消耗内存开销，所以为 Mergesort 添加一点开销从性能角度来看可能不是任何问题。

**参考**：观看[Coursera 的普林斯顿算法课程第 3 周的 QuickSort 视频](https://class.coursera.org/algs4partI-003/lecture/index)

* * *

## 回答 #14

> 赞同：4
> 
> 时间：2016-08-26T06:56:18.957

与合并排序不同，快速排序不使用辅助空间。而合并排序使用辅助空间 O(n)。但是合并排序的最坏情况时间复杂度为 O(nlogn)，而快速排序的最坏情况复杂度为 O(n^2)，这发生在数组已经排序时。

* * *

## 回答 #15

> 赞同：4
> 
> 时间：2020-03-19T15:49:33.583

这是面试中常见的一个问题，尽管合并排序的最坏情况性能更好，但快速排序被认为比合并排序更好，尤其是对于大输入。由于某些原因，快速排序更好：

**1-辅助空间：**快速排序是一种就地排序算法。就地分拣意味着不需要额外的存储空间来执行分拣。另一方面，合并排序需要一个临时数组来合并排序的数组，因此它不是就地的。

**2-最坏情况：**`O(n^2)`使用随机快速排序可以避免快速排序的最坏情况。通过选择正确的支点可以很容易地避免这种情况。通过选择正确的枢轴元素来获得平均案例行为，使其即兴发挥并变得与合并排序一样高效。

**3- 引用的局部性：**快速排序尤其表现出良好的缓存局部性，这使得它在许多情况下比合并排序更快，例如在虚拟内存环境中。

**4- Tail recursion:** QuickSort is tail recursive while Merge sort is not. A tail recursive function is a function where recursive call is the last thing executed by the function. The tail recursive functions are considered better than non tail recursive functions as tail-recursion can be optimized by compiler.

* * *

## 回答 #16

> 赞同：3
> 
> 时间：2013-04-03T14:31:52.363

答案将稍微倾向于快速排序，以适应 DualPivotQuickSort 为原始值带来的变化。它在**JAVA 7中用于在****java.util.Arrays 中**排序

 **```
It is proved that for the Dual-Pivot Quicksort the average number of
comparisons is 2*n*ln(n), the average number of swaps is 0.8*n*ln(n),
whereas classical Quicksort algorithm has 2*n*ln(n) and 1*n*ln(n)
respectively. Full mathematical proof see in attached proof.txt
and proof_add.txt files. Theoretical results are also confirmed
by experimental counting of the operations. 
```

您可以在此处找到 JAVA7 实现 - [http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/util/Arrays.java](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/util/Arrays.java)

DualPivotQuickSort 的进一步精彩阅读 - [http://permalink.gmane.org/gmane.comp.java.openjdk.core-libs.devel/2628](http://permalink.gmane.org/gmane.comp.java.openjdk.core-libs.devel/2628)

* * *

## 回答 #17

> 赞同：3
> 
> 时间：2016-03-12T13:51:03.890

在归并排序中，一般算法是：

1.  对左子数组进行排序
2.  对右子数组进行排序
3.  合并 2 个已排序的子数组

在顶层，合并 2 个已排序的子数组涉及处理 N 个元素。

再下一层，步骤 3 的每次迭代都涉及处理 N/2 个元素，但您必须重复此过程两次。所以你仍然在处理 2 * N/2 == N 个元素。

再下一层，您将合并 4 * N/4 == N 个元素，依此类推。递归堆栈中的每个深度都涉及在对该深度的所有调用中合并相同数量的元素。

请考虑使用快速排序算法：

1.  选择一个枢轴点
2.  将轴心点放在数组中的正确位置，所有较小的元素都在左边，较大的元素在右边
3.  对左子数组进行排序
4.  对右子数组进行排序

在顶层，您正在处理一个大小为 N 的数组。然后您选择一个枢轴点，将其放在正确的位置，然后可以在算法的其余部分完全忽略它。

再下一层，您正在处理 2 个子数组，它们的组合大小为 N-1（即减去前面的枢轴点）。您为每个子阵列选择一个枢轴点，最多可有 2 个额外的枢轴点。

再下一层，您正在处理 4 个组合大小为 N-3 的子数组，原因与上述相同。

然后是 N-7... 然后是 N-15... 然后是 N-32...

递归堆栈的深度保持大致相同 (logN)。使用合并排序，您总是在递归堆栈的每一级处理 N 元素合并。但是，使用快速排序，您正在处理的元素数量会随着您向下堆栈而减少。例如，如果您查看递归堆栈中间的深度，您正在处理的元素数是 N - 2^((logN)/2)) == N - sqrt(N)。

免责声明：在合并排序中，因为每次将数组分成 2 个完全相同的块，递归深度正好是 logN。在快速排序中，由于您的枢轴点不太可能正好位于数组的中间，因此递归堆栈的深度可能略大于 logN。我还没有计算过这个因素和上述因素在算法复杂性中的实际作用有多大。

* * *

## 回答 #18

> 赞同：3
> 
> 时间：2016-08-25T23:55:17.400

这是一个很老的问题，但由于我最近处理了这两个问题，这里是我的 2c：

合并排序平均需要 ~ N log N 次比较。对于已经（几乎）排序的排序数组，这下降到 1/2 N log N，因为在合并时我们（几乎）总是选择“左”部分 1/2 N 次，然后只复制右 1/2 N 个元素。此外，我可以推测已经排序的输入使处理器的分支预测器发光，但可以正确猜测几乎所有分支，从而防止管道停顿。

快速排序平均需要 ~ 1.38 N log N 比较。在比较方面，它并没有从已经排序的数组中受益匪浅（但是它在交换方面，可能在 CPU 内的分支预测方面）。

我在相当现代的处理器上的基准测试显示如下：

当比较函数是回调函数时（如在 qsort() libc 实现中），对于 64 位整数，快速排序在随机输入上比合并排序慢 15%，对于已经排序的数组慢 30%。

另一方面，如果比较不是回调，我的经验是快速排序优于合并排序高达 25%。

但是，如果您的（大）数组具有很少的唯一值，则合并排序在任何情况下都会开始超过快速排序。

所以也许底线是：如果比较是昂贵的（例如回调函数，比较字符串，比较结构的许多部分，主要是为了有所作为） - 你可能会更好与归并排序。对于更简单的任务，快速排序会更快。

前面所说的都是真的： - 快速排序可以是 N^2，但 Sedgewick 声称，一个好的随机实现比执行 N^2 的计算机执行排序更有可能被闪电击中 - 合并排序需要额外的空间

* * *

## 回答 #19

> 赞同：2
> 
> 时间：2008-09-16T08:42:05.273

快速排序具有更好的平均案例复杂度，但在某些应用程序中它是错误的选择。快速排序容易受到拒绝服务攻击。如果攻击者可以选择要排序的输入，他可以很容易地构造一个集合，它的最坏情况时间复杂度为 o(n^2)。

Mergesort 的平均情况复杂度和最坏情况复杂度是相同的，因此不会遇到同样的问题。合并排序的这一特性也使其成为实时系统的最佳选择——正是因为没有导致它运行得慢得多、慢得多的病态案例。

由于这些原因，我更喜欢 Mergesort，而不是 Quicksort。

* * *

## 回答 #20

> 赞同：2
> 
> 时间：2011-09-10T15:33:06.913

这很难说。MergeSort 最差的是 n(log2n)-n+1，如果 n 等于 2^k，这是准确的（我已经证明了这一点）。对于任何 n，它在 (n lg n - n + 1) 和 (n lg n + n + O(lg n))。但是对于 quickSort，最好的是 nlog2n（n 也等于 2^k）。如果将 Mergesort 除以 quickSort，当 n 是无限时它等于 1。所以就好像 MergeSort 最坏的情况比 QuickSort 的最好情况要好，为什么我们要使用快速排序？但是请记住，MergeSort 没有到位，它需要 2n 个内存空间。而且 MergeSort 还需要做很多数组副本，我们算法分析中不包括。一句话，理论上MergeSort确实比quicksort快，但实际上需要考虑内存空间，array copy的成本，merger比quick sort慢。我曾经做过一个随机类在 java 中给我 1000000 个数字的实验，合并排序用了 2610 毫秒，快速排序用了 1370 毫秒。

* * *

## 回答 #21

> 赞同：2
> 
> 时间：2013-07-09T20:12:19.500

快速排序是最坏情况 O(n^2)，但是，平均情况始终优于执行合并排序。每个算法都是 O(nlogn)，但你需要记住，在谈论大 O 时，我们会忽略较低复杂度的因素。当涉及到常数因素时，快速排序比合并排序有显着的改进。

合并排序也需要 O(2n) 内存，而快速排序可以就地完成（仅需要 O(n)）。这是快速排序通常优于合并排序的另一个原因。

**额外信息：**

当枢轴选择不当时，会发生快速排序的最坏情况。考虑以下示例：

[5、4、3、2、1]

如果选择枢轴作为组中的最小或最大数字，则快速排序将在 O(n^2) 中运行。选择列表中最大或最小 25% 中的元素的概率为 0.5。这使算法有 0.5 的机会成为一个好的支点。如果我们采用典型的枢轴选择算法（比如选择一个随机元素），我们有 0.5 的机会为每个枢轴选择选择一个好的枢轴。对于大尺寸的集合，总是选择一个糟糕的枢轴的概率是 0.5 * n。基于此概率，快速排序对于平均（和典型）情况是有效的。

* * *

## 回答 #22

> 赞同：2
> 
> 时间：2017-02-12T01:49:13.710

当我对这两种排序算法进行试验时，通过计算递归调用的次数，快速排序始终比归并排序具有更少的递归调用。这是因为快速排序具有枢轴，并且枢轴不包含在下一个递归调用中。这样，快速排序可以比归并排序更快地达到递归基本情况。

* * *

## 回答 #23

> 赞同：1
> 
> 时间：2008-09-16T08:44:17.437

虽然它们都属于同一个复杂性类，但这并不意味着它们都具有相同的运行时。快速排序通常比归并排序更快，只是因为它更容易编写紧凑的实现并且它所做的操作可以更快。这是因为快速排序通常更快，人们使用它而不是合并排序。

然而！我个人经常会使用合并排序或快速排序变体，当快速排序表现不佳时会降级为合并排序。记住。*快速排序平均*只有 O(n log n) 。最坏的情况是 O(n^2)！合并排序总是 O(n log n)。如果实时性能或响应能力是必须的，并且您的输入数据可能来自恶意来源，**则不应使用普通的快速排序。**

* * *

## 回答 #24

> 赞同：1
> 
> 时间：2008-09-28T00:45:48.963

在所有条件相同的情况下，我希望大多数人使用最方便的东西，这往往是 qsort(3)。除了已知的快速排序在数组上非常快，就像合并排序是列表的常见选择一样。

我想知道为什么很少看到[**基数**](http://en.wikipedia.org/wiki/Radix_sort)或桶排序。它们是 O(n)，至少在链表上，所需要的只是某种将键转换为序数的方法。（字符串和浮点数工作得很好。）

我认为原因与计算机科学的教学方式有关。我什至不得不向我的算法分析讲师证明，确实可以比 O(n log(n)) 更快地排序。（他有证据表明你不能比 O(n log(n)) 更快地*进行比较*排序，这是真的。）

在其他新闻中，浮点数可以排序为整数，但之后您必须将负数转过来。

编辑：实际上，这是一种将浮点数排序为整数的更恶毒的方法：http: [//www.stereopsis.com/radix.html](http://www.stereopsis.com/radix.html)。请注意，无论您实际使用哪种排序算法，都可以使用位翻转技巧...

* * *

## 回答 #25

> 赞同：1
> 
> 时间：2014-11-05T09:32:26.680

快速与合并排序的小补充。

它也可以取决于排序项目的种类。如果访问项目、交换和比较不是简单的操作，例如比较平面内存中的整数，那么归并排序可能是更可取的算法。

例如，我们在远程服务器上使用网络协议对项目进行排序。

此外，在像“链表”这样的自定义容器中，快速排序没有好处。
1.链表上的归并排序，不需要额外的内存。2.快速排序中对元素的访问不是顺序的（在内存中）

* * *

## 回答 #26

> 赞同：0
> 
> 时间：2016-06-28T19:49:17.567

快速排序是一种就地排序算法，因此更适合数组。另一方面，归并排序需要额外的 O(N) 存储，更适合链表。

与数组不同，在like list中，我们可以在中间插入项目，空间为O(1)，时间为O(1)，因此合并排序中的合并操作可以在没有任何额外空间的情况下实现。但是，为数组分配和取消分配额外空间会对归并排序的运行时间产生不利影响。合并排序也有利于链表，因为数据是按顺序访问的，没有太多的随机内存访问。

另一方面，快速排序需要大量随机内存访问，并且使用数组，我们可以直接访问内存，而无需链表所要求的任何遍历。用于数组时的快速排序也具有良好的引用局部性，因为数组连续存储在内存中。

尽管两种排序算法的平均复杂度都是 O(NlogN)，但通常人们在处理普通任务时使用数组进行存储，因此快速排序应该是首选算法。

编辑：我刚刚发现合并排序最差/最好/平均情况总是nlogn，但快速排序可以从n2（元素已经排序的最坏情况）到nlogn（当pivot总是将数组分成两部分时的平均/最佳情况）一半）。

* * *

## 回答 #27

> 赞同：0
> 
> 时间：2018-12-23T14:06:15.560

考虑时间和空间复杂度。对于合并排序：时间复杂度：O(nlogn)，空间复杂度：O(nlogn)

对于快速排序：时间复杂度：O(n^2)，空间复杂度：O(n)

现在，他们都在一个场景中获胜。但是，使用随机枢轴，您几乎总是可以将快速排序的时间复杂度降低到 O(nlogn)。

因此，在许多应用程序中，首选快速排序而不是合并排序。

* * *

## 回答 #28

> 赞同：-1
> 
> 时间：2008-09-17T02:00:10.113

在 c/c++ 领域，当不使用 stl 容器时，我倾向于使用快速排序，因为它是内置在运行时的，而合并排序不是。

所以我相信在很多情况下，这只是阻力最小的路径。

此外，对于整个数据集不适合工作集的情况，快速排序可以提高性能。

* * *

## 回答 #29

> 赞同：-4
> 
> 时间：2017-12-10T22:57:58.817

原因之一是更具哲学性。快速排序是自上而下的哲学。有 n 个要排序的元素，有 n! 可能性。对于互斥的 m 和 nm 的 2 个分区，可能性的数量会下降几个数量级。米！*（纳米）！比 n! 小几个数量级！独自的。想象5！VS 3！*2！。5！比 2 和 3 的 2 个分区多 10 倍的可能性。并推断为 100 万阶乘与 900K！*100K！vs. 所以不用担心在范围或分区内建立任何顺序，只需在分区中建立更广泛级别的顺序并减少分区内的可能性。如果分区本身不是互斥的，则在一个范围内较早建立的任何顺序都将在以后受到干扰。

任何自下而上的排序方法（如合并排序或堆排序）都类似于工人或员工的方法，在这种方法中，人们很早就开始在微观层面进行比较。但是，一旦稍后发现它们之间的元素，这个顺序肯定会丢失。这些方法非常稳定且非常可预测，但需要做一些额外的工作。

快速排序类似于管理方法，其中一个人最初不关心任何订单，只关心满足一个广泛的标准而不考虑订单。然后分区缩小，直到你得到一个排序集。快速排序中真正的挑战是当您对要排序的元素一无所知时，在黑暗中找到一个分区或标准。这就是为什么我们要么需要花费一些精力来找到一个中值，要么随机选择 1 或一些任意的“管理”方法。找到一个完美的中位数可能需要大量的努力，并再次导致愚蠢的自下而上的方法。所以 Quicksort 说只是选择一个随机枢轴，并希望它会在中间的某个地方，或者做一些工作来找到 3 、 5 或更多的中位数以找到更好的中位数，但不打算做到完美&不要' 不要在最初订购时浪费任何时间。如果你很幸运，或者当你没有得到中位数但只是抓住机会时有时会降级到 n^2，那似乎做得很好。任何方式的数据都是随机的。对。因此，我更同意快速排序的自上而下的逻辑方法，事实证明，它更早保存的关于枢轴选择和比较的机会似乎比任何细致而彻底的稳定自下而上的方法更有效，例如合并排序。但 它较早保存的比较似乎比任何细致而彻底的稳定自底向上方法（如合并排序）更有效。但 它较早保存的比较似乎比任何细致而彻底的稳定自底向上方法（如合并排序）更有效。但

# c# - C# 有像 Java 那样的字符串标记器吗？

> ID：70405
> 
> 赞同：69
> 
> 时间：2008-09-16T08:38:15.767
> 
> 标签：c#, string, parsing

我正在做简单的字符串输入解析，我需要一个字符串标记器。我是 C# 新手，但已经编写了 Java，C# 应该有一个字符串标记器似乎很自然。可以？它在哪里？我该如何使用它？

* * *

## 回答 #1

> 赞同：118
> 
> 时间：2008-09-16T08:43:55.097

您可以使用[String.Split 方法](http://msdn.microsoft.com/en-us/library/system.string.split.aspx "String.Split 方法 msdn 参考")。

```
class ExampleClass
{
    public ExampleClass()
    {
        string exampleString = "there is a cat";
        // Split string on spaces. This will separate all the words in a string
        string[] words = exampleString.Split(' ');
        foreach (string word in words)
        {
            Console.WriteLine(word);
            // there
            // is
            // a
            // cat
        }
    }
} 
```

有关更多信息，请参阅[Sam Allen 关于在 c# 中拆分字符串的文章](http://www.dotnetperls.com/split "Sam Allen 的 C# 拆分字符串示例")（性能、正则表达式）

* * *

## 回答 #2

> 赞同：24
> 
> 时间：2013-09-19T21:21:43.427

我只想强调 C# 的 Split 方法的强大功能并提供更详细的比较，尤其是来自 Java 背景的人。

尽管 Java 中的 StringTokenizer 只允许使用单个分隔符，但我们实际上可以拆分多个分隔符，从而减少正则表达式的必要性（尽管如果需要正则表达式，请务必使用正则表达式！）例如：

```
str.Split(new char[] { ' ', '.', '?' }) 
```

这将在三个不同的分隔符上拆分，返回一个令牌数组。我们还可以使用上面示例的第二个参数删除空数组：

```
str.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries) 
```

Java 的字符串标记器确实具有我认为 C# 缺少的一件事（至少 Java 7 具有此功能）是将分隔符保留为标记的能力。C# 的 Split 将丢弃标记。这在某些 NLP 应用程序中可能很重要，但对于更通用的应用程序，这可能不是问题。

* * *

## 回答 #3

> 赞同：19
> 
> 时间：2008-09-16T08:41:40.330

字符串的 split 方法是您所需要的。事实上，Java 中的 tokenizer 类已被弃用，取而代之的是 Java 的字符串拆分方法。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T08:40:05.200

我认为 .NET Framework 中最接近的是

```
字符串.Split()

```

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-16T08:46:57.697

对于复杂的拆分，您可以使用正则表达式创建匹配集合。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2015-06-10T23:21:50.327

```
_words = new List<string>(YourText.ToLower().Trim('\n', '\r').Split(' ').
            Select(x => new string(x.Where(Char.IsLetter).ToArray()))); 
```

或者

```
_words = new List<string>(YourText.Trim('\n', '\r').Split(' ').
            Select(x => new string(x.Where(Char.IsLetterOrDigit).ToArray()))); 
```

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2016-09-02T19:56:52.617

类似Java的方法是：

```
Regex.Split(string, pattern); 
```

在哪里

*   `string`- 您需要拆分的文本
*   `pattern`- 字符串类型模式，什么是分割文本

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2009-07-30T11:10:22.007

采用`Regex.Split(string,"#|#");`

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2009-11-12T08:25:57.687

读到这里，split 函数有一个重载需要一个由分隔符组成的数组 [http://msdn.microsoft.com/en-us/library/system.stringsplitoptions.aspx](http://msdn.microsoft.com/en-us/library/system.stringsplitoptions.aspx)

* * *

## 回答 #10

> 赞同：-1
> 
> 时间：2016-12-14T01:43:12.210

如果您尝试在 .NET 控制台应用程序中拆分命令行参数之类的操作，您将会遇到问题，因为 .NET 要么已损坏，要么正试图变得聪明（这意味着它与损坏一样好）。我需要能够通过空格字符分割参数，保留任何被引用的文字，这样它们就不会在中间被分割。这是我为完成这项工作而编写的代码：

```
private static List<String> Tokenise(string value, char seperator)
{
    List<string> result = new List<string>();
    value = value.Replace("  ", " ").Replace("  ", " ").Trim();
    StringBuilder sb = new StringBuilder();
    bool insideQuote = false;
    foreach(char c in value.ToCharArray())
    {
        if(c == '"')
        {
            insideQuote = !insideQuote;
        }
        if((c == seperator) && !insideQuote)
        {
            if (sb.ToString().Trim().Length > 0)
            {
                result.Add(sb.ToString().Trim());
                sb.Clear();
            }
        }
        else
        {
            sb.Append(c);
        }
    }
    if (sb.ToString().Trim().Length > 0)
    {
        result.Add(sb.ToString().Trim());
    }

    return result;
} 
```

* * *

## 回答 #11

> 赞同：-2
> 
> 时间：2008-09-16T08:50:17.407

如果您使用的是 C# 3.5，您可以为 System.String 编写一个扩展方法来执行您需要的拆分。然后，您可以使用语法：

```
string.SplitByMyTokens(); 
```

更多信息和来自 MS 的有用示例[http://msdn.microsoft.com/en-us/library/bb383977.aspx](http://msdn.microsoft.com/en-us/library/bb383977.aspx)

# vba - 尝试控制另一个数据库时出现间歇性错误

> ID：70417
> 
> 赞同：2
> 
> 时间：2008-09-16T08:40:16.807
> 
> 标签：vba, ms-access

我有以下代码：

```
Dim obj As New Access.Application
obj.OpenCurrentDatabase (CurrentProject.Path & "\Working.mdb")
obj.Run "Routine"
obj.CloseCurrentDatabase
Set obj = Nothing 
```

我正在尝试的问题是一个弹出窗口，告诉我 Access 无法将焦点设置在其他数据库上。从代码中可以看出，我想在另一个 mdb 中运行一个 Subroutine。任何其他方式来实现这一点将不胜感激。

我正在使用 MS Access 2003。

这是一个间歇性错误。由于这是每月仅运行一次的生产代码，因此极难重现，我目前无法为您提供确切的文本和编号。这是发生这种情况的第二个月。

我怀疑当有人使用这个或其他数据库时可能会发生这种情况。

数据流是每月在一个数据库中更新一次所有“项目”，然后在另一个数据库中提供此信息。

也许是因为 'Routines' 代码中的第一行： If vbNo = MsgBox("Do you want to update?", vbYesNo, "Update") Then Exit Function End If

我将制作另一个没有 MsgBox 的子程序。

我已经能够重现这种行为。当焦点必须转移到被调用的数据库时会发生这种情况，但用户将焦点 ([ALT]+[TAB]) 设置在第一个数据库上。“解决方案”是教育用户。

* * *

这是一个间歇性错误。由于这是每月仅运行一次的生产代码，因此极难重现，我目前无法为您提供确切的文本和编号。这是发生这种情况的第二个月。

我怀疑当有人使用这个或其他数据库时可能会发生这种情况。

数据流是每月在一个数据库中更新一次所有“项目”，然后在另一个数据库中提供此信息。

也许是因为 'Routines' 代码中的第一行： If vbNo = MsgBox("Do you want to update?", vbYesNo, "Update") Then Exit Function End If

我将制作另一个没有 MsgBox 的子程序。

* * *

我已经在我们的开发数据库中尝试过这个并且它有效。这并不意味着任何其他代码在开发中也可以正常工作。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T15:35:56.637

我猜这个错误信息与你的一个数据库的状态有关。您在此处使用 Jet 连接和 Access 对象，并且由于多种原因（多用户环境、无法删除 LDB 锁定文件等），您可能无法正确关闭活动数据库并打开另一个数据库。因此，根据我的说法，解决方案是忘记 Jet 引擎并使用另一个连接来更新“其他”数据库中的数据。

当您说“数据流是在一个数据库中每月更新一次所有‘项目’，然后在另一个数据库中提供此信息”时，我假设您的“例程”的作用是通过 SQL 更新一些数据说明或等效的记录集更新。

您为什么不尝试通过打开与其他数据库的连接并（1）发送相应的 SQL 指令或（2）打开记录集并进行请求的更新来尝试进行相应的更新？

例如，一个想法是：

```
Dim cn as ADODB.connexion, 
    qr as string, 
    rs as ADODB.recordset

'qr can be "Update Table_Blablabla Set ... Where ...
'rs can be "SELECT * From Table_Blablabla INNER JOIN Table_Blobloblo  

set cn = New ADODB.connexion
cn.open

You can here send any SQL instruction (with command object and execute method) 
or open and update any recordset linked to your other database, then

cn.close 
```

这也可以通过 ODBC 连接（和 DAO.recordsets）来完成，因此您可以选择自己喜欢的对象。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-17T00:35:16.480

如果您想要另一种运行该函数的方法，请尝试以下操作：

```
Dim obj As New Access.Application
obj.OpenCurrentDatabase (CurrentProject.Path & "\Working.mdb")

obj.DoCmd.RunMacro "MyMacro"
obj.CloseCurrentDatabase
Set obj = Nothing 
```

其中“ **MyMacro** ”有一个“ **RunCode** ”动作，您希望在 Working.mdb 中执行函数名称

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-17T08:18:49.783

我已经能够重现“开发”中的错误。

“此操作无法完成，因为其他应用程序正忙。选择“切换到”以激活....”

我真的看不到消息的其余部分，因为它闪烁得非常快。我猜这个错误是由于两个数据库之间的“切换”造成的。我希望通过教育用户，这将停止。

菲利普，你的回答当然是正确的。如果我没有事先制定“常规”，我会选择那条路。

“我已经能够重现这种行为。当焦点必须转移到被调用的数据库时会发生这种情况，但用户将焦点（[ALT] + [TAB]）设置在第一个数据库上。'解决方案'是教育用户。” 由于无法阻止用户在 Windows 中切换应用程序，我想关闭主题。

# ruby - 你期待哪个 ruby 解释器？

> ID：70446
> 
> 赞同：7
> 
> 时间：2008-09-16T08:46:33.733
> 
> 标签：ruby, jruby, ironruby, rubinius, yarv

现在有多个 Ruby 实现在工作中。你期待哪一个，为什么？您是否在生产中积极使用非 MRI 实施？

一些选项包括：

*   [Ruby MRI（原始 1.8 分支）](http://en.wikipedia.org/wiki/Ruby_MRI)
*   [YARV（官方 1.9）](http://www.atdot.net/yarv/)
*   [JRuby](http://jruby.codehaus.org/)
*   [鲁比纽斯](http://rubini.us/)
*   [铁红宝石](http://ironruby.rubyforge.org/)
*   [磁悬浮](http://ruby.gemstone.com/)（感谢[朱利安](https://stackoverflow.com/users/11526/julian)）
*   [MacRuby](http://www.macruby.org/)（感谢[Damien Pollet](https://stackoverflow.com/users/63112/damien-pollet)）

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2008-09-16T08:55:08.283

[磁悬浮](http://ruby.gemstone.com/)。它将拥有多年来进入主要 Smalltalk VM 的所有优化的速度优势。此外，它会自动持久化所有数据，因此不再需要使用对象-关系映射层等等。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-09-16T10:09:00.120

Ruby 1.9 (YARV) 让我们对 ruby​​ 的发展方向有了一个很好的了解，但我不建议将它用于生产环境。虽然它肯定比 1.8 快得多，但甚至语法的某些部分也在不断变化，所以我认为你不能称之为稳定。它确实有一些有趣的新特性和语法，随着时间的推移，它们肯定会在所有其他实现中找到它们的方式。

JRuby 和 IronRuby 很有用，因为它们使 ruby​​ 可以访问一系列新的库和环境，而这些新库和环境是 ruby​​ 无法使用的。我自己还没有发现它们有多大用处，但认为它们的存在很棒。他们可能允许 ruby​​ 渗透到原本不允许的公司环境中。那只能是一件好事。

Rubinius 和 Maglev 可能是最有趣的项目，但它们对社区的好处可能在未来最远。Rubinius 很可能会发展成为 ruby​​ 语言的尖端“纯”VM，让 ruby​​ 代码运行得比现在快得多。Maglev 似乎也非常有前途，因为它有 20 多年的 VM 经验支持。它还将提供超出标准 VM 的功能，但当然这些将以代码可移植性为代价。

总的来说，我最兴奋的是这些实现之间的竞争。让相互竞争的项目都致力于让 ruby​​ 变得更好，只会让 ruby​​ 生态系统变得更强大。从我也看到的情况来看，虽然存在竞争，但它是友好的；每个项目互相给予和接受想法。JRuby 和 Rubinius 团队在创建 ruby​​ 规范方面所做的工作可能是迄今为止最重要的成果，因为它将有助于确保所有实现保持兼容。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-16T09:13:24.683

[jRuby](http://jruby.codehaus.org/)现在是稳定可靠的。[磁悬浮](http://ruby.gemstone.com/)非常有前途。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2009-04-17T12:43:32.280

还没有人提到[MacRuby](http://www.macruby.org/)吗？我想它现在有点特定于 Mac，但它也可能被编译为 GNU 或[Étoilé](http://etoileos.com/etoile/features/runtime/) Objective-c 运行时。

另外，我在等磁悬浮 :)

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2013-07-20T11:30:29.790

企业 Ruby 怎么样？这已经有一段时间了。

[https://www.phusionpassenger.com/enterprise](https://www.phusionpassenger.com/enterprise)

# security - 是否值得在数据库中加密电子邮件地址？

> ID：70450
> 
> 赞同：56
> 
> 时间：2008-09-16T08:47:28.553
> 
> 标签：security, email, encryption

我已经在使用[加盐哈希](http://www.matasano.com/log/958/enough-with-the-rainbow-tables-what-you-need-to-know-about-secure-password-schemes/)将密码存储在我的数据库中，这意味着我应该免受[彩虹表](https://en.wikipedia.org/wiki/Rainbow_table)攻击。

不过，我有一个想法：如果有人确实掌握了我的数据库怎么办？它包含用户的电子邮件地址。我不能真正散列这些，因为我将使用它们来发送通知电子邮件等。

我应该加密它们吗？

* * *

## 回答 #1

> 赞同：61
> 
> 时间：2008-09-16T09:00:17.790

Bruce Schneier 对这类问题有很好的回应。

> 密码学不是解决您的安全问题的方法。它可能是解决方案的一部分，也可能是问题的一部分。在许多情况下，密码学一开始会使问题变得更糟，而使用密码学是否是一种改进还不清楚。

本质上，“以防万一”加密数据库中的电子邮件并不能真正使数据库更安全。数据库的密钥存储在哪里？这些密钥使用什么文件权限？数据库是否可以公开访问？为什么？这些帐户有哪些帐户限制？机器存放在哪里，谁可以物理访问这个盒子？远程登录/ssh 访问等呢？等等。

因此，我想您可以根据需要对电子邮件进行加密，但是如果这是系统安全性的范围，那么它实际上并没有起到太大作用，并且实际上会使维护数据库的工作变得更加困难。

当然，这可能是您系统的广泛安全策略的一部分 - 如果是这样，那就太好了！

我并不是说这是一个坏主意 - 但是为什么在 Deadlocks'R'us 的门上安装一把锁，当他们可以切开门周围的胶合板时花费 5000 美元？还是从你开着的窗户进来？或者更糟糕的是，他们找到了留在门垫下的钥匙。系统的安全性与最薄弱的环节一样好。如果他们有 root 访问权限，那么他们几乎可以做他们想做的事。

[史蒂夫摩根](https://stackoverflow.com/questions/70450/is-it-worth-encrypting-email-addresses-in-the-database#70484)提出了一个很好的观点，即使他们无法理解电子邮件地址，他们仍然可以造成很多伤害（如果他们只有 SELECT 访问权限，可以减轻这种伤害）

了解您存储电子邮件地址的原因也很重要。[我可能对这个答案](https://stackoverflow.com/questions/767276/what-is-the-best-and-safest-way-to-store-user-email-addresses-in-the-database)有点过分了，但我的意思是你真的需要为一个帐户存储一个电子邮件地址吗？最安全的数据是不存在的数据。

* * *

## 回答 #2

> 赞同：20
> 
> 时间：2012-08-12T16:57:33.720

我意识到这是一个死胡同，但我同意 Arjan 背后的逻辑。我想指出几点：

有人可以从您的数据库中检索数据而无需检索您的源代码（即 SQL 注入、第三方数据库）。考虑到这一点，考虑使用带密钥的加密是合理的。虽然，这只是安全性的附加措施，而不是安全性……这适用于希望使电子邮件比明文更私密的人，万一 **在更新过程中忽略了某些内容，或者攻击者设法检索了电子邮件。**

**IMO：**如果您打算加密电子邮件，请同时存储它的加盐哈希。然后，您可以使用哈希进行验证，并省去不断使用加密查找大量数据字符串的开销。然后有一个单独的私人功能来检索和解密您的电子邮件，当您需要使用一个。

* * *

## 回答 #3

> 赞同：12
> 
> 时间：2008-09-16T08:53:42.623

与大多数安全要求一样，您需要了解威胁级别。

如果电子邮件地址被泄露，会造成什么损害？

发生的几率有多大？

如果电子邮件地址被替换，所造成的损害可能比它们被暴露时要大得多。例如，如果您使用电子邮件地址验证密码重置到安全系统时尤其如此。

如果您对密码进行哈希处理，密码被替换或暴露的可能性会大大降低，但这取决于您拥有哪些其他控制措施。

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2008-09-16T08:58:10.400

我会说这取决于您的数据库的应用程序。

最大的问题是，您将加密密钥存储在哪里？因为如果黑客除了你的数据库之外还有其他任何东西，你所有的努力可能都白费了。（请记住，您的应用程序将需要该加密密钥来解密和加密，因此最终黑客会找到加密密钥并使用加密方案）。

临：

*   *仅*泄露您的数据库不会暴露电子邮件地址。

缺点：

*   加密意味着性能损失。
*   如果不是不可能的话，分配数据库操作将更加困难。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2008-09-16T10:17:18.650

不要意外地将加密与混淆混为一谈。我们通常会混淆电子邮件以防止垃圾邮件。许多网站将使用“webmaster_at_mysite.com”来减慢爬虫将电子邮件地址解析为潜在垃圾邮件目标的速度。这应该在 HTML 模板中完成——在持久数据库存储中这样做没有任何价值。

我们不会加密任何东西，除非我们需要在传输过程中对其保密。您的数据将在何时何地传输？

1.  SQL 语句从客户端传输到服务器；是在同一个盒子上还是通过安全连接？

2.  如果您的服务器受到威胁，则您的传输是无意的。如果您对此感到担心，那么您也许应该保护您的服务器。你有外部威胁，也有内部威胁。是否所有用户（外部和内部）都经过适当的身份验证和授权？

3.  在备份期间，您有意传输到备份媒体；这是使用安全备份策略完成的吗？

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2009-04-20T18:21:07.700

*我[在数据库中存储用户电子邮件地址的最佳和最安全的方法是什么？](https://stackoverflow.com/questions/767276/what-is-the-best-and-safest-way-to-store-user-email-addresses-in-the-database/767550#767550)，只是为了搜索...*

* * *

总的来说，我同意其他人的说法，这不值得付出努力。但是，我不同意任何可以访问您的数据库的人也可以获取您的密钥。对于 SQL 注入当然不是这样，对于以某种方式丢失或被遗忘的备份副本来说可能不是这样。而且我觉得电子邮件地址是个人信息，所以我不关心垃圾邮件，而是关心地址泄露后的个人后果。

当然，当你害怕 SQL 注入时，你应该确保这种注入是被禁止的。备份副本应自行加密。

尽管如此，对于某些在线社区，成员可能绝对不希望其他人知道他们是成员（例如与心理保健、经济帮助、医疗和性建议、成人娱乐、政治等有关的内容）。在这些情况下，尽可能少地存储个人详细信息并加密那些需要的信息（请注意，数据库级加密不会阻止使用 SQL 注入显示详细信息），这可能不是一个坏主意。再次：将电子邮件地址视为个人详细信息。

对于许多网站而言，可能并非如此，您应该专注于禁止`SELECT * FROM`通过 SQL 注入，并确保访问者无法通过更改 URL 以某种方式获取其他人的个人资料或订单信息。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-16T10:13:41.420

SQL Server 和 Oracle（我相信还有其他数据库）都支持数据库级别的数据加密。如果您想加密某些东西，为什么不简单地抽象对可以在数据库服务器端加密的数据的访问，让用户选择是否使用加密数据（在这种情况下，SQL 命令会有所不同）。如果用户想要使用加密数据，那么它可以配置数据库服务器，并且与密钥管理相关的所有维护工作都是使用标准 DBA 工具完成的，由 DB 供应商而不是您提供。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2014-09-01T19:07:11.583

对数据库中的数据进行加密是值得的，这并没有让它变得更困难，但当它以正确的方式加密时会变得更加困难，所以停止哲学并加密敏感数据；）

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-16T09:08:48.237

@Roo

我有点同意你的说法，但是否值得加密数据只是为了让某人更难获得它？

根据您的推理，在您的房子里安装锁或警报器是没有用的，因为它们也很容易被破坏。

**我的回复：**

我想说，如果您有不想落入坏人之手的敏感数据，您可能应该尽最大努力让黑客获取它，即使它不是 100% 万无一失的。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T08:51:58.963

您确实必须权衡某人获得这些电子邮件地址的最坏情况，有人获得它们的可能性以及实施更改所需的额外努力/时间。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2021-02-19T10:03:34.643

我在这里错过了一个重要的答案。当您拥有欧洲用户时，您必须遵守 GDPR 规则。电子邮件地址被视为个人数据，这意味着第[5](https://gdpr.eu/article-5-how-to-process-personal-data/)条确实适用于电子邮件地址。

> 以确保个人数据适当安全的方式进行处理，包括使用适当的技术或组织措施（“完整性和保密性”）防止未经授权或非法处理以及意外丢失、破坏或损坏。

当然，这并不是说您必须加密电子邮件地址。但是通过加密数据，您确实可以保护它免受窥探员工的影响。并保护自己作为开发人员免受在数据库中进行手动更改的请求。

# linux - 哪种脚本语言最好？

> ID：70453
> 
> 赞同：21
> 
> 时间：2008-09-16T08:47:52.500
> 
> 标签：linux, scripting

对于在 Linux 平台上编写用于流程自动化的脚本，哪种脚本语言会更好？Shell 脚本、Perl 或 Python 还是还有其他的？我对他们所有人都是新手。所以，我只是在考虑去哪一个？

* * *

## 回答 #1

> 赞同：45
> 
> 时间：2008-09-16T08:56:14.430

答案是：最适合这份工作的！

我的经验法则；

**Bash** - 用于可能需要 for 循环重复执行某些操作的简短脚本。

**Perl** - 与某种文本处理或文件处理有关的任何事情，特别是如果它是一次性的。只需做一个肮脏讨厌的 perl 脚本就可以了

**Python** - 如果它是你可能想要再次做的事情或者非常类似的事情。那么至少你有机会重用脚本。

* * *

## 回答 #2

> 赞同：10
> 
> 时间：2008-09-16T08:54:13.747

使用所有三个，从 bash/awk/sed 加上 fileutils（grep、find 等）开始，然后使用 perl 和 python 向上移动抽象层次结构。

这样，您将能够自己决定哪一个最适合您的需求。我说从 bash 和朋友开始，因为它们无处不在，有些机器没有安装 perl 或 python，你会在那里感到无助，尤其是在传统的 unix 领域（即不是 linux）

* * *

## 回答 #3

> 赞同：8
> 
> 时间：2008-09-16T09:00:05.993

在选择脚本语言来帮助自动化您的 linux / unix 环境时，我认为最重要的是......您的替代品 :-)

我的意思是下一个/其他可能必须维护您的脚本的系统管理员。我目前在一个环境中工作，主要的 Unix 家伙是一个真正的脚本负责人，但他主要限制自己使用 bash，并加入了一些 perl 和 windows vbscript 以求好运。至少它迫使我重新审视我的 perl。

在同意这里的其他评论的同时，我的建议是掌握 bash - 在可能的情况下尽可能多地使用 bash，因为大多数人都知道，并且可以维护/调试它。而且它将是最便携的。与 sed & awk 一起使用特别强大。

当你掌握了这些之后，你可以回到这里问“在 bash 之后我应该学习什么脚本语言？” :-)

JB

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2008-09-16T08:51:16.953

我推荐**bash、awk 和 sed。**

**重击**- [http://tldp.org/LDP/abs/html/](http://tldp.org/LDP/abs/html/)

**awk** - ~~[http://www.uga.edu/~ucns/wsg/unix/awk/](http://www.uga.edu/~ucns/wsg/unix/awk/)~~

[http://www.grymoire.com/Unix/Awk.html](http://www.grymoire.com/Unix/Awk.html)

**sed** - ~~[http://www.ce.berkeley.edu/~kayyum/unix_tips/sedtips.html](http://www.ce.berkeley.edu/~kayyum/unix_tips/sedtips.html)~~

[http://www.grymoire.com/Unix/Sed.html](http://www.grymoire.com/Unix/Sed.html)

只是一些想法。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2008-09-16T08:52:27.183

我认为这取决于您想要自动化的任务有多复杂。就个人而言，我一直使用 shell 脚本，它使您能够调用 awk、sed、grep、find、ls、cat 等，它们可以组合在一起完成几乎所有使用 perl 或 python 可以实现的任务。另一方面，如果您想要自动化的过程很复杂（例如，不仅仅是线性的步骤序列），那么您可能会发现用 perl 或 python（甚至 ruby​​！）编写脚本要快得多，并且它们更易于维护。

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2008-09-16T09:44:09.587

我将 Perl 用于非常简单的脚本之外的任何事情。

我也`'use warnings'`, `'use strict'`, 避免反引号，将系统称为`'system($command, @and_args)'`. 因为我喜欢它是可维护的：IPC::Run（用于管道）、File::Fu（用于文件名、临时文件等）、YAML（用于配置或其他数据）和 Getopt::Helpful（所以我记得选项是什么。）

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-16T08:55:25.303

取决于手头任务的复杂性和问题域。

Bash 脚本对于简单的系统自动化任务来说既快又脏。对于比移动文件和运行命令更复杂的事情，我个人认为 Perl 是下一个作为*事实上*的sys-admin goto 自动化工具。为了更多地关注代码重用和可读性/可维护性，我想将它升级到 Python 或 Ruby。

PHP 也可以用于自动执行任务，但是根据我的经验，它并没有被广泛接受。

这真的归结为你最感兴趣学习什么语言，最能用于自动化，除了许多其他的东西。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-16T08:56:43.133

我更喜欢 shell 脚本只用于非常小的任务。编写健壮的 shell 脚本需要大量关于可能的陷阱的知识，而这些知识只能通过实践来学习。但是即使学习基础知识也会大大提高您的生产力！

如果我需要复杂的逻辑，我通常使用 Python。复杂的意思是任何有两个以上的 if 语句 =)

Perl 就其最初的用途而言是可以的，但请注意，您学习的许多 perlisms 不适用于其他任何地方。

Python 和 Ruby 大致相当。我建议您好好学习其中一个，然后查看另一个教程。我更喜欢 Python，但这真的取决于个人喜好。

总结一下：**学习 shell 脚本的基础知识。至少学好 Python 或 Ruby。**

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-16T08:51:08.700

我一直在推荐 Python。它应该让你做任何事情。不过，对于小任务，我使用 shell 脚本。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-09-16T08:53:45.370

我通常会说你最了解的那个可以达到你想要的结果。像所有宗教战争一样，在学习了大量语言之后，你意识到你可以用大多数语言做大部分事情（注意我确实说得最多）。我使用 Perl。它可能不像 Python 或 Ruby 那样最新，但它确实有来自 CPAN 的大量库支持。而且我还没有发现任何我不能做的事情。当我这样做时，我会查看其他语言，以找出哪种语言可以填补这一空白。

如果我从今天开始，也许我会选择 Python 或 Ruby，但我对它们的了解还不够，无法做出判断。您的任何朋友/同事是否知道脚本语言。这可以极大地帮助您，因为学习新语言时的支持非常重要。

祝你好运

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-09-16T08:55:59.047

嗯，是这样的：

Perl 不是对用户最友好的脚本语言，但它具有 CPAN（综合 Perl 存档网络），其中包含数千个库，几乎可以实现您可能想到的任何东西，而且 Perl 在文本处理方面确实非常强大。缺点是 perl 代码有点难以维护（如果你不太了解的话）。

Python 是一种脚本语言，在脚本编写者中越来越流行。它还没有像 CPAN 这样的社区，但它更具可读性，并且更易于维护。它和 perl 一样快。

Ruby 是脚本语言的最新趋势。Ruby 是完全的 OOP，这意味着一切都是对象。它的优点是代码可读性很强，如果你是初学者，它很容易学习。主要缺点是它的执行速度，有点 s*x。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2010-02-19T14:59:23.780

如果你想要简约、紧凑和快速的解决方案（比 Python/Ruby 更快），那么 -> 选择 LUA 脚本语言 :-) 但是 Lua 速度和代码紧凑性是通过相对较小的 Lua 语言核心实现的，所以如果你想要“包含电池” （又名。非常大的“标准”库）那么 Lua 不适合你。否则，来自 C/C++ 世界的人非常喜欢 Lua 速度 :-)

ps

Lua vs Ruby 1.9 基准测试（您也可以查看 Lua Vs Python 3）：

[http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=lua&lang2=yarv](http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=lua&lang2=yarv)

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-16T08:54:13.140

这取决于你正在做的自动化类型，如果它正在测试自动化建议 Perl，因为 Perl 是通过 CPAN 的强大扩展模块，一个在线 Perl 模块清单。如果只需要一个方便的工具来完成一个简单的源文件，awk 是非常方便的。如果您打算使用脚本来自动化一个大项目，那么 Perl 是一个更好的选择，它具有更多的特性。同样，Python 从一开始就被设计为一种面向对象的语言。Perl 5 添加了一些 oo 特性，但在我看来，它就像一个笨拙的改造。Python 在多重继承、多态性和封装方面具有良好实现的 oo 特性。n 总结，在我看来，Python 在大多数应用程序中占主导地位，除了相当短的 shell 脚本类型的应用程序，它们大致相当。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-09-16T09:39:04.920

如果我必须选择一个，那必须是 AWK。它是轻量级的，学习曲线很小，并且有许多有用的功能，如索引和子字符串。

* * *

## 回答 #15

> 赞同：-1
> 
> 时间：2008-09-16T08:59:59.317

取决于你想做什么，我经常使用它们：

*   用于简单批处理命令的 Shell，可能带有循环或 if 语句。
*   Perl 当我咀嚼文件并做一些文本替换和类似的事情时。
*   Python 需要更多逻辑时。

在 *nix 下，您应该使用正确的工具来完成正确的工作，这对初学者来说可能很难，因为要学习的东西太多了（作为 *nix 用户大约 15 年之后，我仍然发现了新东西）。我的建议是快速查看所有语言，看看它们能做什么，然后在你的脚本变得笨重时将它们移到其他东西上，然后开始使用 shell。

* * *

## 回答 #16

> 赞同：-1
> 
> 时间：2008-09-16T09:18:22.863

只需一个接一个地编写你的命令，把它放在一个文件中并运行这个文件

```
promp> bash file 
```

你有了第一个自动化。然后了解 bash 变量、循环和控制结构。

* * *

## 回答 #17

> 赞同：-1
> 
> 时间：2008-09-16T09:25:17.400

我第二次使用 Python - 与 perl 或 bash 相比，强大、简单、高性能，而且……实际上很有趣。此外，如果您知道它，您会发现其他用途，它在很多项目中都有使用。不仅仅是作为一种“经典”脚本语言，以扭曲项目为例。我猜对 Perl 也是如此，但我自己更喜欢 Python

底线虽然就像之前所说的那样，但请确保您拥有合适的工具来完成这项工作......

* * *

## 回答 #18

> 赞同：-1
> 
> 时间：2008-09-23T23:09:19.410

如果你的目标是让一个简单的脚本程序“控制”另一个（当然是命令行）程序，那么你应该回顾一下 Tcl/Tk，尤其是它的方言期望——它们很简单并且面向那个目标——很容易创建一个控制 ftp 的脚本，甚至对它们执行 su！

awk 非常适合处理文本文件 - 没有 perl 强大，但更简单直接（并且没有可怕的语法）。

当然，你的里程可能会有所不同，所以我想最好的答案是问你：你想写什么脚本？然后：你熟悉*任何*语言脚本吗？根据每个问题的优缺点及其主要目标，这些问题的答案将为您指出应该使用的脚本语言。

* * *

## 回答 #19

> 赞同：-3
> 
> 时间：2008-09-16T08:51:43.050

在 Linux 上？基本上选择你的毒药。我喜欢 Python，其他的 Ruby，还有其他的 Perl。选择一个然后去做。:-)

* * *

## 回答 #20

> 赞同：-3
> 
> 时间：2008-09-16T09:05:50.117

我会说 Python - 它具有非常高的可读性，它很简单（没有大括号，关键字尽可能接近英语等），你可以在其中做几乎所有事情，从简单到非常复杂的事情。编码也很流行且很有趣。

* * *

## 回答 #21

> 赞同：-3
> 
> 时间：2008-09-16T09:07:09.177

这听起来可能有点奇怪，我已经使用 bash 超过 10 年了。我已经开始使用 PHP5，一开始很困难，但现在我有了一个更好的可重用代码库。

不过我不推荐它作为起点！

# sql - 跨服务器 SQL

> ID：70455
> 
> 赞同：34
> 
> 时间：2008-09-16T08:48:57.533
> 
> 标签：sql, sql-server, tsql, linked-server, cross-server

我想将数据从一台服务器的数据库移植到另一台服务器的数据库。数据库都位于不同的 mssql 2005 服务器上。复制可能不是一种选择，因为目标数据库是在 [时间间隔] 基础上从头开始生成的。

最好我会做类似的事情

```
insert *
from db1/table1
into db2/table2
where rule1 = true 
```

很明显，连接凭据会出现在这个脚本中。

* * *

## 回答 #1

> 赞同：38
> 
> 时间：2008-09-16T08:59:04.843

我认为你想要做的是根据[这篇](http://msdn.microsoft.com/en-us/library/aa213778(SQL.80).aspx)msdn 文章创建一个链接服务器。然后，您将选择使用 4 部分对象名称，例如：

```
Select * From ServerName.DbName.SchemaName.TableName 
```

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2013-09-06T13:39:29.817

您可以像这样使用开放数据源：

```
EXEC sp_configure 'show advanced options', 1
GO
RECONFIGURE
GO

EXEC sp_configure 'Ad Hoc Distributed Queries', 1
GO
RECONFIGURE
GO

SELECT  *
FROM    OPENDATASOURCE('SQLOLEDB',
                   'Data Source=<Ip Of Your Server>;
                    User ID=<SQL User Name>;Password=<SQL password>').<DataBase name>.<SchemaName>.<Table Or View Name>

Go 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T08:52:50.020

SQL Server 集成服务 (SSIS) 是一种选择吗？如果是这样，我会使用它。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-16T09:48:34.053

您是将数据库的全部内容从一台服务器传输到另一台服务器，还是只是从几个表中传输一些数据？

对于这两个选项，SSIS 都可以完成这项工作，特别是如果您计划定期转移。

如果您只是想从 1 个或 2 个表中复制一些数据，并且更喜欢在 SQL Management Studio 中使用 TSQL，那么您可以按照 pelser 的建议使用链接服务器

1.  将源数据库服务器设置为链接服务器
2.  使用以下语法访问数据

```
select columnName1, columnName2, etc from serverName.databaseName.schemaName.tableName
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T13:34:16.757

好吧，我不同意您对复制的评论。您可以通过从头开始创建数据库来启动复制，并且您可以通过更新可用的客户端数据库或简单地重新创建数据库来控制更新。

自动复制将通过自动管理密钥和关系来简化您的工作。

我认为最简单的做法是通过 MSSQL Server Studio 启动快照复制，获取 T-SQL 对应的脚本（即发布和订阅都对应的 T-SQL 指令），并将这些脚本作为作业的一部分记录在SQL 代理的作业列表或复制文件夹中的复制作业。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-16T20:54:30.537

你可以去链接服务器路由。

你只是不能使用 select * into 你必须插入到 select 中。

如果您没有使用它的经验，我会避免复制，因为如果它坏了可能很难修复，如果管理不当，可能容易出现其他问题。

保持简单，尤其是在数据库很小的情况下。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T08:50:47.327

您可以使用数据转换服务来完成这项工作吗？这为做这种事情提供了各种螺栓连接的工具。

[您可以在此处](http://www.microsoft.com/downloads/details.aspx?FamilyID=d09c1d60-a13c-4479-9b91-9e8b9d835cdc&DisplayLang=en)从 Microsoft 网站下载 SQL Server 2005 功能包

* * *

## 回答 #8

> 赞同：-1
> 
> 时间：2016-09-22T01:40:47.957

```
CREATE VIEW newR1 
AS
SELECT * from OPENQUERY ([INSTANCE_NAME], 'select * from DbName.SchemaName.TableName') 
```

# language-agnostic - 我们能做到100%解耦吗？

> ID：70460
> 
> 赞同：3
> 
> 时间：2008-09-16T08:49:52.150
> 
> 标签：language-agnostic

我们能否在一个系统的组件或相互通信的不同系统之间实现 100% 的解耦？我不认为这是可能的。如果两个系统相互通信，那么它们之间应该存在某种程度的耦合。我对吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T08:52:57.167

如果组件是 100% 解耦的，则意味着它们之间不相互通信。

实际上有[不同类型的耦合](http://en.wikipedia.org/wiki/Coupling_%28computer_science%29)。但一般的想法是，如果对象不相互依赖，它们就不是耦合的。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T08:56:15.583

正确的。即使您写入接口或协议，您也正在致力于某事。您可以平静地忘记 100% 的解耦，并放心，无论您做什么，您都不能随便取出一个组件并在不进行至少小的修改的情况下替换另一个组件，除非您承诺使用非常基本的协议，例如 HTTP（甚至然后。）

毕竟，我们人类只是喜欢标准。这就是为什么我们有......好吧，没关系。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T09:00:55.103

如果组件设计为 100% 正交，则应该是可能的。清晰的关注点分离可以实现这一点。组件需要知道的只是其输入的接口。

耦合应该是单向的：组件知道其参数的语义，但应该彼此不可知。

一旦组件之间有 1% 的耦合，那 1% 就会开始增长（在一个持续时间更长的系统中）

然而，知识通常被注入到对等组件中以实现更高的性能。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T09:01:24.773

即使两个组件不直接通信，使用另外两个组件的第三个组件也是系统的一部分，并且与它们耦合。

@Vadmyst：如果您的组件通过网络进行通信，它们必须使用某种协议，该协议与两个本地组件的接口相同。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T09:02:55.957

这是一个令人痛苦的抽象问题。如果所述系统是单个应用程序的组件，那么有各种技术，例如涉及 MVC（模型视图控制器）和 IoC / 依赖注入接口的技术，可以促进组件的解耦。

从物理隔离软件架构的角度来看，CORBA 和 COM 支持本地或网络互操作，并使用 ATL 之类的“通用语言”。这些已被 XML 服务（例如 SOAP）弃用，后者使用 WSDL 来执行耦合。没有什么可以阻止 SOAP 客户端使用 WSDL 进行运行时延迟耦合，尽管我很少看到它。然后是 JSON 之类的东西，它类似于 XML，但经过优化，还有 Google Protocol Buffers，它优化了互操作，但通常是预编译的，而不是后期耦合的。

当谈到 IPC（进程间通信）时，两个系统只需要说一个通用的“协议”。这可能是 XML，可能是共享类库，也可能是专有的。即使在专有级别，您仍然与内存流、TCP/IP 网络、共享文件（内存或硬盘）或其他一些机制“耦合”，并且您仍在使用字节，最终使用 1 和 0。

所以最终这个问题真的不能公平地回答；严格来说，100% 只有通过相互关联的系统才能实现。将您的问题细化为上下文。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T09:03:56.983

区分直接成分和间接成分很重要。努力删除直接连接（一个类引用另一个类）并改用间接连接。将两个“无知”类与第三个管理它们的交互的类绑定。

这类似于位于表单上的一组用户控件，或者是一个数据库连接池和一个连接池类。更基本的组件（控件和连接）由更高的部分（表单和连接池）管理，但没有基本组件知道另一个。基本组件公开事件和方法，另一部分“拉弦”。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T09:05:09.977

不，我们不能。阅读 Joel 的优秀文章[The Laws of Leaky Abstraction](http://www.joelonsoftware.com/articles/LeakyAbstractions.html)，让很多人大开眼界。但是，这不一定是*坏事*，它就是。泄漏抽象提供了很好的机会，因为它们使底层平台可利用。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-16T08:52:09.367

你可以做到这一点。想想两个通过网络相互通信的组件。一个组件可以在 Windows 上运行，而另一个在 Unix 上运行。这不是100%脱钩吗？

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T08:53:43.123

至少，防火墙保护，至少来自某个接口，需要允许来自每台机器的流量流向另一台机器。仅此一项就可以被认为是“耦合”的一种形式，因此，耦合是至少在一定程度上进行通信的机器所固有的。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T08:54:35.477

这可以通过引入两个组件都理解的通信接口或协议而不是在组件之间直接传递数据来实现。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-16T08:56:07.377

两个不相互引用的 web 服务可能是 100% 解耦的一个很好的例子。然后，耦合将以应用程序实用程序的形式到达，该应用程序通过同时使用它们来将它们“耦合”在一起。

耦合本质上并不是坏事，但是您必须对何时执行（仅在实现时，还是在您的框架本身中？）以及耦合是否合理做出可靠的判断。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2009-08-10T18:45:11.163

很长一段时间都非常努力地思考 API，然后确保它尽可能小，直到它几乎消失的地方......

[Lego Software Process](http://ra-ajax.org/LegoProcess.aspx)提出了这一点...... :) - 实际上很好地实现了这一点......

一个有机体的两个细胞有多“紧密耦合”……？

生物体中的细胞仍然可以进行交流，但不是通过任何需要有关接收（或发送）部分知识的方式进行交流，而是通过将化学物质释放到体内来进行交流...；）

# java - （否）Java 中的属性？

> ID：70471
> 
> 赞同：56
> 
> 时间：2008-09-16T08:52:01.083
> 
> 标签：java, getter-setter

所以，直到最近，我才任性地给自己留了一个Java n00b，而我第一次真正的曝光带来了一个小小的震惊：Java 没有C# 风格的属性！

好吧，我可以忍受。但是，我也可以发誓，我在一个代码库中看到了 Java 中的属性 getter/setter 代码，但我不记得在哪里。那是如何实现的？有语言扩展吗？它与NetBeans有关吗？

* * *

## 回答 #1

> 赞同：64
> 
> 时间：2008-09-16T09:00:15.590

Java 中有一个用于 getter 和 setter 的“标准”模式，称为[Bean properties](http://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html)。基本上任何`get`以 . 同样`set`，使用单个参数创建 void 方法的设置器。

例如：

```
// Getter for "awesomeString"
public String getAwesomeString() {
  return awesomeString;
}

// Setter for "awesomeString"
public void setAwesomeString( String awesomeString ) {
  this.awesomeString = awesomeString;
} 
```

如果您提出要求，大多数 Java IDE 都会为您生成这些方法（在 Eclipse 中，只需将光标移动到某个字段并点击`Ctrl`- `1`，然后从列表中选择选项）。

对于它的价值，为了可读性，您实际上也可以使用`is`并`has`代替`get`布尔类型的属性，如：

```
public boolean isAwesome();

public boolean hasAwesomeStuff(); 
```

* * *

## 回答 #2

> 赞同：34
> 
> 时间：2013-08-28T19:47:01.413

我很惊讶没有人提到[龙目岛项目](http://projectlombok.org/)

是的，目前java中没有属性。还有一些其他缺失的功能。
但幸运的是，我们有[项目 lombok](http://projectlombok.org/)正在努力改善这种情况。它每天也越来越受欢迎。

因此，如果您使用的是 lombok：

```
@Getter @Setter int awesomeInteger = 5; 
```

`getAwesomeInteger`这段代码也将生成`setAwesomeInteger`。[所以它与C# 自动实现的属性](http://msdn.microsoft.com/en-us/library/bb384054.aspx)非常相似。

[您可以在此处](http://projectlombok.org/features/GetterSetter.html)获取有关 lombok getter 和 setter 的更多信息。
您绝对应该检查[其他功能](http://projectlombok.org/features/index.html)。我最喜欢的是：

*   [值](http://projectlombok.org/features/val.html)
*   [NoArgsConstructor、RequiredArgsConstructor、AllArgsConstructor](http://projectlombok.org/features/Constructor.html)
*   [日志！](http://projectlombok.org/features/Log.html)

Lombok 与 IDE 完美集成，因此它将显示生成的方法，例如它们是否存在（建议、类内容、转到声明和重构）。
lombok 的唯一问题是其他程序员可能不知道它。您始终可以对代码进行[delombok](http://projectlombok.org/features/delombok.html)，但这与其说是解决方案，不如说是一种解决方法。

* * *

## 回答 #3

> 赞同：11
> 
> 时间：2008-09-16T10:20:40.967

为 Java 7 提出了“Java 属性支持”，但没有将其纳入语言。

如果有兴趣，请参阅[http://tech.puredanger.com/java7#property](http://tech.puredanger.com/java7#property)了解更多链接和信息。

* * *

## 回答 #4

> 赞同：6
> 
> 时间：2008-09-16T08:59:58.477

bean约定是这样写代码：

```
private int foo;
public int getFoo() {
    return foo;
}
public void setFoo(int newFoo) {
    foo = newFoo;
} 
```

在 JVM 上的其他一些语言中，例如 Groovy，您可以获得类似于 C# 的可覆盖属性，例如，

```
int foo 
```

它可以通过简单的方式访问，`.foo`并利用您可以根据需要覆盖的默认值`getFoo`和`setFoo`实现。

* * *

## 回答 #5

> 赞同：6
> 
> 时间：2013-08-28T19:45:00.173

```
public class Animal {

    @Getter @Setter private String name;
    @Getter @Setter private String gender;
    @Getter @Setter private String species;
} 
```

这类似于 C# 属性。这是[http://projectlombok.org/](http://projectlombok.org/)

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2015-01-28T02:37:12.743

你可能不需要“get”和“set”前缀，为了让它看起来更像属性，你可以这样做：

```
public class Person {
    private String firstName = "";
    private Integer age = 0;

    public String firstName() { return firstName; } // getter
    public void firstName(String val) { firstName = val; } // setter

    public Integer age() { return age; } // getter
    public void age(Integer val) { age = val; } //setter

    public static void main(String[] args) {
        Person p = new Person();

        //set
        p.firstName("Lemuel");
        p.age(40);

        //get
        System.out.println(String.format("I'm %s, %d yearsold",
            p.firstName(),
            p.age());
    }
} 
```

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-16T09:03:13.290

如果您愿意，大多数 Java IDE 会自动为您生成 getter 和 setter 代码。有许多不同的约定，像 Eclipse 这样的 IDE 将允许您选择要使用的约定，甚至可以让您定义自己的约定。

Eclipse 甚至包括自动重构，它允许您将属性包装在 getter 和 setter 中，并且它将修改直接访问该属性的所有代码，以使其使用 getter 和/或 setter。

当然，Eclipse 只能修改它知道的代码——您拥有的任何外部依赖项都可能被这种重构破坏。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-16T08:58:21.803

我的 Java 经验也不是那么高，所以任何人都可以随时纠正我。但是 AFAIK，一般惯例是编写两种方法，如下所示：

```
public string getMyString() {
    // return it here
}

public void setMyString(string myString) {
    // set it here
} 
```

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2013-12-26T08:56:17.487

来自**Jeffrey Richter 的** 书**CLR via C#**：（我认为这些可能是 JAVA 中仍未添加属性的原因）

*   属性方法可能会抛出异常；字段访问永远不会引发异常。
*   属性不能作为`out`或`ref`参数传递给方法；一个字段可以。
*   一个属性方法可能需要很长时间才能执行；现场访问总是立即完成。使用属性的一个常见原因是执行线程同步，这可以永远停止线程，因此，如果需要线程同步，则不应使用属性。在那种情况下，一种方法是优选的。另外，如果你的类可以远程访问（例如，你的类是从 派生的 `System.MarshalByRefObject`），调用属性方法会很慢，因此，方法比属性更受欢迎。在我看来，派生自的类不 `MarshalByRefObject`应该使用属性。
*   如果连续多次调用，一个属性方法可能每次返回不同的值；一个字段每次返回相同的值。该类`System.DateTime`有一个只读 `Now`属性，它返回当前日期和时间。每次查询此属性时，它都会返回不同的值。这是一个错误，Microsoft 希望他们可以通过将 Now 设为方法而不是属性来修复该类。`Environment`的 `TickCount`属性是这个错误的另一个例子。
*   属性方法可能会导致可观察到的副作用；字段访问永远不会。换句话说，类型的用户应该能够以他或她选择的任何顺序设置类型定义的各种属性，而不会注意到类型中的任何不同行为。
*   属性方法可能需要额外的内存或返回对实际上不属于对象状态的某些内容的引用，因此修改返回的对象对原始对象没有影响；查询一个字段总是返回一个对保证是原始对象状态的一部分的对象的引用。使用返回副本的属性可能会让开发人员感到非常困惑，而且这个特性通常没有记录。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-09-16T08:59:24.843

如果您使用的是 eclipse，那么它可以自动为内部属性生成 getter 和 setter 方法，它可以是一个有用且省时的工具。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-09-16T14:21:17.080

我只是发布 Java 5/6 注释和一个注释处理器来帮助解决这个问题。

查看[http://code.google.com/p/javadude/wiki/Annotations](http://code.google.com/p/javadude/wiki/Annotations)

文档现在有点轻，但是 quickref 应该可以理解。

基本上，它使用 getter/setter（以及许多其他代码生成选项）生成一个超类。

示例类可能看起来像

```
@Bean(properties = {
    @Property(name="name", bound=true),
    @Property(name="age,type=int.class)
})
public class Person extends PersonGen {
} 
```

还有更多可用的示例，并且生成的代码中没有运行时依赖项。

如果您尝试并发现它有用，请给我发送电子邮件！——斯科特

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2018-02-17T19:09:47.180

java 中没有属性关键字（就像你可以在 C# 中找到它一样），拥有 1 个单词 getter/setter 的最接近的方法是像在 C++ 中一样：

```
public class MyClass
{
    private int aMyAttribute;
    public MyClass()
    {
        this.aMyAttribute = 0;
    }
    public void mMyAttribute(int pMyAttributeParameter)
    {
        this.aMyAttribute = pMyAttributeParameter;
    }
    public int mMyAttribute()
    {
        return this.aMyAttribute;
    }
}
//usage :
int vIndex = 1;
MyClass vClass = new MyClass();
vClass.mMyAttribute(vIndex);
vIndex = 0;
vIndex = vClass.mMyAttribute();
// vIndex == 1 
```

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2019-01-06T22:47:56.423

正如前面提到的 Eclipse，集成开发环境 (IDE) 通常可以自动创建访问器方法。

您也可以使用 NetBeans 来完成。

要为您的类创建访问器方法，请打开一个类文件，然后右键单击源代码编辑器中的任意位置并选择菜单命令 Refactor、Encapsulate Fields。将打开一个对话框。单击全选，然后单击重构。瞧，

祝你好运，

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2019-11-28T11:12:18.357

对我来说，问题有两个方面：

1.  所有这些额外的方法 {get*/set*} 使类代码混乱。

2.  不能像对待属性一样对待它们：

```
 public class Test {
      private String _testField;

      public String testProperty {
       get {
        return _testField;
       }
       set {
        _testField = value;
       }
      }
    }

    public class TestUser {
      private Test test;

      public TestUser() {
        test = new Test();

        test.testProperty = "Just something to store";
        System.out.printLn(test.testProperty);
      }
    } 
```

这是我想重新使用的那种简单的任务。不必使用“方法”调用语法。任何人都可以提供一些关于 Java 发生了什么的答案吗？

我认为问题还在于代码中不必要的混乱，而不是创建 setter/getter 的“困难”。我认为它们是丑陋的代码。我喜欢 C# 所拥有的。我不理解将这种功能添加到 Java 中的阻力。

我目前的解决方案是在不需要保护时使用“公共”成员：

```
public class IntReturn {
    public int val;
}

public class StringReturn {
    public String val;
} 
```

这些将用于从 Lambda 中返回值：

```
StringReturn sRtn = new StringReturn()

if(add(2, 3, sRtn)){
    System.out.println("Value greater than zero");
}

public boolean add(final int a, final int b, final StringReturn sRtn){
    int rtn = a + b;
    sRtn.val = "" + rtn;
    return rtn > 0; // Just something to use the return for.
} 
```

我也真的不喜欢使用方法调用来设置或获取类的内部值。

如果您的信息作为“不可变”传输，那么新的 Java**记录**可能是一个解决方案。但是，它仍然使用 setter/getter 方法，只是没有 set/get 前缀。

# delphi - 您如何对与第三方 COM 对象交互和实例化的代码进行单元测试？

> ID：70482
> 
> 赞同：6
> 
> 时间：2008-09-16T08:53:33.547
> 
> 标签：delphi, unit-testing, com, mocking

目前阻碍我全力投入单元测试的最大问题之一是，我编写的代码中有很大一部分严重依赖来自不同来源的第三方 COM 对象，这些对象也倾向于相互交互（I'如果您需要知道，我会使用几个帮助程序库为 Microsoft Office 编写加载项）。

我知道我可能应该使用模拟对象，但在这种情况下我该怎么做呢？我可以看到，当我只需要传递对已经存在的对象的引用但我的一些例程自己实例化外部 COM 对象，然后有时将它们传递给来自不同库的其他一些外部 COM 对象时，这相对容易。

这里的最佳实践方法是什么？我是否应该让我的测试代码临时更改注册表中的 COM 注册信息，以便测试代码将实例化我的模拟对象之一？我应该注入修改后的类型库单元吗？还有哪些其他方法？

我会特别感谢 Delphi 的示例或工具，但也会对更一般的建议和更高级别的解释感到满意。

谢谢，

奥利弗

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-09-16T09:10:44.160

传统方法说您的客户端代码应该使用一个包装器，它负责实例化 COM 对象。然后可以轻松地模拟此包装器。

因为您的部分代码直接实例化了 COM 对象，所以这并不适合。如果您可以更改该代码，则可以使用工厂模式：他们使用工厂来创建 COM 对象。您可以模拟工厂以返回替代对象。

是通过包装器还是通过原始 COM 接口访问对象取决于您。如果您选择模拟 COM 接口，请记住在您的模拟中检测 IUnknown::QueryInterface，这样您就知道您已经模拟了所有接口，特别是如果该对象随后被传递给其他一些 COM 对象。

或者，查看[CoTreatAsClass](http://msdn.microsoft.com/en-us/library/ms693452.aspx)方法。我从未使用过它，但它可能会满足您的需求。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T09:01:15.197

它归结为“为可测试性而设计”。理想情况下，您不应该直接实例化这些 COM 对象，而应该通过可以被模拟对象替换的间接层来访问它们。

现在，COM 本身确实提供了一定程度的间接性，您可以提供一个模拟对象来替代真实的对象，但我怀疑创建它会很痛苦，我怀疑您是否会从现有的模拟框架中获得很多帮助.

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-16T09:04:17.280

我会围绕您的第三方 COM 对象编写一个瘦包装类，它能够在单元测试情况下加载模拟对象而不是实际的 COM 对象。我通常通过调用第二个构造函数来传递模拟对象来做到这一点。普通的构造函数会像往常一样加载 COM 对象。

[wikipedia article对Wikipedia artible](http://en.wikipedia.org/wiki/Mock_object)这个主题有很好的介绍

# .net - Mono 的 DateTime 序列化

> ID：70487
> 
> 赞同：1
> 
> 时间：2008-09-16T08:54:01.203
> 
> 标签：.net, datetime, mono, remoting

如果你在 Linux 上使用 Mono Remoting，你有什么解决方法来解决 Mono 和 .NET Remoting 之间的 DateTime 编组不兼容问题？

我在使用 .NET 2.0 运行时的 Windows 上使用 WinForms，在使用 Mono 的 Linux 上使用 Remoting。我还不能在两端使用 Mono 运行时，因为 Mono 的 DataGridView 还没有工作。

[更新]

发布问题时，我使用了 Mono 1.9。我现在使用 Mono 2.4，它的 DateTime 现在与 .NET 兼容。向 Miguel de Icaza、他的团队和 Novell 致敬

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T11:06:44.800

我认为一个更好的解决方案是重构代码，所以不要使用（但支持不足的）远程处理，而是使用 Web 服务。IIRC 完全支持大多数基本数据类型的 XML 序列化；在某些情况下，更适合架构（尤其是服务器-客户端架构）。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-17T09:32:12.320

使用测试用例提交错误。

# .net - 从 .NET 向 COM 公开嵌套数组

> ID：70501
> 
> 赞同：0
> 
> 时间：2008-09-16T08:55:38.737
> 
> 标签：.net, com, vb6, marshalling, tlbexp

我在 .NET (C#) 中有一个方法，它返回`string[][]`. 使用 RegAsm 或 TlbExp（来自 .NET 2.0 SDK）为包含程序集创建 COM 类型库时，我收到以下警告：

> 警告：嵌套数组不支持封送处理。

此警告导致相关方法未导出到生成的类型库中。有人告诉我，有一些方法可以使用 Variant 作为 COM 返回类型，然后在 COM 客户端进行强制转换/等。对于这个特定的程序集，目标客户群是 VB6。**但是在 .NET 端，您实际上是如何做到这一点的呢？**

*注意*：我有一个现有的旧版 DLL（及其导出的类型库），其中返回类型为 Variant，但此 DLL（和 .tlb）是使用 .NET 之前的旧版工具生成的，因此我无法使用它们。

如果程序集是用 VB.NET 编写的，它会有所帮助吗？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-16T17:17:41.540

即使您要返回一个对象（映射到 COM 互操作中的变体），也不能解决您的问题。VB 将能够“抓住”它并“传递它”，但它无法对它做任何事情。

从技术上讲，VB 中没有字符串[][] 的完全等价物。但是，如果您的数组不是“锯齿状”（即所有子数组的长度相同），您应该能够使用二维数组作为返回类型。COM Interop 应该能够翻译它。

```
string [,] myReturnValue = new string[rowCount,colCount]; 
```

无论您的方法正式返回一个 Object（它看起来像 VB 的 Variant）还是一个 string[,]（它看起来像 VB 中的一个字符串数组），都有些无关紧要。String 数组是一个更好的返回值，但不是必需的。

如果您的阵列*是*锯齿状的，那么您将不得不想出一种不同的方法。例如，您可以选择让您的返回二维数组与最大的子数组一样大，然后在单独的 [out] int[] 参数中传递长度信息，以便 VB 知道使用了哪些元素。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T11:31:34.977

C# 中的变体等价物是 System.Object。因此，您可能想尝试将结果转换返回到对象并在另一侧将其作为变体重新拾取。

VB 没有 C# 所缺乏的任何功能，所以我怀疑如果 .NET 端是用 VB 编写的会更好或更容易。

# containers - 将原始 .aac 文件包装到 .m4a 容器中的最简单方法是什么

> ID：70513
> 
> 赞同：19
> 
> 时间：2008-09-16T08:56:58.203
> 
> 标签：containers, aac, m4a

这个问题是从以下问题溢出的：

[如何以编程方式将 mp3 转换为 iTunes 可播放的 aac/m4a 文件？](https://stackoverflow.com/questions/70096/how-do-i-programmatically-convert-mp3-to-an-itunes-playable-aacm4a-file)

无论如何，我学会了如何创建 aac 文件，然后我发现 aac 不仅仅是具有不同文件扩展名的 m4a 文件。事实上，我需要以某种方式将 aac 包装到一个 m4a 容器中。理想情况下，我可以简单地调用命令行。

* * *

## 回答 #1

> 赞同：29
> 
> 时间：2011-06-10T05:31:15.093

`ffmpeg`是一种通用（解）复用器/转码器。`MP4Box`是来自[GPAC](http://gpac.wp.institut-telecom.fr/mp4box/)的 (de)muxer/transcoder ，一个专用于 MP4 相关软件技术的软件包。现在使用 MP4Box 似乎更明智，因为它对文件开头的 moov atom 进行了权利，这对于流媒体和 ipod 播放很重要。

像这样使用ffmpeg：

```
ffmpeg -i input.aac -codec: copy output.m4a 
```

像这样使用 MP4Box：

```
MP4Box -add input.aac#audio output.m4a 
```

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-09-16T10:18:53.730

mp4box 如果您想要专用工具；它可能是最简单的方法。ffmpeg 也可以完成这项工作。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2014-03-13T02:34:55.103

`avconv -i input.aac -acodec copy output.m4a`

在我的情况下，如果没有明确的标志 to *copy*，它会出于某种奇怪的原因重新编码音频。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2017-12-11T01:09:38.007

只需使用任何像 Yamb 这样的 mp4-Muxer 来创建一个`mp4`只包含`aac`音轨的文件，然后将文件扩展名更改为`m4a`.

# tsql - 在 TSQL 中获取 ISO 周数的开始和结束日期的正确方法是什么？

> ID：70516
> 
> 赞同：2
> 
> 时间：2008-09-16T08:57:04.893
> 
> 标签：tsql, iso, datetime

我有 ISO 周和年，但如何正确地将其转换为代表该周开始和结束的两个日期？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T09:35:21.543

有几种策略可以做到这一点：

*   [一周开始功能](http://www.sqlteam.com/forums/topic.asp?TOPIC_ID=47307)
*   [周末功能](http://www.sqlteam.com/forums/topic.asp?TOPIC_ID=64760)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T09:44:24.703

如果您有一些 SQL 代码，您可以从[F_TABLE_DATE](http://www.sqlteam.com/forums/topic.asp?TOPIC_ID=61519)中删除相关位。或者，如果你喜欢周围有怪物功能，你可以使用整个 shebang。不过，您必须制造一个合理的开始和结束日期才能传递给 F_TABLE_DATE。

# ruby-on-rails - Rails 开发人员如何与 Flex 前端对话？

> ID：70524
> 
> 赞同：3
> 
> 时间：2008-09-16T08:58:58.680
> 
> 标签：ruby-on-rails, apache-flex

我将 Rails 开发视为 Flex 应用程序的后端，并试图找出 Rails 应用程序和 Flash Player 之间的通信层。我发现的所有东西都建议使用 SOAP Web 服务进行通信。

然而，Flash 支持 AMF，它既好又快（而且是原生的）。有什么方法可以通过 Rails 应用程序通过 AMF 进行通信，同时支持有关 AMF 的所有“好”功能（自动类型转换、数据推送等）。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-16T09:13:04.530

您可以使用[WebORB](http://www.themidnightcoders.com/weborb/rubyonrails/)或[RubyAMF](http://code.google.com/p/rubyamf/)从 Rails 在 AMF 中进行响应，每种方法都有所不同，因此取决于您的需求。RubyAMF 在[Flexible Rails](http://www.flexiblerails.com/)电子书的最后几章中进行了讨论，这是一个很好的将 Rails 与 Flex 结合使用的资源。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-17T09:38:09.843

我正在编写一个 rails/flex 应用程序，我们正在转向在 REST 框架中使用 JSON 通信。来自 Flex 端处理 JSON 响应的简单 HTTP 请求似乎是分离客户端和服务器的最佳方式。XML 同样简单。

值得一提的是，我们也在 flex 端使用 PureMVC 框架，将响应保存在客户端模型中。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T15:28:04.703

您不会使用 SOAP Web 服务，而是使用 Rails 中原生的“本机”REST Web 服务。上面 DEFusion 引用的那本书实际上是关于：如何使用 FLEX 客户端作为使用 REST（即 XML）的 Rails 应用程序的前端。

AMF 协议主要由 Adob​​e 构建为二进制协议，以允许 FLEX 前端与 CodeFusion 以及 Java 服务器应用程序进行通信。它不是免费的，除了使用 Adob​​e 的 BlazeDS，您实际上不会获得太多支持。然后当然，您必须选择一个能够使用 AMF 协议与 BlazeDS 对话的插件（再次参见 DEfusion 的帖子）并依赖它。

您会惊讶于通过 REST 将 Flex 直接连接到 Rails 的效果如何，而且您不必依赖第三方。我建议你试试看。

希望这可以帮助

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-30T11:42:33.190

如果您想要与可以响应/生成 AMF 的控制器进行 MVC 样式交互，请使用 RubyAMF。

将 WebOrb 用于任何其他样式，包括直接访问模型对象。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2009-11-11T12:56:27.530

我已经使用所有三种方法（WebOrb、RubyAMF、REST）构建了应用程序......

WebOrb for Rails 几乎已经死了，它已经有一段时间没有更新了。也就是说，我能够创建一些 Flex/Ruby 魔法，使 Flex 对 Rails 的模型对象的访问变得透明……如果您有兴趣，我会挖掘它并发送给您。

RubyAMF 很好，但不如 WebOrb 灵活（哈哈！）。

返回 JSON 的 REST 非常简单，如果我必须构建另一个（我希望不会），我将继续使用它。

YMMV。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T09:12:22.393

有一个名为[WebORB for Ruby on Rails](http://www.themidnightcoders.com/weborb/rubyonrails/index.htm)的 Rails 插件，它使用 AMF 进行远程处理。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2009-11-10T16:18:22.937

你可以使用 WebORB 或 RubyAMF，或者只是简单的 XML——Rails 在 XML 方面非常聪明，这里和那里都有一些陷阱。

我们几乎完全使用 XML 在 Rails 应用程序和 Flex Web 应用程序之间进行通信。这很简单。

要从 Rails 应用程序中检索数据，只需创建一个 result_type 为 e4x 的 HTTPService，然后调用您的 url。在您的 Rails 控制器中，执行以下操作：

```
def people
  render :xml => Person.all.to_xml
end 
```

有时，Rails 会将标签添加到末尾。如果发生这种情况，请将您的控制器更改为：

```
def people
  render :xml => Person.all.to_xml.target!
end 
```

如果您想将数据发送到 Rails 应用程序，这同样简单..

```
<mx:HTTPService id="theservice" url="http://localhost:3000/svc/add_person" method="POST">
 <mx:request>
  <person>
   <first>Firstname</first>
   <last>Lastname</last>
  </person>
 </request>
</HTTPService> 
```

在你的控制器中：

```
def add_person
  p=Person.create(params[:person])
  render :xml => {:result => "Success"}.to_xml.target!
end 
```

*   凯文

# python - 为什么 Python 的“私有”方法实际上不是私有的？

> ID：70528
> 
> 赞同：756
> 
> 时间：2008-09-16T08:59:32.377
> 
> 标签：python, python-2.7, encapsulation, information-hiding

Python 使我们能够通过在名称前添加双下划线来在类中创建“私有”方法和变量，例如：`__myPrivateMethod()`. 那么，如何解释这一点

```
>>>> class MyClass:
...     def myPublicMethod(self):
...             print 'public method'
...     def __myPrivateMethod(self):
...             print 'this is private!!'
...
>>> obj = MyClass()

>>> obj.myPublicMethod()
public method

>>> obj.__myPrivateMethod()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: MyClass instance has no attribute '__myPrivateMethod'

>>> dir(obj)
['_MyClass__myPrivateMethod', '__doc__', '__module__', 'myPublicMethod']

>>> obj._MyClass__myPrivateMethod()
this is private!! 
```

这是怎么回事？！

我会为那些不太明白的人解释一下。

```
>>> class MyClass:
...     def myPublicMethod(self):
...             print 'public method'
...     def __myPrivateMethod(self):
...             print 'this is private!!'
...
>>> obj = MyClass() 
```

我用公共方法和私有方法创建了一个类并实例化它。

接下来，我调用它的公共方法。

```
>>> obj.myPublicMethod()
public method 
```

接下来，我尝试调用它的私有方法。

```
>>> obj.__myPrivateMethod()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: MyClass instance has no attribute '__myPrivateMethod' 
```

这里的一切看起来都不错；我们无法调用它。事实上，它是“私人的”。嗯，实际上并非如此。在对象上运行*dir()*揭示了 Python 为所有“私有”方法神奇地创建的新神奇方法。

```
>>> dir(obj)
['_MyClass__myPrivateMethod', '__doc__', '__module__', 'myPublicMethod'] 
```

这个新方法的名字总是一个下划线，然后是类名，然后是方法名。

```
>>> obj._MyClass__myPrivateMethod()
this is private!! 
```

封装这么多，嗯？

无论如何，我总是听说 Python 不支持封装，那么为什么还要尝试呢？是什么赋予了？

* * *

## 回答 #1

> 赞同：662
> 
> 时间：2008-09-16T10:06:07.943

名称加扰用于确保子类不会意外覆盖其超类的私有方法和属性。它的设计目的不是为了防止从外部故意访问。

例如：

```
>>> class Foo(object):
...     def __init__(self):
...         self.__baz = 42
...     def foo(self):
...         print self.__baz
...     
>>> class Bar(Foo):
...     def __init__(self):
...         super(Bar, self).__init__()
...         self.__baz = 21
...     def bar(self):
...         print self.__baz
...
>>> x = Bar()
>>> x.foo()
42
>>> x.bar()
21
>>> print x.__dict__
{'_Bar__baz': 21, '_Foo__baz': 42} 
```

当然，如果两个不同的类具有相同的名称，它就会崩溃。

* * *

## 回答 #2

> 赞同：214
> 
> 时间：2010-06-30T08:24:05.460

### 私有函数示例

```
import re
import inspect

class MyClass:

    def __init__(self):
        pass

    def private_function(self):
        try:
            function_call = inspect.stack()[1][4][0].strip()

            # See if the function_call has "self." in the beginning
            matched = re.match( '^self\.', function_call)
            if not matched:
                print 'This is a private function. Go away.'
                return
        except:
            print 'This is a private function. Go away.'
            return

        # This is the real function, only accessible inside the class #
        print 'Hey, welcome in to the function.'

    def public_function(self):
        # I can call a private function from inside the class
        self.private_function()

### End ### 
```

* * *

## 回答 #3

> 赞同：201
> 
> 时间：2009-12-22T23:25:42.737

当我第一次从 Java 转向 Python 时，我**讨厌**这个。把我吓死了。

今天，它可能只是**我最**喜欢 Python 的一件事。

我喜欢在一个平台上，人们相互信任，并且不觉得他们需要在他们的代码周围建造坚不可摧的墙。在强封装的语言中，如果 API 有错误，并且您已经找出问题所在，您可能仍然无法解决它，因为所需的方法是私有的。在 Python 中，态度是：“确定”。如果您认为您了解情况，也许您甚至已经阅读过它，那么我们只能说“祝您好运！”。

请记住，封装与“安全”或让孩子远离草坪甚至没有微弱的关系。它只是另一种模式，应该用于使代码库更易于理解。

* * *

## 回答 #4

> 赞同：154
> 
> 时间：2008-09-16T09:03:45.080

从*[潜入 Python，3.9。私人功能](http://www.faqs.org/docs/diveintopython/fileinfo_private.html)*：

> 严格来说，私有方法可以在其类之外访问，只是不容易访问。Python 中没有什么是真正私有的。在内部，私有方法和属性的名称会在运行中被修改和取消修改，以使它们看起来无法通过它们的给定名称访问。您可以通过名称 _MP3FileInfo__parse 访问 MP3FileInfo 类的 __parse 方法。承认这很有趣，然后承诺永远不会在实际代码中这样做。私有方法是私有的是有原因的，但就像 Python 中的许多其他东西一样，它们的私有性最终是一个约定问题，而不是强制问题。

* * *

## 回答 #5

> 赞同：103
> 
> 时间：2008-09-16T09:33:18.317

常用的短语是“我们在这里都是同意的成年人”。通过添加一个单下划线（不要暴露）或双下划线（隐藏），您是在告诉您班级的用户您希望该成员以某种方式成为“私人”。但是，您相信其他所有人都会负责任地行事并尊重这一点，除非他们有令人信服的理由不这样做（例如，调试器和代码完成）。

如果您确实必须拥有私有的东西，那么您可以在扩展中实现它（例如，在 C 中用于[CPython](https://en.wikipedia.org/wiki/CPython)）。然而，在大多数情况下，您只需学习[Pythonic](https://en.wiktionary.org/wiki/Pythonic#Adjective)的做事方式。

* * *

## 回答 #6

> 赞同：34
> 
> 时间：2008-09-16T09:04:57.030

这并不是说您绝对无法解决任何语言中成员的隐私问题（C++ 中的指针算术和 .NET/Java 中的反射）。

关键是，如果您尝试不小心调用私有方法，则会出现错误。但是，如果您想在脚上开枪，那就去做吧。

您不会尝试通过 OO 封装来保护您的东西，是吗？

* * *

## 回答 #7

> 赞同：16
> 
> 时间：2020-11-24T11:16:38.667

# 重要的提示：

任何形式的标识符`__name`（至少两个前导下划线，最多一个尾随下划线）都被公开替换为`_classname__name`，其中`classname`是去掉前导下划线的当前类名。

**因此，`__name`不能直接访问，但可以作为`_classname__name`.**

这并不意味着您可以保护您的私人数据，因为它可以通过更改变量的名称轻松访问。

#### 来源：

官方文档中的“私有变量”部分：[https ://docs.python.org/3/tutorial/classes.html#tut-private](https://docs.python.org/3/tutorial/classes.html#tut-private)

## 例子

```
class Cat:
    def __init__(self, name='unnamed'):
        self.name = name
    def __print_my_name(self):
        print(self.name)

tom = Cat()
tom.__print_my_name() #Error
tom._Cat__print_my_name() #Prints name 
```

* * *

## 回答 #8

> 赞同：12
> 
> 时间：2008-09-16T09:09:32.430

这只是这些语言设计选择之一。在某种程度上，他们是有道理的。他们做到了，所以你需要不遗余力地尝试调用该方法，如果你真的非常需要它，你一定有一个很好的理由！

调试钩子和测试作为可能的应用程序浮现在脑海中，当然要负责任地使用。

* * *

## 回答 #9

> 赞同：12
> 
> 时间：2008-09-17T04:29:45.137

当模块属性名称以单个下划线开头（例如_foo）时，存在类似的行为。

使用该方法时，这样命名的模块属性不会复制到导入模块中`from*`，例如：

```
from bar import * 
```

但是，这是一种约定，而不是语言限制。这些不是私有属性；它们可以被任何进口商引用和操作。有人争辩说，正因为如此，Python 无法实现真正​​的封装。

* * *

## 回答 #10

> 赞同：4
> 
> 时间：2016-08-24T12:31:44.700

在 Python 3.4 中，行为如下：

```
>>> class Foo:
        def __init__(self):
                pass
        def __privateMethod(self):
                return 3
        def invoke(self):
                return self.__privateMethod()

>>> help(Foo)
Help on class Foo in module __main__:

class Foo(builtins.object)
 |  Methods defined here:
 |
 |  __init__(self)
 |
 |  invoke(self)
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)

 >>> f = Foo()
 >>> f.invoke()
 3
 >>> f.__privateMethod()
 Traceback (most recent call last):
   File "<pyshell#47>", line 1, in <module>
     f.__privateMethod()
 AttributeError: 'Foo' object has no attribute '__privateMethod' 
```

从*[9.6 开始。私有变量](https://docs.python.org/3/tutorial/classes.html#tut-private)*：

> 请注意，修改规则主要是为了避免事故。**仍然可以访问或修改被认为是私有的变量。**这甚至在特殊情况下很有用，例如在调试器中。

* * *

## 回答 #11

> 赞同：4
> 
> 时间：2018-04-26T22:37:29.203

关于私有方法和属性最重要的问题是告诉开发人员不要在类之外调用它，这就是封装。人们可能会误解封装的安全性。当一个人故意使用像你提到的那样（下面）的语法时，你不想要封装。

```
obj._MyClass__myPrivateMethod() 
```

我已经从 C# 迁移过来了，起初这对我来说也很奇怪，但过了一段时间我想到只有 Python 代码设计人员对 OOP 的看法不同。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2019-01-14T10:15:52.000

> 为什么 Python 的“私有”方法实际上不是私有的？

据我了解，他们*不能*是私人的。如何保护隐私？

显而易见的答案是“只能通过`self`”访问私有成员，但这不起作用——`self`这在 Python 中并不特殊。它只不过是函数第一个参数的常用名称。

# vim - 在不标记缓冲区更改的情况下计算 Vim 中的出现次数

> ID：70529
> 
> 赞同：113
> 
> 时间：2008-09-16T08:59:57.087
> 
> 标签：vim

为了知道当前缓冲区中存在多少次模式，我这样做：

```
:%s/pattern-here/pattern-here/g 
```

它给出了模式的出现次数，但显然很麻烦，并且还具有设置“已更改”状态的副作用。

有没有更优雅的计数方式？

* * *

## 回答 #1

> 赞同：169
> 
> 时间：2008-09-16T09:18:01.693

为避免替换，请将第二个模式留空，并添加“n”标志：

```
:%s/pattern-here//gn 
```

这被描述为[官方提示](http://vimdoc.sourceforge.net/htmldoc/tips.html#count-items)。

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2013-01-31T21:49:40.420

```
:help count-items 
```

在 VIM 6.3 中，您可以这样做。

```
:set report=0
:%s/your_word/&/g    # returns the count without substitution 
```

在 VIM 7.2 中，你会这样做：

```
:%s/your_word/&/gn   # returns the count, n flag avoids substitution 
```

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-09-16T09:24:28.947

```
:!cat %| grep -c "pattern" 
```

它不完全是 vim 命令，但它会为您提供 vim 所需的内容。
如果需要经常使用，可以将其映射到命令中。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2009-07-22T21:16:11.553

vimscript [IndexedSearch](http://www.vim.org/scripts/script.php?script_id=1682)增强了 Vim 搜索命令以显示“At match #N out of M matches”。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2015-09-17T15:26:45.413

将光标放在要计数的单词上并执行以下操作。

```
:%s/<c-r><c-w>//gn 
```

看`:h c_ctrl-r_ctrl-w`

* * *

## 回答 #6

> 赞同：-1
> 
> 时间：2011-11-09T23:32:45.273

vimgrep 是你的朋友：

```
vimgrep pattern % 
```

显示：

```
(1 of 37) 
```

# java - 在 Java 中作弊单继承？

> ID：70537
> 
> 赞同：8
> 
> 时间：2008-09-16T09:00:27.040
> 
> 标签：java, oop, inheritance

我听说有一种方法可以欺骗单继承并在 Java 中实现多继承。有谁知道如何实现这个（不使用接口）？

只是出于好奇;-)

* * *

## 回答 #1

> 赞同：20
> 
> 时间：2008-09-16T10:37:58.537

当然可以，但这很棘手，你应该真正考虑一下这是否是你想要的方式。
这个想法是使用基于范围的继承和基于类型的继承。这是类型对话，因为内部类“继承”外部类的方法和字段。这有点像 mixins，外部类混入内部类，但不安全，因为您可以更改外部类的状态以及使用其方法。
Gilad Bracha（主要的 java 语言设计者之一）写了[一篇论文](http://bracha.org/dyla.pdf)讨论那个。因此，假设您想在一些不相关的类之间共享一些内部使用的方法（例如，用于字符串操作），您可以创建它们的子类作为具有所有需要方法的类的内部类，并且子类可以使用来自它们的超类和外部类的方法。

无论如何，对于复杂的类来说这很棘手，您可以使用静态导入（从 java 5 开始）获得大部分功能。不过，这是面试和酒吧测验的好问题；-)

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-11-29T06:28:08.180

~~Java 不支持单一~~多重继承，相反，它具有用于相同目的的接口。如果您坚持使用多重继承，则应该在 C++ 中完成。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-16T09:04:43.380

使用组合而不是继承往往是解决这个问题的方法。这实际上对可测试性也有很大帮助，因此总的来说这是一种很好的做法。

但是，如果您只是希望您的类型像其他几种类型一样“表现”，那么您可以从任意数量的接口继承；显然，您不能从这些中“借用”实现细节。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-16T09:05:32.237

我相信Java不支持多重继承的根本原因和C#是一样的；所有对象最终都是从 Object 派生的，并且它具有指向同一基类的多个路径对于编译器来说是模棱两可的。模棱两可 == 不好，所以编译器不允许这样做。

相反，您可以通过委托模拟多重继承。有关示例，请参见[本文。](http://www.javaworld.com/javaworld/jw-10-2005/jw-1024-multiple.html)

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-16T09:12:18.773

您可以通过使用 java.lang.reflect.Proxy 实例来欺骗它（我有点强调）。

这实际上只允许您添加额外的接口并在运行时将它们的调用委托给另一个实例。

作为一个指导和指导新开发人员的人，如果有人向我展示这样做的代码，我会感到震惊。反射是你真正需要了解的工具之一，并且在开始之前对 Java 有很好的理解。我个人只做过一次，它是为了让一些我无法控制的代码实现一些接口我无法控制的其他代码是预期的（这是一个快速的 hack，所以我不必编写和维护太多的胶水代码）。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-16T09:05:18.230

使用`interface`s。您可以根据需要实现任意数量。如果需要，您通常可以在[复合模式 (GoF)](http://c2.com/cgi/wiki?CompositePattern)上使用一些变体，以便能够重用实现代码。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-16T09:13:25.043

您需要小心区分接口继承（本质上是提供特定设施的合同的继承）和实现继承（实现机制的继承）。

Java通过*implements*机制提供接口继承，*可以*有多个接口继承。

实现继承是*扩展*机制，您只有一个版本。你*真的*需要多重实现继承吗？我打赌你不会，这充满了不愉快的后果，除非你是埃菲尔程序员。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-16T09:14:43.103

您可以通过显式管理超类集并使用反射在所有超类中搜索目标方法来“模拟”它。我不想在生产中这样做，但它可能是一个有趣的玩具程序。通过利用反射、动态创建类和以编程方式调用编译器，您可能会做很多奇怪的事情。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T09:02:28.830

JAVA 不支持多重继承。

你可以让它实现多个接口，有些人认为这是解决问题的一种方法。就我个人而言，我还没有使用多重继承，所以我无法真正理解它的吸引力。

通常，当有人在 c# 或 JAVA 中建议多重继承时，这是因为在 c++ 中“他们可以”。我喜欢“仅仅因为你可以并不意味着你应该”。由于 c# & JAVA 不支持它，为什么要试图强迫它做一些它不打算做的事情。这并不是说在某些特殊情况下它是一种有效的技术，只是代码通常可以重构为不需要它。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T09:38:53.030

我在考虑这个问题并意识到虽然动态代理可以工作（这就是 RMI（使用？）的工作方式），但如果你真的想要这种功能，你最好看看面向方面编程 (AOP) 使用类似于 AspectJ (eclipse.org/aspectj)。

通过这种方式，您可以将几个不同的方面放入一个类中，从而为您提供伪 mixin 继承，而没有可怕的脆弱继承层次结构。

正如其他人所指出的那样，想要/需要多重继承通常表明您没有从正确的角度解决问题。记住“优先组合胜过继承”的 GoF 原则！

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-16T10:21:54.630

有人努力将 mixins 引入 Java。查看此链接：[http ://www.disi.unige.it/person/LagorioG/jam/](http://www.disi.unige.it/person/LagorioG/jam/)

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2009-05-12T20:29:35.547

通过使用内部类，这也是 C++ 有时更喜欢的：[Inner Class Idiom](http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Inner_Class)。

* * *

## 回答 #13

> 赞同：-1
> 
> 时间：2017-10-15T09:53:56.190

是的，您可以说这是一个技巧，而且非常有趣，您不能将多个类继承到单个类，但是可以为一个类实现多个接口，例如

```
public class parents implements first, second{

} 
```

但请记住，您必须覆盖接口中声明的方法。

# java - 如何对 AJAX 应用程序进行黑盒测试？

> ID：70554
> 
> 赞同：7
> 
> 时间：2008-09-16T09:03:43.193
> 
> 标签：java, .net, javascript, ajax, testing

在 AJAX Web 应用程序上执行黑盒测试的最佳跨平台方法是什么？

理想情况下，解决方案应具有以下属性：

*   能够集成到持续集成构建循环中
*   跨平台，因此您可以在 Windows 笔记本电脑和 Linux 持续集成服务器上运行它
*   编写交互脚本的简单方法
*   自由自在，因此您可以在必要时将其调整到您的工具链中

我研究过 HttpUnit，但我不相信它可以处理 AJAX 繁重的网站。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T09:09:10.777

Selenium 可能是您正在寻找的：[http ://selenium.openqa.org/](http://selenium.openqa.org/)

它允许您编写动作脚本并评估结果。它是开源的（Apache 2.0），跨平台，并且有很好的工具。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T13:16:12.463

我已经使用 Selenium 来完成这项任务，但发现它很脆弱。

看看两位 Google 员工的演讲：[我的按钮看起来大吗？构建可测试的 AJAX 应用程序](http://video.google.com/videoplay?docid=4378663232897374824)

他们隔离可测试的 javascript（非 DOM 交互）并使用 Rhino javascript 引擎对其进行测试。

# algorithm - 如何比较短语的相似性？

> ID：70560
> 
> 赞同：12
> 
> 时间：2008-09-16T09:04:44.750
> 
> 标签：algorithm, full-text-search

输入问题时，stackoverflow 会向您显示它认为可能涵盖同一主题的问题列表。我在其他站点或其他程序中也看到了类似的功能（例如，帮助文件系统），但我自己从未编写过类似的东西。现在我很想知道一个人会使用什么样的算法。

我想到的第一个方法是将短语拆分为单词并查找包含这些单词的短语。在你这样做之前，你可能想扔掉无关紧要的词（比如'the'、'a'、'does'等），然后你会想要对结果进行排名。

嘿，等等 - 让我们为网页做这个，然后我们可以有一个...... watchamacallit ... - 一个“搜索引擎”，然后我们可以销售广告，然后......

不，说真的，解决这个问题的常用方法是什么？

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2008-09-16T09:18:01.147

一种方法是所谓的词袋模型。

正如您所猜到的，首先您计算单词在文本中出现的次数（通常在 NLP 术语中称为文档）。然后你扔掉所谓的停用词，如“the”、“a”、“or”等。

你只剩下字数和字数了。这样做一段时间，您将获得出现在文档中的一组全面的单词。然后，您可以为这些单词创建一个索引：“aardvark”是 1，“apple”是 2，...，“z-index”是 70092。

现在你可以把你的词袋变成向量了。例如，如果您的文档包含两个对土豚的引用，而没有其他内容，它将如下所示：

```
[2 0 0 ... 70k zeroes ... 0]. 
```

[在此之后，您可以用点积](http://en.wikipedia.org/wiki/Dot_product)计算两个向量之间的“角度” 。角度越小，文件越接近。

这是一个简单的版本，还有其他更高级的技术。愿[维基百科与你同在](http://en.wikipedia.org/wiki/Document_classification)。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T10:11:25.700

@Hanno，您应该尝试 Levenshtein 距离算法。给定一个输入字符串**s**和一个字符串列表**t对****t**中的每个字符串**u**进行迭代，并返回具有最小 Levenshtein 距离的字符串。

 **[http://en.wikipedia.org/wiki/Levenshtein_distance](http://en.wikipedia.org/wiki/Levenshtein_distance)

[请参阅http://www.javalobby.org/java/forums/t15908.html](http://www.javalobby.org/java/forums/t15908.html)中的 Java 实现示例

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-16T13:08:38.300

为了增强词袋的想法：

您还可以通过多种方式关注 n-gram，即按顺序排列的两个或多个单词的字符串。您可能想要这样做，因为搜索“空间复杂性”不仅仅是搜索其中包含“空间”和“复杂性”的事物，因为这个短语的含义不仅仅是其各部分的总和；也就是说，如果你得到一个谈论外层空间和宇宙复杂性的结果，这可能不是搜索“空间复杂性”的真正含义。

这里自然语言处理的一个关键思想是[互信息](http://en.wikipedia.org/wiki/Mutual_information)，它允许您（从算法上）判断一个短语是否真的是一个特定的短语（例如“空间复杂度”）或只是巧合相邻的单词。从数学上讲，主要思想是从概率上询问这些词是否比您仅凭它们的频率猜测的更频繁地出现在彼此旁边。如果您在搜索查询中（或在编制索引时）看到具有高互信息分数的短语，则可以通过尝试保持这些词的顺序来获得更好的结果。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-16T09:26:40.253

根据我开发全文搜索引擎的（相当少的）经验：我会查找包含查询中一些单词的问题（在您的情况下，查询是您的问题）。当然，干扰词应该被忽略，我们可能想要检查“ASP.Net”等“强”词的查询以缩小搜索范围。http://en.wikipedia.org/wiki/Index_(search_engine)#Inverted_indices'>倒排索引通常用于查找我们感兴趣的单词的问题。

在从查询中找到带有单词的问题后，我们可能想要计算我们对问题感兴趣的单词之间的距离，因此具有“短语相似性”文本的问题排名高于具有“讨论相似性，您听到以下短语......”文本的问题。

# perl - 学习 Perl 的最佳在线资源是什么？

> ID：70573
> 
> 赞同：22
> 
> 时间：2008-09-16T09:07:42.357
> 
> 标签：perl

我是任何脚本语言的新手。但是，我仍然在编写脚本，就像为我的目的定制其他脚本一样。对我来说，学习 Perl 的最佳在线资源是什么？

* * *

## 回答 #1

> 赞同：33
> 
> 时间：2008-09-16T09:11:24.923

如果您已经了解一点 perl，[PerlMonks](http://www.perlmonks.org/)是一个很棒的在线资源。你可以在他们的[Seekers of Perl Wisdom](http://www.perlmonks.org/?node=Seekers%20of%20Perl%20Wisdom)部分提出问题，答案通常质量很高。许多跟上 Perl 最新发展的人都在那里闲逛。

作为额外的好处，如果你问一个明确的问题，很多时候那里的人会花时间研究潜在的问题，并会指出替代方法，而不是简单地把你的问题放在表面上。

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2008-09-17T03:48:18.747

我意识到这个问题是关于在线资源的，但是由于以下书籍，我在大约三周内自学了 Perl：

[学习 Perl](http://oreilly.com/catalog/9780596520106/)

[中级 Perl](http://oreilly.com/catalog/9780596102067/)

我已经有了一点 C 的背景知识，但是这些书的教学方式是惊人的。我用 Perl 编写的脚本目前正在为 UA/NASA Phoenix Mars Lander 上的一些仪器团队使用的数据分析过程提供动力——我是一名大三学生！如果它对 NASA 来说足够好，那对你来说就足够了 :)

* * *

## 回答 #3

> 赞同：9
> 
> 时间：2008-09-16T10:06:05.103

[perldoc](http://perldoc.perl.org/perl.html)文档是了解如何*很好*地使用该语言的最佳来源。

骆驼书“Programming Perl”是一本出色的印刷参考书，其中包含由编写 perldocs 的同一个人编写的详尽解释（其他带有动物的书大多都可以。）当心在线教程 - 其中许多教授非常草率的 perl。

使用 'warnings' 和 'strict' - 然后 perl 将非常有助于指出你的错误。

Perlmonks 也很棒（他们还会告诉你使用“警告”和“严格”。）

然后你必须一次学习[CPAN](http://cpan.org/)一个模块（这是 perlmonks 和邮件列表非常有用的地方。）

* * *

## 回答 #4

> 赞同：6
> 
> 时间：2008-09-16T11:38:49.310

[http://learn.perl.org/](http://learn.perl.org/)

从[在线图书馆](http://www.perl.org/books/library.html)：

*   [开始 Perl](http://www.perl.org/books/beginning-perl/)
*   [不耐烦的 Perl](http://www.perl.org/books/impatient-perl/)

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-16T09:17:26.670

我*强烈建议*从[Simon Cozens 的《Beginning Perl》一书开始](http://www.perl.org/books/beginning-perl/)。

此外，阅读[Perl 文档](http://perldoc.perl.org/index-language.html)。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-09-16T09:32:17.477

Perl 处于（相对）快速变化的状态，并且已经进入了这样的位置：除了对 Perl 5 的基本介绍（当前的主要版本）之外，最好的文档是语言本身附带的电子文档。

阅读“perldoc perlintro”，然后查看“perldoc perl”以获得其余的**核心**语言文档。请注意，在 Debian 系统上，您需要“apt-get install perl-doc”来获取此文档。

一旦你掌握了一些东西，查看“perldoc perldelta”，看看你系统上安装的 Perl 版本有什么新东西（现在应该是 5.8.8 或 5.10 —— 5.10 中的东西很酷！）。如果 perldelta 页面没有任何意义（相信我，我记得那种感觉），请稍后再返回。

最后，对于您在文档中找不到答案的问题，请使用 freenode #perl。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-30T15:05:08.007

[官方 Perl 5 Wiki](http://www.perlfoundation.org/perl5/index.cgi?perl_5_wiki)是一个很好的资源，包含大量信息和链接，它旨在对初学者友好。

另请参阅 wiki 主页底部，了解来自[Planet Perl](http://planet.perl.org/)提要聚合器的最新头条新闻。每隔几天浏览一次是很有用的，因为它有时会回答你不知道要问但你应该问的问题。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-16T09:09:26.237

如果你是初学者，我建议你看看 PLEAC 提供的食谱。您可以在[http://pleac.sf.net](http://pleac.sf.net)找到它。在那里你可以找到大多数语言的食谱。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-09-16T10:27:48.547

我非常推荐 Programming Perl，但请注意，您可能需要订阅 Safari 才能[在线阅读](http://books.google.ch/books?id=ezqe1hh91q4C&dq=%22programming+perl%22&pg=PP1&ots=juByzz8TT3&sig=y9WxaVAvJL-4tYCWgSklb7wqaN8&hl=en&sa=X&oi=book_result&resnum=1&ct=result#PPA11,M1)。

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-09-16T12:39:23.330

正如其他人所指出的，在线书籍[Beginning Perl](http://www.perl.org/books/beginning-perl/)享有很高的声誉，并且是由一位非常聪明的专家和积极的Perl 贡献者撰写的。除此之外，我将[初学者资源集中在 Perl Beginners' Site](http://perl-begin.org/)中，您可能会在那里找到您喜欢的东西。

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2011-09-02T12:05:12.367

一个新资源是 chromatic 的[Modern Perl](http://onyxneon.com/books/modern_perl/)，可在线免费获得，但如果您愿意，可以购买纸质版本。

# virtual - 虚拟构造函数

> ID：70575
> 
> 赞同：3
> 
> 时间：2008-09-16T09:07:49.313
> 
> 标签：virtual, constructor, scenarios

是否需要虚拟构造函数？如果是这样，任何人都可以发布一个场景吗？

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-09-16T09:14:35.010

如果您在谈论 C++ 中的虚拟析构函数（没有虚拟构造函数之类的东西），那么如果您以多态方式使用子类，则应始终使用它们。

```
class A
{
  ~A();
}

class B : public A
{
  ~B();
}

A* pB = new B();
delete pB; // NOTE: WILL NOT CALL B's destructor

class A
{
  virtual ~A();
}

class B : public A
{
  virtual ~B();
}

A* pB = new B();
delete pB; // NOTE: WILL CALL B's destructor 
```

**编辑：**不知道为什么我对此投了反对票（如果您发表评论会有所帮助...），但也可以在这里阅读

[http://blogs.msdn.com/oldnewthing/archive/2004/05/07/127826.aspx](http://blogs.msdn.com/oldnewthing/archive/2004/05/07/127826.aspx)

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T09:11:19.620

一如既往：查看[C++ FAQ lite: virtual functions](http://www.parashift.com/c++-faq-lite/virtual-functions.html#faq-20.8)。

它不仅会解释“虚拟构造函数”，还会解释析构函数/函数！

当然，如果您首先想要 C++...

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-16T09:25:10.537

有很多场景，例如，如果您想为多个环境创建 GUI。假设您有控件类（“小部件”），但每个环境实际上都有自己的小部件集。因此，为每个环境子类化这些小部件的创建是合乎逻辑的。做到这一点的方法（因为，正如已经指出的那样，在大多数语言中，构造函数实际上不能是虚拟的），是使用[抽象工厂](http://en.wikipedia.org/wiki/Abstract_factory_pattern)，上面的示例实际上是用于描述这种设计模式的标准示例。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-16T09:24:36.763

Delphi 是一种支持虚拟构造函数的语言。

通常，它们将用于创建元类型（即描述类型的类型）的类工厂类型场景中。然后，您将使用该元类型来构建后代类的具体示例

代码将类似于....

```
type
  MyMetaTypeRef = class of MyBaseClass;

var
  theRef : MyMetaTypeRef;
  inst : MyBaseClass;
begin 
  theRef := GetTheMetaTypeFromAFactory(); 
  inst := theRef.Create(); // Use polymorphic behaviour to create the class 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T09:10:19.793

用什么语言？例如，在 C++ 中，构造函数不能是虚拟的。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T09:13:07.600

根据定义，构造函数不能是虚拟的。在构造函数调用的时候还没有创建对象，所以多态性没有任何意义。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T09:48:55.393

在 C++ 中，构造函数没有理由是虚拟的，因为它们是静态函数。这意味着它们是静态绑定的，因此您必须确定要调用的构造函数才能完全调用它。没有不确定性，也没有虚拟的东西。

这也意味着，无论如何，您都需要知道您的对象将成为的类。但是，您可以执行以下操作：

```
Superclass *object = NULL;
if (condition) {
    object = new Subclass1();
}
else {
    object = new Subclass2();
}
object.setMeUp(args); 
```

...有一个虚函数并在构造后调用它。这是 Objective-C 中的标准模式，首先调用类的“alloc”方法来获取实例，然后调用适合您使用的初始化程序。

不过，提到抽象工厂模式的人可能更适合 C++ 和 Java。

* * *

## 回答 #8

> 赞同：-1
> 
> 时间：2012-07-26T07:33:43.023

在 C++ 中，所有构造函数都是隐式虚拟的（有一点额外的）。也就是说，基类的构造函数在派生类的构造函数之前被调用。所以，就好像它们是虚拟的。因为，在虚方法中，如果派生类实现了相同签名的方法，则只会调用派生类中的方法。

但是，**在构造函数中，两种方法都被调用**（参见下面的示例）。

对于为什么会这样的更完整的解释，请参阅有效 C++，第三版，由 Scott Meyers 的第 9 条（在构造或销毁期间不要调用虚函数）。该项目的标题可能会与问题相关，但如果您阅读说明，它将完全有意义。

```
#include <iostream>
#include <vector>

class Animal {

    public:

        Animal(){
            std::cout << "Animal Constructor Invoked." << std::endl;
        }

        virtual void eat() {
            std::cout << "I eat like a generic animal.\n";
        }

        //always make destructors virtual in base classes
        virtual ~Animal() {

        }

};

class Wolf : public Animal {

    public:

        Wolf(){
            std::cout << "Wolf Constructor Invoked." << std::endl;
        }

        void eat() {
            std::cout << "I eat like a wolf!" << std::endl;
        }

};

int main() {

    Wolf wolf;
    std::cout << "-------------" << std::endl;
    wolf.eat();

} 
```

输出：

```
Animal Constructor Invoked.
Wolf Constructor Invoked.
-------------
I eat like a wolf! 
```

* * *

## 回答 #9

> 赞同：-2
> 
> 时间：2013-02-20T02:57:02.637

虚拟构造函数在 C++ 中没有意义。这是因为在 C++ 构造函数中没有返回值。在其他一些编程语言中，情况并非如此。在那些语言中，可以直接调用构造函数，并且构造函数有一个返回值。这使得它们在实现某些类型的设计模式时很有用。然而，在 C++ 中，情况并非如此。

# python - 学习 Python 的最佳在线资源？

> ID：70577
> 
> 赞同：28
> 
> 时间：2008-09-16T09:08:47.377
> 
> 标签：python

我是任何脚本语言的新手。但是，我仍然在编写脚本，有点像为我的目的定制其他脚本。对我来说，学习 Python 的最佳在线资源是什么？

【回应总结：】

一些在线资源：

[](http://docs.python.org/tut/tut.html)[http://docs.python.org/tut/tut.html](http://docs.python.org/tut/tut.html) - 初学者

[](http://diveintopython3.ep.io/)[http://diveintopython3.ep.io/](http://diveintopython3.ep.io/) - 中级

[http://www.pythonchallenge.com/](http://www.pythonchallenge.com/) - 专家技能

[http://docs.python.org/](http://docs.python.org/) - 所有知识的集合

多一点：

[Python 的一个字节。](http://www.swaroopch.com/notes/Python)

[Python 2.5 快速参考](http://rgruet.free.fr/PQR25/PQR2.5.html)

[Python 侧边栏](http://www.edgewall.org/python-sidebar/)

[适合初学者的不错的博客](http://www.learningpython.com/)

[思考 Python：软件设计导论](http://www.greenteapress.com/thinkpython/thinkpython.html)

* * *

## 回答 #1

> 赞同：25
> 
> 时间：2008-09-16T09:12:58.490

如果你需要从头开始学习 python - 你可以从这里开始：[http](http://docs.python.org/tut/tut.html) : //docs.python.org/tut/tut.html - 好的初学者指南

如果您需要扩展您的知识 - 在此处继续[http://diveintopython3.ep.io/](http://diveintopython3.ep.io/) - 好的中级书籍

如果您需要完美的技能 - 完成此[http://www.pythonchallenge.com/](http://www.pythonchallenge.com/) - 出色而有趣的挑战

完美的知识来源是[http://docs.python.org/](http://docs.python.org/) - 所有知识的集合

* * *

## 回答 #2

> 赞同：7
> 
> 时间：2008-09-16T09:10:50.697

如果您是初学者，请尝试我的书[A Byte of Python](http://www.swaroopch.com/notes/Python)。

如果您已经有编程经验，请尝试[Dive Into Python](http://www.diveintopython.org)。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-16T10:51:08.943

我认为[Python Challenge](http://www.pythonchallenge.com/)很棒。

这不是关于学习 Python（语法），而是为您提供小而有趣的谜语。解谜是基于 Python 的，但你可以使用任何合适的东西（你的计算器、bash 脚本、Perl ......）。在你解决了一个之后，你可以看到其他人是如何解决它的，并且可以讨论不同方法的优缺点。

很高兴**了解**如何在 Python中完成事情（*智能）。*如果您对其他脚本语言或命令行等有所了解，则此站点的效果特别好。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-16T09:13:37.147

Python 主页上的[教程](http://docs.python.org/tut/tut.html)是一个很好的起点。[此外，这里](http://showmedo.com)还有一些截屏视频。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T09:22:08.703

这些是无价值的在线参考工具：

*   [Python 2.5 快速参考](http://rgruet.free.fr/PQR25/PQR2.5.html)

*   [Python 侧边栏](http://www.edgewall.org/python-sidebar/)

其他适合初学者的在线资源：

*   一个适合初学者的好 Python 博客：http: [//www.learningpython.com/](http://www.learningpython.com/)

*   [Google Code 上的 Python 视频](http://code.google.com/edu/languages/index.html#_python_understanding)

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-16T10:05:13.827

[思考 Python：软件设计导论](http://www.greenteapress.com/thinkpython/thinkpython.html)

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-16T16:49:53.993

[Python教程](http://docs.python.org/tut/tut.html)实际上非常好。

[在 showmedo 上](http://showmedo.com/videos/python)还有一个关于 python 的视频系列。

在这两个资源之间，你应该有足够的基础来学习！

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-16T20:10:14.293

你也可以看看[Building Skills in Python](http://homepage.mac.com/s_lott/books/python.html)。它假定有一定程度的编程经验。

如果您真的是新手，请尝试[Building Skills in Programming](http://homepage.mac.com/s_lott/books/nonprogrammer.html)。它包括许多背景和基础知识。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2011-05-19T20:43:31.827

[谷歌的 Python 类](http://code.google.com/edu/languages/google-python-class/)

> 欢迎来到 Google 的 Python 课程——这是一个免费课程，适合有一点编程经验并想学习 Python 的人。该课程包括书面材料、讲座视频和大量用于练习 Python 编码的代码练习。这些材料在 Google 内部用于向只有一点编程经验的人介绍 Python。第一个练习涉及基本的 Python 概念，如字符串和列表，随后的练习是处理文本文件、进程和 http 连接的完整程序。该课程适合那些对某种语言有一点编程经验的人，足以知道什么是“变量”或“if 语句”。除此之外，您无需成为专家级程序员即可使用此材料。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T09:09:42.353

[http://showmedo.com](http://showmedo.com)上有一些截屏视频

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-16T09:12:19.710

我从[Python 教程](http://docs.python.org/tut/tut.html)中学到了！

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-09-16T09:12:21.253

+1[潜入 Python](http://www.diveintopython.org/ "潜入 Python")

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-16T09:13:12.093

[蟒蛇手册](http://www.python.org/doc/current/tut/tut.html)

有时它有点啰嗦，但它告诉你所有你需要知道的东西。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-09-16T09:25:31.627

[PLEAC](http://pleac.sf.net)，有一本 Python Cookbook，非常有帮助。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-09-16T09:27:00.440

[10 分钟学会 Python](http://www.poromenos.org/tutorials/python "10 分钟学会 Python")

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2008-09-16T10:28:31.430

如果您想了解惯用的 Python [，Cookbook绝对是必不可少的。](https://rads.stackoverflow.com/amzn/click/com/0596007973)

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2008-09-16T11:01:32.350

我认为[ActiveState 的 Python 社区](http://code.activestate.com/recipes/langs/python/)是一个很好的资源。[DZone Snippets](http://snippets.dzone.com/tag/python/)也 很有用。

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2008-09-16T11:19:46.253

我第一次遇到[Software Carpentry](http://swc.scipy.org/)，查看 python 教程列表。但它不仅仅是关于 python 的教程。事实证明，我真正学到的是如何使用颠覆，而且我的项目中没有一个比 perl 更适合 python……然而。

* * *

## 回答 #19

> 赞同：0
> 
> 时间：2008-09-16T16:22:55.323

还可以考虑 [Hands-On Python]( [http://www.cs.luc.edu/~anh/python/hands-on/](http://www.cs.luc.edu/~anh/python/hands-) )。它被用作洛约拉大学计算机科学 150 的主要教材。它是 Python 的简明介绍，同时强调良好的编程风格和设计。

* * *

## 回答 #20

> 赞同：0
> 
> 时间：2008-09-23T16:28:07.287

[榛树](http://thehazeltree.org)

* * *

## 回答 #21

> 赞同：0
> 
> 时间：2010-03-31T15:46:39.430

Python Cookbook 非常有用。

# html - HTML 中 id 属性的有效值是什么？

> ID：70579
> 
> 赞同：2174
> 
> 时间：2008-09-16T09:08:52.527
> 
> 标签：html

在为 HTML 元素创建`id`属性时，值有哪些规则？

* * *

## 回答 #1

> 赞同：1813
> 
> 时间：2008-09-17T01:42:42.433

对于[HTML 4](http://www.w3.org/TR/html4/types.html#type-id)，技术上的答案是：

> ID 和 NAME 标记必须以字母 ([A-Za-z]) 开头，后跟任意数量的字母、数字 ([0-9])、连字符 ("-")、下划线 ("_") , 冒号 (":") 和句点 (".")。

[HTML 5](https://www.w3.org/TR/html5/dom.html#the-id-attribute)更加宽容，只是说一个 id 必须至少包含一个字符，并且不能包含任何空格字符。

[XHTML](https://www.w3.org/TR/xhtml1/diffs.html#h-4.2)中的 id 属性区分大小写。

作为一个纯粹的实际问题，您可能希望避免使用某些字符。句点、冒号和“#”在 CSS 选择器中具有特殊含义，因此您必须使用[CSS 中的反斜杠或](http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier)[传递给 jQuery](http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/)的选择器字符串中的双反斜杠来转义这些字符。想想在您对 id 中的句点和冒号发疯之前，您必须多久在样式表或代码中转义一个字符。

例如，HTML 声明`<div id="first.name"></div>`是有效的。`#first\.name`您可以像这样在 CSS 和 jQuery中选择该元素：`$('#first\\.name').`但是如果您忘记了反斜杠，`$('#first.name')`您将有一个完全有效的选择器来查找具有 id`first`并且还具有 class的元素`name`。这是一个容易被忽视的错误。从长远来看，您可能会更高兴选择 id `first-name`（连字符而不是句点），而不是。

您可以通过严格遵守命名约定来简化您的开发任务。例如，如果您将自己完全限制为小写字符，并且始终使用连字符或下划线分隔单词（但不能同时使用两者，选择一个，从不使用另一个），那么您就有一个易于记忆的模式。你永远不会想知道“是不是`firstName`？`FirstName`” 因为你总是知道你应该输入`first_name`. 更喜欢骆驼案？然后限制自己，不要使用连字符或下划线，并且始终始终对第一个字符使用大写或小写，不要混合使用它们。

* * *

现在一个非常模糊的问题是，至少有一个浏览器 Netscape 6[错误地将 id 属性值视为区分大小写](https://developer.mozilla.org/en-US/docs/Case_Sensitivity_in_class_and_id_Names)。这意味着如果您`id="firstName"`在 HTML（小写“f”）和`#FirstName { color: red }`CSS（大写“F”）中输入了内容，那么有问题的浏览器将无法将元素的颜色设置为红色。在 2015 年 4 月进行本次编辑时，我希望您没有被要求支持 Netscape 6。将此视为历史脚注。

* * *

## 回答 #2

> 赞同：233
> 
> 时间：2008-09-16T09:09:57.470

从[HTML 4 规范](http://www.w3.org/TR/html4/types.html#type-id)：

> ID 和 NAME 标记必须以字母 ([A-Za-z]) 开头，后跟任意数量的字母、数字 ([0-9])、连字符 ("-")、下划线 ("_") , 冒号 (":") 和句点 (".")。

一个常见的错误是使用以数字开头的 ID。

* * *

## 回答 #3

> 赞同：170
> 
> 时间：2008-09-16T14:01:21.590

从技术上讲，您可以在 id/name 属性中使用冒号和句点，但我强烈建议避免两者。

在 CSS（以及 jQuery 等几个 JavaScript 库）中，句点和冒号都有特殊的含义，如果不小心就会遇到问题。句点是类选择器，冒号是伪选择器（例如，当鼠标悬停在元素上时，“:hover”表示元素）。

如果你给一个元素 id “my.cool:thing”，你的 CSS 选择器将如下所示：

```
#my.cool:thing { ... /* some rules */ ... } 
```

这实际上是在用 CSS 语言说“id 为 'my' 的元素、一个 'cool' 类和 'thing' 伪选择器”。

坚持使用任何大小写、数字、下划线和连字符的 AZ。如上所述，请确保您的 ID 是唯一的。

这应该是您首先关心的问题。

* * *

## 回答 #4

> 赞同：71
> 
> 时间：2009-01-10T20:40:31.970

jQuery**确实**处理任何有效的 ID 名称。您只需要转义元字符（即点、分号、方括号...）。这就像说 JavaScript 有引号问题只是因为你不会写

```
var name = 'O'Hara'; 
```

[jQuery API 中的选择器（见底部注释）](http://docs.jquery.com/Selectors)

* * *

## 回答 #5

> 赞同：69
> 
> 时间：2008-09-16T09:11:25.810

严格来说应该匹配

```
[A-Za-z][-A-Za-z0-9_:.]* 
```

但是[jQuery](https://en.wikipedia.org/wiki/JQuery)似乎有冒号的问题，所以最好避免使用它们。

* * *

## 回答 #6

> 赞同：66
> 
> 时间：2013-01-18T07:09:23.670

## HTML5：

它摆脱了对*id*属性的额外限制（[参见此处](http://www.w3.org/TR/2011/WD-html5-20110525/elements.html#the-id-attribute)）。剩下的唯一要求（除了在文档中是唯一的）是：

1.  该值必须至少包含一个字符（不能为空）
2.  它不能包含任何空格字符。

* * *

## HTML5 之前的：

ID 应匹配：

```
[A-Za-z][-A-Za-z0-9_:.]* 
```

1.  必须以 AZ 或 az 字符*开头*
2.  可能包含`-`（连字符）、`_`（下划线）、`:`（冒号）和`.`（句点）

但是应该避免`:`，`.`因为：

例如，一个 ID 可以标记为“ab:c”并在样式表中引用为 #ab:c，但除了作为元素的 id 之外，它还可以表示 id “a”、类“b”、伪-选择器“c”。`.`最好避免混淆并完全远离使用`:`。

* * *

## 回答 #7

> 赞同：66
> 
> 时间：2015-08-02T15:53:16.860

## HTML5：ID 和类属性的允许值

从 HTML5 开始，对 ID 值的唯一限制是：

1.  在文档中必须是唯一的
2.  不得包含任何空格字符
3.  必须至少包含一个字符

类似的规则适用于类（当然，唯一性除外）。

所以值可以是所有数字，只有一个数字，只是标点符号，包括特殊字符，等等。只是没有空格。这与 HTML4 非常不同。

在 HTML 4 中，ID 值必须以字母开头，然后只能跟字母、数字、连字符、下划线、冒号和句点。

在 HTML5 中，这些是有效的：

```
<div id="999"> ... </div>
<div id="#%LV-||"> ... </div>
<div id="____V"> ... </div>
<div id="⌘⌥"> ... </div>
<div id="♥"> ... </div>
<div id="{}"> ... </div>
<div id="©"> ... </div>
<div id="♤₩¤☆€~¥"> ... </div> 
```

请记住，在 ID 的值中使用数字、标点符号或特殊字符可能会在其他上下文（例如 CSS、JavaScript、正则表达式）中引起问题。

例如，以下 ID 在 HTML5 中有效：

```
<div id="9lions"> ... </div> 
```

***但是，它在 CSS 中是无效的：***

来自 CSS2.1 规范：

> [**4.1.3 字符和大小写**](https://www.w3.org/TR/CSS21/syndata.html#characters)
> 
> 在 CSS 中，*标识符*（包括选择器中的元素名称、类和 ID）只能包含字符 [a-zA-Z0-9] 和 ISO 10646 字符 U+00A0 及更高，加上连字符 (-) 和下划线 ( _); ***它们不能以数字、两个连字符或一个连字符后跟一个数字开头***。

在大多数情况下，您可以在字符有限制或特殊含义的上下文中转义字符。

* * *

**W3C 参考资料**

HTML5

> [**3.2.5.1`id` 属性**](http://www.w3.org/TR/html5/dom.html#the-id-attribute)
> 
> 该`id`属性指定其元素的唯一标识符 (ID)。
> 
> 该值在元素的主子树中的所有 ID 中必须是唯一的，并且必须包含至少一个字符。该值不得包含任何空格字符。
> 
> 注意：对于 ID 可以采用的形式没有其他限制；特别是，ID 可以仅包含数字、以数字开头、以下划线开头、仅包含标点符号等。
> 
> [**3.2.5.7`class` 属性**](http://www.w3.org/TR/html5/dom.html#classes)
> 
> 该属性（如果指定）必须具有一个值，该值是一组以空格分隔的标记，表示该元素所属的各种类。
> 
> HTML 元素分配给它的类由所有在 class 属性的值按空格分割时返回的类组成。（重复项被忽略。）
> 
> 作者可以在类属性中使用的标记没有其他限制，但鼓励作者使用描述内容性质的值，而不是描述所需内容呈现的值。

* * *

## 回答 #8

> 赞同：35
> 
> 时间：2010-07-07T10:09:22.097

连字符、下划线、句点、冒号、数字和字母都适用于 CSS 和 jQuery。以下应该有效，但它必须在整个页面中是唯一的，并且还必须以字母 [A-Za-z] 开头。

使用冒号和句点需要做更多的工作，但您可以按照以下示例进行操作。

```
<html>
<head>
<title>Cake</title>
<style type="text/css">
    #i\.Really\.Like\.Cake {
        color: green;
    }
    #i\:Really\:Like\:Cake {
        color: blue;
    }
</style>
</head>
<body>
    <div id="i.Really.Like.Cake">Cake</div>
    <div id="testResultPeriod"></div>

    <div id="i:Really:Like:Cake">Cake</div>
    <div id="testResultColon"></div>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
    <script type="text/javascript">
        $(function() {
            var testPeriod = $("#i\\.Really\\.Like\\.Cake");
            $("#testResultPeriod").html("found " + testPeriod.length + " result.");

            var testColon = $("#i\\:Really\\:Like\\:Cake");
            $("#testResultColon").html("found " + testColon.length + " result.");
        });
    </script>
</body>
</html> 
```

* * *

## 回答 #9

> 赞同：34
> 
> 时间：2008-09-16T10:04:28.243

在实践中，许多站点使用`id`以数字开头的属性，即使这在技术上不是有效的 HTML。

[HTML 5 草案规范](http://www.w3.org/html/wg/html5/#id)放宽了`id`和属性的规则`name`：它们现在只是不透明的字符串，不能包含空格。

* * *

## 回答 #10

> 赞同：29
> 
> 时间：2013-08-26T21:54:46.390

## HTML5

请记住，ID 必须是唯一的，即文档中不能有多个元素具有相同的 id 值。

HTML5 中关于 ID 内容的规则是（除了唯一性之外）：

```
This attribute's value must not contain white spaces. [...]
Though this restriction has been lifted in HTML 5,
an ID should start with a letter for compatibility. 
```

这是关于 ID 的**W3**规范（来自 MDN）：

```
Any string, with the following restrictions:
must be at least one character long
must not contain any space characters
Previous versions of HTML placed greater restrictions on the content of ID values
(for example, they did not permit ID values to begin with a number). 
```

## 更多信息：

*   [**W3**](http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.id) - 全局属性 (`id`)
*   [**MDN**](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#id)属性 (`id`)

* * *

## 回答 #11

> 赞同：20
> 
> 时间：2013-11-13T20:14:15.863

要引用带有句点的 id，您需要使用反斜杠。我不确定连字符或下划线是否相同。

例如：

### HTML

```
<div id="maintenance.instrumentNumber">############0218</div> 
```

CSS

```
#maintenance\.instrumentNumber{word-wrap:break-word;} 
```

* * *

## 回答 #12

> 赞同：18
> 
> 时间：2008-09-16T09:12:19.553

从 HTML 4 规范...

ID 和 NAME 标记必须以字母 ([A-Za-z]) 开头，后跟任意数量的字母、数字 ([0-9])、连字符 ("-")、下划线 ("_" )、冒号 (":") 和句点 (".")。

* * *

## 回答 #13

> 赞同：16
> 
> 时间：2008-09-16T12:31:38.560

此外，永远不要忘记 ID 是唯一的。一旦使用，ID 值可能不会再次出现在文档中的任何位置。

您可能有许多 ID，但都必须具有唯一值。

另一方面，有类元素。就像 ID 一样，它可以出现多次，但值可能会被反复使用。

* * *

## 回答 #14

> 赞同：12
> 
> 时间：2016-07-15T13:02:03.640

元素的唯一标识符。

文档中不能有多个元素具有相同的 id 值。

任何字符串，具有以下限制：

1.  必须至少有一个字符长
2.  不得包含任何空格字符：

    *   U+0020 空间
    *   U+0009 字符表（制表符）
    *   U+000A 换行 (LF)
    *   U+000C 换页 (FF)
    *   U+000D 回车 (CR)

使用字符 except`ASCII letters and digits, '_', '-' and '.'`可能会导致兼容性问题，因为它们在`HTML 4`. 虽然在 中取消了此限制`HTML 5`，但为了兼容性，ID 应以字母开头。

* * *

## 回答 #15

> 赞同：11
> 
> 时间：2009-04-22T10:18:43.957

看起来，虽然冒号 (:) 和句点 (.) 在 HTML 规范中是有效的，但它们在[CSS](http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier)中作为 id 选择器是无效的，因此如果您打算将它们用于此目的，最好避免使用它们。

* * *

## 回答 #16

> 赞同：10
> 
> 时间：2013-08-21T10:57:06.103

对于[HTML5](https://en.wikipedia.org/wiki/HTML5)：

> 该值在元素的主子树中的所有 ID 中必须是唯一的，并且必须包含至少一个字符。该值不得包含任何空格字符。

至少一个字符，没有空格。

这为有效用例打开了大门，例如使用重音字符。它还为我们提供了更多的弹药，因为您现在可以使用会导致 CSS 和 JavaScript 出现问题的*id*值，除非您非常小心。

* * *

## 回答 #17

> 赞同：9
> 
> 时间：2013-05-02T06:28:33.333

1.  ID 最适合命名布局的一部分，因此不应为 ID 和类指定相同的名称
2.  ID 允许使用字母数字和特殊字符
3.  但避免使用`# : . * !`符号
4.  不允许有空格
5.  不是以数字或连字符后跟数字开头
6.  区分大小写
7.  使用 ID 选择器比使用类选择器快
8.  对长 CSS 类或 Id 规则名称使用连字符“-”（也可以使用下划线“_”，但对[SEO 不利）](https://en.wikipedia.org/wiki/Search_engine_optimization)
9.  如果规则将 ID 选择器作为其键选择器，则不要将标记名称添加到规则中。由于 ID 是唯一的，添加标签名称会不必要地减慢匹配过程。
10.  在 HTML5 中，id 属性可以用于任何 HTML 元素，而在 HTML 4.01 中，id 属性不能用于：`<base>, <head>, <html>, <meta>, <param>, <script>, <style>, and <title>.`

* * *

## 回答 #18

> 赞同：9
> 
> 时间：2016-11-12T13:52:52.467

任何**字母数字值**、“ **-** ”和“ **_** ”都是有效的。但是，您应该以**AZ**或**az**之间的任何字符*开始 id 名称*。

 ***** * *

## 回答 #19

> 赞同：6
> 
> 时间：2017-05-09T04:22:32.303

没有空格，它必须以至少一个从 a 到 z 和 0 到 9 的字符开头。

* * *

## 回答 #20

> 赞同：6
> 
> 时间：2019-06-14T11:23:50.040

在 HTML 中

**ID**应以**{AZ}**或**{az}**开头。您可以添加**数字、句点、连字符、下划线和冒号。**

例如：

```
<span id="testID2"></span>
<span id="test-ID2"></span>
<span id="test_ID2"></span>
<span id="test:ID2"></span>
<span id="test.ID2"></span> 
```

但即使您可以使用冒号 (:) 或句点 ( `.`) 创建 ID。**CSS**很难将这些 ID 用作选择器。主要是当您想使用伪元素（`:before`和`:after`）时。

在 JavaScript 中也很难选择这些 ID。因此，您应该使用前四个 ID 作为周围许多开发人员的首选方式，如果有必要，您也可以使用后两个。

* * *

## 回答 #21

> 赞同：6
> 
> 时间：2019-07-07T08:21:41.910

值可以是：[az]、[AZ]、[0-9]、[* _ : -]

它用于 HTML5...

我们可以使用任何标签添加 id。

* * *

## 回答 #22

> 赞同：4
> 
> 时间：2019-09-07T21:36:10.287

从*ES2015 开始*，如果文档字符集设置为 UTF-8，我们也可以使用*几乎*所有**Unicode 字符作为 ID。**

在这里测试：[https ://mothereff.in/js-variables](https://mothereff.in/js-variables)

[![在此处输入图像描述](https://i.stack.imgur.com/E4FWL.png)](https://i.stack.imgur.com/E4FWL.png)

阅读：*[ES2015 中的有效 JavaScript 变量名](https://mathiasbynens.be/notes/javascript-identifiers-es6)*

> 在 ES2015 中，标识符必须以 $、_ 或任何具有 Unicode 派生核心属性 ID_Start 的符号开头。
> 
> 标识符的其余部分可以包含 $、_、U+200C 零宽度非连接符、U+200D 零宽度连接符或任何具有 Unicode 派生核心属性 ID_Continue 的符号。

```
const target = document.querySelector("div").id
console.log(
   target
)
document.getElementById(target).style.backgroundColor = "black"
```

```
div {
  border: 1px black solid;
  width: 100%;
  height: 200px
}
```

```
<div id="H̹̙̦̮͉̩̗̗ͧ̇̏̊̾Eͨ͆͒̆ͮ̃͏̷̮̣̫̤̣Cͯ̂͐͏̨̛͔̦̟͈̻O̜͎͍͙͚̬̝̣̽ͮ͐͗̀ͤ̍̀͢M̴̡̲̭͍͇̼̟̯̦̉̒͠Ḛ̛̙̞̪̗ͥͤͩ̾͑̔͐ͅṮ̴̷̷̗̼͍̿̿̓̽͐H̙̙̔̄͜">
```

* * *

你应该使用它吗？可能不是一个好主意！

阅读它：*[JavaScript：函数体后缺少语法错误}](https://stackoverflow.com/questions/11945216/javascript-syntax-error-missing-after-function-body/52799593#52799593)*

* * *

## 回答 #23

> 赞同：0
> 
> 时间：2021-03-11T19:13:00.210

帮助，我的 Javascript 坏了！

每个人都说 ID 不能重复。

最好在除 FireFox 之外的所有浏览器中尝试

```
<div id="ONE"></div>
<div id="ONE"></div>
<div id="ONE"></div>
<script>
  document.body.append( document.querySelectorAll("#ONE").length , ' DIVs!')
  document.body.append( ' in a ', typeof ONE )
  console.log( ONE );
</script>
```

* * *

## 回答 #24

> 赞同：0
> 
> 时间：2021-04-01T05:26:41.710

***网页编号***

id 属性指定其元素的唯一标识符 (ID)。

对于 ID 可以采用的形式没有其他限制；特别是，ID 可以仅包含数字、以数字开头、以下划线开头、仅包含标点符号等。

元素的唯一标识符可用于多种用途，最明显的是作为使用片段链接到文档的特定部分的一种方式，作为在编写脚本时定位元素的一种方式，以及作为一种从 CSS 中设置特定元素样式的方式.

* * *

## 回答 #25

> 赞同：0
> 
> 时间：2021-04-04T00:36:40.420

1.  大写和小写字母的作品
2.  '_' 和 '-' 也有效
3.  数字作品
4.  冒号 (,) 和句号 (.) 似乎有效
5.  有趣的是，表情符号有效

* * *

## 回答 #26

> 赞同：-4
> 
> 时间：2012-09-22T18:27:51.233

字母 → 大写和小

数字 → 0-9

特殊字符 → ':', '-', '_', '.'

格式应该从“。”开始。或字母，后跟更多字母或数字的特殊字符。id 字段的值不能以“_”结尾。

此外，不允许使用空格，如果提供，它们将被视为不同的值，这在 id 属性的情况下无效。

# session - 记录图像下载

> ID：70600
> 
> 赞同：0
> 
> 时间：2008-09-16T09:11:27.747
> 
> 标签：session, download

我正在尝试找到一种方法来找出谁在从图片库下载什么图片。用户可以使用缩略图旁边的按钮或右键单击并使用“将链接另存为”进行下载 是否可以将用户会话或 ID 与使用 PHP 或 JavaScript 的所有浏览器的“链接另存为”操作相关联。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T09:19:43.483

是的，我首选的方法是通过 PHP。您必须设置一个脚本来加载文件并将其发送到用户浏览器。该脚本还可以在某处（例如您的数据库）记录下载。

例如 - 在非常粗糙的伪代码中：

下载.php

```
$file = $_GET['file'];
updateFileCount($file);
header('Content-Type: image/jpeg');
sendFile($file); 
```

然后，您只需将下载链接指向 download.php，而不是实际文件。（请注意，当然，updateFileCount 和 sendFile 是您必须提供的函数 -[此脚本](http://elouai.com/force-download.php)是您可以使用的下载脚本示例）

注意：我强烈建议避免使用 $_GET['file'] 来获取整个文件名 - 恶意用户可以使用它从您的 Web 服务器中检索敏感文件。但是安全使用 PHP 下载是另一个问题的话题。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-18T20:31:38.890

I agree strongly with the suggestion put forward by Phill Sacre. For what you are looking for this is the way to go.

It also has the benefit of being potentially able to keep the tracked files out of the direct web path so that they can't be direct linked to.

I use this method in a client site where the images are paid content so must be restricted access.

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T09:14:32.450

您需要一个网关脚本，例如 ImageDownload.php?picture=me.jpg 或类似的东西。

该页面将返回图像字节，并记录下载图像。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T09:15:19.670

因为要保存的图像在本地计算机上，所以无法获取此类信息，因为他们已经从您的系统中检索了图像。即使使用 javascript，我知道你可以做的最好的事情是在用户每次按下第二个鼠标按钮时使用某种 ajax'y 的东西进行记录。

我不太喜欢这个想法，但是如果您想在每次有人下载图像时都记录下来，您可以将图像托管在 Flash 或 Java 应用程序中，这样就需要单击下载图像按钮。这样，他们获得图像而不这样做的唯一方法是在数据包进入他们身边时捕获数据包或截取屏幕截图。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T09:21:23.323

您的服务器访问日志应该已经有对文件的非缩略图版本的请求，因此您只需修改日志格式以包含 sessionid，我认为您可以将其映射回用户。

# c# - 将 C# 连接到 Oracle 数据库所需的最小客户端占用空间是多少？

> ID：70602
> 
> 赞同：71
> 
> 时间：2008-09-16T09:11:44.937
> 
> 标签：c#, oracle, client

通过在我的笔记本电脑上下载并安装客户端管理工具和 Visual Studio 2008，我已成功从 C# (Visual Studio 2008) 连接到 Oracle 数据库 (10g)。

Oracle 客户端工具的安装占用空间超过 200Mb，而且相当冗长。

有谁知道最小可行的足迹是多少？我希望它是一个单独的 DLL 和一个注册命令，但我觉得我需要安装一个 oracle home，并设置各种环境变量。

我在我的代码中使用 Oracle.DataAccess。

* * *

## 回答 #1

> 赞同：71
> 
> 时间：2008-09-16T10:06:11.513

您需要一个 Oracle 客户端才能连接到 Oracle 数据库。最简单的方法是安装[Oracle 数据访问组件](http://www.oracle.com/technology/software/tech/windows/odpnet/index.html)。

为了尽量减少占用空间，我建议如下：

*   使用框架附带的 Microsoft 提供程序 for Oracle (System.Data.OracleClient)。
*   下载[Oracle Instant Client 软件包](http://www.oracle.com/technology/software/tech/oci/instantclient/htdocs/winsoft.html)- Basic Lite：这是一个 zip 文件，（几乎）是最低限度的。我推荐版本 10.2.0.4，它比版本 11.1.0.6.0 小很多。
*   在特定文件夹中解压缩以下文件：
    *   v10：
        *   oci.dll
        *   orannzsbb10.dll
        *   oraociicus10.dll
    *   v11：
        *   oci.dll
        *   orannzsbb11.dll
        *   oraociei11.dll
*   在 x86 平台上，将 Visual Studio 2003 的 CRT DLL (msvcr71.dll) 添加到此文件夹中，因为 Oracle 人员忘记[阅读此内容](http://support.microsoft.com/kb/326922)...
*   将此文件夹添加到 PATH 环境变量。
*   在您的应用程序中使用[Easy Connect Naming](http://download.oracle.com/docs/cd/B19306_01/network.102/b14212/naming.htm#ABC524382SRI12)方法来摆脱臭名昭著的 TNSNAMES.ORA 配置文件。它看起来像这样：`sales-server:1521/sales.us.acme.com`。

这相当于大约**19Mb** (v10)。

如果您不关心在多个应用程序之间共享此文件夹，另一种方法是将上述 DLL 与您的应用程序二进制文件一起提供，并跳过 PATH 设置步骤。

如果您绝对需要使用 Oracle 提供程序 (Oracle.DataAccess)，您将需要：

*   ODP .NET 11.1.0.6.20（据称可与 Instant Client 一起使用的第一个版本）。
*   Instant Client 11.1.0.6.0，很明显。

请注意，我尚未测试此最新配置...

* * *

## 回答 #2

> 赞同：15
> 
> 时间：2011-07-07T10:07:38.723

我使用上面 Pandicus 建议的方法，在 Windows XP 上，使用 ODAC 11.2.0.2.1。步骤如下：

1.  从 oracle.com (53 MB) 下载“ODAC 11.2 Release 3 (11.2.0.2.1) with Xcopy Deployment”包，然后解压缩 ZIP。
2.  收集以下 DLL：oci.dll (1 MB)、oraociei11.dll (130 MB!)、OraOps11w.dll (0.4 MB)、Oracle.DataAccess.dll (1 MB)。剩下的东西可以删除，什么都不需要安装。
3.  添加对 Oracle.DataAccess.dll 的引用，添加`using Oracle.DataAccess.Client;`到您的代码中，现在您可以使用和之类`OracleConnection`的类型来访问 Oracle 数据库。有关详细信息，请参阅[类文档](http://download.oracle.com/docs/cd/B19306_01/win.102/b14307/intro003.htm#BHCJFIAJ)。无需使用 tnsnames.ora 配置文件，只需正确设置[连接字符串](http://www.connectionstrings.com/oracle)即可。`OracleCommand``OracleDataReader`
4.  上述 4 个 DLL 必须与您的可执行文件一起部署。

* * *

## 回答 #3

> 赞同：15
> 
> 时间：2014-10-20T15:51:32.623

截至 2014 年，OPD.NET 托管驱动程序是最小的占用空间。

这是与以前（过时）答案建议的非托管版本的代码使用比较：http: [//docs.oracle.com/cd/E51173_01/win.122/e17732/intro005.htm#ODPNT148](http://docs.oracle.com/cd/E51173_01/win.122/e17732/intro005.htm#ODPNT148)

您将需要下载这些 dll 并`Oracle.ManagedDataAccess.dll`在您的项目中引用：仅下载[ODP.NET，托管驱动程序 Xcopy 版本](http://www.oracle.com/technetwork/database/windows/downloads/utilsoft-087491.html)

这是一个典型的足迹，您需要与您的版本一起打包：

1.  `Oracle.ManagedDataAccess.dll`
2.  `Oracle.ManagedDataAccessDTC.dll`

总而言之， .Net 4.0*高达*6.4 MB。

* * *

## 回答 #4

> 赞同：14
> 
> 时间：2009-09-11T05:12:29.170

这种方式允许您使用来自 oracle 的 5 个可再发行文件连接 ODP.net：

[Chris 的博客条目：使用新的 ODP.Net 通过简单的部署从 C# 访问 Oracle](http://splinter.com.au/using-the-new-odpnet-to-access-oracle-from-c)

编辑：万一博客每次宕机，这里有一个简短的总结......

*   oci.dll
*   Oracle.DataAccess.dll
*   oraociicus11.dll
*   OraOps11w.dll
*   orannzsbb11.dll
*   oraocci11.dll
*   ociw32.dll

> 确保您从同一个 ODP.Net / ODAC 发行版中获取所有这些 DLL，以避免版本号冲突，并将它们全部放在与您的 EXE 相同的文件夹中

* * *

## 回答 #5

> 赞同：8
> 
> 时间：2008-09-16T09:34:16.303

DevArt [http://www.devart.com/](http://www.devart.com/)，以前的 CoreLab (crlab.com) 提供纯 C# Oracle 客户端。那是一个 dll，它工作正常。

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2014-04-18T20:34:48.940

这是**Oracle 11.2.0.4.0**的更新。我在**Windows 7**上使用`System.Data.OracleClient`.

**1.**下载**Instant Client 包 - Basic Lite**：[Windows 32 位](http://www.oracle.com/technetwork/topics/winsoft-085727.html)或[64 位](http://www.oracle.com/technetwork/topics/winx64soft-089540.html)。

**2.**将以下文件复制到系统路径中的某个位置：

**32 位**

```
 1,036,288  2013-10-11  oci.dll
   348,160  2013-10-11  ociw32.dll
 1,290,240  2013-09-21  orannzsbb11.dll
   562,688  2013-10-11  oraocci11.dll
36,286,464  2013-10-11  oraociicus11.dll 
```

**64 位**

```
 691,712  2013-10-09  oci.dll
   482,304  2013-10-09  ociw32.dll
 1,603,072  2013-09-10  orannzsbb11.dll
 1,235,456  2013-10-09  oraocci11.dll
45,935,104  2013-10-09  oraociicus11.dll 
```

**3.构造一个**[不需要**tnsnames.ora**](http://www.connectionstrings.com/oracle/)的连接字符串。

*（请参见下面测试程序中的示例。）*

**4.**运行这个最小的 C# 程序来测试你的安装：

```
using System;
using System.Data;
using System.Data.OracleClient;

class TestOracleInstantClient
{
    static public void Main(string[] args)
    {
        const string host = "yourhost.yourdomain.com";
        const string serviceName = "yourservice.yourdomain.com";
        const string userId = "foo";
        const string password = "bar";

        var conn = new OracleConnection();

        // Construct a connection string using Method 1 or 2.
        conn.ConnectionString =
            GetConnectionStringMethod1(host, serviceName, userId, password);

        try
        {
            conn.Open();
            Console.WriteLine("Connection succeeded.");
            // Do something with the connection.
            conn.Close();
        }
        catch (Exception e)
        {
            Console.WriteLine("Connection failed: " + e.Message);
        }
    }

    static private string GetConnectionStringMethod1(
        string host,
        string serviceName,
        string userId,
        string password
        )
    {
        string format =
            "SERVER=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)" +
            "(HOST={0})(PORT=1521))" +
            "(CONNECT_DATA=(SERVER=DEDICATED)" +
            "(SERVICE_NAME={1})));" +
            "uid={2};" +
            "pwd={3};"; // assumes port is 1521 (the default)

        return String.Format(format, host, serviceName, userId, password);
    }

    static private string GetConnectionStringMethod2(
        string host,
        string serviceName,
        string userId,
        string password
        )
    {
        string format =
            "Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)" +
            "(HOST={0})(PORT=1521))" +
            "(CONNECT_DATA=(SERVER=DEDICATED)" +
            "(SERVICE_NAME={1})));" +
            "User Id={2};" +
            "Password={3};"; // assumes port is 1521 (the default)

        return String.Format(format, host, serviceName, userId, password);
    }
} 
```

**最后提示：**如果您遇到错误*“System.Data.OracleClient 需要 Oracle 客户端软件版本 8.1.7”*，请参阅[此问题](https://stackoverflow.com/q/447983/1497596)。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-16T09:27:23.230

ODAC xcopy 将为您提供大约 45MB 的空间。 [http://www.oracle.com/technology/software/tech/windows/odpnet/index.html](http://www.oracle.com/technology/software/tech/windows/odpnet/index.html)

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2009-10-07T03:11:54.270

我发现 Oracle 论坛上的这篇文章也非常有用：

## [如何使用 Visual Studio 设置 Oracle Instant Client](http://forums.oracle.com/forums/message.jspa?messageID=1418596#1418596)

备注：ADO.NET 团队正在弃用 System.Data.OracleClient，因此对于未来的项目，您应该使用 ODP.NET

再生产：

> 设置以下环境变量：
> 
> 1.  确保您的 PATH 中没有其他 oracle 目录
> 2.  将您的**PATH**设置为指向您的即时客户端
> 3.  将您的**TNS_ADMIN 设置**为指向 tnsnames.ora 文件所在的位置
> 4.  设置你的**NLS_LANG**
> 5.  将您的**ORACLE_HOME**设置为您的即时客户端
> 
> 对我来说，我将 NLS_LANG 设置为
> 
> [http://download-east.oracle.com/docs/html/A95493_01/gblsupp.htm#634282](http://download-east.oracle.com/docs/html/A95493_01/gblsupp.htm#634282)
> 
> 我通过使用即时客户端的 sqlplus 插件验证了这是使用正确的客户端软件。
> 
> 对我来说，我设置：SET NLS_LANG=AMERICAN_AMERICA.WE8MSWIN1252
> 
> 注意：在进行任何更改之前，请备份您的 Oracle 注册表项（如果存在）并备份任何环境变量的字符串。
> 
> [在此处阅读 Oracle Instant Client 常见问题解答](http://www.oracle.com/technology/tech/oci/instantclient/ic-faq.html)

# gnu-screen - 我必须知道什么才能正确使用 GNU Screen？

> ID：70614
> 
> 赞同：109
> 
> 时间：2008-09-16T09:12:43.920
> 
> 标签：gnu-screen

我刚刚向一位朋友介绍了**GNU Screen**，但他们很难适应它。这让我想到了他需要了解的有关出色的**Screen**实用程序的基本知识，以及您认为值得从头开始教某人（初学者）的事情。记住绑定等有哪些类比和方便的技巧？

这一定非常棒。

* * *

## 回答 #1

> 赞同：96
> 
> 时间：2008-09-16T09:39:03.983

我已经使用`Screen`了 10 多年，并且可能使用的功能不到一半。因此，绝对没有必要立即学习它的所有功能（我不建议尝试）。我的日常命令是：

```
^A ^W - window list, where am I
^A ^C - create new window
^A space - next window
^A p - previous window
^A ^A - switch to previous screen (toggle)
^A [0-9] - go to window [0-9]
^A esc - copy mode, which I use for scrollback 
```

我想就是这样。我有时会使用分屏功能，但肯定不是每天都使用。另一个提示是，如果屏幕似乎已锁定，因为您不小心按了一些随机组合键，请同时执行这两项操作`^Q`并`^A ^Q`尝试将其解锁。

* * *

## 回答 #2

> 赞同：38
> 
> 时间：2008-09-16T10:01:04.290

直到我找到一种方法来在屏幕底部设置一个“状态栏”，以显示您所在的“标签”或“虚拟屏幕”以及还有哪些其他屏幕，我才习惯于屏幕。这是我的设置：

```
[roel@roel ~]$ cat .screenrc
# Here comes the pain...
caption always "%{=b dw}:%{-b dw}:%{=b dk}[ %{-b dw}%{-b dg}$USER%{-b dw}@%{-b dg}%H %{=b dk}] [ %= %?%{-b dg}%-Lw%?%{+b dk}(%{+b dw}%n:%t%{+b dk})%?(%u)%?%{-b dw}%?%{-b dg}%+Lw%? %{=b dk}]%{-b dw}:%{+b dw}:"

backtick 2 5 5 $HOME/scripts/meminfo
hardstatus alwayslastline "%{+b dw}:%{-b dw}:%{+b dk}[%{-b dg} %0C:%s%a %{=b dk}]-[   %{-b dw}Load%{+b dk}:%{-b dg}%l %{+b dk}] [%{-b dg}%2`%{+b dk}] %=[ %{-b dg}%1`%{=b dk} ]%{-b dw}:%{+b dw}:%<"

sorendition "-b dw"
[roel@roel ~]$ cat ~/scripts/meminfo
#!/bin/sh
RAM=`cat /proc/meminfo | grep "MemFree" | awk -F" " '{print $2}'`
SWAP=`cat /proc/meminfo | grep "SwapFree" | awk -F" " '{print $2}'`
echo -n "${RAM}kb/ram ${SWAP}kb/swap"
[roel@roel ~]$ 
```

* * *

## 回答 #3

> 赞同：30
> 
> 时间：2008-09-16T09:45:25.853

`Ctrl`+ `A`? - 显示帮助屏幕！

* * *

## 回答 #4

> 赞同：26
> 
> 时间：2008-09-16T09:23:31.460

如果您的朋友习惯于`^A`在 Bash 中按到行首，那么他/她会遇到一些惊喜，因为`^A`屏幕命令键绑定。通常我最终会出现冻结的屏幕，可能是因为我按下了一些随机键`^A`:-)

在这些情况下，我尝试

`^A s`和`^A q`阻止/取消阻止终端滚动

解决这个问题。要转到屏幕内一行的开头，键序列是`^A a`。

* * *

## 回答 #5

> 赞同：12
> 
> 时间：2008-09-16T10:20:25.863

您可以将转义键从`Ctrl`+重新映射`A`为您选择的另一个键，因此如果您确实将它用于其他用途，例如转到 bash 中的行首，您只需在 ~/. screenrc 文件。要使其成为 ^b 或 ^B，请使用：

```
escape ^bB 
```

在命令行中，使用名称会话来控制多个会话。我每个任务使用一个会话，每个会话都有多个选项卡：

```
  screen -ls # 列出你当前的屏幕会话
  screen -S <name> # 创建一个名为 name 的新屏幕会话
  screen -r <name> # 连接到指定的屏幕会话

```

使用 screen 时，您只需要几个命令：

```
  ^A c 创建一个新的外壳
  ^A [0-9] 切换外壳
  ^A k 杀死当前shell
  ^A d 与屏幕断开连接
  ^一个？显示帮助

```

可以在[此处](http://aperiodic.net/screen/quick_reference)找到出色的快速参考。值得收藏。

* * *

## 回答 #6

> 赞同：8
> 
> 时间：2009-08-06T02:27:43.037

对于那些有点熟悉屏幕但往往不记得他们在手册页中阅读的内容的人的一些提示：

*   更改屏幕窗口的名称非常简单：`ctrl`++ 。`A` `shift``A`
*   你错过了屏幕上的最后一条消息吗？`ctrl`++`a` `ctrl`将`m`再次为您显示。
*   如果你想运行一些东西（比如拖尾文件）并让屏幕告诉你什么时候有变化，在目标窗口上使用`ctrl`++ 。*警告：如果有任何*变化，它会通知您。`A` `shift``m`
**   要直接选择窗口 15？`.screenrc`在您的文件中尝试这些：*

 *> ```
> bind  ! select 11
> bind  @ select 12
> bind \# select 13
> bind  $ select 14
> bind  % select 15
> bind \^ select 16
> bind  & select 17
> bind  * select 18
> bind  ( select 19
> bind  ) select 10 
> ```

这为 Windows 10 到 19分配了`ctrl`++ 。`a` `shift``0 through 9`

* * *

## 回答 #7

> 赞同：7
> 
> 时间：2008-09-16T09:33:17.070

`Ctrl`+`A`是基本命令

`Ctrl`+ `A` `N`= 转到***N***下一个屏幕

`Ctrl`+ `A` `P`= 转到***P***上一个屏幕

`Ctrl`+ `A` `C`= ***C***创建新屏幕

`Ctrl`+ `A` `D`= ***D***连接你的屏幕

* * *

## 回答 #8

> 赞同：6
> 
> 时间：2008-09-16T09:28:46.783

`Ctrl`+`a`是一个特殊的键。

`Ctrl`+ `a` `d`- [d]etach，将程序（irssi？）留在后台，回家。

`Ctrl`+ `a` `c`[c]创建一个新窗口 `Ctrl`+`a` `0-9`按编号在窗口之间切换

screen -r - 回到分离的会话

这涵盖了 90% 的用例。不要试图一次显示所有功能。

* * *

## 回答 #9

> 赞同：6
> 
> 时间：2008-09-22T19:45:11.813

[http://www.debian-administration.org/articles/34](http://www.debian-administration.org/articles/34)

几年前我写过这个，但它仍然是一个很好的介绍，得到了很多积极的反馈。

* * *

## 回答 #10

> 赞同：6
> 
> 时间：2008-10-01T11:21:49.457

我“必须”添加这个：添加

```
bind s 
```

到你的`.screenrc`，如果你 - 像我一样 - 曾经使用拆分窗口，`C-a S`拆分实际窗口，但`C-a s`冻结它。所以我只是禁用了冻结快捷方式。

* * *

## 回答 #11

> 赞同：4
> 
> 时间：2008-09-19T22:33:45.660

不仅与屏幕相关，而且[在我的终端中启用 256 种颜色并不是真正重要的，GNU Screen 和 Vim](https://web.archive.org/web/20130313011037/http://www.frexx.de/xterm-256-notes/)极大地改善了我的屏幕体验（特别是因为我每天大约 8 小时在 Vim 中编码 - 有一些非常适合眼睛的配色方案）。

* * *

## 回答 #12

> 赞同：3
> 
> 时间：2009-02-19T03:47:10.750

在 Ubuntu Server 的下一个版本中，在默认情况下获得良好的 GNU 屏幕设置方面正在进行一些[有趣的工作](http://blog.dustinkirkland.com/2008/12/ubuntu-server-includes-window-manager.html)，其中包括使用屏幕底部显示所有窗口以及其他有用的机器详细信息（如更新次数可用以及机器是否需要重新启动）。您可能可以抓住他们`.screenrc`并根据您的需要对其进行自定义。

我的最有用的命令`.screenrc`如下：

```
shelltitle "$ |bash" # Make screen assign window titles automatically
hardstatus alwayslastline "%w" # Show all window titles at bottom line of term 
```

通过这种方式，我总能知道哪些窗口是打开的，以及目前在其中运行的是什么。

* * *

## 回答 #13

> 赞同：3
> 
> 时间：2009-05-21T17:34:30.887

我对 .screenrc 所做的第一个修改是更改转义命令。与你们中的许多人不同，我不喜欢默认的 Ctrl-A 序列，因为它在几乎所有其他上下文中都会干扰该基本功能。在我的 .screenrc 文件中，我添加：

逃脱`e

那是反引号-e。

这使我能够使用反引号作为转义键（例如，要创建一个新屏幕，我按反引号-c，分离是反引号-d，反引号-？是帮助，反引号-反引号是前一个屏幕，等等）。它干扰的唯一方法（我不得不改掉这个习惯）是在命令行上使用反引号来捕获执行输出，或者粘贴任何包含反引号的内容。对于前者，我通过使用 BASH $(command) 约定修改了我的习惯。对于后者，我通常只是弹出另一个 xterm 或从屏幕分离，然后粘贴包含反引号的内容。最后，如果我想插入文字反引号，我只需按反引号-e。

* * *

## 回答 #14

> 赞同：3
> 
> 时间：2009-11-05T13:27:47.750

我将以下内容用于`ssh`：

```
#!/bin/sh
# scr - Runs a command in a fresh screen
#
# Get the current directory and the name of command

wd=`pwd`
cmd=$1
shift

# We can tell if we are running inside screen by looking
# for the STY environment variable.  If it is not set we
# only need to run the command, but if it is set then
# we need to use screen.

if [ -z "$STY" ]; then
        $cmd $*
else
        # Screen needs to change directory so that
        # relative file names are resolved correctly.
        screen -X chdir $wd

        # Ask screen to run the command
        if [ $cmd == "ssh" ]; then
                screen -X screen -t ""${1##*@}"" $cmd $*
        else
                screen -X screen -t "$cmd $*" $cmd $*
        fi
fi 
```

然后我设置以下 bash 别名：

```
vim() {
        scr vim $*
}

man() {
        scr man $*
}

info() {
        scr info $*
}

watch() {
        scr watch $*
}

ssh() {
        scr ssh $*
} 
```

它为上述别名打开一个新屏幕，如果使用 ssh，它会使用 ssh 主机名重命名屏幕标题。

* * *

## 回答 #15

> 赞同：2
> 
> 时间：2008-09-22T19:35:52.583

我喜欢为窗口设置一个带有描述性名称的屏幕会话。^a A 将让您为当前窗口命名，而 ^a " 将为您提供窗口列表。完成后，使用 ^ad 分离屏幕并使用 screen -R 重新附加

* * *

## 回答 #16

> 赞同：1
> 
> 时间：2011-01-10T21:13:34.337

我喜欢用来`screen -d -RR`自动创建/附加到给定的屏幕。我创建了 bash 函数以使其更容易......

```
function mkscreen
{
    local add=n

    if [ "$1" == '-a' ]; then
        add=y
        shift;
    fi

    local name=$1;
    shift;
    local command="$*";

    if [ -z "$name" -o -z "$command" ]; then
        echo 'Usage: mkscreen [ -a ] name command

    -a          Add to .bashrc.' 1>&2;
        return 1;
    fi

    if [ $add == y ]; then
        echo "mkscreen $name $command" >> $HOME/.bashrc;
    fi

    alias $name="/usr/bin/screen -d -RR -S $name $command";

    return 0;
}

function rmscreen
{
    local delete=n

    if [ "$1" == '-d' ]; then
        delete=y
        shift;
    fi

    local name=$1;

    if [ -z "$name" ]; then
        echo 'Usage: rmscreen [ -d ] name

    -d          Delete from .bashrc.' 1>&2;
        return 1;
    fi

    if [ $delete == y ]; then
        sed -i -r "/^mkscreen $name .*/d" $HOME/.bashrc;
    fi

    unalias $name;

    return 0;
} 
```

他们为`/usr/bin/screen -d -RR -S $name $command`. 例如，我喜欢在屏幕会话中使用 irssi，所以在我的 .bashrc 中（在这些函数下面），我有：

```
mkscreen irc /usr/bin/irssi 
```

然后我可以输入`irc`终端进入 irssi。如果屏幕 'irc' 还不存在，则创建它并从它运行 /usr/bin/irssi（当然，它会自动连接）。如果它已经在运行，那么我只需重新附加到它，强制分离已经附加到它的任何其他实例。这很不错。

另一个例子是当我遇到 perldocs 时为它们创建临时屏幕别名：

```
mkscreen perlipc perldoc perlipc
perlipc # Start reading the perldoc, ^A d to detach.
...
# Later, when I'm done reading it, or at least finished
# with the alias, I remove it.
rmscreen perlipc 
```

-a 选项（必须是第一个参数）将屏幕别名附加到 .bashrc （因此它是持久的）并 -d 将其删除（这些可能具有破坏性，因此使用风险自负）。xD

附加：

另一个我在使用 screen 时发现很方便的 bash 主义：

```
alias sls='/usr/bin/screen -ls' 
```

这样你就可以用更少的击键列出你的屏幕。我不知道是否`sls`与任何现有的实用程序发生冲突，但当时我的系统上没有，所以我去了。

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2008-09-16T10:31:37.680

^AA 切换回您刚刚来自的屏幕。

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2013-03-07T23:19:45.770

`Ctrl`+`A`对于 Unix 人来说是一个很棒的特殊字符，但是如果你使用 screen 与[OpenVMS](https://en.wikipedia.org/wiki/OpenVMS)对话，那么不能 ^A 会让你过早地秃顶。

在[VMS](https://en.wikipedia.org/wiki/OpenVMS#Origin_and_name_changes)中，如果您在从历史缓冲区执行之前编辑[DCL](https://en.wikipedia.org/wiki/DIGITAL_Command_Language)命令，则插入模式处于关闭状态（由于某些原因，我不会进入这里）...打开它，这样您就不用'不要过度输入你的命令而不是空格，你必须点击`^A。

# cultureinfo - 重构两个基本类

> ID：70625
> 
> 赞同：1
> 
> 时间：2008-09-16T09:13:33.310
> 
> 标签：cultureinfo, regioninfo

您将如何重构这两个类以抽象出相似之处？一个抽象类？简单的继承？重构的类会是什么样子？

```
public class LanguageCode
{
    /// <summary>
    /// Get the lowercase two-character ISO 639-1 language code.
    /// </summary>
    public readonly string Value;

    public LanguageCode(string language)
    {
        this.Value = new CultureInfo(language).TwoLetterISOLanguageName;
    }

    public static LanguageCode TryParse(string language)
    {
        if (language == null)
        {
            return null;
        }

        if (language.Length > 2)
        {
            language = language.Substring(0, 2);
        }

        try
        {
            return new LanguageCode(language);
        }
        catch (ArgumentException)
        {
            return null;
        }
    }
}

public class RegionCode
{
    /// <summary>
    /// Get the uppercase two-character ISO 3166 region/country code.
    /// </summary>
    public readonly string Value;

    public RegionCode(string region)
    {
        this.Value = new RegionInfo(region).TwoLetterISORegionName;
    }

    public static RegionCode TryParse(string region)
    {
        if (region == null)
        {
            return null;
        }

        if (region.Length > 2)
        {
            region = region.Substring(0, 2);
        }

        try
        {
            return new RegionCode(region);
        }
        catch (ArgumentException)
        {
            return null;
        }
    }
} 
```

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T09:16:06.363

这取决于，如果他们不打算做更多，那么我可能会让他们保持原样 - 恕我直言，在这种情况下，分解出的东西可能会更复杂。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T09:19:08.600

这是一个相当简单的问题，对我来说，它闻起来非常像家庭作业。

您显然可以看到代码中的常见位，我很确定您可以通过将这些东西放入超类中自己尝试一下。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T09:21:05.820

您可以将它们组合成一个`Locale`类，该类存储语言代码和区域代码，具有区域和语言的访问器以及一个解析函数，该函数还允许像“en_gb”这样的字符串......

这就是我看到在各种框架中处理语言环境的方式。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T09:21:27.253

就目前而言，这两个不会因为静态方法而很好地重构。

您要么最终在基类上使用某种工厂方法，该方法返回该基类的类型（随后需要强制转换），要么您需要某种额外的辅助类。

考虑到额外代码的数量以及随后转换为适当类型的数量，这是不值得的。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T09:21:48.610

我确信有更好的基于泛型的解决方案。但还是试了一下。

编辑：正如评论所说，静态方法不能被覆盖，因此一种选择是保留它并使用 TwoLetterCode 对象并强制转换它们，但是，正如其他人已经指出的那样，这是相当没用的。

这个怎么样？

```
public class TwoLetterCode {
    public readonly string Value;
    public static TwoLetterCode TryParseSt(string tlc) {
        if (tlc == null)
        {
            return null;
        }

        if (tlc.Length > 2)
        {
            tlc = tlc.Substring(0, 2);
        }

        try
        {
            return new TwoLetterCode(tlc);
        }
        catch (ArgumentException)
        {
            return null;
        }
    }
}
//Likewise for Region
public class LanguageCode : TwoLetterCode {
    public LanguageCode(string language)
    {
        this.Value = new CultureInfo(language).TwoLetterISOLanguageName;
    }
    public static LanguageCode TryParse(string language) {
        return (LanguageCode)TwoLetterCode.TryParseSt(language);
    }
} 
```

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T09:23:42.193

1.  创建一个通用基类（例如`AbstractCode<T>`）
2.  添加抽象方法，例如

    ```
    protected T GetConstructor(string code); 
    ```

3.  在基类中覆盖，例如

    ```
    protected override RegionCode GetConstructor(string code)
    {
        return new RegionCode(code);
    } 
    ```

4.  最后，对 做同样的事情`string GetIsoName(string code)`，例如

    ```
    protected override GetIsoName(string code)
    {
        return new RegionCode(code).TowLetterISORegionName;
    } 
    ```

这将重构两者。克里斯金普顿确实提出了一个重要的问题，即努力是否值得。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T09:41:03.277

除非您有强烈的重构理由（因为您将在不久的将来添加更多类似的类），否则为这样一个小而人为的示例更改设计的代价将克服这种情况下维护或开销的收益。无论如何，这是一个基于泛型和 lambda 表达式的可能设计。

```
public class TwoLetterCode<T>
{
    private readonly string value;

    public TwoLetterCode(string value, Func<string, string> predicate)
    {
        this.value = predicate(value);
    }

    public static T TryParse(string value, Func<string, T> predicate)
    {
        if (value == null)
        {
            return default(T);
        }

        if (value.Length > 2)
        {
            value = value.Substring(0, 2);
        }

        try
        {
            return predicate(value);
        }
        catch (ArgumentException)
        {
            return default(T);
        }
    }

    public string Value { get { return this.value; } }
}

public class LanguageCode : TwoLetterCode<LanguageCode>  {
    public LanguageCode(string language)
        : base(language, v => new CultureInfo(v).TwoLetterISOLanguageName)
    {
    }

    public static LanguageCode TryParse(string language)
    {
        return TwoLetterCode<LanguageCode>.TryParse(language, v => new LanguageCode(v));
    }
}

public class RegionCode : TwoLetterCode<RegionCode>
{
    public RegionCode(string language)
        : base(language, v => new CultureInfo(v).TwoLetterISORegionName)
    {
    }

    public static RegionCode TryParse(string language)
    {
        return TwoLetterCode<RegionCode>.TryParse(language, v => new RegionCode(v));
    }
} 
```

# c++ - 在 xll 中通过 xlcFormatNumber 设置 Excel 数字格式

> ID：70643
> 
> 赞同：4
> 
> 时间：2008-09-16T09:16:02.523
> 
> 标签：c++, excel, xll

我正在尝试设置单元格的数字格式，但对 xlcFormatNumber 的调用失败，将单元格数字格式保留为“常规”。我可以使用 xlSet 成功设置单元格的值。

```
XLOPER xRet;
XLOPER xRef;

//try to set the format of cell A1
xRef.xltype = xltypeSRef;
xRef.val.sref.count = 1;
xRef.val.sref.ref.rwFirst = 0;
xRef.val.sref.ref.rwLast = 0;
xRef.val.sref.ref.colFirst = 0;
xRef.val.sref.ref.colLast = 0;

XLOPER xFormat; 
xFormat.xltype = xltypeStr;
xFormat.val.str = "\4#.00"; //I've tried various formats

Excel4( xlcFormatNumber, &xRet, 2, (LPXLOPER)&xRef, (LPXLOPER)&xFormat); 
```

我还没有找到有关此命令用法的任何文档。在这里的任何帮助将不胜感激。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T13:21:02.250

感谢 Simon Murphy 的回答：- [电子表格上的蓝精灵](http://smurfonspreadsheets.wordpress.com/2008/08/13/excel-xlls-for-free/#comment-12148)

```
//It is necessary to select the cell to apply the formatting to
Excel4 (xlcSelect, 0, 1, &xRef);

//Then we apply the formatting
Excel4( xlcFormatNumber, 0, 1, &xFormat); 
```

# python - Python 身份验证 API

> ID：70653
> 
> 赞同：6
> 
> 时间：2008-09-16T09:17:41.007
> 
> 标签：python, authentication, desktop

我正在寻找一个 python 库，它可以帮助我为正在编写的桌面应用程序创建身份验证方法。我在 django 或 turbogears 等 Web 框架中找到了几种方法。

我只想将一种用户名-密码关联存储到本地文件中。我可以自己写它，但我真的它已经存在并且将是一个更好的解决方案（我对加密不是很流利）。

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-09-17T04:31:02.420

dbr 说：

> ```
> def hash_password(password):
>     """Returns the hashed version of a string
>     """
>     return hasher.new( str(password) ).hexdigest() 
> ```

这是一种非常不安全的哈希密码方式。你*不想*这样做。如果你想知道为什么要阅读那些为 OpenBSD 做密码散列系统的人所写的[Bycrypt 论文。](http://www.openbsd.org/papers/bcrypt-paper.pdf)此外，如果想深入讨论如何破解密码，请查看对开膛手杰克（流行的 unix 密码破解者）作者的[采访。](http://www.securityfocus.com/columnists/388)

现在 B-Crypt 很棒，但我不得不承认我不使用这个系统，因为我没有可用的 EKS-Blowfish 算法并且不想自己实现它。我使用了稍微更新的 FreeBSD 系统版本，我将在下面发布。要点是这样的。不要只是散列密码。对密码加盐，然后对密码进行哈希处理并重复 10,000 次左右。

如果这没有意义，这里是代码：

```
#note I am using the Python Cryptography Toolkit
from Crypto.Hash import SHA256

HASH_REPS = 50000

def __saltedhash(string, salt):
    sha256 = SHA256.new()
    sha256.update(string)
    sha256.update(salt)
    for x in xrange(HASH_REPS): 
        sha256.update(sha256.digest())
        if x % 10: sha256.update(salt)
    return sha256

def saltedhash_bin(string, salt):
    """returns the hash in binary format"""
    return __saltedhash(string, salt).digest()

def saltedhash_hex(string, salt):
    """returns the hash in hex format"""
    return __saltedhash(string, salt).hexdigest() 
```

对于部署这样的系统，要考虑的关键是 HASH_REPS 常量。这是该系统中可扩展的成本因素。您将需要进行测试以确定您希望等待计算每个哈希的异常时间与基于脱机字典的密码文件攻击的风险之间的关系。

安全性很难，我提出的方法不是最好的方法，但它比简单的哈希要好得多。此外，实现起来非常简单。因此，即使您不选择更复杂的解决方案，这也不是最糟糕的。

希望这会有所帮助，蒂姆

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-16T09:27:28.770

我认为您应该制作自己的身份验证方法，因为您可以使其最适合您的应用程序，但使用库进行加密，例如[pycrypto](http://www.pycrypto.org)或其他更轻量级的库。

顺便说一句，如果你需要 pycrypto 的 windows 二进制文件，你可以[在这里得到它们](http://www.voidspace.org.uk/python/modules.shtml#pycrypto)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T09:50:34.877

如果您想要简单，请使用字典，其中键是用户名，值是密码（使用 SHA256 等加密）。 [将其腌制](http://docs.python.org/lib/module-pickle.html)到磁盘/从磁盘腌制（因为这是一个桌面应用程序，我假设将其保存在内存中的开销可以忽略不计）。

例如：

```
import pickle
import hashlib

# Load from disk
pwd_file = "mypasswords"
if os.path.exists(pwd_file):
    pwds = pickle.load(open(pwd_file, "rb"))
else:
    pwds = {}

# Save to disk
pickle.dump(pwds, open(pwd_file, "wb"))

# Add password
pwds[username] = hashlib.sha256(password).hexdigest()

# Check password
if pwds[username] = hashlib.sha256(password).hexdigest():
   print "Good"
else:
   print "No match" 
```

请注意，这会将密码存储为[哈希](http://docs.python.org/lib/module-hashlib.html)- 因此它们基本上是不可恢复的。如果您丢失了密码，您将获得一个新密码，而不是找回旧密码。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T10:08:57.360

将以下内容视为伪代码..

```
try:
    from hashlib import sha as hasher
except ImportError:
    # You could probably exclude the try/except bit,
    # but older Python distros dont have hashlib.
    try:
        import sha as hasher
    except ImportError:
        import md5 as hasher

def hash_password(password):
    """Returns the hashed version of a string
    """
    return hasher.new( str(password) ).hexdigest()

def load_auth_file(path):
    """Loads a comma-seperated file.
    Important: make sure the username
    doesn't contain any commas!
    """
    # Open the file, or return an empty auth list.
    try:
        f = open(path)
    except IOError:
        print "Warning: auth file not found"
        return {}

    ret = {}
    for line in f.readlines():
        split_line = line.split(",")
        if len(split_line) > 2:
            print "Warning: Malformed line:"
            print split_line
            continue # skip it..
        else:
            username, password = split_line
            ret[username] = password
        #end if
    #end for
    return ret

def main():
    auth_file = "/home/blah/.myauth.txt"
    u = raw_input("Username:")
    p = raw_input("Password:") # getpass is probably better..
    if auth_file.has_key(u.strip()):
        if auth_file[u] == hash_password(p):
            # The hash matches the stored one
            print "Welcome, sir!" 
```

我建议不要使用逗号分隔的文件，而是使用 SQLite3（它可以用于其他设置等。

另外，请记住这不是很安全 - 如果应用程序是本地的，恶意用户可能只是替换`~/.myauth.txt`文件。本地应用程序身份验证很难做好。您必须使用用户密码加密它读取的任何数据，并且通常要非常小心。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2010-01-02T19:05:18.197

```
import hashlib
import random

def gen_salt():
    salt_seed = str(random.getrandbits(128))
    salt = hashlib.sha256(salt_seed).hexdigest()
    return salt

def hash_password(password, salt):
    h = hashlib.sha256()
    h.update(salt)
    h.update(password)
    return h.hexdigest()

#in datastore
password_stored_hash = "41e2282a9c18a6c051a0636d369ad2d4727f8c70f7ddeebd11e6f49d9e6ba13c"
salt_stored = "fcc64c0c2bc30156f79c9bdcabfadcd71030775823cb993f11a4e6b01f9632c3"

password_supplied = 'password'

password_supplied_hash = hash_password(password_supplied, salt_stored)
authenticated = (password_supplied_hash == password_stored_hash)
print authenticated #True 
```

另请参阅[gae-authenticate-to-a-3rd-party-site](https://stackoverflow.com/questions/1990722/gae-authenticate-to-a-3rd-party-site)

* * *

## 回答 #6

> 赞同：-1
> 
> 时间：2012-05-08T09:02:37.937

使用“md5”比base64好很多

```
>>> import md5
>>> hh = md5.new()
>>> hh.update('anoop')
>>> hh.digest
<built-in method digest of _hashlib.HASH object at 0x01FE1E40> 
```

# gnu-screen - 什么是 GNU 屏幕？

> ID：70661
> 
> 赞同：5
> 
> 时间：2008-09-16T09:19:01.380
> 
> 标签：gnu-screen

什么是 GNU 屏幕？

* * *

## 回答 #1

> 赞同：27
> 
> 时间：2008-09-16T09:45:29.410

什么是[GNU 屏幕](https://www.gnu.org/software/screen/)？伟大的！

Erm，一个稍微有用的答案：它允许您在一个终端中运行多个控制台应用程序或命令。有点像选项卡式终端模拟器。事实上，这正是它的本质（只是没有使用常规的 GUI 工具包）

为什么这么棒？很简单，您可以在屏幕会话中运行一个程序（运行`screen`它会运行您的默认 shell，运行`screen myapp`它会在会话中运行 myapp），点击`ctrl`+ `a`（屏幕控制序列），然后按`d`( `ctrl`+ `a`, `d`) 分离。

该程序一直在后台运行，*但是*，与 do 不同的是`mycmd &`，您可以运行`screen -r`以重新附加会话，并且一切都与您离开时一样。您可以向命令发送输入，如果它是一个 curses UI，那么一切仍然可以正常工作，就像它是一个“真正的”终端一样。

它在控制台 IRC 客户端中非常流行——您可以`screen irssi`从任何可以 SSH 的地方运行（比如说）并重新附加会话。

几个有用的命令：

*   `ctrl`+ `a`，`c`在会话中创建一个新的虚拟终端（或“窗口”）
*   `ctrl`+和+ `a`，在多个窗口中循环`n``ctrl``a``p`
*   `ctrl`+ `a`,`1`选择窗口 1, `ctrl`+ `a`,`4`选择窗口 4 等等
*   `ctrl`+ `a`, `ctrl`+`a`在最后两个活动窗口之间滑动
*   `ctrl`+ `a`, `shift`+ `a`(大写 a) 允许你重命名当前窗口
*   `ctrl`+ `a`, ```（对我来说，那是`shift`+ `2`- 引号）列出窗口，您可以使用箭头并选择一个。我将在稍后列出的“标签栏”设置也很有用

我偶然发现了一些其他有用的东西：

*   启动屏幕时使用该`-U`标志，使其支持 Unicode（例如，`screen -xU`）
*   该`-x`标志允许您多次重新附加同一会话。（`-r`断开现有连接）
*   您可以使用状态栏做一些有趣的事情。我有我的设置要显示`[ hostname ][ 0-$ bash (1*$ irssi) ][16/09 9:32]`（在主机名上运行，它有两个窗口。这是由我的 .screenrc 中的 hardstatus 行设置的（在答案的末尾）

```
startup_message off
vbell off
hardstatus alwayslastline
hardstatus string '%{gk}[ %{G}%H %{g}][%= %{wk}%?%-Lw%?%{=b kR}(%{W}%n*%f %t%?(%u)%?%{=b kR})%{= kw}%?%+Lw%?%?%= %{g}]%{=y C}[%d/%m %c]%{W}' 
```

# backup - VMWare 服务器：备份映像的最佳方式

> ID：70668
> 
> 赞同：6
> 
> 时间：2008-09-16T09:21:16.147
> 
> 标签：backup, vmware, virtualization

备份 VMWare 服务器 (1.0.x) 的最佳方法是什么？有问题的虚拟机是我们的开发环境，与主网络隔离运行（因此您不能只是将数据从虚拟服务器复制到真实服务器）。

映像文件通常在使用中，并且在服务器运行时被锁定，因此很难在机器运行时备份这些文件。

目前：我离开时手动暂停服务器，并有一个计划任务在午夜运行，以将图像复制到远程 NAS。

有没有更好的方法来做到这一点，理想情况下不必记住暂停虚拟机？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T09:33:43.620

VMWare 服务器包含命令行工具“vmware-cmd”，可用于执行几乎任何可以通过控制台执行的操作。

在这种情况下，您只需在开始备份之前将“vmware-cmd susepend”添加到脚本中，并在备份完成后添加“vmware-cmd start”。

我们使用 vmware-server 作为构建系统的一部分，以提供一个已知的环境来运行自动数据库升级，因此我们最终将回滚状态作为每个构建的一部分（由 CruiseControl 驱动），并且发现这个接口非常可靠.

```
Usage: /usr/bin/vmware-cmd <options> <vm-cfg-path> <vm-action> <arguments>
       /usr/bin/vmware-cmd -s <options> <server-action> <arguments>

  Options:
    Connection Options:
       -H <host>       specifies an alternative host (if set, -U and -P must also be set)
       -O <port>       specifies an alternative port
       -U <username>   specifies a user
       -P <password>   specifies a password
    General Options:
       -h More detailed help.
       -q Quiet. Minimal output
       -v Verbose.

  Server Operations:
    /usr/bin/vmware-cmd -l 
    /usr/bin/vmware-cmd -s register <config_file_path>
    /usr/bin/vmware-cmd -s unregister <config_file_path>
    /usr/bin/vmware-cmd -s getresource <variable>
    /usr/bin/vmware-cmd -s setresource <variable> <value>

  VM Operations:
    /usr/bin/vmware-cmd <cfg> getconnectedusers
    /usr/bin/vmware-cmd <cfg> getstate
    /usr/bin/vmware-cmd <cfg> start <powerop_mode>
    /usr/bin/vmware-cmd <cfg> stop <powerop_mode>
    /usr/bin/vmware-cmd <cfg> reset <powerop_mode>
    /usr/bin/vmware-cmd <cfg> suspend <powerop_mode>
    /usr/bin/vmware-cmd <cfg> setconfig <variable> <value>
    /usr/bin/vmware-cmd <cfg> getconfig <variable>
    /usr/bin/vmware-cmd <cfg> setguestinfo <variable> <value>
    /usr/bin/vmware-cmd <cfg> getguestinfo <variable>
    /usr/bin/vmware-cmd <cfg> getid
    /usr/bin/vmware-cmd <cfg> getpid
    /usr/bin/vmware-cmd <cfg> getproductinfo <prodinfo>
    /usr/bin/vmware-cmd <cfg> connectdevice <device_name>
    /usr/bin/vmware-cmd <cfg> disconnectdevice <device_name>
    /usr/bin/vmware-cmd <cfg> getconfigfile
    /usr/bin/vmware-cmd <cfg> getheartbeat
    /usr/bin/vmware-cmd <cfg> getuptime
    /usr/bin/vmware-cmd <cfg> getremoteconnections
    /usr/bin/vmware-cmd <cfg> gettoolslastactive
    /usr/bin/vmware-cmd <cfg> getresource <variable>
    /usr/bin/vmware-cmd <cfg> setresource <variable> <value>
    /usr/bin/vmware-cmd <cfg> setrunasuser <username> <password>
    /usr/bin/vmware-cmd <cfg> getrunasuser
    /usr/bin/vmware-cmd <cfg> getcapabilities
    /usr/bin/vmware-cmd <cfg> addredo <disk_device_name>
    /usr/bin/vmware-cmd <cfg> commit <disk_device_name> <level> <freeze> <wait>
    /usr/bin/vmware-cmd <cfg> answer 
```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2009-02-16T01:18:48.840

Worth looking at rsync? If only part of a large image file is changing then rsync might be the fastest way to copy any changes.

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2010-01-25T02:58:38.217

I found an easy to follow guide for backing up VM's in vmware server 2 here: [Backup VMware Server 2](http://www.bdts.com.au/tips/46-vmware/57-backing-up-vmware-server-2-.html)

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T09:24:35.250

如果我没记错的话，VMWare Server 有一个脚本接口，可以通过 Perl 或 COM 获得。您可以使用它在运行备份之前自动暂停虚拟机。

如果您的备份软件支持卷影复制，那也可能会起作用。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-24T18:57:54.217

There is a tool called (ahem) Hobocopy which will copy locked VM files. I would recommend taking a snapshot of the VM and then backing up the VMDK. Then merge the snapshot after the copy is complete.

# python - Python Psycopg 错误和连接处理（v MySQLdb）

> ID：70681
> 
> 赞同：2
> 
> 时间：2008-09-16T09:22:36.847
> 
> 标签：python, mysql, psycopg2

有没有办法让 psycopg 和 postgres 处理错误而不必重新建立连接，比如 MySQLdb？下面的注释版本适用于 MySQLdb，注释使其适用于 Psycopg2：

```
results = {'felicitas': 3, 'volumes': 8, 'acillevs': 1, 'mosaics': 13, 'perat\xe9': 1, 'representative': 6....}
for item in sorted(results):
    try:
        cur.execute("""insert into resultstab values ('%s', %d)""" % (item, results[item]))
        print item, results[item]
#       conn.commit()
    except:
#       conn=psycopg2.connect(user='bvm', database='wdb', password='redacted')
#       cur=conn.cursor()
        print 'choked on', item
        continue 
```

这必须减慢速度，任何人都可以提出传递格式错误的建议吗？显然，上面的撇号窒息了，但是有没有办法让它通过它而不得到类似下面的东西，或者提交，重新连接等？：

```
agreement 19
agreements 1
agrees 1
agrippa 9
choked on agrippa's
choked on agrippina 
```

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-16T10:04:53.967

我认为您的代码目前看起来像这样：

```
l = "a very long ... text".split()
for e in l:
    cursor.execute("INSERT INTO yourtable (yourcol) VALUES ('" + e + "')") 
```

所以试着把它改成这样：

```
l = "a very long ... text".split()
for e in l:
    cursor.execute("INSERT INTO yourtable (yourcol) VALUES (%s)", (e,)) 
```

所以永远不要忘记在参数列表中传递你的参数，那么你就不必关心你的引号和东西，它也更安全。您可以在[http://www.python.org/dev/peps/pep-0249/阅读更多相关信息](http://www.python.org/dev/peps/pep-0249/)

还可以查看 .executemany() 方法，该方法专门设计用于多次执行同一语句。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2009-01-21T01:43:57.897

首先，您应该让 psycopg 通过将参数传递给 execute() 方法来为您进行转义，而不是自己使用 '%' 进行格式化。那是：

```
cur.execute("insert into resultstab values (%s, %s)", (item, results[item])) 
```

请注意我们如何使用“%s”作为标记，即使对于非字符串值也是如此，并避免在查询中使用引号。psycopg 将为我们做所有的报价。

然后，如果您想忽略一些错误，只需回滚并继续。

```
try:
    cur.execute("SELECT this is an error")
except:
    conn.rollback() 
```

就这样。psycopg 将回滚并在您的下一条语句中启动新事务。

# c++ - GCC 3.x 和 4.x 中 C++ 对象中的 VTable 布局和 VTable 指针位置是什么？

> ID：70682
> 
> 赞同：16
> 
> 时间：2008-09-16T09:22:46.657
> 
> 标签：c++, g++

我正在寻找 VTable 结构、顺序和内容的详细信息，以及 vtable 指针在对象中的位置。

理想情况下，这将涵盖单继承、多继承和虚拟继承。

对外部文档的引用也将不胜感激

GCC 4.0x 类布局的文档在[这里](http://www.cse.wustl.edu/~mdeters/seminar/fall2005/mi.html#virtual)，Itanium 和更广泛的 GNU、ABI 布局文档在[这里](http://www.codesourcery.com/public/cxx-abi/abi.html#general)。

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2015-01-26T17:50:25.493

虚拟表通常被视为函数指针数组，尽管编译器可以自由地将数据指针（在 MI 和 VI 场景中，或类型信息）、整数（用于修正）或标记元素（例如 NULL 指针）放入其中也是。布局通常是特定于编译器的（或者是特定于 ABI 的，多个 C++ 编译器共享一个 ABI），但如果正在编译的类具有稳定的接口，则它是稳定的（否则你必须一直重新编译你的代码，这是一个拖累） . 还需要额外的表来处理涉及虚拟和多重继承的极端情况，并确保派生类构造期间的虚拟调用按照标准所说的那样在这些情况下运行（这些是 VTT 和构造表中的下面的输出用于）。

至于 GCC 4.x 的具体情况：`-fdump-class-hierarchy`开关确实像描述的那样（然后是一些）。我使用下面的示例代码在[Coliru上对其进行了测试：](http://coliru.stacked-crooked.com/a/16d53eb062d38bec)

```
struct Base
{
    virtual ~Base() {}
    virtual void f() = 0;
};

struct OtherBase
{
    virtual ~OtherBase() {}
    virtual void g() {}
};

struct Derived: public Base
{
    virtual ~Derived() {}
    virtual void f() {}
};

struct MultiplyDerived: public Base, public OtherBase
{
    virtual ~MultiplyDerived() {}
    virtual void f() {}
    virtual void g() {}
};

struct OtherDerived: public Base
{
    virtual ~OtherDerived() {}
    virtual void f() {}
};

struct DiamondDerived: public Derived, public OtherDerived
{
    virtual ~DiamondDerived() {}
    virtual void f() {}
};

struct VirtuallyDerived: virtual public Base
{
    virtual ~VirtuallyDerived() {}
    virtual void f() {}
};

struct OtherVirtuallyDerived: virtual public Base
{
    virtual ~OtherVirtuallyDerived() {}
    virtual void f() {}
};

struct VirtuallyDiamondDerived: public VirtuallyDerived, public OtherVirtuallyDerived
{
    virtual ~VirtuallyDiamondDerived() {}
    virtual void f() {}
};

struct DoublyVirtuallyDiamondDerived: virtual public VirtuallyDerived, virtual public OtherVirtuallyDerived
{
    virtual ~DoublyVirtuallyDiamondDerived() {}
    virtual void f() {}
};

struct MixedVirtuallyDerived: virtual public Base, public OtherBase
{
    virtual ~MixedVirtuallyDerived() {}
};

struct MixedVirtuallyDiamondDerived: public VirtuallyDerived, public MixedVirtuallyDerived
{
    virtual ~MixedVirtuallyDiamondDerived() {}
    virtual void f() {}
    virtual void g() {}
};

struct VirtuallyMultiplyDerived: virtual public Base, virtual public OtherBase
{
    virtual ~VirtuallyMultiplyDerived() {}
};

struct OtherVirtuallyMultiplyDerived: virtual public Base, virtual public OtherBase
{
    virtual ~OtherVirtuallyMultiplyDerived() {}
};

struct MultiplyVirtuallyDiamondDerived: public VirtuallyMultiplyDerived, public OtherVirtuallyMultiplyDerived
{
    virtual ~MultiplyVirtuallyDiamondDerived() {}
    virtual void f() {}
    virtual void g() {}
}; 
```

并从 G++ 接收（损坏的名称指南：TI 是 typeinfos，TV 是 vtables，Th 和 Tv 是用于在存在多重和/或虚拟继承的情况下进行正确虚拟调用的 thunk）：

```
用于基础的 Vtable

Base::_ZTV4Base: 5u 个条目

0 (int (*)(...))0

8 (int (*)(...))(& _ZTI4Base)

16 0u

24 0u

32 (int (*)(...))__cxa_pure_virtual

类库

   大小=8 对齐=8

   基本尺寸=8 基本对齐=8

Base (0x0x7fd42c0355a0) 0 几乎为空

    vptr=((& Base::_ZTV4Base) + 16u)

OtherBase 的 Vtable

OtherBase::_ZTV9OtherBase: 5u 条目

0 (int (*)(...))0

8 (int (*)(...))(& _ZTI9OtherBase)

16 (int (*)(...))OtherBase::~OtherBase

24 (int (*)(...))OtherBase::~OtherBase

32 (int (*)(...))OtherBase::g

类 OtherBase

   大小=8 对齐=8

   基本尺寸=8 基本对齐=8

OtherBase (0x0x7fd42c035600) 0 几乎为空

    vptr=((& OtherBase::_ZTV9OtherBase) + 16u)

导出的 Vtable

Derived::_ZTV7Derived: 5u 个条目

0 (int (*)(...))0

8 (int (*)(...))(& _ZTI7Derived)

16 (int (*)(...))Derived::~Derived

24 (int (*)(...))Derived::~Derived

32 (int (*)(...))Derived::f

类派生

   大小=8 对齐=8

   基本尺寸=8 基本对齐=8

派生 (0x0x7fd42c02d138) 0 几乎为空

    vptr=((& Derived::_ZTV7Derived) + 16u)

  Base (0x0x7fd42c035660) 0 几乎为空

      主要派生（0x0x7fd42c02d138）

MultiplyDerived 的 Vtable

MultiplyDerived::_ZTV15MultiplyDerived: 11u 个条目

0 (int (*)(...))0

8 (int (*)(...))(& _ZTI15MultiplyDerived)

16 (int (*)(...))MultiplyDerived::~MultiplyDerived

24 (int (*)(...))MultiplyDerived::~MultiplyDerived

32 (int (*)(...))MultiplyDerived::f

40 (int (*)(...))MultiplyDerived::g

48 (int (*)(...))-8

56 (int (*)(...))(& _ZTI15MultiplyDerived)

64 (int (*)(...))MultiplyDerived::_ZThn8_N15MultiplyDerivedD1Ev

72 (int (*)(...))MultiplyDerived::_ZThn8_N15MultiplyDerivedD0Ev

80 (int (*)(...))MultiplyDerived::_ZThn8_N15MultiplyDerived1gEv

类 MultiplyDerived

   尺寸=16 对齐=8

   基本尺寸=16 基本对齐=8

乘法衍生 (0x0x7fd42c04aaf0) 0

    vptr=((& MultiplyDerived::_ZTV15MultiplyDerived) + 16u)

  Base (0x0x7fd42c0356c0) 0 几乎为空

      主要用于 MultiplyDerived (0x0x7fd42c04aaf0)

  OtherBase (0x0x7fd42c035720) 8 几乎为空

      vptr=((& MultiplyDerived::_ZTV15MultiplyDerived) + 64u)

OtherDerived 的 Vtable

OtherDerived::_ZTV12OtherDerived: 5u 条目

0 (int (*)(...))0

8 (int (*)(...))(& _ZTI12OtherDerived)

16 (int (*)(...))OtherDerived::~OtherDerived

24 (int (*)(...))OtherDerived::~OtherDerived

32 (int (*)(...))OtherDerived::f

其他派生类

   大小=8 对齐=8

   基本尺寸=8 基本对齐=8

OtherDerived (0x0x7fd42c02d1a0) 0 几乎为空

    vptr=((& OtherDerived::_ZTV12OtherDerived) + 16u)

  基数 (0x0x7fd42c035780) 0 几乎为空

      主要的其他派生（0x0x7fd42c02d1a0）

DiamondDerived 的 Vtable

DiamondDerived::_ZTV14DiamondDerived: 10u 个条目

0 (int (*)(...))0

8 (int (*)(...))(& _ZTI14DiamondDerived)

16 (int (*)(...))DiamondDerived::~DiamondDerived

24 (int (*)(...))DiamondDerived::~DiamondDerived

32 (int (*)(...))DiamondDerived::f

40 (int (*)(...))-8

48 (int (*)(...))(& _ZTI14DiamondDerived)

56 (int (*)(...))DiamondDerived::_ZThn8_N14DiamondDerivedD1Ev

64 (int (*)(...))DiamondDerived::_ZThn8_N14DiamondDerivedD0Ev

72 (int (*)(...))DiamondDerived::_ZThn8_N14DiamondDerived1fEv

类 DiamondDerived

   尺寸=16 对齐=8

   基本尺寸=16 基本对齐=8

钻石派生（0x0x7fd42c0625b0）0

    vptr=((& DiamondDerived::_ZTV14DiamondDerived) + 16u)

  派生 (0x0x7fd42c02d208) 0 几乎为空

      主要用于 DiamondDerived (0x0x7fd42c0625b0)

    Base (0x0x7fd42c0357e0) 0 几乎为空

        主要派生（0x0x7fd42c02d208）

  OtherDerived (0x0x7fd42c02d270) 8 几乎为空

      vptr=((& DiamondDerived::_ZTV14DiamondDerived) + 56u)

    Base (0x0x7fd42c035840) 8 几乎为空

        主要的其他派生（0x0x7fd42c02d270）

VirtuallyDerived 的 Vtable

VirtuallyDerived::_ZTV16VirtuallyDerived: 8u 条目

0 0u

8 0u

16 0u

24 (int (*)(...))0

32 (int (*)(...))(& _ZTI16VirtuallyDerived)

40 (int (*)(...))VirtuallyDerived::~VirtuallyDerived

48 (int (*)(...))VirtuallyDerived::~VirtuallyDerived

56 (int (*)(...))VirtuallyDerived::f

虚拟衍生的 VTT

VirtuallyDerived::_ZTT16VirtuallyDerived: 2u 个条目

0 ((& VirtuallyDerived::_ZTV16VirtuallyDerived) + 40u)

8 ((& VirtuallyDerived::_ZTV16VirtuallyDerived) + 40u)

虚拟派生类

   大小=8 对齐=8

   基本尺寸=8 基本对齐=8

VirtuallyDerived (0x0x7fd42c02d2d8) 0 几乎为空

    vptridx=0u vptr=((& VirtuallyDerived::_ZTV16VirtuallyDerived) + 40u)

  Base (0x0x7fd42c0358a0) 0 几乎为空的虚拟

      主要用于 VirtuallyDerived (0x0x7fd42c02d2d8)

      vptridx=8u vbaseoffset=-40

OtherVirtuallyDerived 的 Vtable

OtherVirtuallyDerived::_ZTV21OtherVirtuallyDerived: 8u 条目

0 0u

8 0u

16 0u

24 (int (*)(...))0

32 (int (*)(...))(& _ZTI21OtherVirtuallyDerived)

40 (int (*)(...))OtherVirtuallyDerived::~OtherVirtuallyDerived

48 (int (*)(...))OtherVirtuallyDerived::~OtherVirtuallyDerived

56 (int (*)(...))OtherVirtuallyDerived::f

其他虚拟派生的 VTT

OtherVirtuallyDerived::_ZTT21OtherVirtuallyDerived: 2u 个条目

0 ((& OtherVirtuallyDerived::_ZTV21OtherVirtuallyDerived) + 40u)

8 ((& OtherVirtuallyDerived::_ZTV21OtherVirtuallyDerived) + 40u)

类 OtherVirtuallyDerived

   大小=8 对齐=8

   基本尺寸=8 基本对齐=8

OtherVirtuallyDerived (0x0x7fd42c02d340) 0 几乎为空

    vptridx=0u vptr=((& OtherVirtuallyDerived::_ZTV21OtherVirtuallyDerived) + 40u)

  Base (0x0x7fd42c035900) 0 几乎为空的虚拟

      主要用于 OtherVirtuallyDerived (0x0x7fd42c02d340)

      vptridx=8u vbaseoffset=-40

VirtuallyDiamondDerived 的 Vtable

VirtuallyDiamondDerived::_ZTV23VirtuallyDiamondDerived: 16u 个条目

0 0u

8 0u

16 0u

24 (int (*)(...))0

32 (int (*)(...))(& _ZTI23VirtuallyDiamondDerived)

40 (int (*)(...))VirtuallyDiamondDerived::~VirtuallyDiamondDerived

48 (int (*)(...))VirtuallyDiamondDerived::~VirtuallyDiamondDerived

56 (int (*)(...))VirtuallyDiamondDerived::f

64 18446744073709551608u

72 18446744073709551608u

80 18446744073709551608u

88 (int (*)(...))-8

96 (int (*)(...))(& _ZTI23VirtuallyDiamondDerived)

104 (int (*)(...))VirtuallyDiamondDerived::_ZThn8_N23VirtuallyDiamondDerivedD1Ev

112 (int (*)(...))VirtuallyDiamondDerived::_ZThn8_N23VirtuallyDiamondDerivedD0Ev

120 (int (*)(...))VirtuallyDiamondDerived::_ZThn8_N23VirtuallyDiamondDerived1fEv

VirtuallyDiamondDerived 中 VirtuallyDerived（0x0x7fd42c02d3a8 实例）的构造 vtable

VirtuallyDiamondDerived::_ZTC23VirtuallyDiamondDerived0_16VirtuallyDerived: 8u 条目

0 0u

8 0u

16 0u

24 (int (*)(...))0

32 (int (*)(...))(& _ZTI16VirtuallyDerived)

40 0u

48 0u

56 (int (*)(...))VirtuallyDerived::f

VirtuallyDiamondDerived 中 OtherVirtuallyDerived (0x0x7fd42c02d410 实例) 的构造 vtable

VirtuallyDiamondDerived::_ZTC23VirtuallyDiamondDerived8_21OtherVirtuallyDerived: 15u 个条目

0 18446744073709551608u

8 0u

16 0u

24 (int (*)(...))0

32 (int (*)(...))(& _ZTI21OtherVirtuallyDerived)

40 0u

48 0u

56 (int (*)(...))OtherVirtuallyDerived::f

64 8u

72 8u

80 (int (*)(...))8

88 (int (*)(...))(& _ZTI21OtherVirtuallyDerived)

96 0u

104 0u

112 (int (*)(...))OtherVirtuallyDerived::_ZTv0_n32_N21OtherVirtuallyDerived1fEv

VirtuallyDiamondDerived 的 VTT

VirtuallyDiamondDerived::_ZTT23VirtuallyDiamondDerived: 7u 个条目

0 ((& VirtuallyDiamondDerived::_ZTV23VirtuallyDiamondDerived) + 40u)

8 ((& VirtuallyDiamondDerived::_ZTC23VirtuallyDiamondDerived0_16VirtuallyDerived) + 40u)

16 ((& VirtuallyDiamondDerived::_ZTC23VirtuallyDiamondDerived0_16VirtuallyDerived) + 40u)

24 ((& VirtuallyDiamondDerived::_ZTC23VirtuallyDiamondDerived8_21OtherVirtuallyDerived) + 40u)

32 ((& VirtuallyDiamondDerived::_ZTC23VirtuallyDiamondDerived8_21OtherVirtuallyDerived) + 96u)

40 ((& VirtuallyDiamondDerived::_ZTV23VirtuallyDiamondDerived) + 40u)

48 ((& VirtuallyDiamondDerived::_ZTV23VirtuallyDiamondDerived) + 104u)

VirtuallyDiamondDerived 类

   尺寸=16 对齐=8

   基本尺寸=16 基本对齐=8

VirtuallyDiamondDerived (0x0x7fd42c07e460) 0

    vptridx=0u vptr=((& VirtuallyDiamondDerived::_ZTV23VirtuallyDiamondDerived) + 40u)

  VirtuallyDerived (0x0x7fd42c02d3a8) 0 几乎为空

      主要用于 VirtuallyDiamondDerived (0x0x7fd42c07e460)

      subvttidx=8u

    Base (0x0x7fd42c035960) 0 几乎为空的虚拟

        主要用于 VirtuallyDerived (0x0x7fd42c02d3a8)

        vptridx=40u vbaseoffset=-40

  OtherVirtuallyDerived (0x0x7fd42c02d410) 8 几乎为空

      失主

      subvttidx=24u vptridx=48u vptr=((& VirtuallyDiamondDerived::_ZTV23VirtuallyDiamondDerived) + 104u)

    基本 (0x0x7fd42c035960) 替代路径

DoublyVirtuallyDiamondDerived 的 Vtable

DoublyVirtuallyDiamondDerived::_ZTV29DoublyVirtuallyDiamondDerived: 18u 个条目

0 8u

8 0u

16 0u

24 0u

32 0u

40 (int (*)(...))0

48 (int (*)(...))(& _ZTI29DoublyVirtuallyDiamondDerived)

56 (int (*)(...))DoublyVirtuallyDiamondDerived::~DoublyVirtuallyDiamondDerived

64 (int (*)(...))DoublyVirtuallyDiamondDerived::~DoublyVirtuallyDiamondDerived

72 (int (*)(...))DoublyVirtuallyDiamondDerived::f

80 18446744073709551608u

88 18446744073709551608u

96 18446744073709551608u

104 (int (*)(...))-8

112 (int (*)(...))(& _ZTI29DoublyVirtuallyDiamondDerived)

120 (int (*)(...))DoublyVirtuallyDiamondDerived::_ZTv0_n24_N29DoublyVirtuallyDiamondDerivedD1Ev

128 (int (*)(...))DoublyVirtuallyDiamondDerived::_ZTv0_n24_N29DoublyVirtuallyDiamondDerivedD0Ev

136 (int (*)(...))DoublyVirtuallyDiamondDerived::_ZTv0_n32_N29DoublyVirtuallyDiamondDerived1fEv

DoublyVirtuallyDiamondDerived 中 VirtuallyDerived 的构造 vtable

DoublyVirtuallyDiamondDerived::_ZTC29DoublyVirtuallyDiamondDerived0_16VirtuallyDerived: 8u 个条目

0 0u

8 0u

16 0u

24 (int (*)(...))0

32 (int (*)(...))(& _ZTI16VirtuallyDerived)

40 0u

48 0u

56 (int (*)(...))VirtuallyDerived::f

DoublyVirtuallyDiamondDerived 中 OtherVirtuallyDerived 的构造 vtable

DoublyVirtuallyDiamondDerived::_ZTC29DoublyVirtuallyDiamondDerived8_21OtherVirtuallyDerived: 15u 个条目

0 18446744073709551608u

8 0u

16 0u

24 (int (*)(...))0

32 (int (*)(...))(& _ZTI21OtherVirtuallyDerived)

40 0u

48 0u

56 (int (*)(...))OtherVirtuallyDerived::f

64 8u

72 8u

80 (int (*)(...))8

88 (int (*)(...))(& _ZTI21OtherVirtuallyDerived)

96 0u

104 0u

112 (int (*)(...))OtherVirtuallyDerived::_ZTv0_n32_N21OtherVirtuallyDerived1fEv

VTT for DoublyVirtuallyDiamondDerived

DoublyVirtuallyDiamondDerived::_ZTT29DoublyVirtuallyDiamondDerived: 8u 个条目

0 ((&DoublyVirtuallyDiamondDerived::_ZTV29DoublyVirtuallyDiamondDerived) + 56u)

8 ((&DoublyVirtuallyDiamondDerived::_ZTV29DoublyVirtuallyDiamondDerived) + 56u)

16 ((&DoublyVirtuallyDiamondDerived::_ZTV29DoublyVirtuallyDiamondDerived) + 56u)

24 ((&DoublyVirtuallyDiamondDerived::_ZTV29DoublyVirtuallyDiamondDerived) + 120u)

32 ((&DoublyVirtuallyDiamondDerived::_ZTC29DoublyVirtuallyDiamondDerived0_16VirtuallyDerived) + 40u)

40 ((&DoublyVirtuallyDiamondDerived::_ZTC29DoublyVirtuallyDiamondDerived0_16VirtuallyDerived) + 40u)

48 ((&DoublyVirtuallyDiamondDerived::_ZTC29DoublyVirtuallyDiamondDerived8_21OtherVirtuallyDerived) + 40u)

56 ((&DoublyVirtuallyDiamondDerived::_ZTC29DoublyVirtuallyDiamondDerived8_21OtherVirtuallyDerived) + 96u)

类 DoubleVirtuallyDiamondDerived

   尺寸=16 对齐=8

   基本尺寸=8 基本对齐=8

DoublyVirtuallyDiamondDerived (0x0x7fd42c07ea10) 0 几乎为空

    vptridx=0u vptr=((&DoublyVirtuallyDiamondDerived::_ZTV29DoublyVirtuallyDiamondDerived) + 56u)

  VirtuallyDerived (0x0x7fd42c02d478) 0 几乎为空的虚拟

      主要用于 DoublyVirtuallyDiamondDerived (0x0x7fd42c07ea10)

      subvttidx=32u vptridx=8u vbaseoffset=-48

    Base (0x0x7fd42c035a80) 0 几乎为空的虚拟

        主要用于 VirtuallyDerived (0x0x7fd42c02d478)

        vptridx=16u vbaseoffset=-40

  OtherVirtuallyDerived (0x0x7fd42c02d4e0) 8 几乎为空的虚拟

      失主

      subvttidx=48u vptridx=24u vbaseoffset=-56 vptr=((&DoublyVirtuallyDiamondDerived::_ZTV29DoublyVirtuallyDiamondDerived) + 120u)

    基本 (0x0x7fd42c035a80) 替代路径

MixedVirtuallyDerived 的 Vtable

MixedVirtuallyDerived::_ZTV21MixedVirtuallyDerived: 13u 个条目

0 8u

8 (int (*)(...))0

16 (int (*)(...))(& _ZTI21MixedVirtuallyDerived)

24 0u

32 0u

40 (int (*)(...))OtherBase::g

48 0u

56 18446744073709551608u

64 (int (*)(...))-8

72 (int (*)(...))(& _ZTI21MixedVirtuallyDerived)

80 0u

88 0u

96 (int (*)(...))__cxa_pure_virtual

混合虚拟衍生的 VTT

MixedVirtuallyDerived::_ZTT21MixedVirtuallyDerived: 2u 个条目

0 ((& MixedVirtuallyDerived::_ZTV21MixedVirtuallyDerived) + 24u)

8 ((& MixedVirtuallyDerived::_ZTV21MixedVirtuallyDerived) + 80u)

类 MixedVirtuallyDerived

   尺寸=16 对齐=8

   基本尺寸=8 基本对齐=8

MixedVirtuallyDerived (0x0x7fd42c07eee0) 0 几乎为空

    vptridx=0u vptr=((& MixedVirtuallyDerived::_ZTV21MixedVirtuallyDerived) + 24u)

  Base (0x0x7fd42c035c60) 8 个几乎为空的虚拟

      vptridx=8u vbaseoffset=-24 vptr=((& MixedVirtuallyDerived::_ZTV21MixedVirtuallyDerived) + 80u)

  OtherBase (0x0x7fd42c035cc0) 0 几乎为空

      主要用于 MixedVirtuallyDerived (0x0x7fd42c07eee0)

MixedVirtuallyDiamondDerived 的 Vtable

MixedVirtuallyDiamondDerived::_ZTV28MixedVirtuallyDiamondDerived: 15u 个条目

0 0u

8 0u

16 0u

24 (int (*)(...))0

32 (int (*)(...))(& _ZTI28MixedVirtuallyDiamondDerived)

40 (int (*)(...))MixedVirtuallyDiamondDerived::~MixedVirtuallyDiamondDerived

48 (int (*)(...))MixedVirtuallyDiamondDerived::~MixedVirtuallyDiamondDerived

56 (int (*)(...))MixedVirtuallyDiamondDerived::f

64 (int (*)(...))MixedVirtuallyDiamondDerived::g

72 18446744073709551608u

80 (int (*)(...))-8

88 (int (*)(...))(& _ZTI28MixedVirtuallyDiamondDerived)

96 (int (*)(...))MixedVirtuallyDiamondDerived::_ZThn8_N28MixedVirtuallyDiamondDerivedD1Ev

104 (int (*)(...))MixedVirtuallyDiamondDerived::_ZThn8_N28MixedVirtuallyDiamondDerivedD0Ev

112 (int (*)(...))MixedVirtuallyDiamondDerived::_ZThn8_N28MixedVirtuallyDiamondDerived1gEv

MixedVirtuallyDiamondDerived 中 VirtuallyDerived（0x0x7fd42c02d750 实例）的构造 vtable

MixedVirtuallyDiamondDerived::_ZTC28MixedVirtuallyDiamondDerived0_16VirtuallyDerived: 8u 个条目

0 0u

8 0u

16 0u

24 (int (*)(...))0

32 (int (*)(...))(& _ZTI16VirtuallyDerived)

40 0u

48 0u

56 (int (*)(...))VirtuallyDerived::f

MixedVirtuallyDiamondDerived 中 MixedVirtuallyDerived（0x0x7fd42c0b5380 实例）的构造 vtable

MixedVirtuallyDiamondDerived::_ZTC28MixedVirtuallyDiamondDerived8_21MixedVirtuallyDerived: 13u 个条目

0 18446744073709551608u

8 (int (*)(...))0

16 (int (*)(...))(& _ZTI21MixedVirtuallyDerived)

24 0u

32 0u

40 (int (*)(...))OtherBase::g

48 0u

56 8u

64 (int (*)(...))8

72 (int (*)(...))(& _ZTI21MixedVirtuallyDerived)

80 0u

88 0u

96 (int (*)(...))__cxa_pure_virtual

VTT for MixedVirtuallyDiamondDerived

MixedVirtuallyDiamondDerived::_ZTT28MixedVirtuallyDiamondDerived: 7u 个条目

0 ((& MixedVirtuallyDiamondDerived::_ZTV28MixedVirtuallyDiamondDerived) + 40u)

8 ((& MixedVirtuallyDiamondDerived::_ZTC28MixedVirtuallyDiamondDerived0_16VirtuallyDerived) + 40u)

16 ((& MixedVirtuallyDiamondDerived::_ZTC28MixedVirtuallyDiamondDerived0_16VirtuallyDerived) + 40u)

24 ((& MixedVirtuallyDiamondDerived::_ZTC28MixedVirtuallyDiamondDerived8_21MixedVirtuallyDerived) + 24u)

32 ((& MixedVirtuallyDiamondDerived::_ZTC28MixedVirtuallyDiamondDerived8_21MixedVirtuallyDerived) + 80u)

40 ((& MixedVirtuallyDiamondDerived::_ZTV28MixedVirtuallyDiamondDerived) + 40u)

48 ((& MixedVirtuallyDiamondDerived::_ZTV28MixedVirtuallyDiamondDerived) + 96u)

类 MixedVirtuallyDiamondDerived

   尺寸=16 对齐=8

   基本尺寸=16 基本对齐=8

MixedVirtuallyDiamondDerived (0x0x7fd42c0b5310) 0

    vptridx=0u vptr=((& MixedVirtuallyDiamondDerived::_ZTV28MixedVirtuallyDiamondDerived) + 40u)

  VirtuallyDerived (0x0x7fd42c02d750) 0 几乎为空

      主要用于 MixedVirtuallyDiamondDerived (0x0x7fd42c0b5310)

      subvttidx=8u

    Base (0x0x7fd42c035d20) 0 几乎为空的虚拟

        主要用于 VirtuallyDerived (0x0x7fd42c02d750)

        vptridx=40u vbaseoffset=-40

  MixedVirtuallyDerived (0x0x7fd42c0b5380) 8 几乎为空

      subvttidx=24u vptridx=48u vptr=((& MixedVirtuallyDiamondDerived::_ZTV28MixedVirtuallyDiamondDerived) + 96u)

    基本 (0x0x7fd42c035d20) 替代路径

    OtherBase (0x0x7fd42c035d80) 8 几乎为空

        主要用于 MixedVirtuallyDerived (0x0x7fd42c0b5380)

VirtuallyMultiplyDerived 的 Vtable

VirtuallyMultiplyDerived::_ZTV24VirtuallyMultiplyDerived：16u 个条目

0 8u

8 0u

16 0u

24 0u

32 (int (*)(...))0

40 (int (*)(...))(& _ZTI24VirtuallyMultiplyDerived)

48 0u

56 0u

64 (int (*)(...))__cxa_pure_virtual

72 0u

80 18446744073709551608u

88 (int (*)(...))-8

96 (int (*)(...))(& _ZTI24VirtuallyMultiplyDerived)

104 0u

112 0u

120 (int (*)(...))OtherBase::g

VirtuallyMultiplyDerived 的 VTT

VirtuallyMultiplyDerived::_ZTT24VirtuallyMultiplyDerived：3u 个条目

0 ((& VirtuallyMultiplyDerived::_ZTV24VirtuallyMultiplyDerived) + 48u)

8 ((& VirtuallyMultiplyDerived::_ZTV24VirtuallyMultiplyDerived) + 48u)

16 ((& VirtuallyMultiplyDerived::_ZTV24VirtuallyMultiplyDerived) + 104u)

类 VirtuallyMultiplyDerived

   尺寸=16 对齐=8

   基本尺寸=8 基本对齐=8

VirtuallyMultiplyDerived (0x0x7fd42c0b59a0) 0 几乎为空

    vptridx=0u vptr=((& VirtuallyMultiplyDerived::_ZTV24VirtuallyMultiplyDerived) + 48u)

  Base (0x0x7fd42c035e40) 0 几乎为空的虚拟

      主要用于 VirtuallyMultiplyDerived (0x0x7fd42c0b59a0)

      vptridx=8u vbaseoffset=-40

  OtherBase (0x0x7fd42c035ea0) 8 几乎为空的虚拟

      vptridx=16u vbaseoffset=-48 vptr=((& VirtuallyMultiplyDerived::_ZTV24VirtuallyMultiplyDerived) + 104u)

OtherVirtuallyMultiplyDerived 的 Vtable

OtherVirtuallyMultiplyDerived::_ZTV29OtherVirtuallyMultiplyDerived: 16u 个条目

0 8u

8 0u

16 0u

24 0u

32 (int (*)(...))0

40 (int (*)(...))(& _ZTI29OtherVirtuallyMultiplyDerived)

48 0u

56 0u

64 (int (*)(...))__cxa_pure_virtual

72 0u

80 18446744073709551608u

88 (int (*)(...))-8

96 (int (*)(...))(& _ZTI29OtherVirtuallyMultiplyDerived)

104 0u

112 0u

120 (int (*)(...))OtherBase::g

其他虚拟乘法衍生的 VTT

OtherVirtuallyMultiplyDerived::_ZTT29OtherVirtuallyMultiplyDerived: 3u 个条目

0 ((& OtherVirtuallyMultiplyDerived::_ZTV29OtherVirtuallyMultiplyDerived) + 48u)

8 ((& OtherVirtuallyMultiplyDerived::_ZTV29OtherVirtuallyMultiplyDerived) + 48u)

16 ((& OtherVirtuallyMultiplyDerived::_ZTV29OtherVirtuallyMultiplyDerived) + 104u)

类 OtherVirtuallyMultiplyDerived

   尺寸=16 对齐=8

   基本尺寸=8 基本对齐=8

OtherVirtuallyMultiplyDerived (0x0x7fd42c0b5d90) 0 几乎为空

    vptridx=0u vptr=((& OtherVirtuallyMultiplyDerived::_ZTV29OtherVirtuallyMultiplyDerived) + 48u)

  Base (0x0x7fd42c035f00) 0 几乎为空的虚拟

      主要用于 OtherVirtuallyMultiplyDerived (0x0x7fd42c0b5d90)

      vptridx=8u vbaseoffset=-40

  OtherBase (0x0x7fd42c035f60) 8 几乎为空的虚拟

      vptridx=16u vbaseoffset=-48 vptr=((& OtherVirtuallyMultiplyDerived::_ZTV29OtherVirtuallyMultiplyDerived) + 104u)

MultiplyVirtuallyDiamondDerived 的 Vtable

MultiplyVirtuallyDiamondDerived::_ZTV31MultiplyVirtuallyDiamondDerived: 26u 个条目

0 16u

8 0u

16 0u

24 0u

32 (int (*)(...))0

40 (int (*)(...))(& _ZTI31MultiplyVirtuallyDiamondDerived)

48 (int (*)(...))MultiplyVirtuallyDiamondDerived::~MultiplyVirtuallyDiamondDerived

56 (int (*)(...))MultiplyVirtuallyDiamondDerived::~MultiplyVirtuallyDiamondDerived

64 (int (*)(...))MultiplyVirtuallyDiamondDerived::f

72 (int (*)(...))MultiplyVirtuallyDiamondDerived::g

80 8u

88 18446744073709551608u

96 18446744073709551608u

104 18446744073709551608u

112 (int (*)(...))-8

120 (int (*)(...))(& _ZTI31MultiplyVirtuallyDiamondDerived)

128 (int (*)(...))MultiplyVirtuallyDiamondDerived::_ZThn8_N31MultiplyVirtuallyDiamondDerivedD1Ev

136 (int (*)(...))MultiplyVirtuallyDiamondDerived::_ZThn8_N31MultiplyVirtuallyDiamondDerivedD0Ev

144 0u

152 18446744073709551600u

160 18446744073709551600u

168（整数（*）（...））-16

176（int（*）（...））（&_ZTI31MultiplyVirtuallyDiamondDerived）

184 (int (*)(...))MultiplyVirtuallyDiamondDerived::_ZTv0_n24_N31MultiplyVirtuallyDiamondDerivedD1Ev

192 (int (*)(...))MultiplyVirtuallyDiamondDerived::_ZTv0_n24_N31MultiplyVirtuallyDiamondDerivedD0Ev

200 (int (*)(...))MultiplyVirtuallyDiamondDerived::_ZTv0_n32_N31MultiplyVirtuallyDiamondDerived1gEv

MultiplyVirtuallyDiamondDerived 中 VirtuallyMultiplyDerived（0x0x7fd42bcdf230 实例）的构造 vtable

MultiplyVirtuallyDiamondDerived::_ZTC31MultiplyVirtuallyDiamondDerived0_24VirtuallyMultiplyDerived: 16u 个条目

0 16u

8 0u

16 0u

24 0u

32 (int (*)(...))0

40 (int (*)(...))(& _ZTI24VirtuallyMultiplyDerived)

48 0u

56 0u

64 (int (*)(...))__cxa_pure_virtual

72 0u

80 18446744073709551600u

88 (int (*)(...))-16

96 (int (*)(...))(& _ZTI24VirtuallyMultiplyDerived)

104 0u

112 0u

120 (int (*)(...))OtherBase::g

MultiplyVirtuallyDiamondDerived 中 OtherVirtuallyMultiplyDerived（0x0x7fd42bcdf2a0 实例）的构造 vtable

MultiplyVirtuallyDiamondDerived::_ZTC31MultiplyVirtuallyDiamondDerived8_29OtherVirtuallyMultiplyDerived: 23u 个条目

0 8u

8 18446744073709551608u

16 18446744073709551608u

24 0u

32 (int (*)(...))0

40 (int (*)(...))(& _ZTI29OtherVirtuallyMultiplyDerived)

48 0u

56 0u

64 (int (*)(...))__cxa_pure_virtual

72 0u

80 8u

88 (int (*)(...))8

96 (int (*)(...))(& _ZTI29OtherVirtuallyMultiplyDerived)

104 0u

112 0u

120 (int (*)(...))__cxa_pure_virtual

128 0u

136 18446744073709551608u

144（整数（*）（...））-8

152 (int (*)(...))(& _ZTI29OtherVirtuallyMultiplyDerived)

160 0u

168 0u

176 (int (*)(...))OtherBase::g

MultiplyVirtuallyDiamondDerived 的 VTT

MultiplyVirtuallyDiamondDerived::_ZTT31MultiplyVirtuallyDiamondDerived: 10u 个条目

0 ((& MultiplyVirtuallyDiamondDerived::_ZTV31MultiplyVirtuallyDiamondDerived) + 48u)

8 ((& MultiplyVirtuallyDiamondDerived::_ZTC31MultiplyVirtuallyDiamondDerived0_24VirtuallyMultiplyDerived) + 48u)

16 ((& MultiplyVirtuallyDiamondDerived::_ZTC31MultiplyVirtuallyDiamondDerived0_24VirtuallyMultiplyDerived) + 48u)

24 ((& MultiplyVirtuallyDiamondDerived::_ZTC31MultiplyVirtuallyDiamondDerived0_24VirtuallyMultiplyDerived) + 104u)

32 ((& MultiplyVirtuallyDiamondDerived::_ZTC31MultiplyVirtuallyDiamondDerived8_29OtherVirtuallyMultiplyDerived) + 48u)

40 ((& MultiplyVirtuallyDiamondDerived::_ZTC31MultiplyVirtuallyDiamondDerived8_29OtherVirtuallyMultiplyDerived) + 104u)

48 ((& MultiplyVirtuallyDiamondDerived::_ZTC31MultiplyVirtuallyDiamondDerived8_29OtherVirtuallyMultiplyDerived) + 160u)

56 ((& MultiplyVirtuallyDiamondDerived::_ZTV31MultiplyVirtuallyDiamondDerived) + 48u)

64 ((& MultiplyVirtuallyDiamondDerived::_ZTV31MultiplyVirtuallyDiamondDerived) + 184u)

72 ((& MultiplyVirtuallyDiamondDerived::_ZTV31MultiplyVirtuallyDiamondDerived) + 128u)

类 MultiplyVirtuallyDiamondDerived

   大小=24 对齐=8

   基本尺寸=16 基本对齐=8

MultiplyVirtuallyDiamondDerived (0x0x7fd42bcdf1c0) 0

    vptridx=0u vptr=((& MultiplyVirtuallyDiamondDerived::_ZTV31MultiplyVirtuallyDiamondDerived) + 48u)

  VirtuallyMultiplyDerived (0x0x7fd42bcdf230) 0 几乎为空

      主要用于 MultiplyVirtuallyDiamondDerived (0x0x7fd42bcdf1c0)

      subvttidx=8u

    Base (0x0x7fd42bce2000) 0 几乎为空的虚拟

        主要用于 VirtuallyMultiplyDerived (0x0x7fd42bcdf230)

        vptridx=56u vbaseoffset=-40

    OtherBase (0x0x7fd42bce2060) 16 几乎为空的虚拟

        vptridx=64u vbaseoffset=-48 vptr=((& MultiplyVirtuallyDiamondDerived::_ZTV31MultiplyVirtuallyDiamondDerived) + 184u)

  OtherVirtuallyMultiplyDerived (0x0x7fd42bcdf2a0) 8 几乎为空

      失主

      subvttidx=32u vptridx=72u vptr=((& MultiplyVirtuallyDiamondDerived::_ZTV31MultiplyVirtuallyDiamondDerived) + 128u)

    基本 (0x0x7fd42bce2000) 替代路径

    OtherBase (0x0x7fd42bce2060) 替代路径

```

* * *

## 回答 #2

> 赞同：-5
> 
> 时间：2014-09-04T20:54:59.247

我见过的大多数编译器实现只是将基础对象“嵌入”到派生对象中。保留 vtable 的位置变得无关紧要，因为对象的相对偏移量只会在编译时在评估引用时添加。

多重继承和虚拟继承更加复杂，并且可能需要不同的偏移量，具体取决于正在访问的内容。

我强烈推荐阅读这篇关于代码项目的文章：[The Impossibly Fast C++ Delegates](http://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible)

它出色地概括了不同编译器如何处理继承的各个方面。如果您对不同编译器的低级工作感兴趣，请好好阅读。

编辑：我在那里链接了错误的文章。已更正。

# c# - 在 WCF 服务中获取生成的 HTML

> ID：70685
> 
> 赞同：0
> 
> 时间：2008-09-16T09:23:54.423
> 
> 标签：c#, wcf

在我正在处理的 WCF 应用程序中，我需要访问特定网页的生成源（在页面上进行了所有 AJAX 调用之后）。

我尝试过使用`System.Net.WebRequest`，但它只是让我回到了页面的原始来源。有没有办法执行一个页面然后获取源代码？

否则，有没有办法从 WCF 服务中执行 Javascript？然后，我可以使用 javascript 和 JSON 响应从我的网络服务中创建 HTML 页面！

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T15:54:27.543

You could use Javascript to traverse and pass the DOM than make a call into your WCF service from the Javascript when all the Ajax calls are complete. If you are after the data that is stored on the page after all the Ajax calls I would re-think your implementation...

Petar

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T09:55:48.170

好吧，WCF 被设计为供非浏览器使用，因此确实无法期望 WCF 响应可以包含将由客户端自动执行的 Javascript。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T16:36:31.640

@Petar：感谢您的意见。是的，我正在寻找在 Ajax 调用后将存储在页面中的数据。而且，不知何故，第三方供应商不会通过一些我可以直接从我自己的 WCF 服务调用的 JSON 调用给我这些数据。

# java - 在 Java 中实现单例模式的有效方法是什么？

> ID：70689
> 
> 赞同：842
> 
> 时间：2008-09-16T09:24:28.447
> 
> 标签：java, singleton, design-patterns

在 Java 中实现单例设计模式的有效方法是什么？

* * *

## 回答 #1

> 赞同：801
> 
> 时间：2008-09-16T11:31:57.173

使用枚举：

```
public enum Foo {
    INSTANCE;
} 
```

Joshua Bloch 在 Google I/O 2008 上的[Effective Java Reloaded](http://sites.google.com/site/io/effective-java-reloaded)演讲中解释了这种方法：[链接到视频](http://www.youtube.com/watch?v=pi_I7oD_uGI#t=28m50s)。另请参阅他的演示文稿的幻灯片 30-32 ( [effective_java_reloaded.pdf](https://14b1424d-a-62cb3a1a-s-sites.googlegroups.com/site/io/effective-java-reloaded/effective_java_reloaded.pdf?attachauth=ANoY7crKCOet2NEUGW7RV1XfM-Jn4z8YJhs0qJM11OhLRnFW_JbExkJtvJ3UJvTE40dhAciyWcRIeGJ-n3FLGnMOapHShHINh8IY05YViOJoZWzaohMtM-s4HCi5kjREagi8awWtcYD0_6G7GhKr2BndToeqLk5sBhZcQfcYIyAE5A4lGNosDCjODcBAkJn8EuO6572t2wU1LMSEUgjvqcf4I-Fp6VDhDvih_XUEmL9nuVJQynd2DRpxyuNH1SpJspEIdbLw-WWZ&attredirects=0) )：

> ### 实现可序列化单例的正确方法
> 
> ```
> public enum Elvis {
>     INSTANCE;
>     private final String[] favoriteSongs =
>         { "Hound Dog", "Heartbreak Hotel" };
>     public void printFavorites() {
>         System.out.println(Arrays.toString(favoriteSongs));
>     }
> } 
> ```

**编辑：** “Effective Java”的[在线部分](http://www.ddj.com/java/208403883?pgno=3)说：

> “这种方法在功能上等同于公共字段方法，只是它更简洁，免费提供序列化机制，并且即使面对复杂的序列化或反射攻击，也能提供防止多次实例化的铁定保证。虽然这种方法已经尚未被广泛采用，**单元素枚举类型是实现单例的最佳方式**。”

* * *

## 回答 #2

> 赞同：237
> 
> 时间：2008-09-16T15:44:40.343

根据使用情况，有几个“正确”的答案。

从 Java 5 开始，最好的方法是使用枚举：

```
public enum Foo {
   INSTANCE;
} 
```

在 Java 5 之前，最简单的情况是：

```
public final class Foo {

    private static final Foo INSTANCE = new Foo();

    private Foo() {
        if (INSTANCE != null) {
            throw new IllegalStateException("Already instantiated");
        }
    }

    public static Foo getInstance() {
        return INSTANCE;
    }

    public Object clone() throws CloneNotSupportedException{
        throw new CloneNotSupportedException("Cannot clone instance of this class");
    }
} 
```

让我们回顾一下代码。首先，您希望课程是最终的。在这种情况下，我使用`final`关键字让用户知道它是最终的。然后你需要将构造函数设为私有，以防止用户创建自己的 Foo。从构造函数中抛出异常会阻止用户使用反射来创建第二个 Foo。然后创建一个`private static final Foo`字段来保存唯一的实例，以及一个`public static Foo getInstance()`返回它的方法。Java 规范确保仅在第一次使用该类时才调用构造函数。

当您有一个非常大的对象或繁重的构造代码*，并且*还有其他可访问的静态方法或字段可能在需要实例之前使用时，那么并且只有这样您才需要使用延迟初始化。

您可以使用 a`private static class`来加载实例。代码将如下所示：

```
public final class Foo {

    private static class FooLoader {
        private static final Foo INSTANCE = new Foo();
    }

    private Foo() {
        if (FooLoader.INSTANCE != null) {
            throw new IllegalStateException("Already instantiated");
        }
    }

    public static Foo getInstance() {
        return FooLoader.INSTANCE;
    }
} 
```

由于`private static final Foo INSTANCE = new Foo();`仅在实际使用类 FooLoader 时才执行该行，因此这会处理延迟实例化，并保证它是线程安全的。

当您还希望能够序列化您的对象时，您需要确保反序列化不会创建副本。

```
public final class Foo implements Serializable {

    private static final long serialVersionUID = 1L;

    private static class FooLoader {
        private static final Foo INSTANCE = new Foo();
    }

    private Foo() {
        if (FooLoader.INSTANCE != null) {
            throw new IllegalStateException("Already instantiated");
        }
    }

    public static Foo getInstance() {
        return FooLoader.INSTANCE;
    }

    @SuppressWarnings("unused")
    private Foo readResolve() {
        return FooLoader.INSTANCE;
    }
} 
```

该方法`readResolve()`将确保返回唯一的实例，即使该对象在之前的程序运行中被序列化。

* * *

## 回答 #3

> 赞同：146
> 
> 时间：2013-05-16T06:24:00.763

**免责声明：**我刚刚总结了所有很棒的答案并用我自己的话写出来。

* * *

在实现 Singleton 时，我们有两个选择：

1.  延迟加载
2.  早期加载

延迟加载会增加一点开销（老实说很多），所以只有当你有一个非常大的对象或繁重的构造代码*并且*还有其他可访问的静态方法或字段可能在需要实例之前使用时才使用它，然后且仅那么你需要使用延迟初始化。否则，选择提前加载是​​一个不错的选择。

实现单例最简单的方法是：

```
public class Foo {

    // It will be our sole hero
    private static final Foo INSTANCE = new Foo();

    private Foo() {
        if (INSTANCE != null) {
            // SHOUT
            throw new IllegalStateException("Already instantiated");
        }
    }

    public static Foo getInstance() {
        return INSTANCE;
    }
} 
```

一切都很好，除了它是一个早期加载的单例。让我们尝试延迟加载的单例

```
class Foo {

    // Our now_null_but_going_to_be sole hero
    private static Foo INSTANCE = null;

    private Foo() {
        if (INSTANCE != null) {
            // SHOUT
            throw new IllegalStateException("Already instantiated");
        }
    }

    public static Foo getInstance() {
        // Creating only  when required.
        if (INSTANCE == null) {
            INSTANCE = new Foo();
        }
        return INSTANCE;
    }
} 
```

到目前为止一切都很好，但是我们的英雄在与多个想要我们英雄实例的多个邪恶线程单独战斗时将无法生存。所以让我们保护它免受邪恶的多线程：

```
class Foo {

    private static Foo INSTANCE = null;

    // TODO Add private shouting constructor

    public static Foo getInstance() {
        // No more tension of threads
        synchronized (Foo.class) {
            if (INSTANCE == null) {
                INSTANCE = new Foo();
            }
        }
        return INSTANCE;
    }
} 
```

但仅仅保护英雄还不够，真的！！！这是我们可以/应该做的最好的事情来帮助我们的英雄：

```
class Foo {

    // Pay attention to volatile
    private static volatile Foo INSTANCE = null;

    // TODO Add private shouting constructor

    public static Foo getInstance() {
        if (INSTANCE == null) { // Check 1
            synchronized (Foo.class) {
                if (INSTANCE == null) { // Check 2
                    INSTANCE = new Foo();
                }
            }
        }
        return INSTANCE;
    }
} 
```

这被称为“双重检查锁定习语”。很容易忘记 volatile 语句，很难理解为什么它是必要的。详情：*[“双重检查锁被破坏”声明](http://www.cs.umd.edu/%7Epugh/java/memoryModel/DoubleCheckedLocking.html)*

现在我们确定了邪恶的线程，但是残酷的连载呢？我们必须确保即使在反序列化时也不会创建新对象：

```
class Foo implements Serializable {

    private static final long serialVersionUID = 1L;

    private static volatile Foo INSTANCE = null;

    // The rest of the things are same as above

    // No more fear of serialization
    @SuppressWarnings("unused")
    private Object readResolve() {
        return INSTANCE;
    }
} 
```

该方法`readResolve()`将确保返回唯一的实例，即使该对象在我们程序的先前运行中被序列化。

最后，我们对线程和序列化添加了足够的保护，但是我们的代码看起来又大又丑。让我们给我们的英雄改头换面：

```
public final class Foo implements Serializable {

    private static final long serialVersionUID = 1L;

    // Wrapped in a inner static class so that loaded only when required
    private static class FooLoader {

        // And no more fear of threads
        private static final Foo INSTANCE = new Foo();
    }

    // TODO add private shouting construcor

    public static Foo getInstance() {
        return FooLoader.INSTANCE;
    }

    // Damn you serialization
    @SuppressWarnings("unused")
    private Foo readResolve() {
        return FooLoader.INSTANCE;
    }
} 
```

是的，这就是我们的同一个英雄 :)

由于该行仅在实际使用`private static final Foo INSTANCE = new Foo();`该类时才执行`FooLoader`，因此它负责惰性实例化，并保证它是线程安全的。

我们已经走到了这一步。这是实现我们所做的一切的最佳方法是最好的方法：

```
public enum Foo {
    INSTANCE;
} 
```

内部将被视为

```
public class Foo {

    // It will be our sole hero
    private static final Foo INSTANCE = new Foo();
} 
```

就是这样！不再担心序列化、线程和丑陋的代码。ENUMS[**单例也被延迟初始化**](https://stackoverflow.com/questions/16771373/singleton-via-enum-way-is-lazy-initialized)。

> 这种方法在功能上等同于公共字段方法，只是它更简洁，免费提供序列化机制，并提供针对多次实例化的铁定保证，即使面对复杂的序列化或反射攻击。虽然这种方法尚未被广泛采用，但单元素枚举类型是实现单例的最佳方式。

——Joshua Bloch 在“有效的 Java”中

现在您可能已经意识到为什么 ENUMS 被认为是实现单例的最佳方式，感谢您的耐心等待 :)

[**在我的博客**](http://ajinkyaparakh.blogspot.in/2013/05/implementing-singleton-in-java.html)上更新了它。

* * *

## 回答 #4

> 赞同：125
> 
> 时间：2008-09-16T12:24:47.093

[Stu Thompson 发布的解决方案](https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java/70835#70835)在 Java 5.0 及更高版本中有效。但我宁愿不使用它，因为我认为它容易出错。

很容易忘记 volatile 语句，很难理解为什么它是必要的。由于双重检查锁定反模式，如果没有 volatile，此代码将不再是线程安全的。[在Java Concurrency in Practice](http://jcip.net/ "Java 并发实践")的第 16.2.4 段中了解更多信息。简而言之：这种模式（在 Java 5.0 之前或没有 volatile 语句）可能会返回对（仍然）处于不正确状态的 Bar 对象的引用。

这种模式是为了性能优化而发明的。但这真的不再是一个真正的问题。下面的惰性初始化代码速度很快，而且——更重要的是——更容易阅读。

```
class Bar {
    private static class BarHolder {
        public static Bar bar = new Bar();
    }

    public static Bar getBar() {
        return BarHolder.bar;
    }
} 
```

* * *

## 回答 #5

> 赞同：95
> 
> 时间：2008-09-16T09:51:16.153

Java 5+ 中的线程安全：

```
class Foo {
    private static volatile Bar bar = null;
    public static Bar getBar() {
        if (bar == null) {
            synchronized(Foo.class) {
                if (bar == null)
                    bar = new Bar();
            }
        }
        return bar;
    }
} 
```

* * *

注意`volatile`这里的修饰符。:) 这很重要，因为没有它，JMM（Java 内存模型）不能保证其他线程看到其值的变化。同步*并不*关心这一点——它只序列化对该代码块的访问。

@Bno 的回答详细介绍了 Bill Pugh (FindBugs) 推荐的方法，并且可以说更好。去阅读并投票给他的答案。

* * *

## 回答 #6

> 赞同：92
> 
> 时间：2008-09-16T09:49:23.897

忘记[延迟初始化](https://en.wikipedia.org/wiki/Lazy_initialization)；这太有问题了。这是最简单的解决方案：

```
public class A {    

    private static final A INSTANCE = new A();

    private A() {}

    public static A getInstance() {
        return INSTANCE;
    }
} 
```

* * *

## 回答 #7

> 赞同：47
> 
> 时间：2008-09-16T09:33:23.217

确保你真的需要它。在谷歌上搜索“单例反模式”以查看一些反对它的论据。

我想它本质上没有任何问题，但这只是一种暴露一些全局资源/数据的机制，所以请确保这是最好的方法。特别是，我发现[依赖注入](https://en.wikipedia.org/wiki/Dependency_injection)(DI) 更有用，特别是如果您还使用单元测试，因为 DI 允许您使用模拟资源进行测试。

* * *

## 回答 #8

> 赞同：21
> 
> 时间：2008-09-16T12:06:04.143

我对一些建议[依赖注入](https://en.wikipedia.org/wiki/Dependency_injection)（DI）作为使用单例的替代方法的答案感到困惑；这些是不相关的概念。您可以使用 DI 注入单例或非单例（例如，每线程）实例。如果您使用 Spring 2.x，至少这是真的，我不能代表其他 DI 框架。

所以我对 OP 的回答是（除了最简单的示例代码之外）：

1.  使用像[Spring Framework](https://en.wikipedia.org/wiki/Spring_Framework)这样的 DI 框架，然后
2.  无论您的依赖项是单例、请求范围、会话范围或其他什么，都将其作为您的 DI 配置的一部分。

这种方法为您提供了一个很好的解耦（因此灵活且可测试）架构，其中是否使用单例是一个容易可逆的实现细节（当然，前提是您使用的任何单例都是线程安全的）。

* * *

## 回答 #9

> 赞同：20
> 
> 时间：2008-09-16T09:48:54.007

真正考虑一下为什么在编写之前需要一个单例。有一个关于使用它们的准宗教辩论，如果你用谷歌搜索 Java 中的单例，你很容易偶然发现。

就个人而言，出于多种原因，我尽量避免使用单例，其中大部分可以通过谷歌搜索单例找到。我觉得单身人士经常被滥用，因为他们很容易被每个人理解。它们被用作将“全局”数据引入 OO 设计的机制，并且它们被使用是因为它很容易绕过对象生命周期管理（或者真正考虑如何从 B 内部执行 A）。查看[控制反转](https://en.wikipedia.org/wiki/Inversion_of_control)(IoC) 或[依赖注入](https://en.wikipedia.org/wiki/Dependency_injection)(DI) 之类的东西，以获得一个不错的中间立场。

如果你真的需要一个，那么维基百科有一个很好的例子来说明单例的正确实现。

* * *

## 回答 #10

> 赞同：16
> 
> 时间：2013-02-17T03:46:40.603

以下是三种不同的方法

1.  枚举

    ```
     /**
     * Singleton pattern example using Java Enum
     */
     public enum EasySingleton {
         INSTANCE;
     } 
    ```

2.  双重检查锁定/延迟加载

    ```
     /**
     * Singleton pattern example with Double checked Locking
     */
     public class DoubleCheckedLockingSingleton {
          private static volatile DoubleCheckedLockingSingleton INSTANCE;

          private DoubleCheckedLockingSingleton() {}

          public static DoubleCheckedLockingSingleton getInstance() {
              if(INSTANCE == null) {
                 synchronized(DoubleCheckedLockingSingleton.class) {
                     // Double checking Singleton instance
                     if(INSTANCE == null) {
                         INSTANCE = new DoubleCheckedLockingSingleton();
                     }
                 }
              }
              return INSTANCE;
          }
     } 
    ```

3.  静态工厂方法

    ```
     /**
     * Singleton pattern example with static factory method
     */

     public class Singleton {
         // Initialized during class loading
         private static final Singleton INSTANCE = new Singleton();

         // To prevent creating another instance of 'Singleton'
         private Singleton() {}

         public static Singleton getSingleton() {
             return INSTANCE;
         }
     } 
    ```

* * *

## 回答 #11

> 赞同：13
> 
> 时间：2008-09-22T20:44:55.023

我使用[Spring Framework](https://en.wikipedia.org/wiki/Spring_Framework)来管理我的单例。

它不强制执行类的“单一性”（如果涉及多个类加载器，您无论如何都不能真正做到这一点），但它提供了一种非常简单的方法来构建和配置不同的工厂以创建不同类型的对象。

* * *

## 回答 #12

> 赞同：12
> 
> 时间：2017-07-12T16:06:06.620

实现单例有很多细微差别。持有人模式不能在许多情况下使用。并且 IMO 在使用 volatile 时 - 您还应该使用局部变量。让我们从头开始，对问题进行迭代。你会明白我的意思。

* * *

第一次尝试可能看起来像这样：

```
public class MySingleton {

     private static MySingleton INSTANCE;

     public static MySingleton getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new MySingleton();
        }
        return INSTANCE;
    }
    ...
} 
```

这里我们有一个 MySingleton 类，它有一个名为*INSTANCE*的私有静态成员和一个名为 getInstance() 的公共静态方法。第一次调用 getInstance() 时，*INSTANCE*成员为空。然后流程将落入创建条件并创建 MySingleton 类的新实例。对 getInstance() 的后续调用将发现*INSTANCE*变量已设置，因此不会创建另一个 MySingleton 实例。这确保只有一个 MySingleton 实例在 getInstance() 的所有调用者之间共享。

但是这个实现有一个问题。多线程应用程序在创建单个实例时会有竞争条件。如果多个执行线程同时（或大约）同时调用 getInstance() 方法，它们都会将*INSTANCE*成员视为 null。这将导致每个线程创建一个新的 MySingleton 实例并随后设置*INSTANCE*成员。

* * *

```
private static MySingleton INSTANCE;

public static synchronized MySingleton getInstance() {
    if (INSTANCE == null) {
        INSTANCE = new MySingleton();
    }
    return INSTANCE;
} 
```

这里我们在方法签名中使用了 synchronized 关键字来同步 getInstance() 方法。这肯定会解决我们的比赛条件。线程现在将阻塞并一次进入一个方法。但它也会产生性能问题。这个实现不仅同步了单个实例的创建；它同步所有对 getInstance() 的调用，包括读取。读取不需要同步，因为它们只返回*INSTANCE*的值。由于读取将构成我们调用的大部分（请记住，实例化仅在第一次调用时发生），因此同步整个方法会导致不必要的性能损失。

* * *

```
private static MySingleton INSTANCE;

public static MySingleton getInstance() {
    if (INSTANCE == null) {
        synchronize(MySingleton.class) {
            INSTANCE = new MySingleton();
        }
    }
    return INSTANCE;
} 
```

在这里，我们将同步从方法签名移到了包装 MySingleton 实例创建的同步块。但这能解决我们的问题吗？好吧，我们不再阻止读取，但我们也向后退了一步。多个线程将同时或大约同时访问 getInstance() 方法，它们都将*INSTANCE*成员视为 null。

然后，他们将点击同步块，其中一个人将获得锁并创建实例。当该线程退出该块时，其他线程将争夺锁，每个线程将一个接一个地穿过该块并创建我们类的新实例。所以我们回到了我们开始的地方。

* * *

```
private static MySingleton INSTANCE;

public static MySingleton getInstance() {
    if (INSTANCE == null) {
        synchronized(MySingleton.class) {
            if (INSTANCE == null) {
                INSTANCE = createInstance();
            }
        }
    }
    return INSTANCE;
} 
```

*在这里，我们从块内部*发出另一张支票。如果已经设置了*INSTANCE成员，我们将跳过初始化。*这称为双重检查锁定。

这解决了我们的多重实例化问题。但是，我们的解决方案再一次提出了另一个挑战。其他线程可能不会“看到” *INSTANCE*成员已更新。这是因为 Java 如何优化内存操作。

线程将变量的原始值从主存复制到 CPU 的缓存中。然后将值的更改写入该缓存并从该缓存中读取。这是 Java 的一个特性，旨在优化性能。但这给我们的单例实现带来了问题。第二个线程——由不同的 CPU 或内核处理，使用不同的缓存——不会看到第一个线程所做的更改。这将导致第二个线程将*INSTANCE*成员视为 null，从而强制创建单例的新实例。

* * *

```
private static volatile MySingleton INSTANCE;

public static MySingleton getInstance() {
    if (INSTANCE == null) {
        synchronized(MySingleton.class) {
            if (INSTANCE == null) {
                INSTANCE = createInstance();
            }
        }
    }
    return INSTANCE;
} 
```

我们通过在*INSTANCE*成员的声明中使用*volatile*关键字来解决这个问题。这将告诉编译器始终读取和写入主内存，而不是 CPU 缓存。

 *但这种简单的改变是有代价的。因为我们绕过了 CPU 缓存，所以每次对 volatile *INSTANCE*成员进行操作时都会对性能造成影响——我们做了四次。我们再次检查存在（1 和 2），设置值（3），然后返回值（4）。有人可能会说这条路径是边缘情况，因为我们只在第一次调用该方法时创建实例。也许对创作的影响是可以容忍的。但即使是我们的主要用例 reads 也会对 volatile 成员进行两次操作。一次检查存在，再次返回其值。

* * *

```
private static volatile MySingleton INSTANCE;

public static MySingleton getInstance() {
    MySingleton result = INSTANCE;
    if (result == null) {
        synchronized(MySingleton.class) {
            result = INSTANCE;
            if (result == null) {
                INSTANCE = result = createInstance();
            }
        }
    }
    return result;
} 
```

由于性能损失是由于直接对 volatile 成员进行操作，所以让我们将一个局部变量设置为 volatile 的值，并改为对局部变量进行操作。这将减少我们对 volatile 进行操作的次数，从而收回我们失去的一些性能。请注意，当我们进入同步块时，我们必须再次设置我们的局部变量。这可以确保它在我们等待锁定时发生的任何更改都是最新的。

我最近写了一篇关于这个的文章。[解构单身人士](https://medium.com/@michael.andrews/deconstructing-the-singleton-b5f881f85f5)。您可以在此处找到有关这些示例的更多信息以及“持有人”模式的示例。还有一个真实的例子展示了双重检查的易失性方法。

* * *

## 回答 #13

> 赞同：11
> 
> 时间：2008-09-16T09:35:42.587

维基百科有一些单[例](http://en.wikipedia.org/wiki/Singleton_pattern)的例子，也用 Java。Java 5 实现看起来相当完整，并且是线程安全的（应用了双重检查锁定）。

* * *

## 回答 #14

> 赞同：11
> 
> 时间：2015-04-01T11:14:54.207

**版本 1：**

```
public class MySingleton {
    private static MySingleton instance = null;
    private MySingleton() {}
    public static synchronized MySingleton getInstance() {
        if(instance == null) {
            instance = new MySingleton();
        }
        return instance;
    }
} 
```

延迟加载，线程安全的阻塞，由于`synchronized`.

**版本 2：**

```
public class MySingleton {
    private MySingleton() {}
    private static class MySingletonHolder {
        public final static MySingleton instance = new MySingleton();
    }
    public static MySingleton getInstance() {
        return MySingletonHolder.instance;
    }
} 
```

延迟加载，线程安全，非阻塞，高性能。

* * *

## 回答 #15

> 赞同：10
> 
> 时间：2008-09-16T09:50:16.593

如果您不需要延迟加载，那么只需尝试：

```
public class Singleton {
    private final static Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() { return Singleton.INSTANCE; }

    protected Object clone() {
        throw new CloneNotSupportedException();
    }
} 
```

如果您想要延迟加载并且希望您的单例是线程安全的，请尝试双重检查模式：

```
public class Singleton {
    private static Singleton instance = null;

    private Singleton() {}

    public static Singleton getInstance() {
        if(null == instance) {
            synchronized(Singleton.class) {
                if(null == instance) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

    protected Object clone() {
        throw new CloneNotSupportedException();
    }
} 
```

由于不能保证双重检查模式有效（由于编译器的一些问题，我对此一无所知），您还可以尝试同步整个 getInstance 方法或为所有单例创建注册表。

* * *

## 回答 #16

> 赞同：9
> 
> 时间：2013-01-17T05:31:12.463

我会说一个枚举单例。

在 Java 中使用枚举的单例通常是声明枚举单例的一种方式。枚举单例可能包含实例变量和实例方法。为简单起见，还请注意，如果您使用任何实例方法，那么如果它影响对象的状态，则需要确保该方法的线程安全。

枚举的使用非常容易实现，并且没有关于可序列化对象的缺点，这些缺点必须以其他方式规避。

```
/**
* Singleton pattern example using a Java Enum
*/
public enum Singleton {
    INSTANCE;
    public void execute (String arg) {
        // Perform operation here
    }
} 
```

可以通过 来访问，比在 Singleton 上`Singleton.INSTANCE`调用方法要容易得多。`getInstance()`

> 1.12 枚举常量的序列化
> 
> 枚举常量的序列化方式与普通的可序列化或可外部化对象不同。枚举常量的序列化形式仅由其名称组成；常量的字段值不存在于表单中。要序列化枚举常量，`ObjectOutputStream`请写入枚举常量的 name 方法返回的值。要反序列化枚举常量，`ObjectInputStream`请从流中读取常量名称；然后通过调用该`java.lang.Enum.valueOf`方法获得反序列化的常量，将常量的枚举类型与接收到的常量名称一起作为参数传递。与其他可序列化或可外部化的对象一样，枚举常量可以充当随后出现在序列化流中的反向引用的目标。
> 
> 枚举常量的序列化过程无法自定义：在序列化和反序列化过程中，枚举类型定义的任何类特定`writeObject`的 、`readObject`、`readObjectNoData`、`writeReplace`和`readResolve`方法都将被忽略。类似地，任何`serialPersistentFields`或`serialVersionUID`字段声明也被忽略——所有枚举类型都有一个固定`serialVersionUID`的`0L`. 没有必要为枚举类型记录可序列化字段和数据，因为发送的数据类型没有变化。
> 
> [引用自 Oracle 文档](http://docs.oracle.com/javase/1.5.0/docs/guide/serialization/spec/serial-arch.html#enum)

传统单例的另一个问题是，一旦实现了`Serializable`接口，它们就不再保持单例，因为`readObject()`方法总是返回一个新实例，就像 Java 中的构造函数一样。这可以通过使用`readResolve()`和丢弃新创建的实例来避免，方法是用如下的单例替换：

```
 // readResolve to prevent another instance of Singleton
 private Object readResolve(){
     return INSTANCE;
 } 
```

*如果您的单例类*维护状态，这可能会变得更加复杂，因为您需要使它们成为瞬态的，但是在枚举单例中，JVM 保证了序列化。

* * *

**好读**

1.  [单例模式](http://www.oodesign.com/singleton-pattern.html)
2.  [枚举、单例和反序列化](https://stackoverflow.com/questions/13219678/enums-singletons-and-deserialization)
3.  [双重检查锁定和单例模式](http://www.ibm.com/developerworks/java/library/j-dcl/index.html)

* * *

## 回答 #17

> 赞同：8
> 
> 时间：2016-08-23T10:25:42.783

在 Java 中创建单例有四种方法。

1.  渴望初始化单例

    ```
     public class Test {
         private static final Test test = new Test();

         private Test() {
         }

         public static Test getTest() {
             return test;
         }
     } 
    ```

2.  延迟初始化单例（线程安全）

    ```
     public class Test {
          private static volatile Test test;

          private Test() {
          }

          public static Test getTest() {
             if(test == null) {
                 synchronized(Test.class) {
                     if(test == null) {
                         test = new Test();
                     }
                 }
             }
             return test;
         }
     } 
    ```

3.  带有支架图案的 Bill Pugh 单例（最好是最好的）

    ```
     public class Test {

         private Test() {
         }

         private static class TestHolder {
             private static final Test test = new Test();
         }

         public static Test getInstance() {
             return TestHolder.test;
         }
     } 
    ```

4.  枚举单例

    ```
     public enum MySingleton {
         INSTANCE;

         private MySingleton() {
             System.out.println("Here");
         }
     } 
    ```

* * *

## 回答 #18

> 赞同：4
> 
> 时间：2016-05-18T16:19:13.100

这是如何实现一个简单的[单例](https://en.wikipedia.org/wiki/Singleton_pattern)：

```
public class Singleton {
    // It must be static and final to prevent later modification
    private static final Singleton INSTANCE = new Singleton();
    /** The constructor must be private to prevent external instantiation */
    private Singleton(){}
    /** The public static method allowing to get the instance */
    public static Singleton getInstance() {
        return INSTANCE;
    }
} 
```

这是如何正确地懒惰地创建你的单例：

```
public class Singleton {
    // The constructor must be private to prevent external instantiation
    private Singleton(){}
    /** The public static method allowing to get the instance */
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
    /**
     * The static inner class responsible for creating your instance only on demand,
     * because the static fields of a class are only initialized when the class
     * is explicitly called and a class initialization is synchronized such that only
     * one thread can perform it, this rule is also applicable to inner static class
     * So here INSTANCE will be created only when SingletonHolder.INSTANCE
     * will be called
     */
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
} 
```

* * *

## 回答 #19

> 赞同：3
> 
> 时间：2011-08-02T20:41:52.710

如果您需要延迟加载类的实例变量，则需要仔细[检查习语。](http://en.wikipedia.org/wiki/Double-checked_locking)如果您需要延迟加载静态变量或单例，则需要[按需初始化持有者](http://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom)习语。

此外，如果单例需要可序列化，则所有其他字段都需要是瞬态的，并且需要实现 readResolve() 方法以保持单例对象不变。否则，每次反序列化对象时，都会创建一个新的对象实例。readResolve() 所做的是替换 readObject() 读取的新对象，这会强制该新对象被垃圾收集，因为没有变量引用它。

```
public static final INSTANCE == ....
private Object readResolve() {
  return INSTANCE; // Original singleton instance.
} 
```

* * *

## 回答 #20

> 赞同：3
> 
> 时间：2015-08-29T12:42:30.080

制作单例对象的各种方法：

1.  根据[Joshua Bloch](https://en.wikipedia.org/wiki/Joshua_Bloch) - Enum 将是最好的。

2.  您也可以使用双重检查锁定。

3.  甚至可以使用内部静态类。

* * *

## 回答 #21

> 赞同：3
> 
> 时间：2015-10-02T11:30:21.823

**枚举单例**

实现线程安全的单例的最简单方法是使用 Enum：

```
public enum SingletonEnum {
  INSTANCE;
  public void doSomething(){
    System.out.println("This is a singleton");
  }
} 
```

自从在 Java 1.5 中引入 Enum 以来，此代码就可以工作

**双重检查锁定**

如果你想编写一个在多线程环境中工作的“经典”单例（从 Java 1.5 开始），你应该使用这个。

```
public class Singleton {

  private static volatile Singleton instance = null;

  private Singleton() {
  }

  public static Singleton getInstance() {
    if (instance == null) {
      synchronized (Singleton.class){
        if (instance == null) {
          instance = new Singleton();
        }
      }
    }
    return instance;
  }
} 
```

这在 1.5 之前不是线程安全的，因为 volatile 关键字的实现不同。

**早期加载单例（甚至在 Java 1.5 之前也可以使用）**

此实现在加载类时实例化单例并提供线程安全。

```
public class Singleton {

  private static final Singleton instance = new Singleton();

  private Singleton() {
  }

  public static Singleton getInstance() {
    return instance;
  }

  public void doSomething(){
    System.out.println("This is a singleton");
  }

} 
```

* * *

## 回答 #22

> 赞同：2
> 
> 时间：2013-05-22T18:51:33.313

对于 JSE 5.0 及更高版本，采用 Enum 方法。否则，使用静态单例持有者方法（（Bill Pugh 描述的延迟加载方法）。后一种解决方案也是线程安全的，不需要特殊的语言结构（即 volatile 或 synchronized）。

* * *

## 回答 #23

> 赞同：2
> 
> 时间：2016-08-14T12:08:22.677

另一个经常用来反对单例的论点是它们的可测试性问题。单例不容易用于测试目的。如果这是一个问题，我想进行以下轻微修改：

```
public class SingletonImpl {

    private static SingletonImpl instance;

    public static SingletonImpl getInstance() {
        if (instance == null) {
            instance = new SingletonImpl();
        }
        return instance;
    }

    public static void setInstance(SingletonImpl impl) {
        instance = impl;
    }

    public void a() {
        System.out.println("Default Method");
    }
} 
```

添加的`setInstance`方法允许在测试期间设置单例类的模型实现：

```
public class SingletonMock extends SingletonImpl {

    @Override
    public void a() {
        System.out.println("Mock Method");
    }

} 
```

这也适用于早期初始化方法：

```
public class SingletonImpl {

    private static final SingletonImpl instance = new SingletonImpl();

    private static SingletonImpl alt;

    public static void setInstance(SingletonImpl inst) {
        alt = inst;
    }

    public static SingletonImpl getInstance() {
        if (alt != null) {
            return alt;
        }
        return instance;
    }

    public void a() {
        System.out.println("Default Method");
    }
}

public class SingletonMock extends SingletonImpl {

    @Override
    public void a() {
        System.out.println("Mock Method");
    }

} 
```

这也有将此功能暴露给普通应用程序的缺点。处理该代码的其他开发人员可能会尝试使用“setInstance”方法来更改特定功能，从而更改整个应用程序行为，因此该方法至少应在其 javadoc 中包含一个好的警告。

尽管如此，对于模型测试（需要时）的可能性，这种代码公开可能是可以接受的代价。

* * *

## 回答 #24

> 赞同：1
> 
> 时间：2013-10-24T09:39:01.667

最简单的单例类：

```
public class Singleton {
  private static Singleton singleInstance = new Singleton();
  private Singleton() {}
  public static Singleton getSingleInstance() {
    return singleInstance;
  }
} 
```

* * *

## 回答 #25

> 赞同：0
> 
> 时间：2015-01-06T07:22:59.043

我仍然认为在 Java 1.5 之后，枚举是可用的最佳单例实现，因为它还确保即使在多线程环境中也只创建一个实例。

```
public enum Singleton {
    INSTANCE;
} 
```

你完成了！

* * *

## 回答 #26

> 赞同：0
> 
> 时间：2015-08-21T00:43:39.307

看看这个帖子。

[Java核心库中的GoF设计模式示例](https://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns-in-javas-core-libraries)

从最佳答案的“单身”部分，

> ### 单例（可通过创建方法识别，每次都返回相同的实例（通常是其自身））
> 
> *   java.lang.Runtime#getRuntime()
> *   java.awt.Desktop#getDesktop()
> *   java.lang.System#getSecurityManager()

您还可以从 Java 原生类本身学习 Singleton 的示例。

* * *

## 回答 #27

> 赞同：0
> 
> 时间：2018-09-10T21:05:02.180

我见过的最好的单例模式使用供应商接口。

*   它是通用且可重复使用的
*   它支持延迟初始化
*   它仅在初始化之前同步，然后将阻塞供应商替换为非阻塞供应商。

见下文：

```
public class Singleton<T> implements Supplier<T> {

    private boolean initialized;
    private Supplier<T> singletonSupplier;

    public Singleton(T singletonValue) {
        this.singletonSupplier = () -> singletonValue;
    }

    public Singleton(Supplier<T> supplier) {
        this.singletonSupplier = () -> {
            // The initial supplier is temporary; it will be replaced after initialization
            synchronized (supplier) {
                if (!initialized) {
                    T singletonValue = supplier.get();
                    // Now that the singleton value has been initialized,
                    // replace the blocking supplier with a non-blocking supplier
                    singletonSupplier = () -> singletonValue;
                    initialized = true;
                }
                return singletonSupplier.get();
            }
        };
    }

    @Override
    public T get() {
        return singletonSupplier.get();
    }
} 
```

* * *

## 回答 #28

> 赞同：-3
> 
> 时间：2008-09-16T17:38:34.203

有时一个简单的“ **`static Foo foo = new Foo();`**”是不够的。想想你想做的一些基本的数据插入。

另一方面，您必须同步任何实例化单例变量的方法。同步本身也不错，但它可能导致性能问题或锁定（在非常罕见的情况下使用此示例。解决方案是

```
public class Singleton {

    private static Singleton instance = null;

    static {
          instance = new Singleton();
          // do some of your instantiation stuff here
    }

    private Singleton() {
          if(instance!=null) {
                  throw new ErrorYouWant("Singleton double-instantiation, should never happen!");
          }
    }

    public static getSingleton() {
          return instance;
    }

} 
```

现在会发生什么？该类是通过类加载器加载的。在从字节数组解释类之后，VM 立即执行**静态 { }** - 块。这就是全部秘密：静态块只被调用一次，即给定包的给定类（名称）被这个类加载器加载的时间。

* * *

## 回答 #29

> 赞同：-5
> 
> 时间：2013-11-08T00:36:40.580

```
public class Singleton {

    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {
        if (INSTANCE != null)
            throw new IllegalStateException(“Already instantiated...”);
        }

    public synchronized static Singleton getInstance() {
        return INSTANCE;
    }

} 
```

由于我们在 getInstance 之前添加了 Synchronized 关键字，因此我们避免了两个线程同时调用 getInstance 的情况下的竞争条件。

# sql-server - 任务计划程序问题启动 MSSQLSERVER

> ID：70694
> 
> 赞同：1
> 
> 时间：2008-09-16T09:24:39.320
> 
> 标签：sql-server, sql-server-2005, scheduled-tasks

我正在尝试创建一个任务计划程序任务来每天早上启动我的 SQL Server 2005 实例，因为每晚都会停止它。这是一个临时解决方案，直到我可以诊断出停机。

我创建了一个任务以在我的管理员用户下运行，并使用参数*/c net start mssqlserver*启动程序*cmd*。当我在我的管理员用户下的控制台中手动运行命令时，它会运行，但是当我尝试手动执行任务时，它会记录以下消息，并且服务仍然停止：

 **操作“C:\Windows\system32\cmd.EXE”，返回码为 2*。

有什么建议么？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T10:06:51.793

使用 NET 命令：

要启动服务，请键入：net startservice

要停止服务，请输入：net stopservice

要暂停服务，请输入：net pauseservice

要恢复服务，请输入：net continueservice

有关其他详细信息，请参阅此 Microsoft 文章： [Microsoft 文章](http://technet.microsoft.com/en-us/library/cc736564.aspx#BKMK_cmd)

此外，我会查看 Windows 事件日志（应用程序和系统）以了解有关 SQLServer 首先停止的原因的详细信息。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T13:33:22.157

我建议打开服务 MMC 管理单元（只需运行 services.msc），查找服务并修改服务属性以在服务失败时自动重新启动。

1.  打开服务 MMC 管理单元（运行 services.msc）
2.  找到服务。如果您安装了 SQL Server 2005 的默认实例，即“SQL Server (MSSQLSERVER)”。如果您安装了命名实例，则名称将在括号中。
3.  右键单击服务并选择“属性”。
4.  切换到“恢复”选项卡。
5.  根据需要设置第一次、第二次和后续失败的选项。
6.  单击“确定”。

John Dyer 在 Windows 事件日志中查找有关 SQL Server 停止原因的详细信息也是正确的（运行 eventvwr.exe）。

# coding-style - 如何写一个 linter？

> ID：70705
> 
> 赞同：24
> 
> 时间：2008-09-16T09:26:08.273
> 
> 标签：coding-style, verilog, syntax-checking

在我的日常工作中，我和团队中的其他人用 Verilog-AMS 编写了很多硬件模型，这是一种主要由商业供应商和一些开源模拟器项目支持的语言。让相互支持代码更有帮助的一件事是 LINTER，它可以检查我们的代码是否存在常见问题，并协助执行共享代码格式样式。我当然希望能够添加自己的规则，并且在我证明它们对自己有用之后，将它们推广给团队的其他成员。我不介意做必须完成的工作，但当然也希望利用其他现有项目的工作。

拥有 yacc 或 bison 格式的允许语言语法是否可以帮助我？还是我应该将每个语言语句吸进一个 perl 字符串，然后使用模式匹配来查找我不喜欢的东西？

（大多数语法和编译错误很容易被商业工具捕获。但我们有一些自己的扩展。）

* * *

## 回答 #1

> 赞同：19
> 
> 时间：2008-09-19T05:50:49.373

lex/flex 和 yacc/bison 提供了易于使用、易于理解的词法分析器和解析器生成器，我真的建议您这样做，而不是在例如 Perl 中按程序进行。正则表达式是一种强大的东西，可以用来分割具有相对但不是完全固定结构的字符串。使用任何真正的编程语言，您的状态机的大小将变得无法使用 Real Lexer/Parser (tm) 之外的任何东西进行管理。想象一下，仅使用正则表达式和过程代码来处理 Verilog AMS 等允许的关键字、标识符、运算符、无关括号、无关分号和注释的所有可能交错。

不可否认，那里有相当长的学习曲线，但是编写一个可用于 flex 和 bison 的语法，并在来自 bison 的语法树上做一些有用的事情，将比编写一个更好地利用你的时间大量特殊情况的字符串处理代码，首先使用语法树更自然地处理。此外，您以这种方式编写它所学到的东西将真正拓宽您的技能组合，而编写一堆骇人听闻的 Perl 代码则不会，因此，如果您有能力，我强烈推荐它；-)

此外，如果您很懒惰，请查看为 Verilog 和 VHDL 进行语法突出显示和基本重构的 Eclipse 插件。它们处于令人难以置信的原始状态，我上次检查过，但它们可能有一些你正在寻找的代码，或者至少有一段基线代码可供查看，以便更好地了解你自己滚动的方法。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-11-16T21:23:48.810

我写了几个verilog解析器，如果你最喜欢的编程语言是C/C++/Java，我会推荐PCCTS/ANTLR。您可以从[PCCTS/ANTLR Verilog 语法](http://www.antlr.org/grammar/verilog/verilog.g)开始。我最喜欢的解析器生成器是基于 Common Lisp的[Zebu 。](http://www.cliki.net/Zebu)

当然，最重要的工作是指定所有的 linting 规则。使用某种语言来指定 linting 规则也是有意义的。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2009-06-15T18:20:35.013

不要低估进入 linter 的工作量。解析是很容易的部分，因为您有工具（bison、flex、ANTLR/PCCTS）来自动化大部分内容。

但是一旦你有了解析，然后呢？您必须为设计构建语义树。根据输入的复杂程度，您必须详细说明 Verilog-AMS 设计（即解析参数、展开生成等。如果您使用这些功能）。只有这样，您才能尝试执行规则。

在编写 linter 之前，我会认真考虑其他可能的解决方案，除非用户数量和潜在的时间节省由此证明开发时间是合理的。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T09:29:20.980

在试图找到我的答案时，我在[ANTLR](http://www.ibm.com/developerworks/edu/au-dw-au-parsingwithantlr-i.html)上找到了这个- 可能有用

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T09:30:15.563

如果您完全使用 Java（因此使用 IDEA），则可能会使用IDE 的[自定义语言扩展](http://www.jetbrains.com/idea/plugins/developing_custom_language_plugins.html)

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T09:30:17.467

`yacc`/`bison`绝对可以帮助您，因为良好的 linting 需要解析程序。正则表达式（至少是真正的正则表达式）可能涵盖琐碎的情况，但是很容易编写正则表达式不匹配但仍然是糟糕风格的代码。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T10:14:11.510

ANTLR 看起来是更常见的（好吧*，我*之前听说过）YACC/BISON 方法的替代路径，事实证明它也通常使用 LEX/FLEX 作为前端。

快速阅读 FLEX 手册页让我觉得它可能是那种正则表达式类型想法的框架。

好的..我会让这个炖久一点，然后看看我能多快地在其中一个或另一个中构建一个原型解析器。

再长一点

# oracle - Oracle 客户端从 9 升级到 10

> ID：70721
> 
> 赞同：0
> 
> 时间：2008-09-16T09:30:02.040
> 
> 标签：oracle

上周五我工作的地方，升级了一个 oracle 客户端，我们的 IIS 服务器从版本 9 到版本 10。现在它在版本 10 上，我们看到很多连接正在打开到数据库。它打开了如此多的连接，以至于我们无法使用 PlSQL 开发人员或 Toad 等工具登录数据库。当 Oracle 客户端版本 9 时，我们从来没有遇到过这样的问题。由于这个特定盒子上存在的客户端数量，我认为不可能恢复到 Oracle 9 客户端。有没有人知道这个问题或知道任何可能的解决方法？

任何帮助是极大的赞赏

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T11:48:36.277

您使用的是哪个连接库？OO4O、ODP、其他？

我在这里根据旧问题的记忆工作，所以细节有点模糊。使用 OO4O 有两种不同的方式来初始化库。一个尝试重用连接比另一个更多。

在 ODP 中，默认使用连接池。有时这会导致额外的连接，以防再次需要它们。池连接存在一些问题，导致我将其关闭。（如果在死连接上调用 PL/SQL 过程可能会挂起）

如果您获得更多信息，我会尽力澄清

让我们知道您的发现并祝您好运

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-17T08:37:05.120

非常感谢您的回复，这对我们非常有用。我们将我们的问题发送给 Oracle 并得到了以下回复

============ 这是注释中讨论的一个已知问题：417092.1 Oracle Objects for OLE (OO4O) 使数据库连接保持打开状态

您的问题：“10g 客户端接口是否允许 ASP 代码/类功能与 9i 客户端相同？”

此问题的解决方法是执行循环以删除所有参数。例如 -

for i = 1 to OraDatabase.Parameters.Count OraDatabase.Parameters.Remove(0) next

错误 5918934 如果未删除 OraParameters，OO4O 会留下会话已针对此行为记录，并且由于解决内存问题所需的体系结构更改，已被视为“无法修复”。

我们确实在我们的代码中实现了一个循环来删除参数，但是再看一遍，看起来它并没有删除所有参数。我们目前正在对此进行调查。

一旦我们确定了解决方案，我会回信给这篇文章

达米安

# java - 打包Tomcat

> ID：70724
> 
> 赞同：1
> 
> 时间：2008-09-16T09:30:18.200
> 
> 标签：java, web-applications, tomcat

在我的工作中，我们必须在各种环境中部署应用程序。这是一个标准的 WAR 文件，需要进行一些配置，部署在 Tomcat 6 上。

有什么方法可以用 Tomcat 创建一个“部署包”，以便您只需提取它并设置 Tomcat 以及您的应用程序？我不确定使用 Tomcat 文件夹创建 .zip 文件是否可行！它肯定不会安装该服务。

欢迎提出建议！

我应该注意到 - 目前 - 所有应用程序都部署在 Windows 服务器上。

谢谢，菲尔

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2008-09-16T10:11:30.893

一种选择是使用嵌入式 Winstone servlet 容器而不是 Tomcat，如下所述： [http ://winstone.sourceforge.net/#embedding](http://winstone.sourceforge.net/#embedding)

然后，您将拥有运行应用程序的可执行 jar 文件。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T11:04:47.223

您可能会修改 Tomcat 本身使用的安装程序。

简单地压缩目录是一个有效的解决方案，但正如您所注意到的，它不会安装该服务。

我可能会 (a) 压缩目录 (b) 使用开源服务注册表程序之一来安装服务器，也许 (c) 使用 NSIS 构建安装程序。

根据安装环境，您的安装程序可能还需要向用户询问服务器端口，因为您的应用程序可能无法使用默认的 HTTP 端口。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T14:22:11.120

我们使用[Ant Installer](http://antinstaller.sourceforge.net/)来部署我们的应用程序、应用服务器并将其安装为服务。我们在安装程序中嵌入[Java Service Wrapper](http://wrapper.tanukisoftware.org/doc/english/integrate.html)来安装 Windows 服务。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T14:26:17.350

它是商业的，但[install4j](http://www.ej-technologies.com/products/install4j/overview.html)会为你做这件事，包括安装服务。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2009-01-18T13:46:33.057

您可以使用[BitRock 跨平台安装程序](http://bitrock.com)。您可以查看[BitNami](http://bitnami.org) ，了解使用 BitRock 打包的许多 Java 应用程序，例如[Alfresco](http://bitnami.org/stack/alfresco)、[JRoller](http://bitnami.org/stack/roller)和[Liferay 。](http://bitnami.org/stack/liferay)BitNami 堆栈是完全免费的，尽管 Bitrock 本身是一个商业工具（我们有开源项目的免费许可证）

# search-engine - 您如何防止搜索引擎将文字广告编入索引？

> ID：70728
> 
> 赞同：1
> 
> 时间：2008-09-16T09:31:13.860
> 
> 标签：search-engine, ads

有什么方法可以阻止搜索引擎将文字广告编入索引？

这些基本上是程式化的链接。

我曾考虑使用文本生成图像或使用 javascript 将它们写入 DIV。

什么是最好和最被接受的方式？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-16T09:36:29.323

一种方法是使用 iFrame 来展示广告，并在其中使用元标记告诉 Google 不要将它们编入索引。

另一种方法是使用 JavaScript 打印广告，这样当浏览器不支持 JavaScript（Google Bot 不执行 JavaScript）时，它们就不会出现。

很多广告系统都使用 JavaScript，但我真的不知道这是否是最好的方法 - 但它是一种方法。

# java - 实现几个签名冲突的接口

> ID：70732
> 
> 赞同：3
> 
> 时间：2008-09-16T09:32:02.597
> 
> 标签：java, collections

最后，我尝试在 Java 中实现混合结构，如下所示：

```
public class MapOfSet<K, V extends HasKey<K>> implements Set<V>, Map<K, Set<V>> 
```

其中 HasKey 是如下接口：

```
public interface HasKey<K> {
    public K getKey();
} 
```

不幸的是，Set 接口的方法签名和 Java 中的 Map 接口之间存在一些冲突。我最终选择只实现 Set 接口并添加 Map 方法而不实现该接口。

你看到更好的解决方案了吗？

针对第一条评论，这是我的目标：

> 具有集合结构，并且能够有效地访问该集合的值的子集，对应于给定的键值。一开始我实例化了一个地图和一个集合，但我试图将这两个结构结合起来以优化性能。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-16T09:39:55.243

你想达到什么目的？已经通过它的 [keySet()]( [http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#keySet())](http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#keySet()))方法`Map`公开了它的密钥。如果你想要一个可靠的迭代顺序，有[LinkedHashMap](http://java.sun.com/j2se/1.5.0/docs/api/java/util/LinkedHashMap.html)和[TreeMap](http://java.sun.com/j2se/1.5.0/docs/api/java/util/TreeMap.html)。`Set`

更新：如果你想确保一个值只被插入一次，你可以扩展我上面提到的类之一来创建类似 a 的东西，`SingleEntryMap`并覆盖 的实现`put(K key, V value)`来进行唯一性检查并在值已经被抛出时抛出异常被插入。

更新：这样的事情会起作用吗？（我没有打开我的编辑器，所以这可能无法编译）

```
public final class KeyedSets<K, V> implements Map<K,Set<V>> {
    private final Map<K, Set<V>> internalMap = new TreeMap<K, Set<V>>;
    // delegate methods go here
    public Set<V> getSortedSuperset() {
        final Set<V> superset = new TreeSet<V>();
        for (final Map.Entry<K, V> entry : internalMap.entrySet()) {
            superset.addAll(entry.getValue());
        }
        return superset;
    }
} 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T10:16:11.677

也许您可以添加更多信息，您真正想要哪些操作。我猜你想创建一个通过键自动对元素进行分组的集合，对吧？问题是您希望能够进行哪些操作？如何将元素添加到 Set 中？可以通过从分组视图中删除元素来删除它们吗？我的建议是这样的界面：

```
public interface GroupedSet<K, V extends HasKey<K>> extends Set<V>{
    Set<V> havingKey(K k);
} 
```

如果您希望能够使用 Set as map 您可以添加另一种方法

```
Map<K,Set<V>> asMap(); 
```

这避免了使用多个接口继承和由此产生的问题。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T09:37:59.400

我会说有时用作 Map 有时用作 Set 的东西应该实现 Map，因为它可以被视为一组键或值以及键和值之间的映射。这就是 Map.containsKey() 和 Map.containsValue() 方法的用途。

# c# - 如何在 PL/SQL 中列出 Oracle Apps 配置文件选项？

> ID：70742
> 
> 赞同：0
> 
> 时间：2008-09-16T09:34:03.870
> 
> 标签：c#, oracle, configuration

我管理多个 Oracle Apps 环境，目前通过在每个环境中加载表单并手动检查每个变量来检查许多环境中的配置文件选项，这需要大量时间。

是否有一段代码将列出配置文件选项以及它们适用于什么级别和对象？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T10:48:30.400

您将要查询`APPLSYS.FND_PROFILE_OPTIONS`和`FND_PROFILE_OPTION_VALUES`。有关可以从中获取 SQL 的综合脚本，请查看此处： [http ://tipsnscripts.com/?p=16](http://tipsnscripts.com/?p=16)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2011-08-31T18:32:53.980

我希望这将帮助您在尝试跟踪用户的更改时获得更详细的信息。

```
SELECT FP.LEVEL_ID "Level ID", 
     FPO.PROFILE_OPTION_NAME "PROFILE NAME",
     FP.LEVEL_VALUE "LEVEL VALUE",
     DECODE (FP.LEVEL_ID,
             10001,
             'SITE',
             10002,
             'APPLICATION',
             10003,
             'RESPONSIBILITY',
             10004,
             'USER')
        "LEVEL",
     DECODE (FP.LEVEL_ID,
             10001,
             'SITE',
             10002,
             APPLICATION_SHORT_NAME,
             10003,
             RESPONSIBILITY_NAME,
             10004,
             FL.USER_NAME)
        LVALUE,
     FPO.USER_PROFILE_OPTION_NAME "PROFILE DESCRIPTION",
     FP.PROFILE_OPTION_VALUE "PROFILE VALUE",
     FU.USER_NAME "USER NAME",
     FU.LAST_UPDATE_DATE
FROM FND_PROFILE_OPTIONS_VL FPO,
     FND_PROFILE_OPTION_VALUES FP,
     FND_RESPONSIBILITY_TL,
     FND_APPLICATION FA,
     FND_USER FL,
     FND_USER FU
WHERE FPO.APPLICATION_ID = FP.APPLICATION_ID
     AND FPO.PROFILE_OPTION_ID = FP.PROFILE_OPTION_ID
     AND FP.LEVEL_VALUE = FL.USER_ID(+)
     AND FP.LEVEL_VALUE = RESPONSIBILITY_ID(+)
     AND FP.LEVEL_VALUE = FA.APPLICATION_ID(+)
     AND FU.USER_ID = FP.LAST_UPDATED_BY
     AND FP.PROFILE_OPTION_VALUE IS NOT NULL
     AND (UPPER (FP.Profile_Option_Value) LIKE UPPER ('%&1%')
          OR UPPER (FP.Profile_Option_Value) LIKE UPPER ('%&2%')) 
```

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T11:30:02.233

有了要获取哪些表的知识（感谢 Sten）和一些明智的编辑，我想出了一个满足我需求的查询：

```
SELECT SUBSTR(e.profile_option_name,1,30) PROFILE,
    DECODE(a.level_id,10001,'Site',10002,'Application',10003,'Responsibility',10004,'User') L,
    DECODE(a.level_id,10001,'Site',10002,c.application_short_name,10003,b.responsibility_name,10004,d.user_name) LValue,
    NVL(a.profile_option_value,'Is Null') Value,
    SUBSTR(a.last_update_date,1,25) UPDATED_DATE
FROM fnd_profile_option_values a
INNER JOIN fnd_profile_options e ON a.profile_option_id = e.profile_option_id 
LEFT OUTER JOIN fnd_responsibility_tl b ON a.level_value = b.responsibility_id
LEFT OUTER JOIN fnd_application c ON a.level_value = c.application_id
LEFT OUTER JOIN fnd_user d ON a.level_value = d.user_id
WHERE e.profile_option_name LIKE '%&1%'
ORDER BY profile_option_name; 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2011-06-23T13:26:42.463

```
SELECT SUBSTR(e.profile_option_name,1,30) PROFILE,
    DECODE(a.level_id,10001,'Site',10002,'Application',10003,'Responsibility',10004,'User') L,
    DECODE(a.level_id,10001,'Site',10002,c.application_short_name,10003,b.responsibility_name,10004,d.user_name) LValue,
    NVL(a.profile_option_value,'Is Null') Value,
    SUBSTR(a.last_update_date,1,25) UPDATED_DATE
FROM fnd_profile_option_values a
INNER JOIN fnd_profile_options e ON a.profile_option_id = e.profile_option_id 
LEFT OUTER JOIN fnd_responsibility_tl b ON a.level_value = b.responsibility_id
LEFT OUTER JOIN fnd_application c ON a.level_value = c.application_id
LEFT OUTER JOIN fnd_user d ON a.level_value = d.user_id
WHERE e.profile_option_name LIKE '%&1%'
ORDER BY profile_option_name; 
```

# c - C 中的开源 radix/mtrie 实现？

> ID：70753
> 
> 赞同：2
> 
> 时间：2008-09-16T09:36:28.513
> 
> 标签：c, algorithm, data-structures

我打算使用**RADIX / MTRIE**作为路由实现的首选数据结构。

是否有一个不错的开源实现（除了freebsd-net）可以用于我的目的，还是我需要自己编写一个？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T10:32:48.003

在 GNU 通用公共许可证版本 2 或（由您选择）任何更高版本下提供了一个基数树实现：

[http://www.gelato.unsw.edu.au/lxr/source/lib/radix-tree.c](http://www.gelato.unsw.edu.au/lxr/source/lib/radix-tree.c)

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-16T10:26:57.923

如果您找不到其他任何东西，您可以随时[**从 Google Code 移植这个 java 版本**。](http://code.google.com/p/radixtree/)

# .net - 您是否在 Windows 窗体中使用归纳用户界面模式？

> ID：70755
> 
> 赞同：4
> 
> 时间：2008-09-16T09:36:33.067
> 
> 标签：.net, winforms, user-interface, usability

如果你这样做了，你能提供一些关于实现的背景信息以及实现这个模式的原因吗？

这些文章中更详细地描述了该模式：

*   [Microsoft 归纳式用户界面指南](http://msdn.microsoft.com/en-us/library/ms997506.aspx)
*   [Windows 窗体中的 IUI 和 Web 样式导航，第 1](http://msdn.microsoft.com/en-us/library/ms951103.aspx)部分和[第 2 部分](http://msdn.microsoft.com/en-us/library/ms951278.aspx)

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T09:50:31.973

是的 - 我们遇到了一个问题，即我们软件的许多管理员发现它太难使用了。为了解决这个问题，我们使用 Microsoft 的 WinForms IUI 框架为我们的软件构建了一个新的配置和管理工具。

用户反馈非常积极，特别是所有内容都是任务驱动的——即我们主页上的链接包括“创建新用户”、“创建新部门”之类的内容——而不是用户必须通过点击来发现如何执行此操作一系列菜单。由于归纳界面更类似于网络浏览器（超文本链接、后退/前进按钮），因此新用户似乎更容易学习。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-11-14T08:57:35.230

我建议使用 IUI 接口，只要您不是每天都使用软件...

每当您每月仅使用一次应用程序时，指导您完成...

我总是手动实现 IUI，或者至少使用了 Wizard-User-Control。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-11-14T09:22:27.317

你应该小心不要制作一个过于简单的系统。专家用户（银行家、保险公司、CRM 等）应该在屏幕上显示尽可能多的信息。如果您在工作日期间多次使用该表格，则发现通过缓慢验证的表格进行处理会很烦人。

# c# - 优先级、关联性和顺序之间有什么区别？

> ID：70756
> 
> 赞同：5
> 
> 时间：2008-09-16T09:37:23.660
> 
> 标签：c#, arithmetic-expressions

这种混淆的出现是因为大多数人都被训练来根据[PEDMAS 或 BODMAS 规则](http://en.wikipedia.org/wiki/PEMDAS#Mnemonics)评估算术表达式，而像 C# 这样的编程语言中的算术表达式不能以相同的方式工作。

你对此有何看法？

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-09-16T10:01:02.353

*优先级*规则指定运算符的优先级（首先评估哪些运算符，例如乘法的优先级高于加法，PEMDAS）。

*关联性*规则告诉如何对具有相同优先级的运算符进行分组。算术运算符是左结合的，但赋值是右结合的（例如，a = b = c 将被计算为 b = c，a = b）。

该*顺序*是应用*优先级*和*关联性*规则的结果，并说明如何评估表达式 - 首先评估哪些运算符，稍后评估哪些，最后评估哪些。可以使用大括号更改实际顺序*（*大括号也是具有最高优先级的运算符）。

编程语言中运算符的*优先级*和*关联*性可以在其语言手册或规范中找到。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-16T09:55:35.253

我不确定是否真的有区别。传统的 BODMAS（括号、命令、除法、乘法、加法、减法）或 PEDMAS（括号、指数、除法、乘法、加法、减法）只是所有可能操作的子集，并表示这些操作应该应用的顺序. 我不知道有什么语言违反了 BODMAS/PEDMAS 规则，但每种语言通常都会添加各种其他运算符 - 例如 ++、--、= 等。

我总是将运算符优先级列表放在手边，以防出现混淆。然而，当有疑问时，通常值得使用一些括号来明确含义。请注意，括号没有最高优先级 - 请参阅[http://msdn.microsoft.com/en-us/library/126fe14k.aspx](http://msdn.microsoft.com/en-us/library/126fe14k.aspx)以获取 C++ 中的示例。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-16T09:57:03.767

优先级和关联性都指定了应如何以及以何种顺序将术语拆分为子术语。换句话说，如果没有明确指定，它是否指定了隐式设置括号的规则。

如果您有一个没有括号的术语，则从优先级最低的运算符开始并将其括在括号中。

例如：

优先级：

1.  .
2.  ！
3.  *,/
4.  +,-
5.  ==
6.  &&

期限：

```
!person.isMarried && person.age == 25 + 2 * 5 
```

会这样分组：

1.  !(person.isMarried) && (person.age) == 25 + 2 * 5
2.  (!(person.isMarried)) && (person.age) == 25 + 2 * 5
3.  (!(person.isMarried)) && (person.age) == 25 + (2 * 5)
4.  (!(person.isMarried)) && (person.age) == (25 + (2 * 5))
5.  (!(person.isMarried)) && ((person.age) == (25 + (2 * 5)))
6.  ((!(person.isMarried)) && ((person.age) == (25 + (2 * 5))))

一个非常常见的规则是 * 和 / 在 + 和 - 之前的优先级。

关联性指定相同优先级的运算符在哪个方向上分组。大多数运算符是从左到右的。一元前缀运算符是从右到左的。

例子：

```
1 + 2 + 3 + 4 
```

分组如下：

1.  (1 + 2) + 3 + 4
2.  ((1 + 2) + 3) + 4
3.  ((((1 + 2) + 3) + 4)

尽管

！！+1

被分组为

1.  !!(+1)
2.  !(!(+1))
3.  (!(!(+1)))

到目前为止，一切都符合 BODMAS/PEDMAS 规则，您经历过哪些差异？

# asp.net - 有谁知道在 asp.net 列表视图中隐藏列的方法？

> ID：70758
> 
> 赞同：12
> 
> 时间：2008-09-16T09:37:27.917
> 
> 标签：asp.net, listview

我知道您可以在 ItemTemplate 中放置 <% if %> 语句来隐藏控件，但该列仍然存在。您不能将 <% %> 语句放入声明列标题的 LayoutTemplate 中，因此会出现问题。有人知道更好的方法吗？

* * *

## 回答 #1

> 赞同：20
> 
> 时间：2008-09-16T19:56:15.747

这是我刚刚做的另一个解决方案，看到我了解您想要做什么：

**这是你的 ASCX / ASPX**

```
 <asp:ListView ID="ListView1" runat="server" DataSourceID="MyDataSource" ItemPlaceholderID="itemPlaceHolder" OnDataBound="ListView1_DataBound">
        <LayoutTemplate>
            <table border="1">
                <tr>
                    <td>Name</td>
                    <td>Age</td>
                    <td runat="server" id="tdIsSuperCool">IsSuperCool</td>
                </tr>
                <asp:PlaceHolder ID="itemPlaceHolder" runat="server" />
            </table>
        </LayoutTemplate>
        <ItemTemplate>
            <tr>
                <td><%# Eval("Name") %></td>
                <td><%# Eval("Age") %></td>
                <td runat="server" id="myCol" visible='<%# (bool)Eval("IsSuperCool") %>'>true</td>
            </tr>
        </ItemTemplate>
    </asp:ListView>
    <asp:ObjectDataSource 
        ID="MyDataSource" 
        runat="server" 
        DataObjectTypeName="BusinessLogicLayer.Thing" 
        SelectMethod="SelectThings"
        TypeName="BusinessLogicLayer.MyObjectDataSource" /> 
```

**这是后面的代码**

```
/// <summary>
/// Handles the DataBound event of the ListView1 control.
/// </summary>
/// <param name="sender">The source of the event.</param>
/// <param name="e">The <see cref="System.EventArgs"/> instance containing the event data.</param>
protected void ListView1_DataBound(object sender, EventArgs e)
{
    ListView1.FindControl("tdIsSuperCool").Visible = false;
} 
```

在数据绑定中做任何你想做的事情。因为该列现在在服务器上运行，并且您正在处理控件的 DataBound，所以当您执行 ListView1.FindControl("tdIsSuperCool") 时，您处于布局模板中，因此它的工作方式就像一个冠军。

放置您想要控制 td 可见性的任何业务逻辑，您就可以了。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-23T02:09:34.197

尝试使用面板，您可以打开/关闭它

```
 foreach (ListViewItem item in ListView1.Items)
 {
     ((Panel)item.FindControl("myPanel")).Visible= False;
 } 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T11:08:03.660

ListView 让您可以完全控制数据如何呈现给客户端。您指定布局模板，并提供一个占位符，该占位符将是每个项目的注入位置。

下面的输出会给你一个表格，每个项目都是一个新的 TR。

注意使用 runat='server' 和`visible ='<%# %>'`

```
<asp:ListView ID="ListView1" runat="server" DataSourceID="MyDataSource" ItemPlaceholderID="itemPlaceHolder">
    <LayoutTemplate>
        <table>
            <asp:PlaceHolder ID="itemPlaceHolder" runat="server" />
        </table>
    </LayoutTemplate>
    <ItemTemplate>
        <tr>
            <td runat="server" id="myCol" visible='<%# (bool)Eval("IsSuperCool") %>'>
                <%# Eval("SuperCoolIcon") %>
            </td>
            <td>
                <%# Eval("Name") %>
            </td>
            <td>
                <%# Eval("Age") %>
            </td>
        </tr>
    </ItemTemplate>
</asp:ListView> 
```

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2016-12-14T20:51:51.333

我知道这是一个非常古老的问题，但我实际上不得不这样做，并认为我找到了一个相当不错的方法来通过 jquery 和 css 做到这一点。

将以下内容添加到标题中：

```
<script type="text/javascript" src="Scripts/jquery-1.7.1.min.js" ></script>
  <style>
    .hide {
      display:none;
    }
    .show {
      display:block;
    }
  </style> 
```

对于要隐藏的所有列，将自定义属性添加到 td/th.

```
<th runat="server" data-prop='authcheck'  id="tdcommentsHeader"  >Comments</th> 
```

我建议使用自定义属性，因为长话短说，它可以用一块石头杀死一群鸟。您甚至不需要更改每列的值，就像我们基于 id 属性一样。

接下来，确保您有一个隐藏字段，告诉您是否要隐藏该列。这可以是 asp:HiddenField 或任何其他形式，只要它在表单上即可。

```
<asp:HiddenField runat="server" ID="IsAuthorized" Value="false" /> 
```

最后，在页面底部，执行：

```
 <script type="text/javascript">
          $(document).ready(function () {
            var isauth = $("[id='IsAuthorized']").val();
              if (isauth==="false") {
              $("[data-prop='authcheck']").addClass('hide');
              //$("[id*='tdcomments']").addClass('hide'); 
            }
          });
      </script> 
```

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T10:15:17.780

如果找不到更好的方法，您始终可以将列宽设置为 0（零）。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T10:25:36.337

列表视图实际上并没有“列”的概念，因为它只是为了成为一个列表。

我将假设您正在使用数据绑定将“某些东西”列表附加到 ListView。如果是这种情况，那么您将只有一个项目列表，而 LayoutTemplate 中的 html 将决定这些项目的显示方式。如果您正在谈论创建一个表格样式的列和行数组，那么 DataGrid 可能是一个更好的选择，因为它可以对特定列进行更多的编程控制。

您可能希望完全通过 CSS 创建表格布局，**如果**纯粹出于布局目的，这是一个令人钦佩的决定。但是，您专门隐藏一列的要求向我表明，表格更适合您的需要。将表格用于表格数据很好......恕我直言......

如果您确实需要使用 ListView，那么您可以随时尝试绑定数据中的某些内容，以确定是否应显示元素，例如：

```
style='display: <%#Eval("DisplayStyle") %>;' 
```

将此代码放在要控制的 html 元素中（在 LayoutTemplate 中）。然后在您绑定的对象中，您需要一个属性“DisplayStyle”，该属性设置为“block”或“none”。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2011-03-24T21:21:12.670

为了访问布局模板列标题文本，我在模板中为它们制作了标签，并在列表视图的预渲染中做了一个 findcontrol，然后如果列应该“关闭”，则将标签设为空白文本。这可能不符合您的意图，但对我来说，我仍然希望使用列空间，只是显示为空白。

您尝试使列表视图向后弯曲的越远，您就越希望使用网格来代替。

# licensing - 未经许可的材料的许可是什么？

> ID：70762
> 
> 赞同：5
> 
> 时间：2008-09-16T09:38:30.443
> 
> 标签：licensing

假设我在开放访问的某个地方（例如，在公共网络共享上）找到了一个“文本”。我没有办法联系到作者，我什至不知道作者是谁。

我可以合法地用这种“文本”做什么？

**更新：**我不打算发布那个“文本”，而是自己从中学习。

**更新：**所以，如果我看到匿名代码、文章等，我什至不应该打开它，否则我会将其内容复制到我的大脑中？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-16T09:51:17.807

IANAL：没有执照。原作者（无论是谁）保留版权和与之相关的所有权利，并且没有向任何人授予任何对其作品进行任何操作的明确许可。不过，请务必咨询精通版权的实际律师，因为似乎应该有一种方法可以在您的特定情况下使用该文本，并且（s）他可能知道那种方法是什么。

更新：版权主要与（重新）分发有关；如果您可以阅读它，您可以自由地从中学习，尽管[DMCA](http://en.wikipedia.org/wiki/Digital_Millennium_Copyright_Act)对您可以采取哪些步骤来阅读它设置了法律限制，例如，您不应该使用[DeCSS](http://en.wikipedia.org/wiki/DeCSS)来阅读字幕，因为那是“规避访问控制”。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T09:44:46.590

据我*所知*（没有任何法律培训）-如果您将文本或代码或您所拥有的内容列为“匿​​名”，那么您就可以了。

我相信通过将其列为匿名您表示您不知道它来自哪里，但您承认您没有将它作为原创作品创作。

从那延伸，您应该对能够证明他们是作者的实际作者持开放态度，并更改您的用法以反映他们的姓名/许可证/版权/其他任何内容。

您应该咨询知识产权律师以了解详细信息并更正我的理解。

# c - pthread_cond_wait 与信号量

> ID：70773
> 
> 赞同：48
> 
> 时间：2008-09-16T09:40:31.653
> 
> 标签：c, multithreading, semaphore

`pthread_cond_wait`使用或使用信号量的优点/缺点是什么？我正在等待这样的状态变化：

```
pthread_mutex_lock(&cam->video_lock);
while(cam->status == WAIT_DISPLAY) {
    pthread_cond_wait(&cam->video_cond, &cam->video_lock);
}
pthread_mutex_unlock(&cam->video_lock); 
```

使用正确初始化的信号量，我想我可以这样做：

```
while(cam->status == WAIT_DISPLAY) {
    sem_wait(&some_semaphore);
} 
```

每种方法的优缺点是什么？

* * *

## 回答 #1

> 赞同：65
> 
> 时间：2008-09-20T18:21:54.963

信号量完全适用于生产者-消费者模型，尽管它还有其他用途。您的程序逻辑负责确保根据等待次数发布正确数量的帖子。如果您发布信号量并且没有人在等待它，那么当他们等待时，他们会立即继续。如果您的问题可以用信号量的计数值来解释，那么使用信号量应该很容易解决。

条件变量在某些方面更加宽容。例如，您可以使用 cond_broadcast 唤醒所有服务员，而生产者不知道有多少服务员。如果你 cond_signal 一个没有人在等待它的 condvar，那么什么也不会发生。如果您不知道是否会有听众感兴趣，这很好。这也是为什么侦听器应始终在等待之前检查持有的互斥锁的状态 - 如果他们不这样做，那么他们可能会错过一个信号并且直到下一个信号才会醒来（可能永远不会）。

因此，条件变量适用于通知相关方状态已更改：您获取互斥锁、更改状态、发送信号（或广播）condvar 并释放互斥锁。如果这描述了您的问题，那么您就处于 condvar 领域。如果不同的听众对不同的状态感兴趣，你可以广播，他们会依次醒来，确定他们是否找到了他们想要的状态，如果没有，就再等。

用互斥锁和信号量尝试这种事情确实非常棘手。当您想要获取互斥体，检查某些状态，然后等待信号量进行更改时，问题就来了。除非您可以原子地释放互斥体并在信号量上等待（在 pthread 中您不能这样做），否则您最终会在持有互斥体的同时等待信号量。这会阻止互斥体，这意味着其他人无法接受它来进行您关心的更改。因此，您会很想以一种取决于您的特定要求的方式添加另一个互斥锁。也许另一个信号量。结果通常是带有有害竞争条件的错误代码。

条件变量避免了这个问题，因为调用 cond_wait 会自动释放互斥体，释放它以供其他人使用。在 cond_wait 返回之前重新获得互斥锁。

IIRC 可以仅使用信号量来实现一种 condvar，但是如果您要与 condvar 一起实现的互斥锁需要具有 trylock，那么这是一个严重的问题，并且定时等待已经结束。不建议。所以不要假设你可以用 condvar 做的任何事情都可以用信号量来完成。当然，互斥体可以具有信号量所缺乏的良好行为，主要是避免优先级反转。

* * *

## 回答 #2

> 赞同：20
> 
> 时间：2008-09-16T11:15:15.233

条件允许你做一些信号量不会做的事情。

例如，假设您有一些需要互斥体的代码，称为`m`. 然而，它需要等到其他线程完成他们的任务，所以它等待一个名为`s`. 现在任何需要的线程都`m`被阻止运行，即使该线程`m`正在等待`s`。这些情况可以使用条件来解决。当您等待条件时，当前持有的互斥锁被释放，因此其他线程可以获取互斥锁。回到我们的例子，假设`c`使用条件而不是`s`. 我们的线程现在获取`m`，然后有条件地等待`c`。这将释放`m`，以便其他线程可以继续。当`c`可用时，`m`被重新获取，我们的原始线程可以继续愉快地前进。

条件变量还允许您让*所有*等待条件变量的线程通过`pthread_cond_broadcast`. 此外，它还允许您执行*定时等待*，这样您就不会永远等待。

当然，有时您不需要条件变量，因此根据您的要求，其中一个可能更好。

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2009-01-12T09:11:45.853

第二个片段是活泼的，不要那样做。

其他答案对相对优点进行了很好的讨论；我将补充一点，这`pthread_cond_broadcast`是条件变量的明显优势。

除此之外，我更习惯于为此设置条件变量，因为它们是您在 Java 中使用的，即使它们可以帮助您在检查共享标志时避免竞争。

实际上，在第二个片段中，您没有任何锁来保护 cam->status 的读取，因此它是通过数据竞争访问的。在这个特定的示例中，大多数平台都会让您摆脱这种情况，但是根据 POSIX 和下一个 C/C++ 标准的内存模型，它具有未定义的语义。

事实上，如果另一个线程分配了一个新的 cam 结构并覆盖了 cam，那么真正的竞争条件是可能的；等待线程可能会看到“cam”指针的更新，而没有看到 cam->status 的初始化。实际上，在这种情况下和一般情况下，第二个片段正在自找麻烦。

[http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/](http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/)

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T10:10:46.403

在您的第二个片段中，您多次获得锁定，从未释放它。

通常，您正在等待的状态可以完全由信号量表示，然后您就可以使用它。锁结构的大小更小，它需要更少的原子操作来检查/设置/释放。

否则，如果状态很复杂，并且代码的不同部分在同一变量的不同条件下等待（例如，这里你想要 x<10；那里你想要 y>x），请使用 cond_wait。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2022-02-28T06:40:00.257

```
while(cam->status == WAIT_DISPLAY) {
    sem_wait(&some_semaphore);
} 
```

这是完全错误的。这很容易出现竞争条件。当线程在 sem_Wait 上阻塞时，条件 cam->status == WAIT_DISPLAY 可能无法在系统中保持良好状态，因为其他线程可能已对其进行了修改。因此，您的线程现在由于所有错误的原因而处于休眠状态。

# ruby - 我如何在 Rmagick 中快速做一些事情来测试它的工作

> ID：70779
> 
> 赞同：3
> 
> 时间：2008-09-16T09:41:07.613
> 
> 标签：ruby, rmagick

我需要能够快速转换图像（在 rails 控制器内），以便使用管理我们的应用程序的托管公司可以随时快速测试，以确保 rmagick 不仅安装成功，而且可以通过 rails stiack 调用，我可以用来执行此操作的最快的干净代码是什么？

* * *

## 回答 #1

> 赞同：14
> 
> 时间：2008-09-16T14:01:36.847

```
require 'RMagick'

image = Magick::Image.new(110, 30){ self.background_color = 'white' }
image.write('/tmp/test.jpg') 
```

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-16T11:56:34.947

我想这样做，以便我可以使用 Web 浏览器轻松访问它，因为我正在部署到托管服务器，而我没有 shell 访问权限（以提高安全性）。

所以这就是我所做的

```
class DiagnosticsController < ApplicationController
  require 'RMagick'

  def rmagick
    images_path = "public/images"
    file_name = "rmagick_generated_thumb.jpg"
    file_path = images_path + "/"+ file_name

    File.delete file_path if File.exists? file_path
    img = Magick::Image.read("lib/sample_images/magic.jpg").first
    thumb = img.scale(0.25)
    @path = file_name
    thumb.write file_path
  end
end #------ 
```

然后在 rmagick.html.erb

```
<%= image_tag @path %> 
```

现在我可以点击控制器，如果我看到图像，我知道 rmagic 已安装。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-16T10:12:16.477

我会登录到服务器并在脚本/控制台中试用您的代码。这仍将通过 rails 堆栈，但允许您快速检查您的代码是否按预期方式工作，以及 RMagick 和 ImageMagick 是否已正确安装，而无需部署任何东西。

当需要编写您的实际代码时，我建议将图像转换代码放在模型中，这样您就可以在控制器的上下文之外调用它。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T10:14:48.750

使用脚本/控制台，并在执行以下操作的模型或控制器中调用代码：

```
require 'RMagick'
include Magick
img = ImageList.new('myfile.jpg')
img.crop(0,0,10,10) # or whatever
img.write('mycroppedfile.jpg') 
```

# model-driven-development - 您如何看待模型驱动的软件开发？

> ID：70781
> 
> 赞同：9
> 
> 时间：2008-09-16T09:41:12.823
> 
> 标签：model-driven-development, mdsd

我真的很想听听您对 Java 和/或 .NET 的模型驱动软件开发的看法。

它节省时间吗？它提高了质量吗？

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-09-16T09:47:20.500

MDA 是一个有点重载的概念。有时这意味着将 UML 或其他类型的图表转换为可执行代码。我从来没有见过现在可用的工具能很好地解决这个问题。它通常会导致项目非常快速地获得结果，然后导致维护噩梦，因为可用的工具并不真正支持大型团队处理可视化图表，并且因为人们开始使用图表以及生成的代码。

我已经看到一些看起来很像域驱动设计的东西被称为 MDA，如果你的意思是我完全赞成 :-)

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2009-06-24T22:44:27.830

我在 IBM Rational Rhapsody for C++ 的项目中使用 MDSD。该模型非常接近 UML，因此我们没有真正的领域特定语言。但我仍然会声称使用 MDSD。根据我的经验，MDSD 有很多好处：

a) 使用 MDSD 有助于将 SW 架构提升到复杂的水平。你总是在一个非常抽象的层面上工作，考虑大局。牛仔编码软件通常缺乏良好的架构，因为开发人员被困在细节上。使用 MDSD，我看到了我工作中的一种趋势，即用足够大小的类、漂亮的模式或只是更好的代码来解决问题。

b) 使用 MDSD 的 SW 大图文档往往会更好。当然，有一些工具可以从您的代码中自动生成类图。但是这些图表包含 1000 个类，您看不到感兴趣的方面。使用 MDSD，您可以专门绘制系统的一个方面，并且同样的图也用于生成您的代码的一部分。

c) 建模有助于处理固有的系统复杂性。我想说，有些系统太复杂了，如果没有计算机辅助设计的支持就无法构建。没有大型软件工具的帮助，没有人会设计 CPU。使用 SW 帮助您编写更复杂的 SW。

d) 使用 MDSD 有助于遵守编码风格指南。没有比让代码由规则集生成更好的方法来获得一致的代码风格。

当然，MDSD 也有一些缺点： d) 如果你有一个模型，你希望每一行代码都来自那个模型。并且可能很难将外部库包含到项目中。因此，要么您接受这样一个事实，即您的系统基于外部组件，要么您重新发明轮子以将其纳入您的模型。

e) 建模工具可能会遇到使用版本控制工具的问题。源代码通常比模型图更容易合并。这迫使团队从复制-编辑-合并转向锁定-编辑-合并工作流程。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-11-10T10:00:33.240

嗡嗡声。

我相信，OTOH，是在运行时建模。与其生成代码，不如让模型在运行时保持活动状态，让您的应用程序成为这些模型的运行时解释器。

我不知道这是否已为 Java 完成。对于 Smalltalk，请参见Seaside 中使用的[Magritte 。](http://www.lukas-renggli.ch/smalltalk/magritte)

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-30T23:00:13.077

我认为它更可取。这就是我试图暗示[这个](https://stackoverflow.com/questions/140098/is-mvc-ars-preferable-to-classic-mvc-to-prevent-overloading)关于 MVC-ARS 而不是 MVC 的问题。ARS（动作/表示/状态）通过设计包含在模型中，并防止控制器或视图过载。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2009-05-04T14:33:20.050

模型驱动软件开发不仅仅是关于 MDA，还有一组其他方法，包括可能更流行的领域特定语言方法。

当然，代码是“一个”模型，但在 DSL 中捕获更高级别的模型是表达相同意图的更简洁的方式。关键是**始终**从模型生成代码，而不是允许对生成的代码进行独立修改。

有大量可用的工具和大量已发布的材料（包括案例研究）告诉您如果不乐意购买现成的发电机，如何构建自己的发电机。可以说，这比使用通用编程语言提供了更多的控制权。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T09:44:24.080

听起来确实不错，但我还没有看到它以实际可行的方式实现。

我是这样认为的：代码就是模型。这样您的模型和代码始终是最新的:-)

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-11-10T03:47:03.820

仅举两本书，我发现上面提到的 MDA 对理解 MDA 很有帮助，这是一个广泛的主题。

*   MDA Distilled - 模型驱动架构的原则。（梅勒）
*   现实生活中的 MDA：使用模型驱动架构解决业务问题 (Guttman)

由于案例研究变得乏味，您无需阅读所有 Guttman 的文章即可获得想法，但介绍读起来很愉快。

* * *

## 回答 #8

> 赞同：-1
> 
> 时间：2008-09-30T22:51:55.780

MDA 通常难以在服务器端层内集成业务规则，因为模型视图映射由生成的代码处理，并且功能挂钩作为事件响应器提供。

我仍然没有看到像 Forté（或 UDS，现已死）+ Express 那样强大的 MDA 工具。我想具有 Forté 功能的 MDA 加上更好的模式来实现独立的服务层（如 ActiveRecord 或 EntityTransactionManager 模式）将成为任何平台的杀手级应用程序。

针对三层 MDA 方法的实际应用问题在于，这些方法非常难以设置和适应特定要求。想想 ABAP 和 SAP 费率

# http - 如何获取http文件元数据？

> ID：70782
> 
> 赞同：2
> 
> 时间：2008-09-16T09:41:37.097
> 
> 标签：http

如何获取文件的创建日期或文件大小，例如[http://www.mywebsite.com/now/Hello.jpg](http://www.mywebsite.com/now/Hello.jpg(note)上的 Hello.jpg（注意：此 URL 不存在）？这个问题的目的是让我的应用程序在检测到该网站具有文件的更新版本并且我的本地文件夹中的文件已过期时，从任何网站重新下载文件。有任何想法吗？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T09:45:44.263

如果您使用 HEAD 请求，它将发送资源的标头，在那里您可以检查缓存控制标头，它会告诉您资源是否已被修改、上次修改时间、大小（内容长度）和日期。

```
$ telnet www.google.com 80
Trying 216.239.59.103...
Connected to www.l.google.com.
Escape character is '^]'.
HEAD /intl/en_ALL/images/logo.gif HTTP/1.0

HTTP/1.0 200 OK
Content-Type: image/gif
Last-Modified: Wed, 07 Jun 2006 19:38:24 GMT
Expires: Sun, 17 Jan 2038 19:14:07 GMT
Cache-Control: public
Date: Tue, 16 Sep 2008 09:45:42 GMT
Server: gws
Content-Length: 8558
Connection: Close

Connection closed by foreign host. 
```

请注意，您可能必须使用许多启发式方法来装饰这种基本且简单的方法，具体取决于每个网络服务器管理员的疯狂程度，因为每个人都可以发送他们喜欢的任何标头。如果它们不提供缓存标头（Last-Modified、Expires、Cache-Control）、Content-Length 或 etag，您将不得不重新下载它进行测试。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T09:45:48.227

网络服务器可能会为此目的发送一个 last-modified 和/或 etag 标头。您可能会在请求中发送一个 if-modified-since 标头。

请参阅[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) 第 14.19、14.25 和 14.29 节

# java - 将 Ext JS 用作基于 Java / Spring / Hibernate 的 Web 应用程序的一部分的最佳方法是什么？

> ID：70785
> 
> 赞同：3
> 
> 时间：2008-09-16T09:42:08.233
> 
> 标签：java, javascript, extjs

我们想在新项目上尝试 Ext JS。将 Ext JS 与服务器端 Java (Spring/Hibernate/JS) 应用程序集成是否有任何众所周知的最佳实践？DWR 是一个不错的选择吗？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-17T16:18:54.903

我的团队几乎一年都在使用 Ext 和 DWR，除了好话外，没有什么可说的。如果您采用这种方法，您最终将使用 DWR 生成的 JavaScript 类向服务器发出请求。这通常会代替使用 Ext.Ajax 和 Ext.data.Connection 类来完成。当您使用需要 Ext.data.Store 的类（例如，手柄、组合框等）并且想要从服务器获取数据时，您将需要使用可以与 DWR 链接的代理。用户社区提供的 Ext.ux.data.DWRProxy 为我们完美地工作：[http](http://extjs.com/forum/showthread.php?t=23884) ://extjs.com/forum/showthread.php?t=23884 。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-16T10:25:20.580

是的，这是可能的。

我对 .NET 做了同样的事情：ext-JS 中的 UI，它通过 JSON 与服务器通信。在 .NET 世界中，您可以使用 DataContractSerializer（来自 WCF 的类）或 JavascriptSerializer (ASP.NET)

我确信在 Java 世界中也有几个很好的 JSON 序列化器。我使用[了 Jabsorb](http://jabsorb.org/)（但不足以给你一个可靠的反馈）。似乎其他人已经尝试过：[链接文本][2]

[2]：[http](http://extjs.com/forum/showthread.php?t=30759) ://extjs.com/forum/showthread.php? t=30759 论坛 ext-js

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-16T17:48:36.270

在我们的应用程序中，我们像这样子类[Ext.data.DataProxy](http://extjs.com/deploy/dev/docs/?class=Ext.data.DataProxy)：

```
var MyProxy = function(fn) {
  this.fn = fn;
};
Ext.extend( MyProxy, Ext.data.DataProxy, {
  load: function(params,reader,callback,scope,arg) {
    this.fn(params,function(data) {
      callback.call(scope,reader.readRecords(data),arg,true);
    });
  },
  update: function() {}
}); 
```

您将它与这样的商店一起使用：

```
var store = new Ext.data.Store({
  reader: myReader, proxy: new MyProxy(function(params,callback) {
    // params are used for paging and searching, if you need it
    callback(SomeService.getData(params));
  })
  // ...
}); 
```

我们实际的代理类有一些额外的调试和错误处理代码，为了简单起见，我省略了这些代码。您可能还需要稍微操作您的数据，以便[Ext.data.JsonReader](http://extjs.com/deploy/dev/docs/?class=Ext.data.JsonReader)可以处理它，但这是基本思想。SomeService 是您为在 dwr.xml（或您的 Spring 配置）中公开的任何 bean 指定的 JavaScript 名称。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2010-05-23T16:22:32.900

看看 Grails，它与 ExtJS 配合得很好。

* * *

## 回答 #5

> 赞同：-1
> 
> 时间：2008-09-16T10:09:54.157

使用 Ext JS/DWR/Spring/Hibernate 构建您的应用程序非常好。

# python - 如何提示用户输入和读取命令行参数

> ID：70797
> 
> 赞同：580
> 
> 时间：2008-09-16T09:44:59.477
> 
> 标签：python, input, command-line-arguments

我如何拥有一个 Python 脚本，a) 可以接受用户输入以及如何制作它 b) 如果从命令行运行，则读取参数？

* * *

## 回答 #1

> 赞同：566
> 
> 时间：2008-09-16T09:50:40.990

要阅读用户输入，您可以尝试[使用该`cmd`模块](https://docs.python.org/dev/library/cmd.html)轻松创建迷你命令行解释器（带有帮助文本和自动完成功能）和[`raw_input`](https://docs.python.org/2/library/functions.html#raw_input)（[`input`](https://docs.python.org/dev/library/functions.html#input)对于 Python 3+）从用户那里读取一行文本。

```
text = raw_input("prompt")  # Python 2
text = input("prompt")  # Python 3 
```

命令行输入位于`sys.argv`. 在你的脚本中试试这个：

```
import sys
print (sys.argv) 
```

有两个用于解析命令行选项的模块：（[~~`optparse`~~](https://docs.python.org/dev/library/optparse.html)自 Python 2.7 起已弃用，请[`argparse`](https://docs.python.org/dev/library/argparse.html)改用）和[`getopt`](https://docs.python.org/dev/library/getopt.html). 如果您只想将文件输入到您的脚本中，看看[`fileinput`](https://docs.python.org/dev/library/fileinput.html).

[Python 库参考](https://docs.python.org/dev/library/)是您的朋友。

* * *

## 回答 #2

> 赞同：486
> 
> 时间：2008-09-16T09:48:16.487

```
var = raw_input("Please enter something: ")
print "you entered", var 
```

或者对于 Python 3：

```
var = input("Please enter something: ")
print("You entered: " + var) 
```

* * *

## 回答 #3

> 赞同：205
> 
> 时间：2011-11-30T22:53:49.487

`raw_input`在 Python 3.x 中不再可用。但是`raw_input`被重命名`input`了，所以同样的功能也存在。

```
input_var = input("Enter something: ")
print ("you entered " + input_var) 
```

[变更文件](http://docs.python.org/py3k/whatsnew/3.0.html#builtins)

* * *

## 回答 #4

> 赞同：33
> 
> 时间：2008-09-16T09:48:40.263

处理命令行参数的最佳方式是[`argparse`模块。](https://docs.python.org/library/argparse.html)

用于`raw_input()`获取用户输入。如果您导入，[`readline module`](https://docs.python.org/library/readline.html)您的用户将拥有行编辑和历史记录。

* * *

## 回答 #5

> 赞同：19
> 
> 时间：2008-09-16T09:58:33.360

小心不要使用该`input`功能，除非您知道自己在做什么。不像`raw_input`,`input`将接受任何 python 表达式，所以有点像`eval`

* * *

## 回答 #6

> 赞同：19
> 
> 时间：2015-05-20T05:33:16.743

这个简单的程序可帮助您了解如何从命令行输入用户输入并显示有关传递无效参数的帮助。

```
import argparse
import sys

try:
     parser = argparse.ArgumentParser()
     parser.add_argument("square", help="display a square of a given number",
                type=int)
    args = parser.parse_args()

    #print the square of user input from cmd line.
    print args.square**2

    #print all the sys argument passed from cmd line including the program name.
    print sys.argv

    #print the second argument passed from cmd line; Note it starts from ZERO
    print sys.argv[1]
except:
    e = sys.exc_info()[0]
    print e 
```

1) 求 5 的平方根

```
C:\Users\Desktop>python -i emp.py 5
25
['emp.py', '5']
5 
```

2) 传递数字以外的无效参数

```
C:\Users\bgh37516\Desktop>python -i emp.py five
usage: emp.py [-h] square
emp.py: error: argument square: invalid int value: 'five'
<type 'exceptions.SystemExit'> 
```

* * *

## 回答 #7

> 赞同：12
> 
> 时间：2008-09-16T09:52:24.620

使用“raw_input”从控制台/终端输入。

如果您只想要一个命令行参数，例如文件名或其他东西

```
$ python my_prog.py file_name.txt 
```

那么你可以使用 sys.argv ...

```
import sys
print sys.argv 
```

sys.argv 是一个列表，其中 0 是程序名称，因此在上面的示例中 sys.argv[1] 将是“file_name.txt”

如果您想拥有完整的命令行选项，请使用 optparse 模块。

佩夫

* * *

## 回答 #8

> 赞同：10
> 
> 时间：2012-10-26T15:29:14.753

如果您正在运行 Python <2.7，则需要[optparse](http://docs.python.org/library/optparse.html)，正如文档所解释的那样，它将为运行应用程序时调用的命令行参数创建一个接口。

但是，在 Python ≥2.7 中， optparse 已被弃用，并被[argparse](http://docs.python.org/library/argparse.html)取代，如上所示。文档中的一个简单示例...

> 以下代码是一个 Python 程序，它采用整数列表并产生总和或最大值：

```
import argparse

parser = argparse.ArgumentParser(description='Process some integers.')
parser.add_argument('integers', metavar='N', type=int, nargs='+',
                   help='an integer for the accumulator')
parser.add_argument('--sum', dest='accumulate', action='store_const',
                   const=sum, default=max,
                   help='sum the integers (default: find the max)')

args = parser.parse_args()
print args.accumulate(args.integers) 
```

* * *

## 回答 #9

> 赞同：7
> 
> 时间：2010-08-06T20:00:22.570

从 Python 开始~~3.2~~2.7，现在有[argparse](http://docs.python.org/dev/library/argparse.html)用于处理命令行参数。

* * *

## 回答 #10

> 赞同：7
> 
> 时间：2017-02-17T18:31:13.250

如果它是 3.x 版本，那么只需使用：

```
variantname = input() 
```

例如，您要输入 8：

```
x = input()
8 
```

x 将等于 8，但它将是一个字符串，除非您以其他方式定义它。

所以你可以使用 convert 命令，比如：

```
a = int(x) * 1.1343
print(round(a, 2)) # '9.07'
9.07 
```

* * *

## 回答 #11

> 赞同：3
> 
> 时间：2017-06-01T18:00:17.193

在 Python 2 中：

```
data = raw_input('Enter something: ')
print data 
```

在 Python 3 中：

```
data = input('Enter something: ')
print(data) 
```

* * *

## 回答 #12

> 赞同：2
> 
> 时间：2019-01-17T17:10:43.020

```
import six

if six.PY2:
    input = raw_input

print(input("What's your name? ")) 
```

# performance - VMWare 服务器：虚拟硬盘类型

> ID：70811
> 
> 赞同：4
> 
> 时间：2008-09-16T09:48:04.507
> 
> 标签：performance, ide, vmware, hard-drive, scsi

为了获得最佳性能，使用虚拟 IDE 硬盘还是虚拟 SCSI 硬盘更好？如果，SCSI，使用 BusLogic 还是 LSILogic 是否重要？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-09-16T10:09:53.300

选择 SCSI 和 LSILogic。IDE 和 BusLogic 是出于兼容性原因。就像你做物理2虚拟...

vmware 的白皮书显示了 LSILogic 和 BusLogic 之间的区别，在我看来，这相当小： http: [//www.vmware.com/pdf/ESX2_Storage_Performance.pdf](http://www.vmware.com/pdf/ESX2_Storage_Performance.pdf)

大约三年后编辑：对于当前的 ESX 环境，最好使用准虚拟 SCSI 设备。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-16T10:19:17.833

我不认为您在 VMWare 中选择的虚拟磁盘类型对性能很重要。重要的是：你有多少内存（越多越好），你有多少 CPU 内核（越多越好），更具体地说，关于磁盘，最重要的是物理驱动器的速度（15K RPM SCSI 驱动器最好）。例如，如果您有 3 个物理 HD 和 3 个虚拟 HD，那么我会在每个物理 HD 中放置一个虚拟 HD。众所周知，这可以提高虚拟 HD 性能。还要对您的虚拟硬盘进行碎片整理。

# asp.net-mvc - 将 Asp.Net MVC 与 SharePoint 一起使用

> ID：70816
> 
> 赞同：30
> 
> 时间：2008-09-16T09:48:30.030
> 
> 标签：asp.net-mvc, sharepoint

是否可以在 SharePoint 网站中使用 Asp.Net MVC 框架？

* * *

## 回答 #1

> 赞同：21
> 
> 时间：2008-09-16T10:02:07.670

在 ScottGu [2008 年 2 月的博客中](http://weblogs.asp.net/scottgu/archive/2008/02/12/asp-net-mvc-framework-road-map-update.aspx)，他写道：

> 目前 MVC 不直接与 SharePoint 集成。不过，这是我们将来会考虑支持的东西。

CodePlex 上有一个项目可以让 ASP.NET MVC 在 SharePoint 中工作：http: [//www.codeplex.com/SharePointMVC](http://www.codeplex.com/SharePointMVC)

* * *

## 回答 #2

> 赞同：21
> 
> 时间：2008-12-11T12:20:16.543

您可能会对此感兴趣[http://www.codeplex.com/SharePointMVC](http://www.codeplex.com/SharePointMVC)

它基本上是一个帮助在 SharePoint 母版页中呈现 ASP.MVC 的库。

还为时过早，但你明白了。

* * *

## 回答 #3

> 赞同：13
> 
> 时间：2010-04-16T08:57:26.057

以下共享点站点 www.themedicinecabinet.co.uk 是使用 ASP.net MVC 2 构建的。本文解释了这是如何完成的 [http://vspug.com/mbailey/files/2010/04/Using-ASP.NET -MVC-2-with-Sharepoint-Publishing.pdf](http://vspug.com/mbailey/files/2010/04/Using-ASP.NET-MVC-2-with-Sharepoint-Publishing.pdf)

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2009-06-20T03:37:16.237

一种可能的架构是使用 asp.net 或 asp.net mvc 前端。然后通过 Web 服务访问共享点功能。

这样做的好处是让您可以访问 sharepoint 的功能，而无需使用 sharepoint 的额外开发成本。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-16T09:52:48.147

我不这么认为，尽管您可以将标准 ASPX 文件上传到 SharePoint 并让它们运行，但我很确定 URL 重写是它会失败的地方。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2009-06-22T15:28:27.197

您可以做的一件事是使用 asp.net mvc 仅通过引用 SharePoint 程序集来创建共享点“支持”应用程序。

我猜 Sharepoint 对象模型将是 MVC 中的 M。

# c - 从 C 程序中执行程序

> ID：70842
> 
> 赞同：8
> 
> 时间：2008-09-16T09:52:26.680
> 
> 标签：c, linux

我应该如何从我的程序中运行另一个`C`程序？我需要能够将数据写入`STDIN`已启动的程序（并且可能从中读取`STDOUT`）

我不确定这是否是标准的 C 函数。我需要应该在 Linux 下工作的解决方案。

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2008-09-16T09:54:35.957

你想用`popen`. 它为您提供了一个单向管道，您可以使用它访问程序的标准输入和标准输出。

popen 是现代 unix 和类 unix 操作系统的标准，Linux 就是其中之一:-)

类型

```
man popen 
```

在终端中阅读更多相关信息。

**编辑**

是否`popen`产生单向或双向管道取决于实现。在[Linux](https://manpages.debian.org/jessie/manpages-dev/popen.3.en.html)和[OpenBSD](http://man.openbsd.org/OpenBSD-current/man3/popen.3)中，`popen`产生只读或只写的单向管道。在[OS X](https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/popen.3.html)上，[FreeBSD](https://www.freebsd.org/cgi/man.cgi?query=popen&apropos=0&sektion=0&manpath=FreeBSD+11.0-RELEASE+and+Ports&arch=default&format=html)和[NetBSD](http://netbsd.gw.com/cgi-bin/man-cgi?popen++NetBSD-current) `popen`产生双向管道。

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2008-09-17T13:53:21.430

不久前，我为其他人编写了一些示例 C 代码，展示了如何执行此操作。这是给你的：

```
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

void error(char *s);
char *data = "Some input data\n";

main()
{
  int in[2], out[2], n, pid;
  char buf[255];

  /* In a pipe, xx[0] is for reading, xx[1] is for writing */
  if (pipe(in) < 0) error("pipe in");
  if (pipe(out) < 0) error("pipe out");

  if ((pid=fork()) == 0) {
    /* This is the child process */

    /* Close stdin, stdout, stderr */
    close(0);
    close(1);
    close(2);
    /* make our pipes, our new stdin,stdout and stderr */
    dup2(in[0],0);
    dup2(out[1],1);
    dup2(out[1],2);

    /* Close the other ends of the pipes that the parent will use, because if
     * we leave these open in the child, the child/parent will not get an EOF
     * when the parent/child closes their end of the pipe.
     */
    close(in[1]);
    close(out[0]);

    /* Over-write the child process with the hexdump binary */
    execl("/usr/bin/hexdump", "hexdump", "-C", (char *)NULL);
    error("Could not exec hexdump");
  }

  printf("Spawned 'hexdump -C' as a child process at pid %d\n", pid);

  /* This is the parent process */
  /* Close the pipe ends that the child uses to read from / write to so
   * the when we close the others, an EOF will be transmitted properly.
   */
  close(in[0]);
  close(out[1]);

  printf("<- %s", data);
  /* Write some data to the childs input */
  write(in[1], data, strlen(data));

  /* Because of the small amount of data, the child may block unless we
   * close it's input stream. This sends an EOF to the child on it's
   * stdin.
   */
  close(in[1]);

  /* Read back any output */
  n = read(out[0], buf, 250);
  buf[n] = 0;
  printf("-> %s",buf);
  exit(0);
}

void error(char *s)
{
  perror(s);
  exit(1);
} 
```

* * *

## 回答 #3

> 赞同：8
> 
> 时间：2008-09-16T09:56:46.263

1.  创建两个管道`pipe(...)`，一个用于`stdin`，一个用于`stdout`。
2.  `fork(...)`过程。
3.  在子进程（`fork(...)`返回 0 的那个）`dup (...)`中，管道到`stdin`/ `stdout`。
4.  `exec[v][e]`子进程中要启动的programm文件。
5.  在父进程（ where ）返回子进程的 PID ）执行一个循环，从子进程（或, ）`fork`读取到缓冲区，直到子进程终止（）。`stdout``select(...)``poll(...)``read(...)``waitpid(...)`
6.  `stdin`如果它期望一些，最终向孩子提供输入。
7.  当完成`close(...)`管道。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-09-17T07:42:33.020

对于简单的单向通信，popen() 是一个不错的解决方案。但是，它对双向通信没有用。

IMO，imjorge (Jorge Ferreira) 给出了双向通信的大部分答案（80%？） - 但省略了一些关键细节。

1.  父进程关闭用于向子进程发送消息的管道的读取端至关重要。
2.  子进程关闭用于向子进程发送消息的管道的写入端至关重要。
3.  父进程关闭用于向父进程发送消息的管道的写入端至关重要。
4.  子进程关闭用于向父进程发送消息的管道的读取端至关重要。

如果您不关闭管道的未使用端，那么当其中一个程序终止时，您将不会获得明智的行为；例如，孩子可能正在从其标准输入读取，但除非管道的写入端在孩子中关闭，否则它将永远不会获得 EOF（读取的零字节），因为它仍然打开管道并且系统认为它有时可能会开始写入该管道，即使它当前挂起等待从中读取某些内容。

写入进程应考虑是否处理在没有读取进程的管道上写入时给出的 SIGPIPE 信号。

您必须了解管道容量（取决于平台，可能只有 4KB）并设计程序以避免死锁。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-16T10:15:03.880

您可以使用系统调用，阅读[系统手册（3）](http://www.linuxmanpages.com/man3/system.3.php)

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T09:56:40.523

我认为你可以使用

> `freopen`

为了这 。

# c - 这种奇怪的 C 代码格式是什么？

> ID：70850
> 
> 赞同：1
> 
> 时间：2008-09-16T09:55:20.637
> 
> 标签：c, formatting

如下格式化 C 代码可以提供什么优势（如果有的话）：

```
while(lock_file(lockdir)==0)
    {
    count++;
    if(count==20)
        {
        fprintf(stderr,"Can't lock dir %s\n",lockdir);
        exit(1);
        }
    sleep(3);
    }
if(rmdir(serverdir)!=0)
    {
    switch(errno)
        {
        case EEXIST:
            fprintf(stderr,"Server dir %s not empty\n",serverdir);
            break;
        default:
            fprintf(stderr,"Can't delete dir %s\n",serverdir);
        }
    exit(1);
    }
unlock_file(lockdir); 
```

与更典型的东西相比

```
while(lock_file(lockdir)==0) {
    count++;
    if(count==20) {
        fprintf(stderr,"Can't lock dir %s\n",lockdir);
        exit(1);
    }
    sleep(3);
}
if(rmdir(serverdir)!=0) {
    switch(errno) {
        case EEXIST:
            fprintf(stderr,"Server dir %s not empty\n",serverdir);
            break;
        default:
            fprintf(stderr,"Can't delete dir %s\n",serverdir);
    }
    exit(1);
}
unlock_file(lockdir); 
```

我只是发现顶级版本难以阅读，并且对于长块之外的语句，特别是对于包含多个嵌套块的长块而言，缩进级别是正确的。

我能看到的唯一优势就是与众不同，并在您编写的代码上留下您的指纹。

我注意到 vim 格式必须手动处理才能处理顶部情况。

* * *

## 回答 #1

> 赞同：27
> 
> 时间：2008-11-07T09:35:09.827

最典型的例子被称为“Whitesmiths style”。[Wikipedia 关于缩进样式的条目](http://en.wikipedia.org/wiki/Indent_style)解释了几种样式及其优缺点。

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2008-11-07T17:05:52.587

您看到的压痕是[Whitesmiths 样式](http://en.wikipedia.org/wiki/Indent_style#Whitesmiths_style)。*它在Code Complete*的第一版中被描述为“begin-end Block Boundaries”。这种风格的基本论点是，在像 C（和 Pascal）这样的语言中，an`if`控制单个语句或块。因此，整个块，而不仅仅是它的内容，应该`if`通过一致的缩进来显示从属于 - 语句。

```
XXXXXXXXXXXXXXX       if (test)
   XXXXXXXXXXXX           one_thing();

XXXXXXXXXXXXXXX       if (test)
   X                     {
   XXXXX                 one_thing();
   XXXXX                 another_thing();
   X                     } 
```

当我第一次读这本书时（在 90 年代），我发现“开始结束块边界”的论点是令人信服的，尽管当我将它付诸实践时（在 Pascal 中）我不太喜欢它。我更不喜欢 C 语言中的它，并且觉得它读起来很混乱。我最终使用了 Steve McConnel 所说的“模拟纯块”（[Sun 的 Java 风格](http://java.sun.com/docs/codeconv/html/CodeConventions.doc6.html#15395)，几乎是[K&R](http://en.wikipedia.org/wiki/Indent_style#K.26R_style)）。

```
XXXXXXXXXXXXXX X      if (test) {
   XXXXXX                one_thing();
   XXXXXX                another_thing();
X                     } 
```

这是用于 Java 编程的最常见的风格（这是我整天都在做的事情）。[它也与我以前的语言](http://www-old.oberon.ethz.ch/oreport.html)最相似，它是一种“纯块”语言，不需要“仿真”。没有单语句体，块是控制结构语法中固有的。

```
IF test THEN
   oneThing;
   anotherThing
END 
```

* * *

## 回答 #3

> 赞同：8
> 
> 时间：2008-09-16T09:57:04.237

没有。缩进和其他编码标准是一个偏好问题。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-09-16T10:10:33.843

对我来说它看起来很标准。我要做的唯一个人更改是将花括号与上一行的开头对齐，而不是下一行的开头，但这只是个人选择。

无论如何，您正在查看的格式样式是 C 和 C++ 的标准样式，并且使用它是因为它使代码更易于阅读，特别是通过查看缩进级别，您可以知道您在哪里使用嵌套循环、条件等。例如：

```
if (x == 0) 
{
  if (y == 2)
  {
    if (z == 3)
    {
       do_something (x);
    }
  }
} 
```

好的，在那个例子中很容易看到发生了什么，但是如果你在这些 if 语句中放了很多代码，如果没有一致的缩进，有时很难判断你在哪里。

在您的示例中，请查看 exit(1) 语句的位置——如果它没有像那样缩进，就很难判断它在哪里。实际上，您可以说它位于那个大 if 语句的末尾。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2008-09-16T09:57:24.000

我会想到的个人偏好？我猜它的代码块在一条垂直线上，所以可能更容易一目了然？个人更喜欢大括号直接在上一行下面开始

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-09-16T09:58:27.867

代码格式是个人喜好。只要它易于阅读，它就会支付维护费用！

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-16T10:03:55.547

通过遵循一些格式和注释标准，首先你要尊重其他将阅读和编辑你编写的代码的人。如果您不接受规则并编写某种深奥的代码，最可能的结果是您将无法有效地与其他人（程序员）沟通。如果软件仅由您和为您编写，并且没有人会阅读它，那么代码格式是个人选择，但是有多少现代软件仅由一个人编写？

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-16T09:57:48.930

它只是另一种风格——人们以他们喜欢的方式编码，这是一种公认​​的风格（尽管不是我喜欢的）。我认为它与括号不缩进但其中的代码缩进的更常见样式相比没有太多缺点或优势。也许有人可以通过说它更清楚地划分代码块来证明它的合理性。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-16T09:58:55.823

为了让这种格式具有“优势”，我们确实需要一些等效的另一种格式的 C 代码来进行比较！

在我工作的地方，使用这种缩进方案是为了促进本土的折叠编辑器机制。

因此，我认为这种格式没有根本性的错误——在一定的合理范围内，格式是个人喜好的问题。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2019-10-18T19:06:26.510

Whitesmiths 风格的“优势”（在您的示例中称为顶部）是它反映了代码的实际逻辑结构：

*   如果存在逻辑依赖则缩进
*   将相应的括号放在同一列上，以便于查找
*   上下文的打开和关闭（可能打开/关闭堆栈框架等）是可见的，而不是隐藏的

因此，更少的 if/else 错误、循环出错、错误级别的捕获以及整体逻辑一致性。

但正如 benefactual 所写：在一定的合理限度内，格式化是个人喜好的问题。

# php - 如何在 PHP 应用程序中使用多线程

> ID：70855
> 
> 赞同：467
> 
> 时间：2008-09-16T09:56:31.490
> 
> 标签：php, multithreading

是否有一种在 PHP 中实现多线程模型的现实方法，无论是真正的还是只是模拟它。前段时间有人建议您可以强制操作系统加载 PHP 可执行文件的另一个实例并处理其他同步进程。

这样做的问题是，当 PHP 代码完成执行 PHP 实例时，PHP 实例仍保留在内存中，因为无法从 PHP 中杀死它。因此，如果您正在模拟多个线程，您可以想象会发生什么。所以我仍在寻找一种可以在 PHP 中有效地完成或模拟多线程的方法。有任何想法吗？

* * *

## 回答 #1

> 赞同：484
> 
> 时间：2013-03-19T13:55:02.653

# 多线程在 php 中是可能的

[是的，您可以使用pthreads](https://github.com/krakjoe/pthreads)在 PHP 中执行多线程

从[PHP 文档](http://www.php.net/manual/en/intro.pthreads.php)：

> pthreads 是一个面向对象的 API，它提供了 PHP 中多线程所需的所有工具。PHP 应用程序可以创建、读取、写入、执行和与线程、Worker 和线程对象同步。
> 
> **警告**：pthreads 扩展不能在 Web 服务器环境中使用。因此，PHP 中的线程应该只保留给基于 CLI 的应用程序。

**简单测试**

```
#!/usr/bin/php
<?php
class AsyncOperation extends Thread {

    public function __construct($arg) {
        $this->arg = $arg;
    }

    public function run() {
        if ($this->arg) {
            $sleep = mt_rand(1, 10);
            printf('%s: %s  -start -sleeps %d' . "\n", date("g:i:sa"), $this->arg, $sleep);
            sleep($sleep);
            printf('%s: %s  -finish' . "\n", date("g:i:sa"), $this->arg);
        }
    }
}

// Create a array
$stack = array();

//Initiate Multiple Thread
foreach ( range("A", "D") as $i ) {
    $stack[] = new AsyncOperation($i);
}

// Start The Threads
foreach ( $stack as $t ) {
    $t->start();
}

?> 
```

第一次运行

```
12:00:06pm:     A  -start -sleeps 5
12:00:06pm:     B  -start -sleeps 3
12:00:06pm:     C  -start -sleeps 10
12:00:06pm:     D  -start -sleeps 2
12:00:08pm:     D  -finish
12:00:09pm:     B  -finish
12:00:11pm:     A  -finish
12:00:16pm:     C  -finish 
```

第二轮

```
12:01:36pm:     A  -start -sleeps 6
12:01:36pm:     B  -start -sleeps 1
12:01:36pm:     C  -start -sleeps 2
12:01:36pm:     D  -start -sleeps 1
12:01:37pm:     B  -finish
12:01:37pm:     D  -finish
12:01:38pm:     C  -finish
12:01:42pm:     A  -finish 
```

**现实世界的例子**

```
error_reporting(E_ALL);
class AsyncWebRequest extends Thread {
    public $url;
    public $data;

    public function __construct($url) {
        $this->url = $url;
    }

    public function run() {
        if (($url = $this->url)) {
            /*
             * If a large amount of data is being requested, you might want to
             * fsockopen and read using usleep in between reads
             */
            $this->data = file_get_contents($url);
        } else
            printf("Thread #%lu was not provided a URL\n", $this->getThreadId());
    }
}

$t = microtime(true);
$g = new AsyncWebRequest(sprintf("http://www.google.com/?q=%s", rand() * 10));
/* starting synchronization */
if ($g->start()) {
    printf("Request took %f seconds to start ", microtime(true) - $t);
    while ( $g->isRunning() ) {
        echo ".";
        usleep(100);
    }
    if ($g->join()) {
        printf(" and %f seconds to finish receiving %d bytes\n", microtime(true) - $t, strlen($g->data));
    } else
        printf(" and %f seconds to finish, request failed\n", microtime(true) - $t);
} 
```

* * *

## 回答 #2

> 赞同：58
> 
> 时间：2010-12-03T22:27:03.310

你为什么不使用[popen](https://secure.php.net/manual/en/function.popen.php)？

```
for ($i=0; $i<10; $i++) {
    // open ten processes
    for ($j = 0; $j < 10; $j++) {
        $pipe[$j] = popen('script2.php', 'w');
    }

    // wait for them to finish
    for ($j = 0; $j < 10; ++$j) {
        pclose($pipe[$j]);
    }
} 
```

* * *

## 回答 #3

> 赞同：27
> 
> 时间：2009-07-03T14:31:49.187

线程在 PHP 中不可用，但可以通过将 HTTP 请求用作异步调用来进行并发编程。

将 curl 的超时设置设置为 1 并为要相互关联的进程使用相同的 session_id，您可以与会话变量进行通信，如下面的示例所示。使用这种方法，您甚至可以关闭浏览器，并且服务器上仍然存在并发进程。

不要忘记像这样验证正确的会话 ID：

> [http://localhost/test/verifysession.php?sessionid=[](http://localhost/test/verifysession.php?sessionid=[the)正确的id]

### 启动进程.php

```
$request = "http://localhost/test/process1.php?sessionid=".$_REQUEST["PHPSESSID"];
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $request);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_TIMEOUT, 1);
curl_exec($ch);
curl_close($ch);
echo $_REQUEST["PHPSESSID"]; 
```

### 进程1.php

```
set_time_limit(0);

if ($_REQUEST["sessionid"])
   session_id($_REQUEST["sessionid"]);

function checkclose()
{
   global $_SESSION;
   if ($_SESSION["closesession"])
   {
       unset($_SESSION["closesession"]);
       die();
   }
}

while(!$close)
{
   session_start();
   $_SESSION["test"] = rand();
   checkclose();
   session_write_close();
   sleep(5);
} 
```

### 验证会话.php

```
if ($_REQUEST["sessionid"])
    session_id($_REQUEST["sessionid"]);

session_start();
var_dump($_SESSION); 
```

### 关闭进程.php

```
if ($_REQUEST["sessionid"])
    session_id($_REQUEST["sessionid"]);

session_start();
$_SESSION["closesession"] = true;
var_dump($_SESSION); 
```

* * *

## 回答 #4

> 赞同：17
> 
> 时间：2008-09-16T10:30:11.473

虽然你不能线程，但你确实在 php.ini 中有一定程度的进程控制。这里有用的两个函数集是：

过程控制功能 [http://www.php.net/manual/en/ref.pcntl.php](http://www.php.net/manual/en/ref.pcntl.php)

POSIX 函数 [http://www.php.net/manual/en/ref.posix.php](http://www.php.net/manual/en/ref.posix.php)

您可以使用 pcntl_fork 分叉您的进程 - 返回子进程的 PID。然后您可以使用 posix_kill 来处理该 PID。

也就是说，如果你杀死一个父进程，应该向子进程发送一个信号，告诉它死亡。如果 php 本身无法识别这一点，您可以注册一个函数来管理它并使用 pcntl_signal 进行干净退出。

* * *

## 回答 #5

> 赞同：13
> 
> 时间：2013-10-31T18:07:50.777

pthreads PECL 扩展使使用线程成为可能

[http://www.php.net/manual/en/book.pthreads.php](http://www.php.net/manual/en/book.pthreads.php)

* * *

## 回答 #6

> 赞同：12
> 
> 时间：2012-09-19T02:39:12.057

我知道这是一个老问题，但是对于搜索的人来说，现在有一个用 C 编写的 PECL 扩展，它提供了 PHP 多线程功能，它位于这里[https://github.com/krakjoe/pthreads](https://github.com/krakjoe/pthreads)

* * *

## 回答 #7

> 赞同：9
> 
> 时间：2008-09-16T14:03:11.103

您可以使用 exec() 运行命令行脚本（例如命令行 php），如果将输出通过管道传输到文件，那么您的脚本将不会等待命令完成。

我不太记得 php CLI 语法，但你会想要类似的东西：

```
exec("/path/to/php -f '/path/to/file.php' | '/path/to/output.txt'"); 
```

我认为出于安全原因，很多共享托管服务器默认禁用 exec()，但可能值得一试。

* * *

## 回答 #8

> 赞同：6
> 
> 时间：2011-05-10T07:40:26.270

您可以选择：

1.  多卷曲
2.  可以使用相同的系统命令
3.  理想的场景是，用 C 语言创建一个线程函数并在 PHP 中编译/配置。现在该函数将成为 PHP 的函数。

* * *

## 回答 #9

> 赞同：6
> 
> 时间：2012-01-13T00:55:28.300

pcntl_fork 怎么样？

查看我们的手册页以获取示例：[PHP pcntl_fork](http://php.net/manual/en/function.pcntl-fork.php)

```
<?php

    $pid = pcntl_fork();
    if ($pid == -1) {
        die('could not fork');
    } else if ($pid) {
        // we are the parent
        pcntl_wait($status); //Protect against Zombie children
    } else {
        // we are the child
    }

?> 
```

* * *

## 回答 #10

> 赞同：6
> 
> 时间：2020-04-29T15:12:25.620

如果您使用的是 Linux 服务器，则可以使用

```
exec("nohup $php_path path/script.php > /dev/null 2>/dev/null &") 
```

如果你需要传递一些参数

```
exec("nohup $php_path path/script.php $args > /dev/null 2>/dev/null &") 
```

在 script.php 中

```
$args = $argv[1]; 
```

或者使用 Symfony [https://symfony.com/doc/current/components/process.html](https://symfony.com/doc/current/components/process.html)

```
$process = Process::fromShellCommandline("php ".base_path('script.php'));
$process->setTimeout(0);     
$process->disableOutput();     
$process->start(); 
```

* * *

## 回答 #11

> 赞同：5
> 
> 时间：2011-01-25T04:45:09.980

根据您要执行的操作，您还可以使用 curl_multi 来实现它。

* * *

## 回答 #12

> 赞同：5
> 
> 时间：2010-08-26T21:33:57.870

您可以模拟线程。PHP 可以通过 popen（或 proc_open）运行后台进程。这些进程可以通过标准输入和标准输出进行通信。当然，这些进程本身可以是一个 php 程序。这可能与您将得到的一样接近。

* * *

## 回答 #13

> 赞同：4
> 
> 时间：2012-02-02T04:07:04.687

`pcntl_fork`如果打开了*安全模式*，它将无法在 Web 服务器环境中工作。在这种情况下，它只能在 PHP 的 CLI 版本中工作。

* * *

## 回答 #14

> 赞同：-2
> 
> 时间：2018-09-01T05:04:10.823

在撰写我当前的评论时，我不知道 PHP 线程。我自己来这里寻找答案，但一种解决方法是，从 Web 服务器接收请求的 PHP 程序将整个答案公式委托给控制台应用程序，该控制台应用程序将其输出、请求的答案存储到二进制文件并且启动控制台应用程序的 PHP 程序会逐字节地返回该二进制文件作为对接收到的请求的回答。控制台应用程序可以用任何在服务器上运行的编程语言编写，包括那些具有适当线程支持的语言，包括使用 OpenMP 的 C++ 程序。

一个不可靠的、肮脏的技巧是使用 PHP 来执行控制台应用程序，“uname”，

```
uname -a 
```

并将该控制台命令的输出打印到 HTML 输出，以找出服务器软件的确切版本。然后将完全相同版本的软件安装到 VirtualBox 实例，编译/组装任何完全独立的、最好是静态的二进制文件，然后将它们上传到服务器。从那时起，PHP 应用程序可以将这些二进制文件用作具有适当多线程的控制台应用程序的角色。当服务器管理员尚未将所有需要的编程语言实现安装到服务器时，这是一种肮脏、不可靠的解决方法。需要注意的是，在 PHP 应用程序接收到控制台应用程序的每个请求时，都会终止/退出/get_killed。

至于托管服务管理员对这种服务器使用模式的看法，我想这归结为文化。在北欧，服务提供商必须提供广告内容，如果允许执行控制台命令并允许上传非恶意软件文件，服务提供商有权在几分钟甚至 30 秒后终止任何服务器进程，那么托管服务管理员缺乏任何论据来形成适当的投诉。在美国和西欧，情况/文化非常不同，我相信在美国和/或西欧，托管服务提供商很有可能会拒绝为使用上述技巧的托管服务客户提供服务。这只是我的猜测，鉴于我在美国的个人经历 托管服务，并考虑到我从其他人那里听到的有关西欧托管服务的信息。在撰写我当前的评论（2018_09_01）时，我对南欧托管服务提供商、南欧网络管理员的文化规范一无所知。

* * *

## 回答 #15

> 赞同：-3
> 
> 时间：2013-11-05T12:51:26.120

多线程意味着同时执行多个任务或进程，我们可以使用以下代码在php中实现这一点，虽然没有直接的方法在php中实现多线程，但我们可以通过以下方式实现几乎相同的结果。

```
chdir(dirname(__FILE__));  //if you want to run this file as cron job
 for ($i = 0; $i < 2; $i += 1){
 exec("php test_1.php $i > test.txt &");
 //this will execute test_1.php and will leave this process executing in the background and will go         

 //to next iteration of the loop immediately without waiting the completion of the script in the   

 //test_1.php , $i  is passed as argument . 
```

}

测试_1.php

```
$conn=mysql_connect($host,$user,$pass);
$db=mysql_select_db($db);
$i = $argv[1];  //this is the argument passed from index.php file
for($j = 0;$j<5000; $j ++)
{
mysql_query("insert  into  test   set

                id='$i',

                comment='test',

                datetime=NOW() ");

} 
```

这将同时执行两次test_1.php，两个进程将同时在后台运行，这样就可以在php中实现多线程。

[这家伙在 php 中的多线程](https://github.com/krakjoe/pthreads)工作做得非常好

# c++ - 通过不同类型的指针删除缓冲区？

> ID：70880
> 
> 赞同：10
> 
> 时间：2008-09-16T10:01:00.747
> 
> 标签：c++, pointers, memory-management

假设我有以下 C++：

```
char *p = new char[cb];
SOME_STRUCT *pSS = (SOME_STRUCT *) p;
delete pSS; 
```

根据 C++ 标准，这是否安全？我需要转换回 a`char*`然后使用`delete[]`吗？我知道它适用于大多数 C++ 编译器，因为它是普通数据，没有析构函数。能保证安全吗？

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-09-16T10:06:34.073

不能保证安全。这是 C++ FAQ lite 中的相关链接：

[16.13]`[]`删除某些内置类型（ , 等）的数组时可以删除`char`吗`int`？

[http://www.parashift.com/c++-faq-lite/freestore-mgmt.html#faq-16.13](https://isocpp.org/wiki/faq/freestore-mgmt#delete-array-built-ins)

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-09-16T10:06:32.527

不，这是未定义的行为 - 编译器可能会做一些不同的事情，并且正如[thudbang](https://stackoverflow.com/questions/70880/deleting-a-buffer-through-a-different-type-of-pointer#70905) 链接到的 C++ FAQ 条目所说，`operator delete[]`可能会被重载以执行与`operator delete`. 有时您可以侥幸逃脱，但在您无法做到的情况下，养成将 delete[] 与 new[] 匹配的习惯也是一种好习惯。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-16T10:13:36.770

我对此表示高度怀疑。

有很多有问题的释放内存的方法，例如你可以`delete`在你的`char`数组上使用（而不是`delete[]`），它可能会正常工作。我[在博客](http://www.byteclub.net/blog/zooba/?p=77)上详细介绍了这一点（为自我链接道歉，但它比重写它更容易）。

编译器与其说是平台问题，不如说是问题。大多数库将使用底层操作系统的分配方法，这意味着相同的代码在 Mac、Windows 和 Linux 上的行为可能不同。我见过这样的例子，每一个都是有问题的代码。

最安全的方法是始终使用相同的数据类型分配和释放内存。如果您正在分配`char`s 并将它们返回给其他代码，则最好提供特定的分配/解除分配方法：

```
SOME_STRUCT* Allocate()
{
    size_t cb; // Initialised to something
    return (SOME_STRUCT*)(new char[cb]);
} 
```

```
void Free(SOME_STRUCT* obj)
{
    delete[] (char*)obj;
} 
```

（重载`new`and`delete`运算符也可能是一种选择，但我从不喜欢这样做。）

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-16T10:13:33.370

C++ 标准 [5.3.5.2] 声明：

> 如果操作数具有类类型，则通过调用上述转换函数将操作数转换为指针类型，并在本节的其余部分中使用转换后的操作数代替原始操作数。在任一替代方案中，delete 的操作数的值都可以是空指针值。**如果它不是空指针值，在第一种选择（删除对象）中，删除操作数的值应是指向非数组对象的指针或指向表示此类基类的子对象（1.8）的指针一个对象（第 10 条）。如果不是，则行为未定义。在第二种选择（删除数组）中，delete 的操作数的值应是从前一个数组 new-expression 产生的指针值。77) 如果不是，则行为未定义。[ 注意：这意味着 delete-expression 的语法必须与 new 分配的对象的类型匹配，而不是 new-expression 的语法。——尾注]**[ 注意：指向 const 类型的指针可以是删除表达式的操作数；在将指针表达式用作删除表达式的操作数之前，没有必要抛弃它的 constness (5.2.11)。——尾注]

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-20T16:05:54.867

这是一个与我在这里回答的问题非常相似的问题：[link text](https://stackoverflow.com/questions/73134/will-this-c-code-cause-a-memory-leak-casting-vector-new#108454)

简而言之，不，根据 C++ 标准，它是不安全的。如果由于某种原因，您需要一个 SOME_STRUCT 对象分配在与大小不同的内存区域中`size_of(SOME_STRUCT)`（并且最好更大！），那么您最好使用像 global 这样的原始分配函数`operator new`来执行分配和然后使用放置在原始内存中创建对象实例`new`。如果对象类型没有构造函数，放置`new`将非常便宜。

```
void* p = ::operator new( cb );
SOME_STRUCT* pSS = new (p) SOME_STRUCT;

// ...

delete pSS; 
```

这将在大多数情况下起作用。如果`SOME_STRUCT`是 POD 结构，它应该始终有效。`SOME_STRUCT`如果的构造函数没有抛出并且`SOME_STRUCT`没有自定义运算符 delete ，它也可以在其他情况下工作。这种技术也消除了对任何演员的需要。

`::operator new` and `::operator delete` are C++'s closest equivalent to `malloc` and `free` and as these (in the absence of class overrides) are called as appropriate by `new` and `delete` expressions they can (with care!) be used in combination.

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T10:07:19.577

虽然这*应该*可行，但我认为您不能保证它是安全的，因为 SOME_STRUCT 不是 char* （除非它只是 typedef）。

此外，由于您使用不同类型的引用，如果您继续使用 *p 访问，并且内存已被删除，您将收到运行时错误。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-16T10:38:24.387

**如果指向的内存和**您指向的指针都是 POD，这将正常工作。在这种情况下，无论如何都不会调用析构函数，并且内存分配器不知道也不关心内存中存储的类型。

对于非 POD 类型，唯一可以这样做的情况是，指针对象是指针的子类型（例如，您使用 Vehicle* 指向汽车）并且指针的析构函数已被声明为虚拟的。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-16T11:41:17.793

这是不安全的，到目前为止，没有一个回应足够强调这样做的疯狂。如果您认为自己是真正的程序员，或者曾经想在团队中作为专业程序员工作，请不要这样做。您现在只能说您的结构包含非析构函数，但是您*正在*为将来设置一个令人讨厌的编译器和系统特定的陷阱。此外，您的代码不太可能按预期工作。您可以期望的最好的结果是它不会崩溃。但是我怀疑你会慢慢地得到内存泄漏，因为通过 new 分配的数组通常会在返回指针*之前的字节中分配额外的内存。*你不会释放你认为的记忆。一个好的内存分配例程应该可以解决这种不匹配问题，就像 Lint 等工具一样。

根本不要那样做，从你的脑海中清除任何导致你甚至考虑这些废话的思考过程。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-16T13:51:53.673

我已将代码更改为使用 malloc/free。虽然我知道 MSVC 如何为普通旧数据实现新/删除（在这种情况下 SOME_STRUCT 是 Win32 结构，所以很简单的 C），但我只是想知道它是否是一种可移植技术。

它不是，所以我会使用它的东西。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-16T23:33:06.053

如果您使用 malloc/free 而不是 new/delete，则 malloc 和 free 不会关心类型。

因此，如果您使用类似 C 的 POD（普通旧数据，如内置类型或结构），您可以 malloc 一些类型，并释放另一种类型。**请注意，即使它有效，这也是一种糟糕的风格**。

# java - 使用 JBoss Richfaces 从 PDF 中提取文本

> ID：70890
> 
> 赞同：0
> 
> 时间：2008-09-16T10:02:50.370
> 
> 标签：java, ajax, jsf, seam, richfaces

我正在尝试编写一个网络应用程序来管理我的博士论文的参考资料。

我曾经在个人 Confluence （很棒的工具！- [http://www.atlassian.com/software/confluence/](http://www.atlassian.com/software/confluence/)）实例中管理这些信息，但是我厌倦了打开 PDF 并将值剪切和粘贴到字段中我想记录的。

我已经公开了一个 Web 服务，它将根据 PDF 文件名和页码返回给我图像。相同的 web 服务还公开了一个方法，该方法将返回提供的矩形内的文本（左上 xy 坐标，右下 xy 坐标）。

我希望能够在 PDF 图像的一部分上拖动一个矩形，然后调用 web 服务给我文本（然后我将其存储在 EntityBean 上）。我正在考虑使用 JBoss 应用程序堆栈（Application Server、Hibernate、Seam 和 Richfaces）。有人知道我该如何实现这一目标吗？我已经看到了在其他 RIA 工具包（例如 dojo）中绘制自定义图像的能力，但是我看不到在 Richfaces 中执行此操作的方法。

希望有人可以证明我错了，或者提供一些关于我能做什么的想法（因为我不是 Web 开发人员 - 我主要构建这个工具，因为现在可用的 RIA 框架让我感兴趣！）

我已经有了提取文本的代码，我的问题纯粹是如何让用户在图像顶部的网络浏览器内绘制一个“选择矩形”？

非常感谢，

艾多斯

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-16T10:23:38.353

尝试使用[RichFaces Paint 2D](http://livedemo.exadel.com/richfaces-demo/richfaces/paint2D.jsf?c=paint2d&tab=usage)标签

[它将Graphics2D](http://java.sun.com/j2se/1.4.2/docs/api/java/awt/Graphics2D.html)包暴露给用户界面。

使用 javascript 跟踪图像上的用户拖动事件，然后将坐标发布到支持 bean 以使用绘制的选择框重新渲染图像。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2009-08-21T08:58:11.783

你可以用 itext ( [http://www.lowagie.com/iText/](http://www.lowagie.com/iText/) )

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-12-22T15:28:22.490

你考虑[过门德利](http://www.mendeley.com/)吗？它将尝试从您的 pdf 中解析和提取书目信息。

# java - Hibernate 使用空值映射复合键

> ID：70909
> 
> 赞同：27
> 
> 时间：2008-09-16T10:07:17.753
> 
> 标签：java, hibernate

使用 Hibernate，您是否可以创建一个复合 ID，其中您映射到该 ID 的列之一可以具有空值？

这是为了处理具有唯一键的遗留表，该唯一键可以具有空值但没有主键。

我意识到我可以在表中添加一个新的主键列，但我想知道是否有任何方法可以避免这样做。

* * *

## 回答 #1

> 赞同：13
> 
> 时间：2008-09-16T10:12:18.270

不，主键不能为空。

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2016-04-15T07:06:22.050

您不会得到错误，但 Hibernate 将无法将具有 NULL 值的复合列的行映射到您的实体。这意味着您会在结果中获得具有 NULL 值的实体。

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2017-02-15T11:17:04.790

不幸的是，没有。我要么不得不使用解决方法：

我将复合 ID 用于视图（！不是表），其中行可以由 2 个列（A，B）精确标识。尽管其中一个列 (B) 可以具有空值以及正整数。所以我的解决方法是我在视图中创建了一个新的 col：“BKey”并且我的视图被写成 B 为空，那么 BKey 的值为 -1，否则 BKey = B。（只有正整数出现在 B 和空）。我还更改了我的合成 id 实现以使用 BKey 而不是 B。希望它对某人有所帮助..

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-16T10:12:21.173

这是不可取的。您可以使用视图和地图来代替吗？如果您遇到遗留数据，您可以使用 COALESCE 提供默认值。我们在使用复合键时遇到了很多麻烦，我想空值会导致更多问题。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T10:16:47.870

对于复合键（假设数据库允许 PK 中的空值），您最多可以有 number_of_cols^2 - 1 个包含空值的条目（例如，对于 2 列的复合键，您可以有 3 行的主键为空，第四个是PK 没有空值）。

* * *

## 回答 #6

> 赞同：-1
> 
> 时间：2008-09-16T10:10:57.587

你为什么想这么做？您的复合 ID 应该映射表的主键，将空值放在键中听起来并不明智，是吗？

**编辑：**休眠不允许这样做；您可以将属性放在键之外并稍微调整 DAO 以在必要时考虑该字段

# internet-explorer - Vista/Server 2008 上缺少 WMI 命名空间

> ID：70917
> 
> 赞同：2
> 
> 时间：2008-09-16T10:09:10.900
> 
> 标签：internet-explorer, namespaces, wmi

什么相当于 Vista/Server 2008 上的 root\CIMV2\Applications\MicrosoftIE 命名空间？

root\cimv2\Applications\MicrosoftIE 命名空间至少可以追溯到 Internet Explorer 5.00.2920.0000，它恰好是 Windows 2000 附带的 Internet Explorer 版本，但看起来它已从 Vista/Server 2008 中删除。

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2008-09-18T12:17:22.447

它已经不存在了，但是它控制的很多东西都被移到了注册表中，你到底想做什么？

# excel - 使用宏刷新我的 excel 工作簿中的所有数据透视表

> ID：70947
> 
> 赞同：91
> 
> 时间：2008-09-16T10:14:20.450
> 
> 标签：excel, vba, refresh

我有一个包含 20 个不同数据透视表的工作簿。有什么简单的方法可以找到所有数据透视表并在 VBA 中刷新它们？

* * *

## 回答 #1

> 赞同：185
> 
> 时间：2008-09-16T10:18:52.013

是的。

```
ThisWorkbook.RefreshAll 
```

或者，如果您的 Excel 版本足够旧，

```
Dim Sheet as WorkSheet, Pivot as PivotTable
For Each Sheet in ThisWorkbook.WorkSheets
    For Each Pivot in Sheet.PivotTables
        Pivot.RefreshTable
        Pivot.Update
    Next
Next 
```

* * *

## 回答 #2

> 赞同：29
> 
> 时间：2008-09-16T10:37:07.133

此 VBA 代码将刷新工作簿中的所有数据透视表/图表。

```
Sub RefreshAllPivotTables()

Dim PT As PivotTable
Dim WS As Worksheet

    For Each WS In ThisWorkbook.Worksheets

        For Each PT In WS.PivotTables
          PT.RefreshTable
        Next PT

    Next WS

End Sub 
```

另一个非编程选项是：

*   右键单击每个数据透视表
*   选择表格选项
*   勾选**“打开时刷新”**选项。
*   点击确定按钮

这将在每次打开工作簿时刷新数据透视表。

* * *

## 回答 #3

> 赞同：20
> 
> 时间：2012-09-25T22:32:39.583

`ActiveWorkbook.RefreshAll`刷新一切，不仅是数据透视表，还有 ODBC 查询。我有几个引用数据连接的 VBA 查询，使用此选项会崩溃，因为命令运行数据连接时没有 VBA 提供的详细信息

如果您只想刷新枢轴，我推荐该选项

```
Sub RefreshPivotTables()     
  Dim pivotTable As PivotTable     
  For Each pivotTable In ActiveSheet.PivotTables         
    pivotTable.RefreshTable     
  Next 
End Sub 
```

* * *

## 回答 #4

> 赞同：8
> 
> 时间：2011-12-08T13:53:48.367

在某些情况下，您可能希望区分数据透视表和它的数据透视缓存。Cache 有自己的刷新方法和自己的集合。因此，我们可以刷新所有数据透视缓存而不是数据透视表。

区别？当您创建一个新的数据透视表时，系统会询问您是否希望它基于以前的表。如果您拒绝，则此数据透视表将获得自己的缓存并将源数据的大小翻倍。如果您同意，您的 WorkBook 将保持较小，但您会添加到共享单个缓存的数据透视表集合中。当您刷新该集合中的任何单个数据透视表时，整个集合都会刷新。因此，您可以想象刷新 WorkBook 中的每个缓存与刷新 WorkBook 中的每个数据透视表之间可能有什么区别。

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2008-12-11T12:49:46.887

数据透视表工具栏中有一个全部刷新选项。足够了。不必做任何其他事情。

按 ctrl+alt+F5

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-16T10:22:35.687

您在 VB*工作表*对象上有一个*数据透视*表集合。因此，像这样的快速循环将起作用：

 *```
Sub RefreshPivotTables()
    Dim pivotTable As PivotTable
    For Each pivotTable In ActiveSheet.PivotTables
        pivotTable.RefreshTable
    Next
End Sub 
```

战壕笔记：

1.  请记住在更新数据透视表之前取消保护任何受保护的工作表。
2.  **经常保存**。
3.  我会考虑更多并在适当的时候更新...... :)

祝你好运！

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2015-04-06T15:24:00.637

编码

```
Private Sub Worksheet_Activate()
    Dim PvtTbl As PivotTable
        Cells.EntireColumn.AutoFit
        For Each PvtTbl In Worksheets("Sales Details").PivotTables
        PvtTbl.RefreshTable
        Next
End Sub 
```

工作正常。

该代码用于激活工作表模块，因此在激活工作表时会显示闪烁/故障。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2015-12-31T09:26:05.457

甚至**我们可以刷新特定的连接**，反过来它会刷新所有链接到它的枢轴。

**对于此代码，我从 Excel 中的表创建了切片器**：

```
Sub UpdateConnection()
        Dim ServerName As String
        Dim ServerNameRaw As String
        Dim CubeName As String
        Dim CubeNameRaw As String
        Dim ConnectionString As String

        ServerNameRaw = ActiveWorkbook.SlicerCaches("Slicer_ServerName").VisibleSlicerItemsList(1)
        ServerName = Replace(Split(ServerNameRaw, "[")(3), "]", "")

        CubeNameRaw = ActiveWorkbook.SlicerCaches("Slicer_CubeName").VisibleSlicerItemsList(1)
        CubeName = Replace(Split(CubeNameRaw, "[")(3), "]", "")

        If CubeName = "All" Or ServerName = "All" Then
            MsgBox "Please Select One Cube and Server Name", vbOKOnly, "Slicer Info"
        Else
            ConnectionString = GetConnectionString(ServerName, CubeName)
            UpdateAllQueryTableConnections ConnectionString, CubeName
        End If
    End Sub

    Function GetConnectionString(ServerName As String, CubeName As String)
        Dim result As String
        result = "OLEDB;Provider=MSOLAP.5;Integrated Security=SSPI;Persist Security Info=True;Initial Catalog=" & CubeName & ";Data Source=" & ServerName & ";MDX Compatibility=1;Safety Options=2;MDX Missing Member Mode=Error;Update Isolation Level=2"
        '"OLEDB;Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=True;Initial Catalog=" & CubeName & ";Data Source=" & ServerName & ";Use Procedure for Prepare=1;Auto Translate=True;Packet Size=4096;Use Encryption for Data=False;Tag with column collation when possible=False"
        GetConnectionString = result
    End Function

    Function GetConnectionString(ServerName As String, CubeName As String)
    Dim result As String
    result = "OLEDB;Provider=MSOLAP.5;Integrated Security=SSPI;Persist Security Info=True;Initial Catalog=" & CubeName & ";Data Source=" & ServerName & ";MDX Compatibility=1;Safety Options=2;MDX Missing Member Mode=Error;Update Isolation Level=2"
    GetConnectionString = result
End Function

Sub UpdateAllQueryTableConnections(ConnectionString As String, CubeName As String)
    Dim cn As WorkbookConnection
    Dim oledbCn As OLEDBConnection
    Dim Count As Integer, i As Integer
    Dim DBName As String
    DBName = "Initial Catalog=" + CubeName

    Count = 0
    For Each cn In ThisWorkbook.Connections
        If cn.Name = "ThisWorkbookDataModel" Then
            Exit For
        End If

        oTmp = Split(cn.OLEDBConnection.Connection, ";")
        For i = 0 To UBound(oTmp) - 1
            If InStr(1, oTmp(i), DBName, vbTextCompare) = 1 Then
                Set oledbCn = cn.OLEDBConnection
                oledbCn.SavePassword = True
                oledbCn.Connection = ConnectionString
                oledbCn.Refresh
                Count = Count + 1
            End If
        Next
    Next

    If Count = 0 Then
         MsgBox "Nothing to update", vbOKOnly, "Update Connection"
    ElseIf Count > 0 Then
        MsgBox "Update & Refresh Connection Successfully", vbOKOnly, "Update Connection"
    End If
End Sub 
```

* * *

## 回答 #9

> 赞同：-2
> 
> 时间：2012-09-18T14:13:03.497

我最近使用过下面列出的命令，它似乎工作正常。

```
ActiveWorkbook.RefreshAll 
```

希望有帮助。

* * *

## 回答 #10

> 赞同：-3
> 
> 时间：2012-05-03T15:35:17.090

如果您使用的是 MS Excel 2003，请转到查看->工具栏->数据透视表 在此工具栏中，我们可以通过单击来进行刷新！这个符号。

# .net - Exclude certain pages from using a HTTPModule

> ID：70956
> 
> 赞同：16
> 
> 时间：2008-09-16T10:15:35.063
> 
> 标签：.net, asp.net

Is there a good way to exclude certain pages from using a HTTP module?

I have an application that uses a custom HTTP module to validate a session. The HTTPModule is set up like this in web config:

```
<system.web>
  <!-- ... -->
  <httpModules>
    <add name="SessionValidationModule"
       type="SessionValidationModule, SomeNamespace" />
  </httpModules>
</system.web> 
```

To exclude the module from the page, I tried doing this (without success):

```
<location path="ToBeExcluded">
  <system.web>
    <!-- ... -->
    <httpModules>
      <remove name="SessionValidationModule" />
    </httpModules>
  </system.web>
</location> 
```

Any thoughts?

* * *

## 回答 #1

> 赞同：14
> 
> 时间：2008-09-16T14:20:55.367

HttpModules attach to the ASP.NET request processing pipeline itself. The httpModule itself must take care of figuring out which requests it wants to act on and which requests it wants to ignore.

This can, for example, be achieved by looking at the context.Request.Path property.

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2008-09-16T12:42:45.443

You could use an HTTPHandler instead of an HTTPModule. Handlers let you specify a path when you declare them in Web.Config.

```
<add verb="*" path="/validate/*.aspx" type="Handler,Assembly"/> 
```

If you must use an HTTPModule, you could just check the path of the request and if it's one to be excluded, bypass the validation.

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2013-08-23T20:21:54.473

Here is some simple example how to filter requests by extension... the example below exclude from the processing files with the specific extensions. Filtering by file name will look almost the same with some small changes...

```
public class AuthenticationModule : IHttpModule
{
    private static readonly List<string> extensionsToSkip = AuthenticationConfig.ExtensionsToSkip.Split('|').ToList();

    // In the Init function, register for HttpApplication 
    // events by adding your handlers.
    public void Init(HttpApplication application)
    {
        application.BeginRequest += new EventHandler(this.Application_BeginRequest);
        application.EndRequest += new EventHandler(this.Application_EndRequest);
    }

    private void Application_BeginRequest(Object source, EventArgs e)
    {
        //  we don't have to process all requests...
        if (extensionsToSkip.Contains(Path.GetExtension(HttpContext.Current.Request.Url.LocalPath)))
            return;

        Trace.WriteLine("Application_BeginRequest: " + HttpContext.Current.Request.Url.AbsoluteUri);
    }

    private void Application_EndRequest(Object source, EventArgs e)
    {
        //  we don't have to process all requests...
        if (extensionsToSkip.Contains(Path.GetExtension(HttpContext.Current.Request.Url.LocalPath)))
            return;

        Trace.WriteLine("Application_BeginRequest: " + HttpContext.Current.Request.Url.AbsoluteUri);
    }
} 
```

General idea is to specify in config file what exactly should be processed (or excluded from the processing) and use that config parameter in the module.

# java - 确定日期夏令时的算法？

> ID：70964
> 
> 赞同：2
> 
> 时间：2008-09-16T10:16:35.467
> 
> 标签：java, actionscript

最初我在 Actionscript 中寻找解决方案。这个问题的重点是算法，当时钟必须切换夏令时时，它会检测精确的分钟。

因此，例如在 10 月 25 日到 31 日之间，我们必须检查，如果实际日期是星期天，是在 2 点之前还是之后......

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-30T20:08:41.553

没有真正的算法来处理夏令时。基本上每个国家都可以自行决定 DST 何时开始和结束。作为开发人员，我们唯一能做的就是使用某种表格来查找它。大多数计算机语言都在语言中集成了这样的表格。

在 Java 中，您可以使用[TimeZone](http://java.sun.com/javase/6/docs/api/java/util/TimeZone.html)类的`inDaylightTime`方法。如果您想知道特定年份 DST 开始或结束的确切日期和时间，我建议使用[Joda Time](http://joda-time.sourceforge.net/)。我看不到仅使用标准库来找出这一点的干净方法。

以下程序是一个示例：（请注意，如果某个时区在某年没有 DST，它可能会产生意想不到的结果）

```
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;

public class App {
    public static void main(String[] args) {
        DateTimeZone dtz = DateTimeZone.forID("Europe/Amsterdam");

        System.out.println(startDST(dtz, 2008));
        System.out.println(endDST(dtz, 2008));
    }

    public static DateTime startDST(DateTimeZone zone, int year) {
        return new DateTime(zone.nextTransition(new DateTime(year, 1, 1, 0, 0, 0, 0, zone).getMillis()));
    }

    public static DateTime endDST(DateTimeZone zone, int year) {
        return new DateTime(zone.previousTransition(new DateTime(year + 1, 1, 1, 0, 0, 0, 0, zone).getMillis()));
    }
} 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2018-05-24T00:08:29.213

# java - Hibernate（JPA）如何进行急切查询，加载所有子对象

> ID：70992
> 
> 赞同：20
> 
> 时间：2008-09-16T10:21:47.983
> 
> 标签：java, hibernate, jpa, ejbql

关于我[之前的问题](https://stackoverflow.com/questions/48733/javahibernate-jpa-designing-the-server-data-reload)，我想确保加载所有子对象，因为我有多个线程可能需要访问数据（从而避免延迟加载异常）。我知道这样做的方法是在查询（EJB QL）中使用“fetch”关键字。像这样：

```
select distinct o from Order o left join fetch o.orderLines 
```

假设一个模型有一个`Order`类，其中有一组`OrderLines`。

我的问题是似乎需要“distinct”关键字，否则我似乎会得到一个`Order`for each `OrderLine`。我在做正确的事吗？

也许更重要的是，有没有办法拉入所有子对象，无论多深？我们有大约 10-15 个类，对于服务器，我们需要加载所有内容......我避免使用`FetchType.EAGER`，因为这意味着它总是渴望，特别是 Web 前端加载所有内容 - 但也许这是要走的路 - 是你做什么？我似乎记得我们之前尝试过这个然后得到非常慢的网页 - 但这也许意味着我们应该使用二级缓存？

* * *

## 回答 #1

> 赞同：15
> 
> 时间：2008-09-16T11:50:07.303

更改注释是 IMO 的一个坏主意。因为它不能在运行时更改为惰性。最好让一切都变得懒惰，并根据需要获取。

如果没有映射，我不确定我是否理解您的问题。对于您描述的用例，左连接提取应该是您所需要的。当然，如果 orderline 有一个订单作为其父级，您将获得每个 orderline 的订单。

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2008-09-16T10:53:51.197

我不确定在您的 EJBQL 中使用 fetch 关键字，您可能会将它与注释混淆......

您是否尝试将 FetchType 属性添加到您的关系属性？

@OneToMany(fetch=FetchType.EAGER)？

看：

[http://java.sun.com/javaee/5/docs/api/javax/persistence/FetchType.html](http://java.sun.com/javaee/5/docs/api/javax/persistence/FetchType.html) [http://www.jroller.com/eyallupu/entry/hibernate_exception_simultaneously_fetch_multiple](http://www.jroller.com/eyallupu/entry/hibernate_exception_simultaneously_fetch_multiple)

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-22T22:34:23.907

您是否尝试过使用结果转换器？如果您使用 Criteria 查询，则可以应用结果转换器（尽管[分页和结果转换器存在一些问题](http://www.jroller.com/RickHigh/entry/hibernate_query_getting_rid_of)）：

```
Criteria c = ((Session)em.getDelegate()).createCriteria(Order.class);
c.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);
c.list(); 
```

这`em.getDelegate()`是一个只有在你使用hibernate时才有效的hack。

> 也许更重要的是，有没有办法拉入所有子对象，无论多深？我们有大约 10-15 个类，对于服务器，我们需要加载所有内容......我避免使用 FetchType.EAGER，因为这意味着它总是渴望，特别是 Web 前端加载所有内容 - 但也许这就是要走的路- 那是你做的吗？我似乎记得我们之前尝试过这个然后得到非常慢的网页 - 但这也许意味着我们应该使用二级缓存？

如果您仍然感兴趣，我在这个线程[如何序列化休眠集合](https://stackoverflow.com/questions/182323/how-to-serialize-hibernate-collections-properly#182955)中回答了一个类似的问题。

Basically you use a utility called [dozer](http://dozer.sf.net) that maps beans onto another beans, and by doing this you trigger all your lazy loads. As you can imagine, this works better if all collections are eagerly fetched.

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-16T18:28:08.360

您可以使用（分离的）条件查询并设置获取模式来执行类似的操作。例如，

```
Session s = ((HibernateEntityManager) em).getSession().getSessionFactory().openSession();
DetachedCriteria dc = DetachedCriteria.forClass(MyEntity.class).add(Expression.idEq(id));
dc.setFetchMode("innerTable", FetchMode.JOIN);
Criteria c = dc.getExecutableCriteria(s);
MyEntity a = (MyEntity)c.uniqueResult(); 
```

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-16T11:18:03.667

这仅适用于 ManyToOne 关系，对他们来说 @ManyToOne(fetch=FetchType.EAGER) 可能合适。

不鼓励急切地获取多个 OneToMany 关系和/或不起作用，正如您可以在 Jeremy 发布的链接中看到的那样。想想执行这样的提取所需的 SQL 语句......

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-16T14:58:00.020

我所做的是重构代码以将对象映射到实体管理器，并且每次我需要刷新时，关闭对象的旧实体管理器并打开一个新的。**我使用了没有获取**的上述查询，因为这对我的需要来说太深了——只是在 OrderLines 中做一个简单的连接——**获取**使它变得更深。

只有少数几个对象需要这个，大约 20 个，所以我认为拥有 20 个开放实体管理器的资源开销不是问题——尽管当它上线时 DBA 可能会有不同的看法......

我还重新设计了一些东西，以便数据库工作在主线程上并具有实体管理器。

克里斯

* * *

## 回答 #7

> 赞同：-4
> 
> 时间：2008-09-16T16:34:22.300

如果问题只是 LazyInitializationExceptions，您可以通过添加 OpenSessionInViewFilter 来避免这种情况。
这将允许在视图中加载对象，但无助于速度问题。

```
 <filter>
        <filter-name>hibernateFilter</filter-name>
        <filter-class> org.springframework.orm.hibernate3.support.OpenSessionInViewFilter
        </filter-class>
    </filter>
    <filter-mapping>
        <filter-name>hibernateFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping> 
```

# testing - 测试梯形逻辑

> ID：70993
> 
> 赞同：10
> 
> 时间：2008-09-16T10:21:50.777
> 
> 标签：testing, logic, plc

我们都知道测试 OO 系统的各种方法。但是，看起来我将要做一个项目，我将在其中处理 PLC 梯形逻辑（不要问：/），我想知道是否有测试系统有效性的好方法。

到目前为止，我看到的唯一方法就是简单地构建一个巨大的表，其中包含系统的所有已知状态以及生成的输出状态。这适用于简单的“如果输入 A 打开，则打开输出 B”的情况。不过，我认为这不适用于更复杂的结构。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-16T10:41:08.060

IC 设计领域中“逻辑”系统的验证称为“设计验证”，这是确保您在硬件 (RTL) 中设计的系统实现所需功能的过程。

梯形逻辑可以转换为现代 HDL 之一，例如 Verilog .. 转换每个梯形图

```
|---|R15|---+---|/R16|---------(R18)--------|
|           |
|---|R12|---+ 
```

像这样的表达

```
always @(*) R18 = !R16 && ( R15 | R12); 
```

或者您可以使用分配语句

```
assign R18 = R16 && (R15 | R12); 
```

闭锁继电器

```
assign R18 = (set condition) || R18 && !(break condition); 
```

然后使用像[Icarus](http://www.icarus.com/eda/verilog/)这样的免费 verilog 模拟器来开发测试平台并测试您的系统。确保您的测试用例能够很好地覆盖您的逻辑！如果您的梯形图编辑软件为您提供了不错的命名功能，请使用它们，而不是 Rnn。

（注意：在用于 PLC 约定的梯形逻辑中，Rnn 用于内部继电器，而 Xnn 是输入，Ynn 是输出，可以从在线教程之一快速收集。

Verilog 将是一种更容易用于开发测试和测试平台的语言！

在某些单元延迟中进行编程可能会有所帮助。

抱歉，我从来没有在 Verilog 翻译器之间寻找梯形逻辑。但在我那个时代，梯形逻辑只是被放入计算机中用于编程 PLC - 我使用的大多数继电器系统都是真正的继电器，连接到机柜中！ ！

祝你好运。jbd

有几个梯形逻辑编辑器（带有模拟器）是免费的。这是一个在 Windows 上运行的软件：

[http://cq.cx/ladder.pl](http://cq.cx/ladder.pl)

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2009-09-02T04:22:10.960

我们已经对 Rockwell Control Logix 控制器的测试覆盖率工具进行了试验。大多数过程语言测试覆盖工具都进行分支覆盖或类似的操作；因为 Relay Ladder Logic 通常不分支，所以这不能很好地工作。

我们的原型是用于 Rockwell 控制器的 RLL 代码的[MC/DC](http://en.wikipedia.org/wiki/Modified_Condition/Decision_Coverage)（修改/条件/决策覆盖）。这告诉了梯级中的每个条件，该条件是否已被测试为 TRUE，测试为 FALSE，更重要的是，如果在某些测试下，条件控制了梯级中决策的输出（至少是由决策控制的动作）在真方向和假方向上。

[这项工作是使用称为DMS](http://www.semanticdesigns.com/Products/DMS/DMSToolkit.html)的通用程序分析和转换工具完成的，该工具 用于为 RLL 代码配备额外的逻辑以收集必要的数据。

您仍然需要编写单元测试代码。最简单的方法是让另一个 PLC 作为您要控制的机械硬件的替代品，然后简单地编写另一个 RLL 程序来运行第一个程序。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2009-03-28T16:52:33.443

有一个叫做 LogixPro 的程序，它有一个梯形逻辑的 IO 模拟器，你可以试试。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2011-09-29T01:08:23.333

有时在小型 PLC 程序中，项目中会编写一个测试程序（或子程序，或梯形图文件），该程序仅在项目被仿真时运行。该文件有一些简单的逻辑，即当输出通电时，打开与反馈相关的输入。然后，您可以通过连接到它的任何 HMI 来控制您的 PLC，并查看代码的行为是否符合预期。当软件下载到真实站点时禁用或删除测试程序非常重要，因为它可以在现实世界中做一些非常奇怪的事情。

在较大的项目中，每个设备都有一个模拟模式，其功能略有相似。[http://www.batchcontrol.com/s88/01_tutorial/06-modules.shtml](http://www.batchcontrol.com/s88/01_tutorial/06-modules.shtml)

这与使用面向 OO 语言的测试框架完全不同，但我还没有真正看到任何针对 PLC 的测试驱动开发，甚至还没有看到很多自动化测试。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2019-06-10T22:33:00.207

我的老板经常告诉我，测试是建立在逻辑本身中的。PLC 实际上是确定性的，因此您实际上应该能够遵循逻辑而不需要模拟测试。然而我们并不完美。拥有框架实际上只会让我们逐步了解我们已经知道的内容，梯形逻辑实际上只是需要练习才能了解 PLCS 的工作原理。

话虽如此，我制作的一个程序确实取得了一些成功，该程序基本上可以打开和关闭 IO ，它甚至可以模拟编码器的计数来测试物体到达某个位置时会发生什么。它们是断言语句，可能会被触发并告诉我我的逻辑错误在哪里。它确实捕获了一些错误，并且对于我从未接触过的系统而言，该实现非常顺利。它本身是非常有益的，我确实认为它可能很有用，但我已经好多了，所以我发现自己不需要它，因为我的经验。***********************************