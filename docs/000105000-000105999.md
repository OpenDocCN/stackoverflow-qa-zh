# StackOverflow 问答 000105000-000105999

# wordpress - 应该如何构建博客以轻松提取其数据？

> ID：105000
> 
> 赞同：0
> 
> 时间：2008-09-19T19:55:49.677
> 
> 标签：wordpress, data-structures, blogs

我目前正在使用 Wordpress 来运行我的网站。然而，随着每个新版本的发布，我越来越关心软件膨胀和用于存储数据的复杂表结构。也许这是徒劳的追求。功能总是被添加到博客软件中，直到它声称是一个 CMS——那时你的数据可能会被卡住。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-20T10:13:42.500

I also sometimes worry about the large changes WordPress undergoes.

However, since all the important data (the posts themselves and the comments) are stored in a database, it does not seem difficult to extract them in case of need (moving to a different system, or just backup). Even if the table structure gets more complex, the MySQL DB WordPress uses is easy to access and extract data from.

I'm sure that it is easy to find such extractors freely floating in the web.

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-24T20:52:49.840

Wordpress 具有“导出”功能。它下载大部分数据，例如 XML 文件中的帖子、页面和评论。这些 XML 文件可以导入到其他 Wordpress 安装中。

您还可以创建一个简单的导入器来将该数据导入其他位置。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T20:15:09.300

您确实可以选择坚持使用 2.0 分支。这将在 2010 年之前仅通过错误修复来维护。看看[http://wordpress.org/download/legacy/](http://wordpress.org/download/legacy/)

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-29T17:01:52.150

以前的答案都没有真正解决这个问题的标题。

应该如何为博客构建表格？老实说，这完全取决于你想用它做什么。

一种方法可能是有一个帖子表和一个评论表。帖子表可以包含标题、内容、日期和帖子 ID。评论表可以有一个帖子 id、评论 id、评论者注释和内容。

但这只有在您自己构建时才有意义。我所见过的博客工具在空间使用方面都不是非常低效的，它们都提供从“标准”格式（从博客、wordpress、moveabletype 等到其他任何地方）的导入工具。并且不要忘记他们都将通过 RSS 发布帖子和评论，这使得它们非常便携。

尤其是 WordPress，tar.gz 文件仍然只有 1.2 MB。如果这足以担心臃肿，我强烈建议您自己构建一个，或者转移到托管的博客平台:)

# unit-testing - 我应该测试私有方法还是只测试公共方法？

> ID：105007
> 
> 赞同：380
> 
> 时间：2008-09-19T19:56:20.517
> 
> 标签：unit-testing, testing, language-agnostic

我已经阅读[了这篇](https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods)关于如何测试私有方法的文章。我通常不测试它们，因为我一直认为只测试将从对象外部调用的公共方法会更快。你测试私有方法吗？我应该总是测试它们吗？

* * *

## 回答 #1

> 赞同：361
> 
> 时间：2008-09-19T19:59:01.697

我不对私有方法进行单元测试。私有方法是一个实现细节，应该对类的用户隐藏。测试私有方法会破坏封装。

如果我发现私有方法非常庞大、复杂或重要到需要它自己的测试，我只需将它放在另一个类中并在那里公开（[方法对象](http://www.refactoring.com/catalog/replaceMethodWithMethodObject.html)）。然后我可以轻松地测试现在存在于自己的类中的以前私有但现在公共的方法。

* * *

## 回答 #2

> 赞同：318
> 
> 时间：2008-09-19T20:19:43.267

测试的目的是什么？

到目前为止，大多数答案都是说私有方法是实现细节，只要公共接口经过良好测试和工作，它们就不会（或至少不应该）重要。*如果您测试的唯一目的是保证公共接口正常工作，*那绝对正确。

就个人而言，我对代码测试的主要用途是确保将来的代码更改不会引起问题，并在出现问题时帮助我的调试工作。我发现测试私有方法和公共接口一样彻底（如果不是更多的话！）进一步实现了这一目的。

考虑：您有一个调用私有方法 B 的公共方法 A。A 和 B 都使用方法 C。C 被更改（可能由您更改，也可能由供应商更改），导致 A 开始无法通过测试。对 B 进行测试不是很有用吗，即使它是私有的，以便您知道问题是出在 A 对 C 的使用、B 对 C 的使用，还是两者兼而有之？

在公共接口的测试覆盖不完整的情况下，测试私有方法也会增加价值。虽然这是我们通常希望避免的情况，但效率单元测试取决于发现错误的测试以及这些测试的相关开发和维护成本。在某些情况下，100% 测试覆盖率的好处可能被认为不足以保证这些测试的成本，从而在公共接口的测试覆盖率中产生差距。在这种情况下，对私有方法进行有针对性的测试可能是对代码库的非常有效的补充。

* * *

## 回答 #3

> 赞同：159
> 
> 时间：2008-09-19T20:03:36.787

我倾向于遵循 Dave Thomas 和 Andy Hunt 在他们的《*实用单元测试*》一书中的建议：

> 一般来说，你不想为了测试而破坏任何封装（或者就像妈妈过去常说的，“不要暴露你的隐私！”）。大多数时候，您应该能够通过执行其公共方法来测试一个类。如果有重要的功能隐藏在私有或受保护的访问之后，那可能是一个警告信号，表明那里有另一个班级正在努力摆脱。

但有时我无法阻止自己测试私有方法，因为它让我确信我正在构建一个*完全*健壮的程序。

* * *

## 回答 #4

> 赞同：72
> 
> 时间：2017-11-20T21:03:10.670

我不喜欢测试私有功能有几个原因。它们如下（这些是 TLDR 人员的要点）：

1.  通常，当您想测试一个类的私有方法时，这是一种设计味道。
2.  您可以通过公共接口测试它们（这是您想要测试它们的方式，因为这是客户端调用/使用它们的方式）。通过查看私有方法的所有通过测试的绿灯，您可能会产生错误的安全感。通过公共接口在私有函数上测试边缘案例会更好/更安全。
3.  通过测试私有方法，您冒着严重的测试重复（看起来/感觉非常相似的测试）的风险。当需求发生变化时，这会产生重大影响，因为过多的测试会中断。它还可能使您处于由于您的测试套件而难以重构的位置……这是最大的讽刺，因为测试套件可以帮助您安全地重新设计和重构！

我将用一个具体的例子来解释这些。事实证明 2) 和 3) 有一些错综复杂的联系，所以它们的例子是相似的，尽管我认为它们是你不应该测试私有方法的不同原因。

有时测试私有方法是合适的，重要的是要注意上面列出的缺点。稍后我将更详细地讨论它。

我还讨论了为什么 TDD 不是最后测试私有方法的有效借口。

## **从糟糕的设计中重构你的出路**

我看到的最常见的（反）模式之一是**Michael Feathers**所说**的“冰山”课程**（如果您不知道 Michael Feathers 是谁，请购买/阅读他的书“有效地使用旧代码”。他是如果您是专业的软件工程师/开发人员，值得了解的人）。还有其他（反）模式会导致此问题出现，但这是迄今为止我偶然发现的最常见的模式。“冰山”类有一个公共方法，其余的都是私有的（这就是为什么很想测试私有方法的原因）。它之所以被称为“冰山”类，是因为通常会出现一个单独的公共方法，但其余功能以私有方法的形式隐藏在水下。

[![规则评估器](https://i.stack.imgur.com/h0RZH.png)](https://i.stack.imgur.com/h0RZH.png)

例如，您可能希望`GetNextToken()`通过连续在字符串上调用它并查看它返回预期结果来进行测试。像这样的函数确实需要进行测试：这种行为并非微不足道，尤其是在您的标记化规则很复杂的情况下。让我们假设它没有那么复杂，我们只是想用空格分隔标记。所以你写了一个测试，也许它看起来像这样（一些语言不可知的伪代码，希望这个想法很清楚）：

```
TEST_THAT(RuleEvaluator, canParseSpaceDelimtedTokens)
{
    input_string = "1 2 test bar"
    re = RuleEvaluator(input_string);

    ASSERT re.GetNextToken() IS "1";
    ASSERT re.GetNextToken() IS "2";
    ASSERT re.GetNextToken() IS "test";
    ASSERT re.GetNextToken() IS "bar";
    ASSERT re.HasMoreTokens() IS FALSE;
} 
```

嗯，这实际上看起来很不错。我们希望确保在进行更改时保持这种行为。但是`GetNextToken()`是*私有*函数！所以我们不能像这样测试它，*因为它甚至不会编译*（假设我们使用的是一些实际上强制公共/私有的语言，不像 Python 这样的脚本语言）。但是改变`RuleEvaluator`类来遵循单一职责原则（Single Responsibility Principle）呢？例如，我们似乎将解析器、标记器和评估器塞进了一个类。把这些责任分开不是更好吗？最重要的是，如果您创建一个`Tokenizer`类，那么它的公共方法将是`HasMoreTokens()`and `GetNextTokens()`。该类`RuleEvaluator`可以有一个`Tokenizer`对象作为成员。现在，我们可以保持与上面相同的测试，只是我们测试的是`Tokenizer`类而不是`RuleEvaluator`类。

下面是它在 UML 中的样子：

[![规则评估器重构](https://i.stack.imgur.com/g1G9o.png)](https://i.stack.imgur.com/g1G9o.png)

请注意，这种新设计增加了模块化，因此您可以在系统的其他部分重用这些类（在不能重用之前，私有方法根​​据定义是不可重用的）。这是分解 RuleEvaluator 的主要优势，同时增加了可理解性/局部性。

测试看起来非常相似，只是这次它实际上会编译，因为该`GetNextToken()`方法现在在`Tokenizer`类上是公共的：

```
TEST_THAT(Tokenizer, canParseSpaceDelimtedTokens)
{
    input_string = "1 2 test bar"
    tokenizer = Tokenizer(input_string);

    ASSERT tokenizer.GetNextToken() IS "1";
    ASSERT tokenizer.GetNextToken() IS "2";
    ASSERT tokenizer.GetNextToken() IS "test";
    ASSERT tokenizer.GetNextToken() IS "bar";
    ASSERT tokenizer.HasMoreTokens() IS FALSE;
} 
```

## **通过公共接口测试私有组件，避免重复测试**

即使您认为不能将问题分解为更少的模块化组件（如果您*尝试*这样做，95% 的时间都可以），您也可以通过公共接口简单地测试私有函数。很多时候私有成员不值得测试，因为它们将通过公共接口进行测试。很多时候，我看到的是看起来*非常*相似的测试，但测试的是两种不同的功能/方法。最终发生的情况是，当需求发生变化时（而且它们总是如此），您现在有 2 个损坏的测试而不是 1 个。如果您真的测试了所有私有方法，您可能会有更多的 10 个损坏的测试而不是 1 个**。简而言之，测试私有函数（通过使用`FRIEND_TEST`或将它们公开或使用反射）否则可以通过公共接口进行测试可能会导致测试重复**。你真的不想要这个，因为没有什么比你的测试套件减慢你的速度更伤人的了。它应该减少开发时间并降低维护成本！如果您测试通过公共接口测试的私有方法，测试套件可能会做相反的事情，并积极增加维护成本并增加开发时间。当您将私有函数公开时，或者如果您使用类似`FRIEND_TEST`和/或反射之类的东西，从长远来看，您通常最终会后悔。

考虑该类的以下可能实现`Tokenizer`：

[![在此处输入图像描述](https://i.stack.imgur.com/Tbjqy.png)](https://i.stack.imgur.com/Tbjqy.png)

假设它`SplitUpByDelimiter()`负责返回一个数组，使得数组中的每个元素都是一个标记。此外，我们只是说这`GetNextToken()`只是这个向量的迭代器。因此，您的公开测试可能如下所示：

```
TEST_THAT(Tokenizer, canParseSpaceDelimtedTokens)
{
    input_string = "1 2 test bar"
    tokenizer = Tokenizer(input_string);

    ASSERT tokenizer.GetNextToken() IS "1";
    ASSERT tokenizer.GetNextToken() IS "2";
    ASSERT tokenizer.GetNextToken() IS "test";
    ASSERT tokenizer.GetNextToken() IS "bar";
    ASSERT tokenizer.HasMoreTokens() IS false;
} 
```

让我们假设我们拥有 Michael Feather 所说的**探索工具**。这是一个可以让您触摸他人私处的工具。一个例子`FRIEND_TEST`来自 googletest，如果语言支持，则为反射。

```
TEST_THAT(TokenizerTest, canGenerateSpaceDelimtedTokens)
{
    input_string = "1 2 test bar"
    tokenizer = Tokenizer(input_string);
    result_array = tokenizer.SplitUpByDelimiter(" ");

    ASSERT result.size() IS 4;
    ASSERT result[0] IS "1";
    ASSERT result[1] IS "2";
    ASSERT result[2] IS "test";
    ASSERT result[3] IS "bar";
} 
```

好吧，现在假设需求发生了变化，并且标记化变得更加复杂。您认为一个简单的字符串定界符是不够的，您需要一个`Delimiter`类来处理这项工作。自然地，您会期望一个测试会失败，但是当您测试私有函数时，这种痛苦会增加。

## 什么时候可以测试私有方法是合适的？

软件中没有“一刀切”。有时“打破规则”是可以的（实际上是理想的）。我强烈主张尽可能不要测试私有功能。我认为可以的主要有两种情况：

1.  我与遗留系统进行了广泛的合作（这就是为什么我是 Michael Feathers 的忠实粉丝），我可以肯定地说，有时只测试私有功能是最安全的。这对于将“表征测试”纳入基线特别有帮助。

2.  你很着急，必须在此时此地做尽可能快的事情。从长远来看，您不想测试私有方法。但我会说，通常需要一些时间来重构以解决设计问题。有时您必须在一周内发货。没关系：如果您认为这是完成工作的最快和最可靠的方法，请使用摸索工具快速而肮脏地测试私有方法。但是请理解，从长远来看，您所做的事情并不理想，请考虑重新使用它（或者，如果它被遗忘但您稍后会看到它，请修复它）。

**可能还有其他情况可以。如果你认为这没问题，并且你有充分的理由，那就去做吧。没有人阻止你。请注意潜在的成本。**

## TDD 的借口

**顺便说一句，我真的不喜欢人们使用 TDD 作为测试私有方法的借口。**我练习 TDD，我不认为 TDD 强迫你这样做。您可以先编写测试（针对您的公共接口），然后编写代码来满足该接口。有时我为公共接口编写一个测试，我也会通过编写一两个较小的私有方法来满足它（但我不直接测试私有方法，但我知道它们可以工作，否则我的公共测试会失败）。如果我需要测试该私有方法的边缘案例，我将编写一大堆测试，这些测试将通过我的公共接口来处理它们。*如果您不知道如何应对边缘情况，这是一个强烈的信号，您需要将其重构为小组件，每个组件都有自己的公共方法。这表明您的私有函数做得太多，超出了 class 的范围*。

另外，有时我发现我写的测试现在太难咀嚼了，所以我想“嗯，当我有更多的 API 可以使用时，我会回到那个测试”（我'将其注释掉并保留在我的脑海中）。这就是我遇到的许多开发人员开始为他们的私有功能编写测试的地方，他们使用 TDD 作为替罪羊。他们说“哦，我需要一些其他测试，但是为了编写那个测试，我需要这些私有方法。因此，由于我不能不编写测试就编写任何生产代码，所以我需要编写一个测试用于私有方法。” 但是他们真正需要做的是重构更小的和可重用的组件，而不是向他们当前的类添加/测试一堆私有方法。

笔记：

[不久前，我回答了一个关于使用 GoogleTest 测试私有方法](https://stackoverflow.com/questions/47354280/what-is-the-best-way-of-testing-private-methods-with-googletest/47358700#47358700)的类似问题。我在这里大部分修改了这个答案，使其与语言无关。

PS这是Michael Feathers关于冰山课程和摸索工具的相关讲座：[https ://www.youtube.com/watch?v=4cVZvoFGJTU](https://www.youtube.com/watch?v=4cVZvoFGJTU)

* * *

## 回答 #5

> 赞同：64
> 
> 时间：2008-09-19T20:09:53.883

随着我在项目中越来越多地遵循我们最新的 QA 建议之一，我觉得有必要测试私有函数：

> 每个函数的[圈复杂度](http://en.wikipedia.org/wiki/Cyclomatic_complexity)不超过 10 。

现在执行这项政策的副作用是，我的许多非常大的公共功能被划分为许多更集中、更好命名的*私人*功能。
公共功能仍然存在（当然），但基本上被简化为调用所有那些私有“子功能”

这实际上很酷，因为调用堆栈现在更容易阅读（而不是大函数中的错误，我在子子函数中有一个错误，其中调用堆栈中先前函数的名称可以帮助我理解'我是如何到达那里'）

然而，现在似乎更容易直接对那些*私有*函数进行单元测试，并将大型公共函数的测试留给需要解决场景的某种“集成”测试。

只是我的2美分。

* * *

## 回答 #6

> 赞同：53
> 
> 时间：2011-08-30T07:15:33.667

是的，我确实测试了私有函数，因为尽管它们是由您的公共方法测试的，但在 TDD（测试驱动设计）中测试应用程序的最小部分是很好的。但是当您在测试单元类中时，无法访问私有函数。这是我们为测试私有方法所做的工作。

**为什么我们有私有方法？**

私有函数主要存在于我们的类中，因为我们想在我们的公共方法中创建可读的代码。我们不希望这个类的用户直接调用这些方法，而是通过我们的公共方法。此外，我们不想在扩展类时改变它们的行为（在受保护的情况下），因此它是私有的。

当我们编码时，我们使用测试驱动设计（TDD）。这意味着有时我们会偶然发现一个私有功能并想要测试。私有函数在 phpUnit 中不可测试，因为我们无法在 Test 类中访问它们（它们是私有的）。

**我们认为这里有 3 个解决方案：**

**1.您可以通过您的公共方法测试您的私人**

*好处*

*   简单的单元测试（不需要“黑客”）

*缺点*

*   程序员需要了解公共方法，而他只想测试私有方法
*   您没有测试应用程序的最小可测试部分

**2\. 如果 private 如此重要，那么为它创建一个新的单独类可能是一种代码味道**

*好处*

*   您可以将其重构为一个新类，因为如果它很重要，其他类可能也需要它
*   可测试单元现在是公共方法，因此可测试

*缺点*

*   如果不需要，您不想创建一个类，并且只由方法来自的类使用
*   由于额外开销而导致的潜在性能损失

**3.将访问修饰符更改为（final）protected**

*好处*

*   您正在测试应用程序的最小可测试部分。当使用 final protected 时，该函数不会被覆盖（就像一个私有的）
*   没有性能损失
*   没有额外的开销

*缺点*

*   您正在将私有访问更改为受保护，这意味着它的孩子可以访问它
*   您仍然需要在测试类中使用 Mock 类才能使用它

*例子*

```
class Detective {
  public function investigate() {}
  private function sleepWithSuspect($suspect) {}
}
Altered version:
class Detective {
  public function investigate() {}
  final protected function sleepWithSuspect($suspect) {}
}
In Test class:
class Mock_Detective extends Detective {

  public test_sleepWithSuspect($suspect) 
  {
    //this is now accessible, but still not overridable!
    $this->sleepWithSuspect($suspect);
  }
} 
```

所以我们的测试单元现在可以调用 test_sleepWithSuspect 来测试我们之前的私有函数。

* * *

## 回答 #7

> 赞同：26
> 
> 时间：2008-09-19T19:59:57.683

我认为最好只测试对象的公共接口。从外部世界的角度来看，只有公共接口的行为很重要，这就是你的单元测试应该针对的。

一旦你为一个对象编写了一些可靠的单元测试，你就不想仅仅因为接口背后的实现发生了变化而返回并更改这些测试。在这种情况下，您破坏了单元测试的一致性。

* * *

## 回答 #8

> 赞同：21
> 
> 时间：2008-09-19T20:04:21.963

如果您的私有方法没有通过调用您的公共方法进行测试，那么它在做什么？我说的是私人的，不受保护或朋友。

* * *

## 回答 #9

> 赞同：18
> 
> 时间：2008-09-19T20:04:47.343

如果私有方法定义良好（即，它具有可测试的功能并且不会随时间而改变），那么可以。我在有意义的地方测试所有可测试的东西。

例如，加密库可能会隐藏它使用私有方法执行块加密的事实，该私有方法一次仅加密 8 个字节。我会为此编写一个单元测试——它并不意味着改变，即使它是隐藏的，如果它确实坏了（例如，由于未来的性能增强），那么我想知道它是私有函数坏了，而不仅仅是其中一项公共职能遭到破坏。

它可以加速以后的调试。

-亚当

* * *

## 回答 #10

> 赞同：12
> 
> 时间：2008-09-19T20:00:05.407

我不是这个领域的专家，但单元测试应该测试行为，而不是实现。私有方法是严格实现的一部分，因此恕我直言，不应测试。

* * *

## 回答 #11

> 赞同：12
> 
> 时间：2009-11-16T17:08:44.903

如果您正在开发测试驱动 (TDD)，您将测试您的私有方法。

* * *

## 回答 #12

> 赞同：11
> 
> 时间：2008-09-19T20:02:05.993

我们通过推理测试私有方法，我的意思是我们寻找至少 95% 的总类测试覆盖率，但我们的测试只调用公共或内部方法。为了获得覆盖，我们需要根据可能发生的不同场景多次调用公共/内部人员。这使我们的测试更加专注于他们正在测试的代码的目的。

Trumpi 对您链接的帖子的回答是最好的。

* * *

## 回答 #13

> 赞同：9
> 
> 时间：2008-09-19T19:58:55.813

我相信单元测试是为了测试公共方法。您的公共方法使用您的私有方法，因此间接地它们也得到了测试。

* * *

## 回答 #14

> 赞同：8
> 
> 时间：2012-10-17T14:45:13.473

我一直在为这个问题烦恼一段时间，尤其是在尝试 TDD 时。

我遇到过两篇文章，我认为它们在 TDD 的情况下已经足够彻底地解决了这个问题。

1.  [测试私有方法、TDD 和测试驱动重构](http://agiletips.blogspot.com/2008/11/testing-private-methods-tdd-and-test.html)
2.  [测试驱动开发不是测试](http://www.stickyminds.com/sitewide.asp?Function=WEEKLYCOLUMN&ObjectId=8497&ObjectType=ARTCOL&btntopic=artcol)

* * *

**总之：**

*   当使用测试驱动开发（设计）技术时，私有方法应该只出现在已经工作和测试代码的重构过程中。

*   根据过程的本质，从经过彻底测试的功能中提取的任何简单实现功能都将进行自我测试（即间接测试覆盖率）。

对我来说，在编码的开始部分似乎很清楚，大多数方法将是更高级别的函数，因为它们封装/描述了设计。

因此，这些方法将是公开的，并且测试它们将很容易。

*一旦一切正常，私有方法将在稍后出现，为了可读性*和*清洁*性，我们正在重构。

* * *

## 回答 #15

> 赞同：6
> 
> 时间：2008-10-20T19:14:19.537

如上所述，“如果你不测试你的私有方法，你怎么知道它们不会破坏？”

这是一个重大问题。单元测试的一大要点是尽快知道在哪里、何时以及如何发生故障。从而减少了大量的开发和质量保证工作。如果所有被测试的都是公众，那么你就没有诚实的覆盖和描述类的内部结构。

我发现最好的方法之一就是简单地将测试引用添加到项目中，并将测试放在与私有方法平行的类中。放入适当的构建逻辑，以便测试不会构建到最终项目中。

然后，您将获得测试这些方法的所有好处，并且您可以在几秒钟内找到问题，而不是几分钟或几小时。

总而言之，是的，对您的私有方法进行单元测试。

* * *

## 回答 #16

> 赞同：6
> 
> 时间：2014-11-21T15:11:19.307

**你不应该**。如果您的私有方法具有必须测试的足够复杂性，您应该将它们放在另一个类中。保持**高凝聚力**，一个班级应该只有一个目的。类公共接口应该足够了。

* * *

## 回答 #17

> 赞同：2
> 
> 时间：2008-09-19T19:58:58.437

如果你不测试你的私有方法，你怎么知道它们不会破坏？

* * *

## 回答 #18

> 赞同：2
> 
> 时间：2008-09-19T20:01:14.840

这显然取决于语言。在过去使用 c++ 时，我已将测试类声明为友元类。不幸的是，这确实需要您的生产代码了解测试类。

* * *

## 回答 #19

> 赞同：2
> 
> 时间：2013-05-06T23:22:19.533

我理解私有方法被视为实现细节然后不必进行测试的观点。如果我们只能在对象之外开发，我会坚持这条规则。但是我们，我们是不是某种受限的开发者，只在对象之外开发，只调用他们的公共方法？或者我们实际上也在开发那个对象？由于我们不必对外部对象进行编程，因此我们可能不得不将那些私有方法调用到我们正在开发的新公共方法中。知道私有方法可以抵抗所有困难不是很好吗？

我知道有些人可能会回答，如果我们正在为该对象开发另一种公共方法，那么应该测试这个方法，就是这样（私有方法可以在没有测试的情况下继续存在）。但这也适用于对象的任何公共方法：在开发 Web 应用程序时，对象的所有公共方法都是从控制器方法调用的，因此可以被视为控制器的实现细节。

那么我们为什么要对对象进行单元测试呢？因为这真的很困难，并不是说不可能确定我们正在使用适当的输入测试控制器的方法，这将触发底层代码的所有分支。换句话说，我们在堆栈中的位置越高，测试所有行为就越困难。私有方法也是如此。

对我来说，私有方法和公共方法之间的界限是测试时的心理标准。对我来说更重要的标准是：

*   该方法是否从不同的地方多次调用？
*   该方法是否足够复杂以至于需要测试？

* * *

## 回答 #20

> 赞同：1
> 
> 时间：2011-05-19T16:14:15.277

如果我发现私有方法非常庞大、复杂或重要到需要它自己的测试，我只需将它放在另一个类中并在那里公开（方法对象）。然后我可以轻松地测试以前私有但现在公共的方法，它现在存在于自己的类中。

* * *

## 回答 #21

> 赞同：1
> 
> 时间：2018-11-02T02:02:34.517

我从不理解单元测试的概念，但现在我知道它的目标是什么。

**单元测试不是一个完整的测试**。因此，它不能替代 QA 和手动测试。TDD 在这方面的概念是错误的，因为您无法测试所有内容，包括私有方法以及使用资源（尤其是我们无法控制的资源）的方法。TDD 的所有质量都是基于它无法实现的。

单元测试更像是一个**支点测试** 您标记了一些任意支点，支点的结果应该保持不变。

* * *

## 回答 #22

> 赞同：1
> 
> 时间：2019-06-10T02:22:22.483

公共与私有对于从您的测试中调用什么 API 来说不是一个有用的区别，方法与类也不是。大多数可测试单元在一种情况下是可见的，但在其他情况下是隐藏的。

重要的是覆盖范围和成本。您需要在实现项目的覆盖目标（线路、分支、路径、块、方法、类、等价类、用例......无论团队决定）的同时最大限度地降低成本。

因此，使用工具来确保覆盖率，并设计您的测试以产生最小的成本（短期和**长期**）。

不要让测试变得比必要的更昂贵。如果只测试公共入口点最便宜，那就这样做。如果测试私有方法最便宜，那就这样做。

随着您的经验越来越丰富，您将更好地预测何时值得重构以避免测试维护的长期成本。

* * *

## 回答 #23

> 赞同：0
> 
> 时间：2008-09-24T08:39:57.387

如果该方法足够重要/足够复杂，我通常会将其设为“受保护”并对其进行测试。某些方法将保留为私有并作为公共/受保护方法的单元测试的一部分进行隐式测试。

* * *

## 回答 #24

> 赞同：0
> 
> 时间：2016-07-22T15:01:02.603

我看到很多人的想法都是一样的：在公共层面进行测试。但这不是我们的 QA 团队所做的吗？他们测试输入和预期输出。如果作为开发人员我们只测试公共方法，那么我们只是重做 QA 的工作，而不是通过“单元测试”增加任何价值。

* * *

## 回答 #25

> 赞同：0
> 
> 时间：2016-10-11T07:00:32.113

**一个要点是**

如果我们测试是为了保证逻辑的正确性，并且私有方法承载了逻辑，我们就应该测试它。不是吗？那么我们为什么要跳过它呢？

基于方法的可见性编写测试是完全不相关的想法。

**反过来**

另一方面，在原始类之外调用私有方法是一个主要问题。在一些模拟工具中模拟私有方法也存在限制。（例如：**Mockito**）

虽然有一些像**Power Mock**这样的工具支持这一点，但这是一个危险的操作。原因是它需要破解 JVM 来实现这一点。

**可以完成的一项工作是**（如果您想为私有方法编写测试用例）

将这些**私有**方法声明为**protected**。但在几种情况下可能并不方便。

* * *

## 回答 #26

> 赞同：0
> 
> 时间：2017-02-14T15:52:14.530

“我应该测试私有方法吗？”的答案 是“.......有时”。通常，您应该针对类的接口进行测试。

*   原因之一是您不需要对某个功能进行双重覆盖。
*   另一个原因是，如果您更改私有方法，您将不得不为它们更新每个测试，即使您的对象的接口根本没有改变。

这是一个例子：

```
class Thing
  def some_string
    one + two
  end

  private 

  def one
    'aaaa'
  end

  def two
    'bbbb'
  end

end

class RefactoredThing
def some_string
    one + one_a + two + two_b
  end

  private 

  def one
    'aa'
  end

  def one_a
    'aa'
  end

  def two
    'bb'
  end

  def two_b
    'bb'
  end
end 
```

您现在`RefactoredThing`有 5 个测试，其中 2 个您必须更新以进行重构，但您的对象的功能确实没有改变。因此，假设事情比这更复杂，并且您有一些方法可以定义输出的顺序，例如：

```
def some_string_positioner
  if some case
  elsif other case
  elsif other case
  elsif other case
  else one more case
  end
end 
```

这不应该由外部用户运行，但是您的封装类可能很重，无法一遍又一遍地通过它运行这么多的逻辑。在这种情况下，您可能宁愿将其提取到一个单独的类中，给该类一个接口并对其进行测试。

最后，假设您的主要对象超重，并且方法很小，您确实需要确保输出正确。你在想，“我必须测试这个私有方法！”。您是否认为可以通过将一些繁重的工作作为初始化参数传递来使您的对象更轻？然后你可以传递一些更轻的东西并针对它进行测试。

* * *

## 回答 #27

> 赞同：0
> 
> 时间：2017-03-23T09:12:20.213

不，您不应该测试私有方法[，为什么？](https://stackoverflow.com/a/5601776/5230044)此外，流行的模拟框架（例如 Mockito）不支持测试私有方法。

* * *

## 回答 #28

> 赞同：0
> 
> 时间：2019-02-14T22:31:22.347

它不仅与公共或私有方法或函数有关，还与实现细节有关。私有函数只是实现细节的一个方面。

毕竟，单元测试是一种白盒测试方法。例如，无论谁使用覆盖分析来识别迄今为止在测试中被忽略的代码部分，都会进入实现细节。

A）是的，您应该测试实施细节：

考虑一个排序函数，如果有多达 10 个元素，则出于性能原因使用 BubbleSort 的私有实现，如果元素超过 10 个，则使用不同排序方法（例如堆排序）的私有实现。公共 API 是排序函数的 API。但是，您的测试套件更好地利用了实际上使用了两种排序算法的知识。

在此示例中，您当然可以在公共 API 上执行测试。但是，这将需要有许多测试用例来执行具有超过 10 个元素的排序函数，以便堆排序算法得到足够好的测试。仅此类测试用例的存在就表明测试套件与功能的实现细节相关联。

如果排序函数的实现细节发生变化，可能是两种排序算法之间的限制发生了变化，或者堆排序被合并排序或其他方式取代：现有的测试将继续工作。尽管如此，它们的价值还是值得怀疑的，它们可能需要重新设计以更好地测试更改后的排序功能。换句话说，尽管测试是在公共 API 上进行的，但仍会进行维护工作。

B) 如何测试实现细节

许多人认为不应测试私有函数或实现细节的原因之一是，实现细节更有可能发生变化。这种更高的更改可能性至少是将实现细节隐藏在接口后面的原因之一。

现在，假设接口背后的实现包含更大的私有部分，内部接口上的单独测试可能是一个选项。有人争辩说，这些部分不应该在私有时进行测试，它们应该变成公共的东西。一旦公开，对该代码进行单元测试就可以了。

这很有趣：虽然接口是内部的，但它可能会发生变化，因为它是一个实现细节。采用相同的接口，将其公开会进行一些神奇的转换，即把它变成一个不太可能改变的接口。显然，这种论证存在一些缺陷。

但是，这背后有一些道理：在测试实现细节时，尤其是使用内部接口时，应该努力使用可能保持稳定的接口。然而，某些接口是否可能是稳定的，不能简单地根据它是公共的还是私有的来确定。在我工作了一段时间的世界项目中，公共接口也经常发生变化，许多私有接口多年来一直保持不变。

尽管如此，使用“前门优先”还是一个很好的经验法则（参见[http://xunitpatterns.com/Principles%20of%20Test%20Automation.html](http://xunitpatterns.com/Principles%20of%20Test%20Automation.html)）。但请记住，它被称为“前门优先”，而不是“仅前门”。

C) 总结

还要测试实现细节。更喜欢在稳定的接口（公共或私有）上进行测试。如果实现细节发生变化，公共 API 上的测试也需要修改。将私有内容变为公开内容并不会神奇地改变其稳定性。

* * *

## 回答 #29

> 赞同：0
> 
> 时间：2019-04-06T10:11:36.400

是的，您应该尽可能测试私有方法。为什么？为了避免测试用例不必要的[状态空间爆炸](https://en.wikipedia.org/wiki/Combinatorial_explosion)，最终只是在相同的输入上重复地隐式测试相同的私有函数。让我们用一个例子来解释为什么。

考虑以下稍微做作的示例。假设我们想要公开一个函数，该函数接受 3 个整数，当且仅当这 3 个整数都是素数时才返回 true。我们可以这样实现它：

```
public bool allPrime(int a, int b, int c)
{
  return andAll(isPrime(a), isPrime(b), isPrime(c))
}

private bool andAll(bool... boolArray)
{
  foreach (bool b in boolArray)
  {
    if(b == false) return false;
  }
  return true;
}

private bool isPrime(int x){
  //Implementation to go here. Sorry if you were expecting a prime sieve.
} 
```

现在，如果我们采取只测试公共函数的严格方法，我们将只被允许测试`allPrime`而不是`isPrime`or `andAll`。

作为测试人员，我们可能对每个参数的五种可能性感兴趣：`< 0`、`= 0`、`= 1`、`prime > 1`、`not prime > 1`。但要彻底，我们还必须看看论点的每种组合是如何一起发挥作用的。所以这`5*5*5`= 125 个测试用例，根据我们的直觉，我们需要彻底测试这个功能。

另一方面，如果允许我们测试私有函数，我们可以用更少的测试用例覆盖尽可能多的领域。我们只需要 5 个测试用例就可以测试`isPrime`到与我们之前的直觉相同的水平。根据 Daniel Jackson 提出的[小范围假设](https://en.wikipedia.org/wiki/Alloy_(specification_language))，我们只需要测试`andAll`一个小长度的函数，例如 3 或 4 个。最多可以再进行 16 个测试。所以总共有21个测试。而不是 125。当然，我们可能希望在 上运行*一些*测试`allPrime`，但我们不会觉得有义务详尽地涵盖我们所说的我们关心的所有 125 种输入场景组合。只有几条快乐的道路。

当然，这是一个人为的例子，但有必要进行清晰的演示。并且该模式扩展到实际软件。私有函数通常是最低级别的构建块，因此经常组合在一起以产生更高级别的逻辑。这意味着在更高级别，由于各种组合，我们对较低级别的东西有更多的重复。

* * *

## 回答 #30

> 赞同：0
> 
> 时间：2019-05-07T23:15:21.233

您还可以将您的方法设置为包私有，即默认值，并且您应该能够对其进行单元测试，除非它需要是私有的。

* * *

## 回答 #31

> 赞同：-1
> 
> 时间：2012-05-25T10:58:59.050

绝对没错。这就是单元测试的重点，你测试单元。私有方法是一个单元。如果不测试私有方法，TDD（测试驱动开发）是不可能的，

# c++ - 除了允许 const 函数修改变量之外，'mutable' 关键字还有其他用途吗？

> ID：105014
> 
> 赞同：575
> 
> 时间：2008-09-19T19:58:05.613
> 
> 标签：c++, keyword, mutable

不久前，我遇到了一些用`mutable`关键字标记类的成员变量的代码。据我所见，它只允许您修改`const`方法中的变量：

```
class Foo  
{  
private:  
    mutable bool done_;  
public:  
    void doSomething() const { ...; done_ = true; }  
}; 
```

这是这个关键字的唯一用途，还是有更多的用处？从那以后，我在一个类中使用了这种技术，将 a 标记`boost::mutex`为可变的，允许`const`函数出于线程安全的原因锁定它，但是，老实说，这感觉有点像 hack。

* * *

## 回答 #1

> 赞同：393
> 
> 时间：2008-09-19T20:04:14.100

它允许区分按位常量和逻辑常量。逻辑 const 是指对象不会以通过公共接口可见的方式更改，例如您的锁定示例。另一个例子是一个类，它在第一次被请求时计算一个值，并缓存结果。

由于 c++11`mutable`可以在 lambda 上使用来表示通过值捕获的东西是可修改的（默认情况下它们不是）：

```
int x = 0;
auto f1 = [=]() mutable {x = 42;};  // OK
auto f2 = [=]()         {x = 42;};  // Error: a by-value capture cannot be modified in a non-mutable lambda 
```

* * *

## 回答 #2

> 赞同：155
> 
> 时间：2010-03-05T02:34:00.533

`mutable`关键字是一种穿透`const`覆盖在物体上的面纱的方法。如果您有一个指向对象的 const 引用或指针，则您不能以任何方式修改该对象，**除非**它被标记的时间和方式`mutable`。

使用您的`const`参考或指针，您将被限制为：

*   仅对任何可见数据成员的读取权限
*   仅调用标记为 的方法的权限`const`。

该`mutable`例外使您现在可以编写或设置标记为 的数据成员`mutable`。这是唯一外部可见的区别。

在内部`const`，您可以看到的那些方法也可以写入标记为 的数据成员`mutable`。本质上，const 面纱被全面刺穿。完全由 API 设计者来确保`mutable`不会破坏`const`概念并且仅在有用的特殊情况下使用。`mutable`关键字有帮助，因为它清楚地标记了受这些特殊情况影响的数据成员。

在实践中，您可以`const`在整个代码库中痴迷地使用（您本质上是想用`const`“疾病”“感染”您的代码库）。在这个世界中，指针和引用`const`几乎没有例外，产生的代码更容易推理和理解。对于一个有趣的题外话查找“参考透明度”。

如果没有`mutable`关键字，您最终将被迫使用它`const_cast`来处理它允许的各种有用的特殊情况（缓存、引用计数、调试数据等）。不幸`const_cast`的是，它的破坏性比`mutable`它强制 API**客户端**破坏`const`他正在使用的对象的保护要大得多。此外，它会导致广泛的`const`破坏：`const_cast`使用 const 指针或引用允许对可见成员进行不受限制的写入和方法调用访问。相比之下`mutable`，API 设计人员需要对异常进行细粒度控制`const`，而这些异常通常隐藏在`const`对私有数据进行操作的方法中。

（注意，我多次提到数据和方法的*可见性*。我说的是标记为公共与私有或受保护的成员，这是[此处](https://stackoverflow.com/questions/224966/private-and-protected-members-c)讨论的完全不同类型的对象保护。）

* * *

## 回答 #3

> 赞同：78
> 
> 时间：2008-09-19T20:01:20.223

您对 boost::mutex 的使用正是这个关键字的用途。另一个用途是用于内部结果缓存以加快访问速度。

基本上，“可变”适用于任何不影响对象外部可见状态的类属性。

在您问题的示例代码中，如果 done_ 的值影响外部状态，则 mutable 可能不合适，这取决于...中的内容；部分。

* * *

## 回答 #4

> 赞同：37
> 
> 时间：2008-09-19T20:02:55.947

Mutable 用于将特定属性标记为可在`const`方法内修改。这是它的唯一目的。在使用它之前请仔细考虑，因为如果您更改设计而不是使用`mutable`.

[http://www.highprogrammer.com/alan/rants/mutable.html](http://www.highprogrammer.com/alan/rants/mutable.html)

> 因此，如果上述疯狂不是 mutable 的用途，那它的用途是什么？这是一个微妙的情况：可变对象适用于对象在逻辑上是恒定的，但实际上需要更改的情况。这些情况很少见，但它们确实存在。

作者给出的示例包括缓存和临时调试变量。

* * *

## 回答 #5

> 赞同：36
> 
> 时间：2008-09-19T20:03:13.790

它在您隐藏内部状态（例如缓存）的情况下很有用。例如：

```
类哈希表
{
...
上市：
    字符串查找（字符串键）常量
    {
        如果（键 == 最后一个键）
            返回最后一个值；

        字符串值 = 查找内部（键）；

        最后一个键 = 键；
        最后一个值 = 值；

        返回值；
    }

私人的：
    可变字符串 lastKey, lastValue;
};
```

然后你可以让一个`const HashTable`对象仍然使用它的`lookup()`方法，这会修改内部缓存。

* * *

## 回答 #6

> 赞同：10
> 
> 时间：2008-09-19T20:25:03.350

`mutable`正如您推断的那样，确实存在以允许人们在其他恒定函数中修改数据。

目的是您可能有一个对对象的内部状态“什么都不做”的函数，因此您标记了该函数`const`，但您可能确实需要以不影响其正确性的方式修改某些对象状态功能。

该关键字可以作为对编译器的提示——理论上的编译器可以将一个常量对象（例如一个全局对象）放置在标记为只读的内存中。存在`mutable`不应该这样做的提示。

以下是声明和使用可变数据的一些正当理由：

*   线程安全。声明 a`mutable boost::mutex`是完全合理的。
*   统计数据。在给定部分或全部参数的情况下，计算对函数的调用次数。
*   记忆。计算一些昂贵的答案，然后将其存储以供将来参考，而不是再次重新计算。

* * *

## 回答 #7

> 赞同：8
> 
> 时间：2008-09-19T20:07:14.280

嗯，是的，这就是它的作用。我将它用于由不会在*逻辑上*更改类状态的方法修改的成员 - 例如，通过实现缓存来加速查找：

```
class CIniWrapper
{
public:
   CIniWrapper(LPCTSTR szIniFile);

   // non-const: logically modifies the state of the object
   void SetValue(LPCTSTR szName, LPCTSTR szValue);

   // const: does not logically change the object
   LPCTSTR GetValue(LPCTSTR szName, LPCTSTR szDefaultValue) const;

   // ...

private:
   // cache, avoids going to disk when a named value is retrieved multiple times
   // does not logically change the public interface, so declared mutable
   // so that it can be used by the const GetValue() method
   mutable std::map<string, string> m_mapNameToValue;
}; 
```

现在，您必须小心使用它 - 并发问题是一个大问题，因为调用者可能会认为它们是线程安全的，如果只使用`const`方法。当然，修改`mutable`数据不应该以任何重要的方式改变对象的行为，这可能会被我给出的示例所违反，例如，如果预期写入磁盘的更改将立即对应用程序可见.

* * *

## 回答 #8

> 赞同：7
> 
> 时间：2013-06-28T12:31:09.630

当您在类中有一个变量时使用可变的，该变量仅在该类中用于表示诸如互斥锁或锁之类的东西。这个变量不会改变类的行为，但是为了实现类本身的线程安全是必需的。因此，如果没有“可变”，您将无法拥有“常量”函数，因为需要在外部世界可用的所有函数中更改此变量。因此，引入 mutable 是为了使成员变量即使是 const 函数也可写。

> 指定的 mutable 通知编译器和阅读器它是安全的，并且可以预期成员变量可以在 const 成员函数中修改。

* * *

## 回答 #9

> 赞同：7
> 
> 时间：2014-01-14T02:38:37.357

对于对用户来说逻辑上无状态的事物（因此在公共类的 API 中应该有“const”getter）但在底层实现（.cpp 中的代码）中不是无状态的，请使用“可变”。

我最常使用它的情况是无状态“普通旧数据”成员的延迟初始化。即，在此类成员的构建（处理器）或携带（内存）昂贵且对象的许多用户永远不会要求它们的狭窄情况下，这是理想的。在这种情况下，您需要在后端进行惰性构建以提高性能，因为 90% 的构建对象根本不需要构建它们，但您仍然需要提供正确的无状态 API 以供公众使用。

* * *

## 回答 #10

> 赞同：5
> 
> 时间：2008-09-19T20:05:22.977

mutable 主要用于类的实现细节。该类的用户不需要知道它，因此他认为“应该”是 const 的方法可以。您让互斥体可变的示例是一个很好的规范示例。

* * *

## 回答 #11

> 赞同：5
> 
> 时间：2008-09-19T20:20:49.630

您对它的使用不是 hack，尽管就像 C++ 中的许多东西一样，对于不想一路返回并将不应该是 const 的东西标记为 non-const 的懒惰程序员来说，mutable*可能是 hack。*

* * *

## 回答 #12

> 赞同：2
> 
> 时间：2014-07-24T19:50:19.040

Mutable 将`const`类的含义从按位 const 更改为逻辑 const。

这意味着具有可变成员的类不再是按位 const 并且将不再出现在可执行文件的只读部分中。

此外，它通过允许`const`成员函数在不使用`const_cast`.

```
class Logical {
    mutable int var;

public:
    Logical(): var(0) {}
    void set(int x) const { var = x; }
};

class Bitwise {
    int var;

public:
    Bitwise(): var(0) {}
    void set(int x) const {
        const_cast<Bitwise*>(this)->var = x;
    }
};

const Logical logical; // Not put in read-only.
const Bitwise bitwise; // Likely put in read-only.

int main(void)
{
    logical.set(5); // Well defined.
    bitwise.set(5); // Undefined.
} 
```

有关更多详细信息，请参阅其他答案，但我想强调它不仅适用于类型安全，而且它会影响编译结果。

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2008-09-19T20:03:04.573

在某些情况下（例如设计不佳的迭代器），类需要保留一个计数或其他一些附带值，这并不会真正影响类的主要“状态”。这是我经常看到 mutable 使用的地方。如果没有 mutable，您将被迫牺牲设计的整个 const-ness。

对我来说，大部分时间也感觉像是一种黑客行为。在极少数情况下很有用。

* * *

## 回答 #14

> 赞同：1
> 
> 时间：2011-05-16T12:32:31.973

`mutable`经典示例（如其他答案中所述）和迄今为止我看到的唯一情况是用于缓存复杂`Get`方法的结果，其中缓存被实现为类的数据成员而不是作为方法中的静态变量（出于在多个函数之间共享或简单清洁的原因）。

通常，使用关键字的替代方法`mutable`通常是方法或`const_cast`技巧中的静态变量。

另一个详细的解释在[这里](http://www.possibility.com/Cpp/const.html)。

* * *

## 回答 #15

> 赞同：1
> 
> 时间：2014-02-01T14:15:16.893

当您覆盖 const 虚函数并想要修改该函数中的子类成员变量时，可变变量会很方便。在大多数情况下，您不想更改基类的接口，因此您必须使用自己的可变成员变量。

* * *

## 回答 #16

> 赞同：1
> 
> 时间：2014-05-27T08:06:05.987

mutable 关键字在为类测试创建存根时非常有用。您可以存根一个 const 函数，并且仍然能够增加（可变）计数器或您添加到存根中的任何测试功能。这使存根类的接口保持不变。

* * *

## 回答 #17

> 赞同：1
> 
> 时间：2015-01-25T18:19:03.073

我们使用 mutable 的最佳示例之一是深拷贝。在复制构造函数中，我们`const &obj`作为参数发送。所以创建的新对象将是常量类型。如果我们想要更改（大多数情况下我们不会更改，在极少数情况下我们可能会更改）这个新创建的 const 对象中的成员，我们需要将其声明为`mutable`.

`mutable`存储类只能用于类的非静态非 const 数据成员。可以修改类的可变数据成员，即使它是声明为 const 的对象的一部分。

```
class Test
{
public:
    Test(): x(1), y(1) {};
    mutable int x;
    int y;
};

int main()
{
    const Test object;
    object.x = 123;
    //object.y = 123;
    /* 
    * The above line if uncommented, will create compilation error.
    */   

    cout<< "X:"<< object.x << ", Y:" << object.y;
    return 0;
}

Output:-
X:123, Y:1 
```

在上面的示例中，我们可以更改成员变量的值，`x`尽管它是声明为 const 的对象的一部分。这是因为变量`x`被声明为可变的。但是如果你试图修改成员变量的值`y`，编译器会抛出错误。

* * *

## 回答 #18

> 赞同：-4
> 
> 时间：2014-02-22T03:21:34.527

非常关键字'mutable'实际上是一个保留关键字。它通常用于改变常量变量的值。如果你想拥有一个constsnt的多个值，请使用关键字mutable。

```
//Prototype 
class tag_name{
                :
                :
                mutable var_name;
                :
                :
               }; 
```

# debugging - 你如何解决在 Vista 上崩溃的 Windbg Logger？

> ID：105022
> 
> 赞同：0
> 
> 时间：2008-09-19T19:59:01.947
> 
> 标签：debugging, windows-vista, windbg

我想使用[Microsoft Debugging Tools for Windows](http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx)附带的[Logger](http://msdn.microsoft.com/en-us/library/cc266316.aspx)工具。但是，在 Vista 上，即使使用内置的 Vista 应用程序也会崩溃：

```
> logger calc 
```

或者

```
> logger notepad 
```

如果我从具有或不具有管理员权限的命令提示符运行该工具，则会出现此问题。我使用的是 3.01 版（2008 年 3 月 20 日）。

Logger 输出窗口显示的最后一件事是“启用详细日志”。

如果我附加一个调试器，我会看到以下调用堆栈发生了“访问冲突写入位置 0x000000”错误：

```
logexts.dll!_LogGetCategory@20()  + 0xb bytes   
logger.exe!PopulateLogextsSettings()  + 0x31 bytes  
logger.exe!SettingsDlgProc()  + 0x48 bytes  
user32.dll!_InternalCallWinProc@20()  + 0x23 bytes  
user32.dll!_UserCallDlgProcCheckWow@32()  - 0x19bc bytes    
user32.dll!_DefDlgProcWorker@20()  + 0x7f bytes 
user32.dll!_DefDlgProcA@16()  + 0x22 bytes  
user32.dll!_InternalCallWinProc@20()  + 0x23 bytes  
user32.dll!_UserCallWinProcCheckWow@32()  + 0xb3 bytes  
user32.dll!_SendMessageWorker@20()  + 0xd5 bytes    
user32.dll!_InternalCreateDialog@28()  + 0x700 bytes    
user32.dll!_InternalDialogBox@24()  + 0xa3 bytes    
user32.dll!_DialogBoxIndirectParamAorW@24()  + 0x36 bytes   
user32.dll!_DialogBoxParamA@20()  + 0x4c bytes  
logger.exe!ChooseSettings()  + 0x24 bytes   
logger.exe!InitLogexts()  + 0x84 bytes  
logger.exe!DebuggerLoop()  + 0x210 bytes    
logger.exe!_WinMain@16()  + 0x215 bytes 
logger.exe!__initterm_e()  + 0x1a1 bytes    
kernel32.dll!@BaseThreadInitThunk@12()  + 0x12 bytes    
ntdll.dll!___RtlUserThreadStart@8()  + 0x27 bytes   
ntdll.dll!__RtlUserThreadStart@8()  + 0x1b bytes 
```

有人遇到过这个问题并知道如何解决吗？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-20T15:03:48.527

我正在使用 6.9.3.113（2008 年 4 月 29 日）的调试工具，在 Vista 上我没有遇到任何问题。如果我尝试跑步

```
logger notepad 
```

它工作正常（即使作为非管理员）。我要检查的第一件事是，如果您运行的是 x64 版本的 Vista，您还需要使用[64 位版本的调试工具](http://www.microsoft.com/whdc/devtools/debugging/install64bit.mspx#)。

# windows - MSI 安装程序：向 SecureCustomProperties 添加多个属性

> ID：105024
> 
> 赞同：2
> 
> 时间：2008-09-19T19:59:30.133
> 
> 标签：windows, installation, windows-installer, delimiter

我正在寻找一种将多个属性添加到`SecureCustomProperties`我的 .msi 安装程序属性表中的值的方法。我尝试过逗号分隔、分号分隔，甚至空格分隔符。以上似乎都不起作用。

提示？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-19T20:02:24.090

好的，所以我几乎就在那里......**用 NO SPACES 分隔的分号**。这似乎可以解决问题。

# c# - 您如何获得计算机的 RAM 总量？

> ID：105031
> 
> 赞同：91
> 
> 时间：2008-09-19T20:00:40.053
> 
> 标签：c#, memory, performancecounter

使用 C#，我想获取我的计算机拥有的 RAM 总量。使用 PerformanceCounter，我可以通过设置获得可用内存的数量：

```
counter.CategoryName = "Memory";
counter.Countername = "Available MBytes"; 
```

但我似乎无法找到获取内存总量的方法。我该怎么做呢？

**更新：**

MagicKat：我在搜索时看到了，但它不起作用 - “您是否缺少程序集或引用？”。我希望将其添加到参考文献中，但在那里看不到。

* * *

## 回答 #1

> 赞同：184
> 
> 时间：2008-09-19T20:06:28.230

添加对`Microsoft.VisualBasic`和的引用`using Microsoft.VisualBasic.Devices;`。

该`ComputerInfo`课程包含您需要的所有信息。

* * *

## 回答 #2

> 赞同：64
> 
> 时间：2008-09-19T20:09:00.313

[`GlobalMemoryStatusEx`](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex)可以使用 p/invoke 调用Windows API 函数：

```
 [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
  private class MEMORYSTATUSEX
  {
     public uint dwLength;
     public uint dwMemoryLoad;
     public ulong ullTotalPhys;
     public ulong ullAvailPhys;
     public ulong ullTotalPageFile;
     public ulong ullAvailPageFile;
     public ulong ullTotalVirtual;
     public ulong ullAvailVirtual;
     public ulong ullAvailExtendedVirtual;
     public MEMORYSTATUSEX()
     {
        this.dwLength = (uint)Marshal.SizeOf(typeof(NativeMethods.MEMORYSTATUSEX));
     }
  }

  [return: MarshalAs(UnmanagedType.Bool)]
  [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
  static extern bool GlobalMemoryStatusEx([In, Out] MEMORYSTATUSEX lpBuffer); 
```

然后像这样使用：

```
ulong installedMemory;
MEMORYSTATUSEX memStatus = new MEMORYSTATUSEX();
if( GlobalMemoryStatusEx( memStatus))
{ 
   installedMemory = memStatus.ullTotalPhys;
} 
```

或者您可以使用 WMI（托管但速度较慢）`TotalPhysicalMemory`在`Win32_ComputerSystem`类中进行查询。

* * *

## 回答 #3

> 赞同：64
> 
> 时间：2008-09-19T21:43:59.900

如上所述，添加对 Microsoft.VisualBasic.dll 的引用。然后获得总物理内存就这么简单（是的，我测试过）：

```
static ulong GetTotalMemoryInBytes()
{
    return new Microsoft.VisualBasic.Devices.ComputerInfo().TotalPhysicalMemory;
} 
```

* * *

## 回答 #4

> 赞同：39
> 
> 时间：2015-12-05T03:29:34.270

***这里的所有答案，包括被接受的答案，都将为您提供可供使用***的 RAM 总量。这可能就是 OP 想要的。

但是，如果您对获取***已安装***RAM 的数量感兴趣，那么您需要调用[GetPhysicallyInstalledSystemMemory](https://msdn.microsoft.com/en-us/library/windows/desktop/cc300158(v=vs.85).aspx)函数。

从链接中的备注部分：

> GetPhysicallyInstalledSystemMemory函数从计算机的 SMBIOS 固件表**中**检索物理安装的 RAM 量。这可能与**GlobalMemoryStatusEx**函数报告的数量不同，后者将 MEMORYSTATUSEX 结构的 ullTotalPhys 成员设置为可供操作系统使用的物理内存量。***操作系统可用的内存量可能小于计算机中物理安装的内存量，***因为 BIOS 和某些驱动程序可能会将内存保留为内存映射设备的 I/O 区域，从而使内存对操作系统不可用和应用。

**示例代码：**

```
[DllImport("kernel32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
static extern bool GetPhysicallyInstalledSystemMemory(out long TotalMemoryInKilobytes);

static void Main()
{
    long memKb;
    GetPhysicallyInstalledSystemMemory(out memKb);
    Console.WriteLine((memKb / 1024 / 1024) + " GB of RAM installed.");
} 
```

* * *

## 回答 #5

> 赞同：31
> 
> 时间：2010-04-16T17:34:54.977

如果您碰巧在使用 Mono，那么您可能有兴趣知道 Mono 2.8（将于今年晚些时候发布）将有一个性能计数器，用于报告 Mono 运行的所有平台（包括 Windows）上的物理内存大小。您将使用以下代码片段检索计数器的值：

```
using System;
using System.Diagnostics;

class app
{
   static void Main ()
   {
       var pc = new PerformanceCounter ("Mono Memory", "Total Physical Memory");
       Console.WriteLine ("Physical RAM (bytes): {0}", pc.RawValue);
   }
} 
```

如果您对提供性能计数器的 C 代码感兴趣，可以在[此处](http://anonsvn.mono-project.com/viewvc/trunk/mono/mono/metadata/mono-perfcounters.c?r1=154243&r2=155566&pathrev=155566)找到。

* * *

## 回答 #6

> 赞同：20
> 
> 时间：2019-11-27T15:05:10.427

对于那些正在使用的人来说，`.net Core 3.0`不需要使用`PInvoke`平台来获得可用的物理内存。该类`GC`添加了一个新方法`GC.GetGCMemoryInfo`，该方法返回一个`GCMemoryInfo Struct`with`TotalAvailableMemoryBytes`作为属性。此属性返回垃圾收集器的总可用内存。（与 MEMORYSTATUSEX 相同的值）

```
var gcMemoryInfo = GC.GetGCMemoryInfo();
installedMemory = gcMemoryInfo.TotalAvailableMemoryBytes;
// it will give the size of memory in MB
var physicalMemory = (double) installedMemory / 1048576.0; 
```

* * *

## 回答 #7

> 赞同：15
> 
> 时间：2014-06-24T20:21:29.373

另一种方法是使用 .NET System.Management 查询工具：

```
string Query = "SELECT Capacity FROM Win32_PhysicalMemory";
ManagementObjectSearcher searcher = new ManagementObjectSearcher(Query);

UInt64 Capacity = 0;
foreach (ManagementObject WniPART in searcher.Get())
{
    Capacity += Convert.ToUInt64(WniPART.Properties["Capacity"].Value);
}

return Capacity; 
```

* * *

## 回答 #8

> 赞同：7
> 
> 时间：2014-03-31T04:49:36.327

您可以简单地使用此代码来获取这些信息，只需添加参考

```
using Microsoft.VisualBasic.Devices; 
```

并且只需使用以下代码

```
 private void button1_Click(object sender, EventArgs e)
    {
        getAvailableRAM();
    }

    public void getAvailableRAM()
    {
        ComputerInfo CI = new ComputerInfo();
        ulong mem = ulong.Parse(CI.TotalPhysicalMemory.ToString());
        richTextBox1.Text = (mem / (1024*1024) + " MB").ToString();
    } 
```

* * *

## 回答 #9

> 赞同：5
> 
> 时间：2008-09-19T20:08:27.227

您可以使用“WMI”。

我找到了一个“片段”。

```
Set objWMIService = GetObject("winmgmts:" _
& "{impersonationLevel=impersonate}!\\" _ 
& strComputer & "\root\cimv2") 
Set colComputer = objWMIService.ExecQuery _
("Select * from Win32_ComputerSystem")

For Each objComputer in colComputer 
  strMemory = objComputer.TotalPhysicalMemory
Next 
```

* * *

## 回答 #10

> 赞同：5
> 
> 时间：2016-01-20T12:28:35.380

```
// use `/ 1048576` to get ram in MB
// and `/ (1048576 * 1024)` or `/ 1048576 / 1024` to get ram in GB
private static String getRAMsize()
{
    ManagementClass mc = new ManagementClass("Win32_ComputerSystem");
    ManagementObjectCollection moc = mc.GetInstances();
    foreach (ManagementObject item in moc)
    {
       return Convert.ToString(Math.Round(Convert.ToDouble(item.Properties["TotalPhysicalMemory"].Value) / 1048576, 0)) + " MB";
    }

    return "RAMsize";
} 
```

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2015-10-29T11:41:24.570

此函数 ( `ManagementQuery`) 适用于 Windows XP 及更高版本：

```
private static string ManagementQuery(string query, string parameter, string scope = null) {
    string result = string.Empty;
    var searcher = string.IsNullOrEmpty(scope) ? new ManagementObjectSearcher(query) : new ManagementObjectSearcher(scope, query);
    foreach (var os in searcher.Get()) {
        try {
            result = os[parameter].ToString();
        }
        catch {
            //ignore
        }

        if (!string.IsNullOrEmpty(result)) {
            break;
        }
    }

    return result;
} 
```

用法：

```
Console.WriteLine(BytesToMb(Convert.ToInt64(ManagementQuery("SELECT TotalPhysicalMemory FROM Win32_ComputerSystem", "TotalPhysicalMemory", "root\\CIMV2")))); 
```

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2018-10-27T00:24:47.063

**兼容 .Net 和 Mono（在 Win10/FreeBSD/CentOS 测试）**

将`ComputerInfo`源代码和`PerformanceCounter`s 用于 Mono 并作为 .Net 的备份：

```
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;

public class SystemMemoryInfo
{
    private readonly PerformanceCounter _monoAvailableMemoryCounter;
    private readonly PerformanceCounter _monoTotalMemoryCounter;
    private readonly PerformanceCounter _netAvailableMemoryCounter;

    private ulong _availablePhysicalMemory;
    private ulong _totalPhysicalMemory;

    public SystemMemoryInfo()
    {
        try
        {
            if (PerformanceCounterCategory.Exists("Mono Memory"))
            {
                _monoAvailableMemoryCounter = new PerformanceCounter("Mono Memory", "Available Physical Memory");
                _monoTotalMemoryCounter = new PerformanceCounter("Mono Memory", "Total Physical Memory");
            }
            else if (PerformanceCounterCategory.Exists("Memory"))
            {
                _netAvailableMemoryCounter = new PerformanceCounter("Memory", "Available Bytes");
            }
        }
        catch
        {
            // ignored
        }
    }

    public ulong AvailablePhysicalMemory
    {
        [SecurityCritical]
        get
        {
            Refresh();

            return _availablePhysicalMemory;
        }
    }

    public ulong TotalPhysicalMemory
    {
        [SecurityCritical]
        get
        {
            Refresh();

            return _totalPhysicalMemory;
        }
    }

    [SecurityCritical]
    [DllImport("Kernel32", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern void GlobalMemoryStatus(ref MEMORYSTATUS lpBuffer);

    [SecurityCritical]
    [DllImport("Kernel32", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool GlobalMemoryStatusEx(ref MEMORYSTATUSEX lpBuffer);

    [SecurityCritical]
    private void Refresh()
    {
        try
        {
            if (_monoTotalMemoryCounter != null && _monoAvailableMemoryCounter != null)
            {
                _totalPhysicalMemory = (ulong) _monoTotalMemoryCounter.NextValue();
                _availablePhysicalMemory = (ulong) _monoAvailableMemoryCounter.NextValue();
            }
            else if (Environment.OSVersion.Version.Major < 5)
            {
                var memoryStatus = MEMORYSTATUS.Init();
                GlobalMemoryStatus(ref memoryStatus);

                if (memoryStatus.dwTotalPhys > 0)
                {
                    _availablePhysicalMemory = memoryStatus.dwAvailPhys;
                    _totalPhysicalMemory = memoryStatus.dwTotalPhys;
                }
                else if (_netAvailableMemoryCounter != null)
                {
                    _availablePhysicalMemory = (ulong) _netAvailableMemoryCounter.NextValue();
                }
            }
            else
            {
                var memoryStatusEx = MEMORYSTATUSEX.Init();

                if (GlobalMemoryStatusEx(ref memoryStatusEx))
                {
                    _availablePhysicalMemory = memoryStatusEx.ullAvailPhys;
                    _totalPhysicalMemory = memoryStatusEx.ullTotalPhys;
                }
                else if (_netAvailableMemoryCounter != null)
                {
                    _availablePhysicalMemory = (ulong) _netAvailableMemoryCounter.NextValue();
                }
            }
        }
        catch
        {
            // ignored
        }
    }

    private struct MEMORYSTATUS
    {
        private uint dwLength;
        internal uint dwMemoryLoad;
        internal uint dwTotalPhys;
        internal uint dwAvailPhys;
        internal uint dwTotalPageFile;
        internal uint dwAvailPageFile;
        internal uint dwTotalVirtual;
        internal uint dwAvailVirtual;

        public static MEMORYSTATUS Init()
        {
            return new MEMORYSTATUS
            {
                dwLength = checked((uint) Marshal.SizeOf(typeof(MEMORYSTATUS)))
            };
        }
    }

    private struct MEMORYSTATUSEX
    {
        private uint dwLength;
        internal uint dwMemoryLoad;
        internal ulong ullTotalPhys;
        internal ulong ullAvailPhys;
        internal ulong ullTotalPageFile;
        internal ulong ullAvailPageFile;
        internal ulong ullTotalVirtual;
        internal ulong ullAvailVirtual;
        internal ulong ullAvailExtendedVirtual;

        public static MEMORYSTATUSEX Init()
        {
            return new MEMORYSTATUSEX
            {
                dwLength = checked((uint) Marshal.SizeOf(typeof(MEMORYSTATUSEX)))
            };
        }
    }
} 
```

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-09-19T20:03:02.263

.NET 具有可以访问的内存量限制。在 Windows XP 中，2GB 是“硬天花板”。例如：你可能有 4 GB，当它达到 2 GB 时它会杀死应用程序。

同样在 64 位模式下，您可以在系统外使用一定比例的内存，所以我不确定您是否可以要求全部内容，或者是否特别注意这一点。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2014-10-22T18:50:40.587

还没有人提到[GetPerformanceInfo](http://msdn.microsoft.com/en-gb/library/windows/desktop/ms683210%28v=vs.85%29.aspx)。[PInvoke 签名](http://www.pinvoke.net/default.aspx/psapi/GetPerformanceInfo.html)可用。

此功能使以下系统范围的信息可用：

*   提交总数
*   提交限制
*   提交峰值
*   物理总计
*   实物可用
*   系统缓存
*   内核总数
*   内核分页
*   内核未分页
*   页面大小
*   句柄计数
*   进程计数
*   线程数

`PhysicalTotal`是 OP 正在寻找的，虽然该值是页数，所以要转换为字节，乘以`PageSize`返回的值。

* * *

## 回答 #15

> 赞同：-3
> 
> 时间：2012-05-05T13:57:14.880

```
/*The simplest way to get/display total physical memory in VB.net (Tested)

public sub get_total_physical_mem()

    dim total_physical_memory as integer

    total_physical_memory=CInt((My.Computer.Info.TotalPhysicalMemory) / (1024 * 1024))
    MsgBox("Total Physical Memory" + CInt((My.Computer.Info.TotalPhysicalMemory) / (1024 * 1024)).ToString + "Mb" )
end sub
*/

//The simplest way to get/display total physical memory in C# (converted Form http://www.developerfusion.com/tools/convert/vb-to-csharp)

public void get_total_physical_mem()
{
    int total_physical_memory = 0;

    total_physical_memory = Convert.ToInt32((My.Computer.Info.TotalPhysicalMemory) /  (1024 * 1024));
    Interaction.MsgBox("Total Physical Memory" + Convert.ToInt32((My.Computer.Info.TotalPhysicalMemory) / (1024 * 1024)).ToString() + "Mb");
} 
```

* * *

## 回答 #16

> 赞同：-3
> 
> 时间：2021-03-25T17:01:54.080

`var ram = new ManagementObjectSearcher("select * from Win32_PhysicalMemory") .Get().Cast<ManagementObject>().First();`

|

`var a = Convert.ToInt64(ram["Capacity"]) / 1024 / 1024 / 1024;`

（richiede System.Managment.dll 来 riferimento，testato su C# con Framework 4.7.2）

questa procedura salva in "a" la ram totale presente in GB

* * *

`ulong memory() { return new Microsoft.VisualBasic.Devices.ComputerInfo().TotalPhysicalMemory; }`

|

`var b = Convert.ToDecimal(memory()) / 1024 / 1024 / 1024;`

(richiede Microsoft.VisualBasics.dll 来 riferimento, testato su C# Framework 4.7.2)

questa procedura salva in "b" il valore della ram in GB effettivamente disponibile

* * *

# javascript - 如何创建 GUID/UUID

> ID：105034
> 
> 赞同：4840
> 
> 时间：2008-09-19T20:01:00.147
> 
> 标签：javascript, guid, uuid

我正在尝试在 JavaScript 中创建全局唯一标识符。我不确定所有浏览器上都有哪些例程，内置随机数生成器的“随机性”和播种程度等。

GUID / UUID 应至少为 32 个字符，并且应保持在 ASCII 范围内，以避免在传递它们时出现问题。

* * *

## 回答 #1

> 赞同：4973
> 
> 时间：2010-01-22T13:40:20.003

*[于 2021 年 10 月 16 日编辑，以反映生产符合 RFC4122 的 UUID 的最新最佳实践]*

这里的大多数读者都想使用[该`uuid`模块](https://www.npmjs.com/package/uuid)。它经过了良好的测试和支持。

该[`crypto.randomUUID()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID)功能是一种新兴标准，越来越多的浏览器支持`Node.js`该[标准](https://caniuse.com/mdn-api_crypto_randomuuid)。

如果这些都不适合你，有这个方法（基于这个问题的原始答案）：

```
function uuidv4() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
}

console.log(uuidv4());
```

注意：强烈建议不要**使用*任何*依赖 Math.random() 的 UUID 生成器**（包括此答案的先前版本中的片段），[原因在此处进行了最佳解释](https://bocoup.com/blog/random-numbers)。TL;DR：基于 Math.random() 的解决方案不能提供良好的唯一性保证。

* * *

## 回答 #2

> 赞同：2575
> 
> 时间：2008-09-19T20:05:25.003

UUID（通用唯一标识符），也称为 GUID（全局唯一标识符），根据[RFC 4122](https://www.ietf.org/rfc/rfc4122.txt)，是旨在提供某些唯一性保证的标识符。

虽然可以在几行 JavaScript 代码中实现符合 RFC 的 UUID（例如，请参阅下面[的 @broofa 的答案](https://stackoverflow.com/a/2117523/109538)），但有几个常见的陷阱：

*   id 格式无效（UUID 的格式必须为“ `xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx`”，其中 x 是 [0-9，af]之一， *M*是 [1-5] 之一，*N*是 [8、9、a 或 b]
*   使用低质量的随机源（例如`Math.random`）

因此，鼓励为生产环境编写代码的开发人员使用严格的、维护良好的实现，例如[uuid](https://github.com/uuidjs/uuid)模块。

* * *

## 回答 #3

> 赞同：909
> 
> 时间：2012-01-10T19:38:54.400

我真的很喜欢[Broofa 的答案](https://stackoverflow.com/a/2117523/508537)是多么干净，但不幸的是，[糟糕的实现`Math.random`](https://stackoverflow.com/q/6906916/508537)留下了碰撞的机会。

这是一个类似的符合[RFC4122](http://www.ietf.org/rfc/rfc4122.txt)第 4 版的解决方案，它通过将前 13 个十六进制数字偏移时间戳的十六进制部分来解决该问题，并在页面加载后以微秒的十六进制部分耗尽偏移量。这样，即使`Math.random`在同一个种子上，两个客户端也必须在页面加载后（如果支持高性能时间）和完全相同的毫秒（或 10,000 多年后）生成 UUID 完全相同的微秒数获取相同的 UUID：

```
function generateUUID() { // Public Domain/MIT
    var d = new Date().getTime();//Timestamp
    var d2 = ((typeof performance !== 'undefined') && performance.now && (performance.now()*1000)) || 0;//Time in microseconds since page-load or 0 if unsupported
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16;//random number between 0 and 16
        if(d > 0){//Use timestamp until depleted
            r = (d + r)%16 | 0;
            d = Math.floor(d/16);
        } else {//Use microseconds since page-load if supported
            r = (d2 + r)%16 | 0;
            d2 = Math.floor(d2/16);
        }
        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}

var onClick = function(){
    document.getElementById('uuid').textContent = generateUUID();
}
onClick();
```

```
#uuid { font-family: monospace; font-size: 1.5em; }
```

```
<p id="uuid"></p>
<button id="generateUUID" onclick="onClick();">Generate UUID</button>
```

[这是一个要测试的小提琴。](https://jsfiddle.net/briguy37/8eacgpnq/)

* * *

### ES6 的现代化代码段

```
const generateUUID = () => {
  let
    d = new Date().getTime(),
    d2 = (performance && performance.now && (performance.now() * 1000)) || 0;
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    let r = Math.random() * 16;
    if (d > 0) {
      r = (d + r) % 16 | 0;
      d = Math.floor(d / 16);
    } else {
      r = (d2 + r) % 16 | 0;
      d2 = Math.floor(d2 / 16);
    }
    return (c == 'x' ? r : (r & 0x7 | 0x8)).toString(16);
  });
};

const onClick = (e) => document.getElementById('uuid').textContent = generateUUID();

document.getElementById('generateUUID').addEventListener('click', onClick);

onClick();
```

```
#uuid { font-family: monospace; font-size: 1.5em; }
```

```
<p id="uuid"></p>
<button id="generateUUID">Generate UUID</button>
```

* * *

## 回答 #4

> 赞同：486
> 
> 时间：2014-02-23T01:46:56.310

[broofa 的答案](https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid/2117523#2117523)确实非常巧妙 - 非常聪明，真的...... 符合 RFC4122，有点可读性和紧凑性。惊人的！

但是，如果您正在查看那个正则表达式、那些许多`replace()`回调、`toString()`'s 和`Math.random()`函数调用（他只使用了四位结果并浪费了其余部分），您可能会开始怀疑性能。事实上，joelpt 甚至决定放弃一个 RFC 以实现通用 GUID 速度`generateQuickGUID`。

**但是，我们能否获得速度*和*RFC 合规性？我说是！**我们可以保持可读性吗？嗯......不是真的，但如果你跟着它很容易。

但首先，与 broofa `guid`（公认的答案）和不符合 rfc 的结果相比，我的结果`generateQuickGuid`：

```
 Desktop   Android
           broofa: 1617ms   12869ms
               e1:  636ms    5778ms
               e2:  606ms    4754ms
               e3:  364ms    3003ms
               e4:  329ms    2015ms
               e5:  147ms    1156ms
               e6:  146ms    1035ms
               e7:  105ms     726ms
             guid:  962ms   10762ms
generateQuickGuid:  292ms    2961ms
  - Note: 500k iterations, results will vary by browser/CPU. 
```

因此，在我的第 6 次优化迭代中，我击败了最受欢迎的答案超过**12 倍**，超过了接受的答案超过了**9 倍**，以及快速不合规的答案超过了**2-3 倍**。而且我仍然符合 RFC 4122。

有兴趣怎么做？我已经把完整的源代码放在[http://jsfiddle.net/jcward/7hyaC/3/](http://jsfiddle.net/jcward/7hyaC/3/)和[http://jsperf.com/uuid-generator-opt/4](http://jsperf.com/uuid-generator-opt/4)

为了解释，让我们从 broofa 的代码开始：

```
function broofa() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    });
}

console.log(broofa())
```

所以它`x`用任何随机十六进制数字替换，`y`随机数据（除了根据 RFC 规范强制前两位），并且正则表达式与or字符`10`不匹配，所以他不必处理它们。非常非常光滑。`-``4`

首先要知道的是函数调用很昂贵，正则表达式也是如此（尽管他只使用了 1 个，但它有 32 个回调，每个匹配一个，并且在 32 个回调中的每一个中它调用 Math.random() 和 v。 toString(16))。

提高性能的第一步是消除 RegEx 及其回调函数，并改用简单的循环。这意味着我们必须处理`-`and`4`字符，而 broofa 没有。另外，请注意，我们可以使用字符串数组索引来保持他光滑的字符串模板架构：

```
function e1() {
    var u='',i=0;
    while(i++<36) {
        var c='xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'[i-1],r=Math.random()*16|0,v=c=='x'?r:(r&0x3|0x8);
        u+=(c=='-'||c=='4')?c:v.toString(16)
    }
    return u;
}

console.log(e1())
```

基本上，相同的内部逻辑，除了我们检查`-`or `4`，并且使用 while 循环（而不是`replace()`回调）使我们几乎提高了 3 倍！

下一步是桌面上的一个小步骤，但在移动设备上会有很大的不同。让我们进行更少的 Math.random() 调用并利用所有这些随机位，而不是将其中的 87% 丢弃在每次迭代中移出的随机缓冲区中。让我们也将模板定义移出循环，以防万一它有帮助：

```
function e2() {
    var u='',m='xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx',i=0,rb=Math.random()*0xffffffff|0;
    while(i++<36) {
        var c=m[i-1],r=rb&0xf,v=c=='x'?r:(r&0x3|0x8);
        u+=(c=='-'||c=='4')?c:v.toString(16);rb=i%8==0?Math.random()*0xffffffff|0:rb>>4
    }
    return u
}

console.log(e2())
```

这为我们节省了 10-30%，具体取决于平台。不错。但是下一个重要的步骤是通过一个经典的优化方法——查找表完全摆脱了 toString 函数调用。一个简单的 16 元素查找表将在更短的时间内执行 toString(16) 的工作：

```
function e3() {
    var h='0123456789abcdef';
    var k='xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    /* same as e4() below */
}
function e4() {
    var h=['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'];
    var k=['x','x','x','x','x','x','x','x','-','x','x','x','x','-','4','x','x','x','-','y','x','x','x','-','x','x','x','x','x','x','x','x','x','x','x','x'];
    var u='',i=0,rb=Math.random()*0xffffffff|0;
    while(i++<36) {
        var c=k[i-1],r=rb&0xf,v=c=='x'?r:(r&0x3|0x8);
        u+=(c=='-'||c=='4')?c:h[v];rb=i%8==0?Math.random()*0xffffffff|0:rb>>4
    }
    return u
}

console.log(e4())
```

下一个优化是另一个经典。由于我们在每次循环迭代中只处理 4 位输出，所以让我们将循环数减半并在每次迭代中处理 8 位。这很棘手，因为我们仍然必须处理符合 RFC 的位位置，但这并不太难。然后我们必须创建一个更大的查找表（16x16 或 256）来存储 0x00 - 0xFF，并且我们只在 e5() 函数之外构建它一次。

```
var lut = []; for (var i=0; i<256; i++) { lut[i] = (i<16?'0':'')+(i).toString(16); }
function e5() {
    var k=['x','x','x','x','-','x','x','-','4','x','-','y','x','-','x','x','x','x','x','x'];
    var u='',i=0,rb=Math.random()*0xffffffff|0;
    while(i++<20) {
        var c=k[i-1],r=rb&0xff,v=c=='x'?r:(c=='y'?(r&0x3f|0x80):(r&0xf|0x40));
        u+=(c=='-')?c:lut[v];rb=i%4==0?Math.random()*0xffffffff|0:rb>>8
    }
    return u
}

console.log(e5())
```

我尝试了一次处理 16 位的 e6()，仍然使用 256 元素[LUT](https://en.wikipedia.org/wiki/Lookup_table)，它显示了优化的收益递减。尽管它的迭代次数更少，但内部逻辑因处理量的增加而变得复杂，它在台式机上的执行情况相同，而在移动设备上仅快 10%。

要应用的最终优化技术 - 展开循环。由于我们循环的次数是固定的，因此我们可以在技术上手动将其全部写出来。我用一个随机变量尝试过一次`r`，我一直在重新分配它，但性能下降了。但是有四个变量预先分配了随机数据，然后使用查找表，并应用适当的 RFC 位，这个版本将它们全部抽出：

```
var lut = []; for (var i=0; i<256; i++) { lut[i] = (i<16?'0':'')+(i).toString(16); }
function e7()
{
    var d0 = Math.random()*0xffffffff|0;
    var d1 = Math.random()*0xffffffff|0;
    var d2 = Math.random()*0xffffffff|0;
    var d3 = Math.random()*0xffffffff|0;
    return lut[d0&0xff]+lut[d0>>8&0xff]+lut[d0>>16&0xff]+lut[d0>>24&0xff]+'-'+
    lut[d1&0xff]+lut[d1>>8&0xff]+'-'+lut[d1>>16&0x0f|0x40]+lut[d1>>24&0xff]+'-'+
    lut[d2&0x3f|0x80]+lut[d2>>8&0xff]+'-'+lut[d2>>16&0xff]+lut[d2>>24&0xff]+
    lut[d3&0xff]+lut[d3>>8&0xff]+lut[d3>>16&0xff]+lut[d3>>24&0xff];
}

console.log(e7())
```

[模块化： http](http://jcward.com/UUID.js) ://jcward.com/UUID.js -`UUID.generate()`

有趣的是，生成 16 字节的随机数据是很容易的部分。整个技巧是用符合 RFC的*字符串格式来表达它，并且最紧密地使用 16 字节的随机数据、展开的循环和查找表来完成。*

我希望我的逻辑是正确的——在这种繁琐的工作中很容易出错。但输出对我来说看起来不错。我希望您通过代码优化享受这段疯狂的旅程！

**请注意：**我的主要目标是展示和教授潜在的优化策略。其他答案涵盖了重要主题，例如冲突和真正的随机数，这对于生成良好的 UUID 很重要。

* * *

## 回答 #5

> 赞同：200
> 
> 时间：2017-05-19T20:50:22.337

采用：

```
let uniqueId = Date.now().toString(36) + Math.random().toString(36).substring(2); 
```

```
document.getElementById("unique").innerHTML =
  Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
```

```
<div id="unique">
</div>
```

如果生成的 ID 间隔超过 1 毫秒，则它们是 100% 唯一的。

如果以较短的间隔生成两个 ID，并假设随机方法是真正随机的，则这将生成 99.99999999999999% 的 ID 可能是全局唯一的（在 10^15 中的 1 中发生冲突）。

您可以通过添加更多数字来增加此数字，但要生成 100% 唯一 ID，您需要使用全局计数器。

如果您需要 RFC 兼容性，此格式将作为有效的版本 4 GUID 传递：

```
let u = Date.now().toString(16) + Math.random().toString(16) + '0'.repeat(16);
let guid = [u.substr(0,8), u.substr(8,4), '4000-8' + u.substr(13,3), u.substr(16,12)].join('-'); 
```

```
let u = Date.now().toString(16)+Math.random().toString(16)+'0'.repeat(16);
let guid = [u.substr(0,8), u.substr(8,4), '4000-8' + u.substr(13,3), u.substr(16,12)].join('-');
document.getElementById("unique").innerHTML = guid;
```

```
<div id="unique">
</div>
```

上面的代码遵循意图，但不是 RFC 的字母。在其他差异中，它是一些随机数字短。（如果需要，可以添加更多随机数字）好处是这真的很快:) 你可以[在这里测试你的 GUID 的有效性](https://www.freecodeformat.com/validate-uuid-guid.php)

* * *

## 回答 #6

> 赞同：182
> 
> 时间：2009-05-17T03:39:23.657

这是一些基于[RFC 4122](http://www.ietf.org/rfc/rfc4122.txt)第 4.4 节（从真正随机或伪随机数创建 UUID 的算法）的代码。

```
function createUUID() {
    // http://www.ietf.org/rfc/rfc4122.txt
    var s = [];
    var hexDigits = "0123456789abcdef";
    for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
    }
    s[14] = "4";  // bits 12-15 of the time_hi_and_version field to 0010
    s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01
    s[8] = s[13] = s[18] = s[23] = "-";

    var uuid = s.join("");
    return uuid;
} 
```

* * *

## 回答 #7

> 赞同：100
> 
> 时间：2013-05-22T13:50:43.363

这是格式中最快的类似 GUID 的字符串生成器方法`XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`。它不会生成符合标准的 GUID。

这个实现的一千万次执行只需要 32.5 秒，这是我在浏览器中见过的最快的（唯一没有循环/迭代的解决方案）。

函数很简单：

```
/**
 * Generates a GUID string.
 * @returns {string} The generated GUID.
 * @example af8a8416-6e18-a307-bd9c-f2c947bbb3aa
 * @author Slavik Meltser.
 * @link http://slavik.meltser.info/?p=142
 */
function guid() {
    function _p8(s) {
        var p = (Math.random().toString(16)+"000000000").substr(2,8);
        return s ? "-" + p.substr(0,4) + "-" + p.substr(4,4) : p ;
    }
    return _p8() + _p8(true) + _p8(true) + _p8();
} 
```

要测试性能，您可以运行以下代码：

```
console.time('t');
for (var i = 0; i < 10000000; i++) {
    guid();
};
console.timeEnd('t'); 
```

我相信你们中的大多数人都会理解我在那里所做的，但也许至少有一个人需要解释：

**算法：**

*   该`Math.random()`函数返回一个介于 0 和 1 之间的十进制数，小数点后有 16 位（例如`0.4363923368509859`）。
*   然后我们把这个数字转换成一个以 16 为底的字符串（从上面的例子中我们会得到 `0.6fb7687f`）。 `Math.random().toString(16)`.
*   然后我们切断`0.`前缀 ( `0.6fb7687f`=> `6fb7687f`) 并得到一个长度为 8 个十六进制字符的字符串。 `(Math.random().toString(16).substr(2,8)`.
*   有时`Math.random()`函数会返回较短的数字（例如`0.4363`），因为末尾是零（从上面的示例来看，实际上数字是`0.4363000000000000`）。这就是为什么我要附加到这个字符串`"000000000"`（一个有九个零的字符串），然后用函数将它截断`substr()`以使其恰好是九个字符（在右边填充零）。
*   恰好添加九个零的原因是因为更糟糕的情况，即`Math.random()`函数将恰好返回 0 或 1（每个零的概率为 1/10^16）。这就是为什么我们需要向它添加九个零（`"0"+"000000000"`或`"1"+"000000000"`），然后将其从第二个索引（第三个字符）中删除，长度为八个字符。对于其余情况，添加零不会损害结果，因为无论如何它都会将其切断。 `Math.random().toString(16)+"000000000").substr(2,8)`.

**大会：**

*   GUID 采用以下格式`XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`。
*   我将 GUID 分为四块，每块又分为两种类型（或格式）：`XXXXXXXX`和`-XXXX-XXXX`.
*   现在我正在使用这两种类型构建 GUID 来组装 GUID 并调用四个部分，如下所示：`XXXXXXXX` `-XXXX-XXXX` `-XXXX-XXXX` `XXXXXXXX`.
*   为了区分这两种类型，我在pair creator函数中添加了一个标志参数`_p8(s)`，该`s`参数告诉函数是否添加破折号。
*   最终，我们使用以下链接构建 GUID: `_p8() + _p8(true) + _p8(true) + _p8()`，并返回它。

[链接到我博客上的这篇文章](http://slavik.meltser.info/the-efficient-way-to-create-guid-uuid-in-javascript/)

**享受！:-)**

* * *

## 回答 #8

> 赞同：80
> 
> 时间：2012-11-15T18:04:57.513

这是一个完全不兼容但非常高效的实现，用于生成一个 ASCII 安全的类似 GUID 的唯一标识符。

```
function generateQuickGuid() {
    return Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15);
} 
```

生成 26 个 [a-z0-9] 字符，生成的 UID 比 RFC 兼容的 GUID 更短且更独特。如果人类可读性很重要，可以轻松添加破折号。

以下是此功能的使用示例和时间安排以及该问题的其他几个答案。计时在 Chrome m25 下进行，每次 1000 万次迭代。

```
>>> generateQuickGuid()
"nvcjf1hs7tf8yyk4lmlijqkuo9"
"yq6gipxqta4kui8z05tgh9qeel"
"36dh5sec7zdj90sk2rx7pjswi2"
runtime: 32.5s

>>> GUID() // John Millikin
"7a342ca2-e79f-528e-6302-8f901b0b6888"
runtime: 57.8s

>>> regexGuid() // broofa
"396e0c46-09e4-4b19-97db-bd423774a4b3"
runtime: 91.2s

>>> createUUID() // Kevin Hakanson
"403aa1ab-9f70-44ec-bc08-5d5ac56bd8a5"
runtime: 65.9s

>>> UUIDv4() // Jed Schmidt
"f4d7d31f-fa83-431a-b30c-3e6cc37cc6ee"
runtime: 282.4s

>>> Math.uuid() // broofa
"5BD52F55-E68F-40FC-93C2-90EE069CE545"
runtime: 225.8s

>>> Math.uuidFast() // broofa
"6CB97A68-23A2-473E-B75B-11263781BBE6"
runtime: 92.0s

>>> Math.uuidCompact() // broofa
"3d7b7a06-0a67-4b67-825c-e5c43ff8c1e8"
runtime: 229.0s

>>> bitwiseGUID() // jablko
"baeaa2f-7587-4ff1-af23-eeab3e92"
runtime: 79.6s

>>>> betterWayGUID() // Andrea Turri
"383585b0-9753-498d-99c3-416582e9662c"
runtime: 60.0s

>>>> UUID() // John Fowler
"855f997b-4369-4cdb-b7c9-7142ceaf39e8"
runtime: 62.2s 
```

这是时间代码。

```
var r;
console.time('t'); 
for (var i = 0; i < 10000000; i++) { 
    r = FuncToTest(); 
};
console.timeEnd('t'); 
```

* * *

## 回答 #9

> 赞同：70
> 
> 时间：2008-09-19T20:06:03.003

来自[sagi shkedy 的技术博客](http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html)：

```
function generateGuid() {
  var result, i, j;
  result = '';
  for(j=0; j<32; j++) {
    if( j == 8 || j == 12 || j == 16 || j == 20)
      result = result + '-';
    i = Math.floor(Math.random()*16).toString(16).toUpperCase();
    result = result + i;
  }
  return result;
} 
```

还有其他涉及使用[ActiveX](https://en.wikipedia.org/wiki/ActiveX)控件的方法，但请远离这些！

我认为值得指出的是，没有 GUID 生成器可以保证唯一的键（查看[Wikipedia 文章](http://en.wikipedia.org/wiki/Globally_Unique_Identifier)）。总是有碰撞的可能。GUID 只是提供足够大的键域来将冲突的变化减少到几乎为零。

* * *

## 回答 #10

> 赞同：69
> 
> 时间：2011-12-12T10:13:24.253

这是[投票最多的答案的组合，以及](https://stackoverflow.com/a/2117523/11236)[Chrome 冲突](https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript)的解决方法：

```
generateGUID = (typeof(window.crypto) != 'undefined' &&
                typeof(window.crypto.getRandomValues) != 'undefined') ?
    function() {
        // If we have a cryptographically secure PRNG, use that
        // https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript
        var buf = new Uint16Array(8);
        window.crypto.getRandomValues(buf);
        var S4 = function(num) {
            var ret = num.toString(16);
            while(ret.length < 4){
                ret = "0"+ret;
            }
            return ret;
        };
        return (S4(buf[0])+S4(buf[1])+"-"+S4(buf[2])+"-"+S4(buf[3])+"-"+S4(buf[4])+"-"+S4(buf[5])+S4(buf[6])+S4(buf[7]));
    }

    :

    function() {
        // Otherwise, just use Math.random
        // https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
    }; 
```

如果你想测试它，它[在 jsbin 上。](http://jsbin.com/uqives/3)

* * *

## 回答 #11

> 赞同：64
> 
> 时间：2011-08-15T02:27:35.500

这是 2011 年 10 月 9 日用户*jed*在[https://gist.github.com/982883](https://gist.github.com/982883)的评论中的解决方案：

```
UUIDv4 = function b(a){return a?(a^Math.random()*16>>a/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,b)} 
```

[这实现了与当前评分最高的答案](https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523)相同的目标，但通过利用强制、递归和指数表示法减少了 50 多个字节。对于那些好奇它是如何工作的人，这里是该函数旧版本的注释形式：

```
UUIDv4 =

function b(
  a // placeholder
){
  return a // if the placeholder was passed, return
    ? ( // a random number from 0 to 15
      a ^ // unless b is 8,
      Math.random() // in which case
      * 16 // a random number from
      >> a/4 // 8 to 11
      ).toString(16) // in hexadecimal
    : ( // or otherwise a concatenated string:
      [1e7] + // 10000000 +
      -1e3 + // -1000 +
      -4e3 + // -4000 +
      -8e3 + // -80000000 +
      -1e11 // -100000000000,
      ).replace( // replacing
        /[018]/g, // zeroes, ones, and eights with
        b // random hex digits
      )
} 
```

* * *

## 回答 #12

> 赞同：54
> 
> 时间：2015-10-13T01:50:19.510

您可以使用[node-uuid](https://github.com/kelektiv/node-uuid)。它提供了简单、快速的[RFC4122](http://www.ietf.org/rfc/rfc4122.txt) UUIDS 生成。

特征：

*   生成 RFC4122 版本 1 或版本 4 UUID
*   在[Node.js](https://en.wikipedia.org/wiki/Node.js)和浏览器中运行。
*   支持平台上的加密强随机 # 生成。
*   占地面积小（想要更小的东西？[看看这个！](https://gist.github.com/982883)）

* * *

**使用 NPM 安装：**

```
npm install uuid 
```

* * *

**或者通过浏览器使用 uuid：**

下载原始文件（uuid v1）：[https](https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js) ://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js 下载原始文件（uuid v4）：[https ://raw.githubusercontent.com/kelektiv/node -uuid/master/v4.js](https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js)

* * *

想要更小？看看这个：[https ://gist.github.com/jed/982883](https://gist.github.com/jed/982883)

* * *

**用法：**

```
// Generate a v1 UUID (time-based)
const uuidV1 = require('uuid/v1');
uuidV1(); // -> '6c84fb90-12c4-11e1-840d-7b25c5ee775a'

// Generate a v4 UUID (random)
const uuidV4 = require('uuid/v4');
uuidV4(); // -> '110ec58a-a0f2-4ac4-8393-c866d813b8d1'

// Generate a v5 UUID (namespace)
const uuidV5 = require('uuid/v5');

// ... using predefined DNS namespace (for domain names)
uuidV5('hello.example.com', v5.DNS)); // -> 'fdda765f-fc57-5604-a269-52a7df8164ec'

// ... using predefined URL namespace (for, well, URLs)
uuidV5('http://example.com/hello', v5.URL); // -> '3bbcee75-cecc-5b56-8031-b6641c1ed1f1'

// ... using a custom namespace
const MY_NAMESPACE = '(previously generated unique uuid string)';
uuidV5('hello', MY_NAMESPACE); // -> '90123e1c-7512-523e-bb28-76fab9f2f73d' 
```

* * *

**ECMAScript 2015 (ES6)：**

```
import uuid from 'uuid/v4';
const id = uuid(); 
```

* * *

## 回答 #13

> 赞同：37
> 
> 时间：2011-08-28T15:17:24.080

```
var uuid = function() {
    var buf = new Uint32Array(4);
    window.crypto.getRandomValues(buf);
    var idx = -1;
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        idx++;
        var r = (buf[idx>>3] >> ((idx%8)*4))&15;
        var v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    });
}; 
```

此版本基于 Briguy37 的答案和一些按位运算符从缓冲区中提取半字节大小的窗口。

它应该遵守 RFC Type 4（随机）模式，因为我上次使用 Java 的 UUID 解析不兼容的 UUID 时遇到了*问题。*

* * *

## 回答 #14

> 赞同：34
> 
> 时间：2009-08-24T16:12:46.980

这将创建一个版本 4 UUID（从伪随机数创建）：

```
function uuid()
{
   var chars = '0123456789abcdef'.split('');

   var uuid = [], rnd = Math.random, r;
   uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
   uuid[14] = '4'; // version 4

   for (var i = 0; i < 36; i++)
   {
      if (!uuid[i])
      {
         r = 0 | rnd()*16;

         uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r & 0xf];
      }
   }

   return uuid.join('');
} 
```

以下是生成的 UUID 示例：

```
682db637-0f31-4847-9cdf-25ba9613a75c
97d19478-3ab2-4aa1-b8cc-a1c3540f54aa
2eed04c9-2692-456d-a0fd-51012f947136 
```

* * *

## 回答 #15

> 赞同：34
> 
> 时间：2013-02-02T15:27:06.797

简单的 JavaScript 模块作为此问题中最佳答案的组合。

```
var crypto = window.crypto || window.msCrypto || null; // IE11 fix

var Guid = Guid || (function() {

  var EMPTY = '00000000-0000-0000-0000-000000000000';

  var _padLeft = function(paddingString, width, replacementChar) {
    return paddingString.length >= width ? paddingString : _padLeft(replacementChar + paddingString, width, replacementChar || ' ');
  };

  var _s4 = function(number) {
    var hexadecimalResult = number.toString(16);
    return _padLeft(hexadecimalResult, 4, '0');
  };

  var _cryptoGuid = function() {
    var buffer = new window.Uint16Array(8);
    crypto.getRandomValues(buffer);
    return [_s4(buffer[0]) + _s4(buffer[1]), _s4(buffer[2]), _s4(buffer[3]), _s4(buffer[4]), _s4(buffer[5]) + _s4(buffer[6]) + _s4(buffer[7])].join('-');
  };

  var _guid = function() {
    var currentDateMilliseconds = new Date().getTime();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(currentChar) {
      var randomChar = (currentDateMilliseconds + Math.random() * 16) % 16 | 0;
      currentDateMilliseconds = Math.floor(currentDateMilliseconds / 16);
      return (currentChar === 'x' ? randomChar : (randomChar & 0x7 | 0x8)).toString(16);
    });
  };

  var create = function() {
    var hasCrypto = crypto != 'undefined' && crypto !== null,
      hasRandomValues = typeof(window.crypto.getRandomValues) != 'undefined';
    return (hasCrypto && hasRandomValues) ? _cryptoGuid() : _guid();
  };

  return {
    newGuid: create,
    empty: EMPTY
  };
})();

// DEMO: Create and show GUID
console.log('1\. New Guid:   ' + Guid.newGuid());

// DEMO: Show empty GUID
console.log('2\. Empty Guid: ' + Guid.empty);
```

用法：

> > **Guid.newGuid()**

> > “c6c2d12f-d76b-5739-e551-07e6de5b0807”

> > **Guid.empty**

> > “00000000-0000-0000-0000-000000000000”

* * *

## 回答 #16

> 赞同：28
> 
> 时间：2014-07-22T15:31:43.443

下面的版本是对[broofa 答案](https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid/2117523#2117523)的改编，但更新为包含一个“真正的”随机函数，该函数在可用的情况下使用加密库，并且 Alea() 函数作为后备。

```
 Math.log2 = Math.log2 || function(n){ return Math.log(n) / Math.log(2); }
  Math.trueRandom = (function() {
  var crypt = window.crypto || window.msCrypto;

  if (crypt && crypt.getRandomValues) {
      // If we have a crypto library, use it
      var random = function(min, max) {
          var rval = 0;
          var range = max - min;
          if (range < 2) {
              return min;
          }

          var bits_needed = Math.ceil(Math.log2(range));
          if (bits_needed > 53) {
            throw new Exception("We cannot generate numbers larger than 53 bits.");
          }
          var bytes_needed = Math.ceil(bits_needed / 8);
          var mask = Math.pow(2, bits_needed) - 1;
          // 7776 -> (2^13 = 8192) -1 == 8191 or 0x00001111 11111111

          // Create byte array and fill with N random numbers
          var byteArray = new Uint8Array(bytes_needed);
          crypt.getRandomValues(byteArray);

          var p = (bytes_needed - 1) * 8;
          for(var i = 0; i < bytes_needed; i++ ) {
              rval += byteArray[i] * Math.pow(2, p);
              p -= 8;
          }

          // Use & to apply the mask and reduce the number of recursive lookups
          rval = rval & mask;

          if (rval >= range) {
              // Integer out of acceptable range
              return random(min, max);
          }
          // Return an integer that falls within the range
          return min + rval;
      }
      return function() {
          var r = random(0, 1000000000) / 1000000000;
          return r;
      };
  } else {
      // From https://web.archive.org/web/20120502223108/http://baagoe.com/en/RandomMusings/javascript/
      // Johannes Baagøe <baagoe@baagoe.com>, 2010
      function Mash() {
          var n = 0xefc8249d;

          var mash = function(data) {
              data = data.toString();
              for (var i = 0; i < data.length; i++) {
                  n += data.charCodeAt(i);
                  var h = 0.02519603282416938 * n;
                  n = h >>> 0;
                  h -= n;
                  h *= n;
                  n = h >>> 0;
                  h -= n;
                  n += h * 0x100000000; // 2^32
              }
              return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
          };

          mash.version = 'Mash 0.9';
          return mash;
      }

      // From http://baagoe.com/en/RandomMusings/javascript/
      function Alea() {
          return (function(args) {
              // Johannes BaagÃ¸e <baagoe@baagoe.com>, 2010
              var s0 = 0;
              var s1 = 0;
              var s2 = 0;
              var c = 1;

              if (args.length == 0) {
                  args = [+new Date()];
              }
              var mash = Mash();
              s0 = mash(' ');
              s1 = mash(' ');
              s2 = mash(' ');

              for (var i = 0; i < args.length; i++) {
                  s0 -= mash(args[i]);
                  if (s0 < 0) {
                      s0 += 1;
                  }
                  s1 -= mash(args[i]);
                  if (s1 < 0) {
                      s1 += 1;
                  }
                  s2 -= mash(args[i]);
                  if (s2 < 0) {
                      s2 += 1;
                  }
              }
              mash = null;

              var random = function() {
                  var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
                  s0 = s1;
                  s1 = s2;
                  return s2 = t - (c = t | 0);
              };
              random.uint32 = function() {
                  return random() * 0x100000000; // 2^32
              };
              random.fract53 = function() {
                  return random() +
                      (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
              };
              random.version = 'Alea 0.9';
              random.args = args;
              return random;

          }(Array.prototype.slice.call(arguments)));
      };
      return Alea();
  }
}());

Math.guid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c)    {
      var r = Math.trueRandom() * 16 | 0,
          v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
  });
}; 
```

* * *

## 回答 #17

> 赞同：27
> 
> 时间：2012-07-02T21:00:32.180

GitHub 上的 JavaScript 项目 - [https://github.com/LiosK/UUID.js](https://github.com/LiosK/UUID.js)

> **UUID.js 符合 RFC 标准的 JavaScript 的 UUID 生成器。**
> 
> 请参阅 RFC 4122 [http://www.ietf.org/rfc/rfc4122.txt](http://www.ietf.org/rfc/rfc4122.txt)。
> 
> **功能 生成符合 RFC 4122 的 UUID。**
> 
> 版本 4 UUID（来自随机数的 UUID）和版本 1 UUID（基于时间的 UUID）可用。
> 
> UUID 对象允许对 UUID 进行多种访问，包括对 UUID 字段的访问。
> 
> JavaScript 的低时间戳分辨率由随机数补偿。

* * *

## 回答 #18

> 赞同：23
> 
> 时间：2010-07-14T23:30:52.323

```
 // RFC 4122
  //
  // A UUID is 128 bits long
  //
  // String representation is five fields of 4, 2, 2, 2, and 6 bytes.
  // Fields represented as lowercase, zero-filled, hexadecimal strings, and
  // are separated by dash characters
  //
  // A version 4 UUID is generated by setting all but six bits to randomly
  // chosen values
  var uuid = [
    Math.random().toString(16).slice(2, 10),
    Math.random().toString(16).slice(2, 6),

    // Set the four most significant bits (bits 12 through 15) of the
    // time_hi_and_version field to the 4-bit version number from Section
    // 4.1.3
    (Math.random() * .0625 /* 0x.1 */ + .25 /* 0x.4 */).toString(16).slice(2, 6),

    // Set the two most significant bits (bits 6 and 7) of the
    // clock_seq_hi_and_reserved to zero and one, respectively
    (Math.random() * .25 /* 0x.4 */ + .5 /* 0x.8 */).toString(16).slice(2, 6),

    Math.random().toString(16).slice(2, 14)].join('-'); 
```

* * *

## 回答 #19

> 赞同：17
> 
> 时间：2012-11-16T19:41:49.123

对于那些想要一个符合[RFC 4122](https://en.wikipedia.org/wiki/Universally_unique_identifier#History)版本 4 并考虑速度的解决方案的人（很少调用 Math.random()）：

```
var rand = Math.random;

function UUID() {
    var nbr, randStr = "";
    do {
        randStr += (nbr = rand()).toString(16).substr(3, 6);
    } while (randStr.length < 30);
    return (
        randStr.substr(0, 8) + "-" +
        randStr.substr(8, 4) + "-4" +
        randStr.substr(12, 3) + "-" +
        ((nbr*4|0)+8).toString(16) + // [89ab]
        randStr.substr(15, 3) + "-" +
        randStr.substr(18, 12)
    );
}

console.log( UUID() );
```

上述函数应该在速度和随机性之间取得不错的平衡。

* * *

## 回答 #20

> 赞同：16
> 
> 时间：2015-03-08T00:39:31.000

我想了解[broofa 的回答](https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid/2117523#2117523)，所以我对其进行了扩展并添加了评论：

```
var uuid = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
        /[xy]/g,
        function (match) {
            /*
            * Create a random nibble. The two clever bits of this code:
            *
            * - Bitwise operations will truncate floating point numbers
            * - For a bitwise OR of any x, x | 0 = x
            *
            * So:
            *
            * Math.random * 16
            *
            * creates a random floating point number
            * between 0 (inclusive) and 16 (exclusive) and
            *
            * | 0
            *
            * truncates the floating point number into an integer.
            */
            var randomNibble = Math.random() * 16 | 0;

            /*
            * Resolves the variant field. If the variant field (delineated
            * as y in the initial string) is matched, the nibble must
            * match the mask (where x is a do-not-care bit):
            *
            * 10xx
            *
            * This is achieved by performing the following operations in
            * sequence (where x is an intermediate result):
            *
            * - x & 0x3, which is equivalent to x % 3
            * - x | 0x8, which is equivalent to x + 8
            *
            * This results in a nibble between 8 inclusive and 11 exclusive,
            * (or 1000 and 1011 in binary), all of which satisfy the variant
            * field mask above.
            */
            var nibble = (match == 'y') ?
                (randomNibble & 0x3 | 0x8) :
                randomNibble;

            /*
            * Ensure the nibble integer is encoded as base 16 (hexadecimal).
            */
            return nibble.toString(16);
        }
    );
}; 
```

* * *

## 回答 #21

> 赞同：15
> 
> 时间：2012-01-13T21:59:35.377

[我在这里](http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx)调整了我自己的 UUID/GUID 生成器，并添加了一些附加功能。

我正在使用[以下 Kybos](http://baagoe.com/en/RandomMusings/javascript/)随机数生成器，使其在密码学上更加可靠。

下面是我的脚本，其中排除了 baagoe.com 的 Mash 和 Kybos 方法。

```
//UUID/Guid Generator
// use: UUID.create() or UUID.createSequential()
// convenience:  UUID.empty, UUID.tryParse(string)
(function(w){
  // From http://baagoe.com/en/RandomMusings/javascript/
  // Johannes BaagÃ¸e <baagoe@baagoe.com>, 2010
  //function Mash() {...};

  // From http://baagoe.com/en/RandomMusings/javascript/
  //function Kybos() {...};

  var rnd = Kybos();

  //UUID/GUID Implementation from http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx
  var UUID = {
    "empty": "00000000-0000-0000-0000-000000000000"
    ,"parse": function(input) {
      var ret = input.toString().trim().toLowerCase().replace(/^[\s\r\n]+|[\{\}]|[\s\r\n]+$/g, "");
      if ((/[a-f0-9]{8}\-[a-f0-9]{4}\-[a-f0-9]{4}\-[a-f0-9]{4}\-[a-f0-9]{12}/).test(ret))
        return ret;
      else
        throw new Error("Unable to parse UUID");
    }
    ,"createSequential": function() {
      var ret = new Date().valueOf().toString(16).replace("-","")
      for (;ret.length < 12; ret = "0" + ret);
      ret = ret.substr(ret.length-12,12); //only least significant part
      for (;ret.length < 32;ret += Math.floor(rnd() * 0xffffffff).toString(16));
      return [ret.substr(0,8), ret.substr(8,4), "4" + ret.substr(12,3), "89AB"[Math.floor(Math.random()*4)] + ret.substr(16,3),  ret.substr(20,12)].join("-");
    }
    ,"create": function() {
      var ret = "";
      for (;ret.length < 32;ret += Math.floor(rnd() * 0xffffffff).toString(16));
      return [ret.substr(0,8), ret.substr(8,4), "4" + ret.substr(12,3), "89AB"[Math.floor(Math.random()*4)] + ret.substr(16,3),  ret.substr(20,12)].join("-");
    }
    ,"random": function() {
      return rnd();
    }
    ,"tryParse": function(input) {
      try {
        return UUID.parse(input);
      } catch(ex) {
        return UUID.empty;
      }
    }
  };
  UUID["new"] = UUID.create;

  w.UUID = w.Guid = UUID;
}(window || this));
```

* * *

## 回答 #22

> 赞同：14
> 
> 时间：2017-07-09T13:01:53.273

ES6 示例

```
const guid=()=> {
  const s4=()=> Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);     
  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4() + s4() + s4()}`;
} 
```

* * *

## 回答 #23

> 赞同：14
> 
> 时间：2021-02-23T11:31:35.620

使用 Blob 的一条线解决方案。

```
window.URL.createObjectURL(new Blob([])).substring(31); 
```

末尾的值 (31) 取决于 URL 的长度。

* * *

**编辑：**

[正如rinogo](https://stackoverflow.com/users/114558/rinogo)所建议的，一个更紧凑和通用的解决方案：

```
window.URL.createObjectURL(new Blob([])).substr(-36); 
```

* * *

## 回答 #24

> 赞同：13
> 
> 时间：2012-05-23T18:42:35.067

更好的方法：

```
function(
  a, b               // Placeholders
){
  for(               // Loop :)
      b = a = '';    // b - result , a - numeric variable
      a++ < 36;      //
      b += a*51&52   // If "a" is not 9 or 14 or 19 or 24
                  ?  //  return a random number or 4
           (
               a^15              // If "a" is not 15,
                  ?              // generate a random number from 0 to 15
               8^Math.random() *
               (a^20 ? 16 : 4)   // unless "a" is 20, in which case a random number from 8 to 11,
                  :
               4                 //  otherwise 4
           ).toString(16)
                  :
         '-'                     //  In other cases, (if "a" is 9,14,19,24) insert "-"
      );
  return b
 } 
```

最小化：

```
function(a,b){for(b=a='';a++<36;b+=a*51&52?(a^15?8^Math.random()*(a^20?16:4):4).toString(16):'-');return b} 
```

* * *

## 回答 #25

> 赞同：13
> 
> 时间：2017-05-10T20:13:46.583

如果您只需要一个没有特定格式的随机 128 位字符串，您可以使用：

```
function uuid() {
    return crypto.getRandomValues(new Uint32Array(4)).join('-');
} 
```

这将返回类似`2350143528-4164020887-938913176-2513998651`.

* * *

## 回答 #26

> 赞同：13
> 
> 时间：2018-12-11T11:39:53.927

我找不到任何使用单个 16 字节`TypedArray`和 a 的答案，因此我认为以下[根据 RFC](https://www.ietf.org/rfc/rfc4122.txt)`DataView`生成版本 4 UUID 的解决方案将在这里独立存在：

```
export const uuid4 = () => {
    const ho = (n, p) => n.toString(16).padStart(p, 0); /// Return the hexadecimal text representation of number `n`, padded with zeroes to be of length `p`
    const data = crypto.getRandomValues(new Uint8Array(16)); /// Fill the buffer with random data
    data[6] = (data[6] & 0xf) | 0x40; /// Patch the 6th byte to reflect a version 4 UUID
    data[8] = (data[8] & 0x3f) | 0x80; /// Patch the 8th byte to reflect a variant 1 UUID (version 4 UUIDs are)
    const view = new DataView(data.buffer); /// Create a view backed by a 16-byte buffer
    return `${ho(view.getUint32(0), 8)}-${ho(view.getUint16(4), 4)}-${ho(view.getUint16(6), 4)}-${ho(view.getUint16(8), 4)}-${ho(view.getUint32(10), 8)}${ho(view.getUint16(14), 4)}`; /// Compile the canonical textual form from the array data
}; 
```

我更喜欢它，因为它只依赖于标准 ECMAScript 平台可用的函数，在可能的情况下——这只是一个过程。

在撰写本文时，`getRandomValues`还没有为`crypto`Node.js 中的对象实现一些东西。`randomBytes`但是，它具有可以替代使用的等效功能。

* * *

## 回答 #27

> 赞同：13
> 
> 时间：2020-06-13T11:42:03.290

本机`URL.createObjectURL`正在生成一个 UUID。您可以利用这一点。

```
function uuid() {
  const url = URL.createObjectURL(new Blob())
  const [id] = url.toString().split('/').reverse()
  URL.revokeObjectURL(url)
  return id
} 
```

* * *

## 回答 #28

> 赞同：12
> 
> 时间：2013-06-12T16:00:03.247

`SP.Guid.newGuid`如果您的环境是 SharePoint，则有一个称为( [MSDN 链接](http://msdn.microsoft.com/en-us/library/ee659495(v=office.14).aspx)的实用程序函数，它创建一个新的 GUID。此函数位于 sp.init.js 文件中。如果您重写此函数（以从其他私有函数中删除一些其他依赖项），它看起来像这样：

```
var newGuid = function () {
    var result = '';
    var hexcodes = "0123456789abcdef".split("");

    for (var index = 0; index < 32; index++) {
        var value = Math.floor(Math.random() * 16);

        switch (index) {
        case 8:
            result += '-';
            break;
        case 12:
            value = 4;
            result += '-';
            break;
        case 16:
            value = value & 3 | 8;
            result += '-';
            break;
        case 20:
            result += '-';
            break;
        }
        result += hexcodes[value];
    }
    return result;
}; 
```

* * *

## 回答 #29

> 赞同：12
> 
> 时间：2015-06-03T00:58:45.677

以下是`crypto.getRandomValues(a)`在[支持的浏览器](http://caniuse.com/#search=getRandomValues)（Internet Explorer 11+、iOS 7+、Firefox 21+、Chrome 和 Android Chrome）上使用的简单代码。

它避免使用`Math.random()`，因为这可能会导致冲突（例如[Muxa](https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript)在真实情况下生成的 4000 个 UUID 发生 20 次冲突）。

```
function uuid() {
    function randomDigit() {
        if (crypto && crypto.getRandomValues) {
            var rands = new Uint8Array(1);
            crypto.getRandomValues(rands);
            return (rands[0] % 16).toString(16);
        } else {
            return ((Math.random() * 16) | 0).toString(16);
        }
    }

    var crypto = window.crypto || window.msCrypto;
    return 'xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx'.replace(/x/g, randomDigit);
} 
```

笔记：

*   针对代码可读性而不是速度进行了优化，因此它适用于每秒几百个 UUID。[它使用http://jsbin.com/fuwigo/1](http://jsbin.com/fuwigo/1)在我的笔记本电脑上的 Chromium 中每秒生成大约 10000 uuid()来测量性能。
*   它仅将*8*用于“y”，因为这简化了代码的可读性（y 允许为*8*、*9*、*A*或*B*）。

* * *

## 回答 #30

> 赞同：12
> 
> 时间：2017-11-24T14:14:11.830

只是另一个更具可读性的变体，只有两个突变。

```
function uuid4()
{
  function hex (s, b)
  {
    return s +
      (b >>> 4   ).toString (16) +  // high nibble
      (b & 0b1111).toString (16);   // low nibble
  }

  let r = crypto.getRandomValues (new Uint8Array (16));

  r[6] = r[6] >>> 4 | 0b01000000; // Set type 4: 0100
  r[8] = r[8] >>> 3 | 0b10000000; // Set variant: 100

  return r.slice ( 0,  4).reduce (hex, '' ) +
         r.slice ( 4,  6).reduce (hex, '-') +
         r.slice ( 6,  8).reduce (hex, '-') +
         r.slice ( 8, 10).reduce (hex, '-') +
         r.slice (10, 16).reduce (hex, '-');
} 
```

* * *

## 回答 #31

> 赞同：11
> 
> 时间：2014-03-06T11:34:54.647

这是基于日期的，并添加了一个随机后缀以“确保”唯一性。

它适用于 CSS 标识符，总是返回类似的东西，并且很容易破解：

uid-139410573297741

```
var getUniqueId = function (prefix) {
            var d = new Date().getTime();
            d += (parseInt(Math.random() * 100)).toString();
            if (undefined === prefix) {
                prefix = 'uid-';
            }
            d = prefix + d;
            return d;
        }; 
```

* * *

## 回答 #32

> 赞同：9
> 
> 时间：2019-01-18T07:16:58.697

好的，使用**uuid**包及其对**版本 1、3、4 和 5 UUID**的支持，执行以下操作：

```
yarn add uuid 
```

进而：

```
const uuidv1 = require('uuid/v1');
uuidv1(); // ⇨ '45745c60-7b1a-11e8-9c9c-2d42b21b1a3e' 
```

您也可以使用完全指定的选项来执行此操作：

```
const v1options = {
  node: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],
  clockseq: 0x1234,
  msecs: new Date('2011-11-01').getTime(),
  nsecs: 5678
};
uuidv1(v1options); // ⇨ '710b962e-041c-11e1-9234-0123456789ab' 
```

[有关更多信息，请访问此处](https://www.npmjs.com/package/uuid)的 npm 页面。

* * *

## 回答 #33

> 赞同：8
> 
> 时间：2021-09-18T17:41:17.133

新增：v15.6.0、v14.17.0 有一个内置的[crypto.randomUUID()](https://nodejs.org/api/crypto.html#crypto_crypto_randomuuid_options)函数。

```
import * as crypto from "crypto";

const uuid = crypto.randomUUID(); 
```

在浏览器中，[`crypto.randomUUID()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID)目前在 Chromium 92+ 和 Firefox 95+ 中受支持。

* * *

## 回答 #34

> 赞同：7
> 
> 时间：2021-06-26T09:44:15.607

受[broofa回答的](https://stackoverflow.com/a/2117523/794539)启发，我对此有自己的看法：

这是使用`crypto.getRandomValues`.

```
function uuidv4() {
    const a = crypto.getRandomValues(new Uint16Array(8));
    let i = 0;
    return '00-0-4-1-000'.replace(/[^-]/g, 
            s => (a[i++] + s * 0x10000 >> s).toString(16).padStart(4, '0')
    );
}

console.log(uuidv4());
```

`Math.random`这是使用几乎相同原理的更快版本：

```
function uuidv4() {
    return '00-0-4-1-000'.replace(/[^-]/g,
            s => ((Math.random() + ~~s) * 0x10000 >> s).toString(16).padStart(4, '0')
    );
}

console.log(uuidv4());
```

* * *

## 回答 #35

> 赞同：6
> 
> 时间：2013-12-01T23:26:36.167

重要的是使用由多个贡献者维护的经过良好测试的代码，而不是为此鞭打自己的东西。

这是您可能想要最稳定的代码而不是在 X 浏览器中运行的最短的聪明版本的地方之一，但没有考虑到 Y 的特质，这通常会导致非常难以-调查错误，而不是仅针对某些用户随机显示。[我个人在https://github.com/aurigadl/uuid-js](https://github.com/aurigadl/uuid-js)使用 uuid-js，它启用了[Bower](https://bower.io/)，因此我可以轻松获取更新。

* * *

## 回答 #36

> 赞同：6
> 
> 时间：2021-03-10T22:48:58.580

执行此操作的最简单功能：

```
function createGuid(){  
   let S4 = () => Math.floor((1+Math.random())*0x10000).toString(16).substring(1); 
   let guid = `${S4()}${S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;

   return guid.toLowerCase();  
} 
```

* * *

## 回答 #37

> 赞同：5
> 
> 时间：2015-10-27T08:33:01.007

您可以使用 npm 包*[guid](https://www.npmjs.com/package/guid)*，一个 GUID 生成器和验证器。

例子：

```
Guid.raw();
// -> '6fdf6ffc-ed77-94fa-407e-a7b86ed9e59d' 
```

**注意：**此软件包已被弃用。请改用**[uuid](https://www.npmjs.com/package/uuid)**。

例子：

```
const uuidv4 = require('uuid/v4');
uuidv4(); // ⇨ '10ba038e-48da-487b-96e8-8d3b99b6d18a' 
```

* * *

## 回答 #38

> 赞同：4
> 
> 时间：2014-04-04T07:13:34.660

我正在使用以下功能：

```
function NewGuid()
{
    var sGuid = "";
    for (var i=0; i<32; i++)
    {
        sGuid += Math.floor(Math.random()*0xF).toString(0xF);
    }
    return sGuid;
} 
```

* * *

## 回答 #39

> 赞同：4
> 
> 时间：2015-05-27T06:00:57.927

生成唯一标识的一个简单解决方案是使用时间令牌并向其添加随机数。我更喜欢在它前面加上“uuid-”。

下面的函数将生成一个随机字符串类型：**uuid-14d93eb1b9b4533e6**。不需要生成 32 个字符的随机字符串。在这种情况下，一个 16 个字符的随机字符串足以在 JavaScript 中提供唯一的 UUID。

```
var createUUID = function() {
  return "uuid-" + ((new Date).getTime().toString(16) + Math.floor(1E7*Math.random()).toString(16));
} 
```

* * *

## 回答 #40

> 赞同：4
> 
> 时间：2020-04-03T11:52:59.297

[broofa 从 2017-06-28 更新](https://stackoverflow.com/revisions/2117523/11)的 TypeScript 版本，基于`crypto`API：

```
function genUUID() {
    // Reference: https://stackoverflow.com/a/2117523/709884
    return ("10000000-1000-4000-8000-100000000000").replace(/[018]/g, s => {
        const c = Number.parseInt(s, 10)
        return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    })
} 
```

原因：

*   使用`+`between`number[]`和`number`无效
*   从`string`to的转换`number`必须是明确的

* * *

## 回答 #41

> 赞同：4
> 
> 时间：2020-07-10T18:23:20.400

这也适用于 Node.js，如果你替换`let buffer = new Uint8Array(); crypto.getRandomValues`为`let buffer = crypto.randomBytes(16)`

它应该在性能上击败大多数正则表达式解决方案。

```
const hex = '0123456789ABCDEF'

let generateToken = function() {
    let buffer = new Uint8Array(16)

    crypto.getRandomValues(buffer)

    buffer[6] = 0x40 | (buffer[6] & 0xF)
    buffer[8] = 0x80 | (buffer[8] & 0xF)

    let segments = []

    for (let i = 0; i < 16; ++i) {
        segments.push(hex[(buffer[i] >> 4 & 0xF)])
        segments.push(hex[(buffer[i] >> 0 & 0xF)])

        if (i == 3 || i == 5 || i == 7 || i == 9) {
            segments.push('-')
        }
    }

    return segments.join('')
}

for (let i = 0; i < 100; ++i) {
  console.log(generateToken())
}
```

性能图表（每个人都喜欢）：[jsbench](https://jsbench.me/zikcgk6woj/1)

* * *

## 回答 #42

> 赞同：4
> 
> 时间：2020-11-23T20:51:00.127

这里有很多正确的答案，但遗憾的是，包含的代码示例非常神秘且难以理解。这就是我创建版本 4（随机）UUID 的方式。

请注意，以下代码使用二进制文字来提高可读性，因此需要 ECMAScript 6。

### Node.js 版本

```
function uuid4() {
  let array = new Uint8Array(16)
  crypto.randomFillSync(array)

  // Manipulate the 9th byte
  array[8] &= 0b00111111 // Clear the first two bits
  array[8] |= 0b10000000 // Set the first two bits to 10

  // Manipulate the 7th byte
  array[6] &= 0b00001111 // Clear the first four bits
  array[6] |= 0b01000000 // Set the first four bits to 0100

  const pattern = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
  let idx = 0

  return pattern.replace(
    /XX/g,
    () => array[idx++].toString(16).padStart(2, "0"), // padStart ensures a leading zero, if needed
  )
} 
```

### 浏览器版本

只有第二行不同。

```
function uuid4() {
  let array = new Uint8Array(16)
  crypto.getRandomValues(array)

  // Manipulate the 9th byte
  array[8] &= 0b00111111 // Clear the first two bits
  array[8] |= 0b10000000 // Set the first two bits to 10

  // Manipulate the 7th byte
  array[6] &= 0b00001111 // Clear the first four bits
  array[6] |= 0b01000000 // Set the first four bits to 0100

  const pattern = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
  let idx = 0

  return pattern.replace(
    /XX/g,
    () => array[idx++].toString(16).padStart(2, "0"), // padStart ensures a leading zero, if needed
  )
} 
```

### 测试

最后，相应的测试（[Jasmine](https://en.wikipedia.org/wiki/Jasmine_(JavaScript_testing_framework))）。

```
describe(".uuid4()", function() {
  it("returns a UUIDv4 string", function() {
    const uuidPattern = "XXXXXXXX-XXXX-4XXX-YXXX-XXXXXXXXXXXX"
    const uuidPatternRx = new RegExp(uuidPattern.
      replaceAll("X", "[0-9a-f]").
      replaceAll("Y", "[89ab]"))

    for (let attempt = 0; attempt < 1000; attempt++) {
      let retval = uuid4()
      expect(retval.length).toEqual(36)
      expect(retval).toMatch(uuidPatternRx)
    }
  })
}) 
```

### UUID v4 解释

UUID 版本 4 的一个很好的解释在这里：*[生成符合 RFC 4122 的 UUID](https://www.cryptosys.net/pki/uuid-rfc4122.html)*。

### 最后的笔记

此外，还有很多第三方软件包。但是，只要您只是基本需求，我不推荐它们。真的，没有什么可赢的，也没有什么可输的。作者可能会追求最微小的性能，“修复”不应该修复的东西，而在安全性方面，这是一个冒险的想法。同样，它们可能会引入其他错误或不兼容性。仔细更新需要时间。

* * *

## 回答 #43

> 赞同：3
> 
> 时间：2016-02-01T16:26:08.150

以防万一有人通过 Google 寻找小型实用程序库，[ShortId](https://www.npmjs.com/package/shortid)满足此问题的所有要求。它允许指定允许的字符和长度，并保证不连续、不重复的字符串。

为了让这更像是一个真正的答案，该库的核心使用以下逻辑来生成其短 ID：

```
function encode(lookup, number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

/* Generates the short id */
function generate() {

    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + encode(alphabet.lookup, version);
    str = str + encode(alphabet.lookup, clusterWorkerId);
    if (counter > 0) {
        str = str + encode(alphabet.lookup, counter);
    }
    str = str + encode(alphabet.lookup, seconds);

    return str;
} 
```

我没有对此进行编辑以*仅*反映此方法的最基本部分，因此上述代码包含库中的一些附加逻辑。如果您对它所做的一切感到好奇，请查看源代码：[https ://github.com/dylang/shortid/tree/master/lib](https://github.com/dylang/shortid/tree/master/lib)

* * *

## 回答 #44

> 赞同：3
> 
> 时间：2016-08-11T18:15:36.707

我发现这个脚本对于在 JavaScript 中创建 GUID 很有用

[https://github.com/addui/GUIDJS](https://github.com/addui/GUIDJS)

```
var myGuid = GUID(); 
```

* * *

## 回答 #45

> 赞同：3
> 
> 时间：2016-10-16T04:44:00.943

在这里你可以找到一个生成 UUID[的非常小的函数。](https://gist.github.com/jed/982883)

最终版本之一是：

```
function b(
  a                  // Placeholder
){
  var cryptoObj = window.crypto || window.msCrypto; // For Internet Explorer 11
  return a           // If the placeholder was passed, return
    ? (              // a random number from 0 to 15
      a ^            // unless b is 8,
      cryptoObj.getRandomValues(new Uint8Array(1))[0]  // in which case
      % 16           // a random number from
      >> a/4         // 8 to 11
      ).toString(16) // in hexadecimal
    : (              // or otherwise a concatenated string:
      [1e7] +        // 10000000 +
      -1e3 +         // -1000 +
      -4e3 +         // -4000 +
      -8e3 +         // -80000000 +
      -1e11          // -100000000000,
      ).replace(     // Replacing
        /[018]/g,    // zeroes, ones, and eights with
        b            // random hex digits
      )
} 
```

* * *

## 回答 #46

> 赞同：3
> 
> 时间：2018-11-07T16:45:01.560

基于[broofa 的工作](https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid?page=3&tab=oldest#tab-top)，我通过将时间戳添加到`math.random()`：

```
function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = parseFloat('0.' + Math.random().toString().replace('0.', '') + new Date().getTime()) * 16 | 0,
            v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
} 
```

* * *

## 回答 #47

> 赞同：3
> 
> 时间：2019-10-07T09:03:40.397

UUID 目前有一个添加到标准库的提案，可以在这里支持*[ECMAScript 提案：JavaScript 标准库 UUID](https://github.com/tc39/proposal-uuid)*

该提案包括具有以下 UUID：

```
// We're not yet certain as to how the API will be accessed (whether it's in the global, or a
// future built-in module), and this will be part of the investigative process as we continue
// working on the proposal.
uuid(); // "52e6953d-edbe-4953-be2e-65ed3836b2f0" 
```

此实现遵循与此处找到的 V4 随机 UUID 生成相同的布局：[https ://www.npmjs.com/package/uuid](https://www.npmjs.com/package/uuid)

```
const uuidv4 = require('uuid/v4');
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed' 
```

我认为值得注意的是，通过在标准库中进行正式实现可以节省多少带宽。该提案的作者还指出：

12 kB *uuid*模块每月从 npm 下载 > 62,000,000 次（2019 年 6 月）；使其在标准库中可用最终会在全球范围内节省 TB 的带宽。如果我们继续使用标准库来满足用户需求，例如 uuid，那么节省的带宽就会增加。

* * *

## 回答 #48

> 赞同：3
> 
> 时间：2020-05-17T15:25:58.903

我已经建立了这里提到的所有内容，以产生两倍于所有环境（包括节点）的可移植性，并从 Math.random() 升级到加密强度随机性。你可能不认为 UUID 需要加密强度，但这意味着发生冲突的可能性更小，这就是 UUID 的全部意义所在。

```
function random() {
    const
        fourBytesOn = 0xffffffff, // 4 bytes, all 32 bits on: 4294967295
        c = typeof crypto === "object"
            ? crypto // Node.js or most browsers
            : typeof msCrypto === "object" // Stinky non-standard Internet Explorer
                ? msCrypto // eslint-disable-line no-undef
                : null; // What old or bad environment are we running in?
        return c
            ? c.randomBytes
                ? parseInt(c.randomBytes(4).toString("hex"), 16) / (fourBytesOn + 1) - Number.EPSILON // Node.js
                : c.getRandomValues(new Uint32Array(1))[0] / (fourBytesOn + 1) - Number.EPSILON // Browsers
            : Math.random();
}

function uuidV4() { // eslint-disable-line complexity
    // If possible, generate a single random value, 128 bits (16 bytes)
    // in length. In an environment where that is not possible, generate
    // and make use of four 32-bit (4-byte) random values.
    // Use crypto-grade randomness when available, else Math.random()
    const
        c = typeof crypto === "object"
            ? crypto // Node.js or most browsers
            : typeof msCrypto === "object" // Stinky non-standard Internet Explorer
                ? msCrypto // eslint-disable-line no-undef
            : null; // What old or bad environment are we running in?
    let
        byteArray = c
            ? c.randomBytes
                ? c.randomBytes(16) // Node.js
                : c.getRandomValues(new Uint8Array(16)) // Browsers
            : null,
        uuid = [ ];

    /* eslint-disable no-bitwise */
    if ( ! byteArray) { // No support for generating 16 random bytes
                        // in one shot -- this will be slower
        const
            int = [
                random() * 0xffffffff | 0,
                random() * 0xffffffff | 0,
                random() * 0xffffffff | 0,
                random() * 0xffffffff | 0
            ];
        byteArray = [ ];
        for (let i = 0; i < 256; i++) {
            byteArray[i] = int[i < 4 ? 0 : i < 8 ? 1 : i < 12 ? 2 : 3] >> i % 4 * 8 & 0xff;
        }
    }
    byteArray[6] = byteArray[6] & 0x0f | 0x40; // Always 4, per RFC, indicating the version
    byteArray[8] = byteArray[8] & 0x3f | 0x80; // Constrained to [89ab], per RFC for version 4
    for (let i = 0; i < 16; ++i) {
        uuid[i] = (byteArray[i] < 16 ? "0" : "") + byteArray[i].toString(16);
    }
    uuid =
        uuid[ 0] + uuid[ 1] + uuid[ 2] + uuid[ 3] + "-" +
        uuid[ 4] + uuid[ 5]                       + "-" +
        uuid[ 6] + uuid[ 7]                       + "-" +
        uuid[ 8] + uuid[ 9]                       + "-" +
        uuid[10] + uuid[11] + uuid[12] + uuid[13] + uuid[14] + uuid[15];
    return uuid;
    /* eslint-enable no-bitwise */
} 
```

* * *

## 回答 #49

> 赞同：3
> 
> 时间：2021-02-07T08:26:32.197

这是一个从字符串生成静态 UUID 的函数，如果没有提供字符串，则生成随机 UUID：

```
function stringToUUID (str)
{
  if (str === undefined || !str.length)
    str = "" + Math.random() * new Date().getTime() + Math.random();

  let c = 0,
      r = "";

  for (let i = 0; i < str.length; i++)
    c = (c + (str.charCodeAt(i) * (i + 1) - 1)) & 0xfffffffffffff;

  str = str.substr(str.length / 2) + c.toString(16) + str.substr(0, str.length / 2);
  for(let i = 0, p = c + str.length; i < 32; i++)
  {
    if (i == 8 || i == 12 || i == 16 || i == 20)
      r += "-";

    c = p = (str[(i ** i + p + 1) % str.length]).charCodeAt(0) + p + i;
    if (i == 12)
      c = (c % 5) + 1; //1-5
    else if (i == 16)
      c = (c % 4) + 8; //8-B
    else
      c %= 16; //0-F

    r += c.toString(16);
  }
  return r;
}

console.log("Random       :", stringToUUID());
console.log("Static [1234]:", stringToUUID("1234")); //29c2c73b-52de-4344-9cf6-e6da61cb8656
console.log("Static [test]:", stringToUUID("test")); //e39092c6-1dbb-3ce0-ad3a-2a41db98778c
```

[jsfiddle](https://jsfiddle.net/vanowm/4sg813qt/)

* * *

## 回答 #50

> 赞同：2
> 
> 时间：2014-06-08T13:30:08.520

对于我的用例，我需要保证在全球范围内唯一的 id 生成；没有例外。我为这个问题苦苦挣扎了一段时间，并想出了一个名为[TUID](https://github.com/mongoh/tuid)（真正唯一 ID）的解决方案。它生成一个 id，前 32 个字符是系统生成的，其余数字表示自纪元以来的毫秒数。在我需要在客户端 JavaScript 代码中生成 id 的情况下，它运行良好。

* * *

## 回答 #51

> 赞同：2
> 
> 时间：2016-03-22T06:37:37.050

这是一个工作示例。它生成一个 32 位*的唯一*UUID。

```
function generateUUID() {
    var d = new Date();
    var k = d.getTime();
    var str = k.toString(16).slice(1)
    var UUID = 'xxxx-xxxx-4xxx-yxxx-xzx'.replace(/[xy]/g, function (c)
    {
        var r = Math.random() * 16 | 0;
        v = c == 'x' ? r : (r & 3 | 8);
        return v.toString(16);
    });

    var newString = UUID.replace(/[z]/, str)
    return newString;
}

var x = generateUUID()
console.log(x, x.length) 
```

* * *

## 回答 #52

> 赞同：2
> 
> 时间：2018-01-01T12:49:58.213

对于那些在 Windows 上使用 JavaScript（例如，[Windows Script Host](https://en.wikipedia.org/wiki/Windows_Script_Host) (WSH)、[CScript](https://en.wikipedia.org/wiki/Windows_Script_Host#Available_scripting_engines)和[HTA](https://en.wikipedia.org/wiki/HTML_Application)）的人。可以使用[ActiveX](https://en.wikipedia.org/wiki/ActiveX)。具体来说，`Scriptlet.Typelib`对象：

```
WScript.Echo((new ActiveXObject("Scriptlet.TypeLib")).Guid) 
```

请注意，此答案仅适用于我列出的技术。它不适用于任何浏览器，甚至 Microsoft [Edge](https://en.wikipedia.org/wiki/Microsoft_Edge)！因此，您的里程将随此答案而变化。

* * *

## 回答 #53

> 赞同：2
> 
> 时间：2019-03-18T10:53:14.260

我们可以使用 replace 和 crypto.getRandomValues 来获得如下输出：

`xxxxxxxx-xxxx-4xxx-xxxx-xxxxxxxxxxxx`

[![在此处输入图像描述](https://i.stack.imgur.com/OJWv4.png)](https://i.stack.imgur.com/OJWv4.png)

如果我们正在寻找一个 opti 解决方案，我们必须用`crypto.getRandomValues(new Uint8Array(1))[0]`数组（32）替换。

```
const uuidv4 = () =>
  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );

console.log(uuidv4()); 
```

要获取此代码：

```
function uuidv4() {
  let bytes = window.crypto.getRandomValues(new Uint8Array(32));
  const randomBytes = () => (bytes = bytes.slice(1)) && bytes[0];

  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
      (c ^ randomBytes() & 15 >> c / 4).toString(16)
    );
}

for (var i = 0; i < 10; i++)
  console.log(uuidv4());
```

### 碰撞：

我们可以像谷歌分析一样使用 : 来添加时间戳`uuidv4() + "." + (+new Date())`。

* * *

## 回答 #54

> 赞同：2
> 
> 时间：2020-12-30T01:41:55.950

以下`uuid` *实现*提供了一个*不同*的ES6 2020 解决方案，使用`BigInt`并专注于“`uuid`设计模式的用例意图”；特别适用于**索引数据库** `primaryKey`场景，在这些场景中统一时间排序和排序是有价值的。

> 因此，请注意这篇文章有 30 多个答案，这里是...
> 
> 这篇文章有：
> 
> 1.  带有独立**es6**的“TL；DR”`code` *部分* **`class Xuid`**
> ***   关于 **es6**提供的*代码*的*用例*和*动机* **讨论** *部分*。 **`class Xuid`****

 *****### TL；*使用单调时钟**的通用 v4*`class Xuid` DR解决方案*`uuid`*

下面的代码是从我编写和拥有的 Smallscript 的**EdgeS网络客户端库中提取的，并在此处提供，免费获得 MIT 许可。***EdgeS Web 客户端工具集发布后，将提供**GitHub[版本。](https://github.com/Smallscript-Corp)*

> 使用示例：
> 
> 评估：`console.log(Xuid.v4New)`
> 发出：`{1eb4a659-8bdc-4ce0-c002-b1d505d38ea8}`

```
class Xuid {
  //@ edges.sm.st, ess.dev: MIT license Smallscript/David Simmons 2020
  //! Can't use `static const field = const` xbrowser (thus, const's duped)
  static get v4New() {
    const ns7Now = this.ns7Now, xnode48 = this.xnode48; let clock_seq13
    // monotonic `clock_seq` guarantee (13-bits/time-quantum)
    if(ns7Now <= this.ns7Now_prevSeq && this.ns7Now_prevSeq)
      clock_seq13 = ((this.ns7Now_prevSeq += 1n) - ns7Now) & 0b1_1111_1111_1111n
    else
      clock_seq13 = 0n, this.ns7Now_prevSeq = ns7Now
    const time60 = ((ns7Now << 4n) & 0xFFFF_FFFF_FFFF_0000n) |
                           (ns7Now & 0x0000_0000_0000_0FFFn),
              v4 = 0x1_00000000_0000_0000_0000_000000000000n |
      (time60 << 64n) | (0x00000000_0000_4000_0000_000000000000n) | // M: V4
      (0b110n << 61n) | (clock_seq13 << 48n) | // N: Variant-2 time-seq collation
      xnode48, s = v4.toString(16)//.substr(1)
    return `{${s.substr(1,8)}-${s.substr(9,4)}-${s.substr(13,4)}-${
      s.substr(17,4)}-${s.substr(21,12)}}`
  }
  static get xnode48()/*:<BigInt#48>*/{
    if(this.xnode48_) return this.xnode48_
    let clockSeqNode; if(typeof URL !== 'undefined' && URL.createObjectURL) {
      const url = URL.createObjectURL(new Blob())
      const id = (url.toString().split('/').reverse()[0]).split('-')
      URL.revokeObjectURL(url)
      clockSeqNode = BigInt('0x'+id[3]+id[4])
    }
    else {
      const a4 = this.a4; this.getRandomValues(this.a4);
      clockSeqNode = (BigInt(a4[2]) << 32n) | BigInt(a4[3])
    }
    // simulate the 48-bit node-id and 13-bit clock-seq
    // to combine with 3-bit uuid-variant
    return this.xnode48_ = clockSeqNode & 0xFFFF_FFFF_FFFFn;
  }
  static get jdNow()/*:<double#ns7>*/{
    // return 2440587.5+Date.now()/864e5 // <- Date-quantum-ms form (7ns form below)
    return this.jdFromNs7(this.ns7Now)
  }
  static get ns7Now()/*:<BigInt#60>*/{
    if(typeof performance !== 'undefined' && performance.now)
      Reflect.defineProperty(this, 'ns7Now',
        Reflect.getOwnPropertyDescriptor(this,'ns7Now_performance'))
    else
      Reflect.defineProperty(this, 'ns7Now',
        Reflect.getOwnPropertyDescriptor(this, 'ns7Now_Date'))
    return this.ns7Now
  }
  static get ns7Now_Date()/*:<BigInt#60>*/{
    // const epoch1582Ns7_bias = 0x1b2_1dd2_1381_4000  // V1 1582 Oct 15
    // const epoch1601Ns7_bias = 0x19d_b1de_d53e_8000n // FILETIME base
    const epoch1970Ns7 = BigInt(Date.now() * 1000_0.0)
    return epoch1970Ns7 + 0x1b2_1dd2_1381_4000n
  }
  static get ns7Now_performance()/*:<BigInt#60>*/{
    const epochPgNs7 = BigInt(performance.now()*/*15*/1000_0.0|/*17*/0)
    if(!this.epoch1970PgNs7) // performance.timing.navigationStart
      this.epoch1970PgNs7 = this.ns7Now_Date - epochPgNs7
    return epochPgNs7 + this.epoch1970PgNs7
  }
  static dateFromJd(jd) {return new Date((jd - 2440587.5) * 864e5)}
  static dateFromNs7(ns7) {
    return new Date(Number(ns7 - 0x1b2_1dd2_1381_4000n) / 1000_0.0)}
  static jdFromNs7(ns7) {   // atomic-clock leap-seconds (ignored)
    return 2440587.5 + (Number(ns7 - 0x1b2_1dd2_1381_4000n) / 864e9)
  }
  static ns7FromJd(jd) {
    return BigInt((jd - 2440587.5) * 864e9) + 0x1b2_1dd2_1381_4000n
  }
  static getRandomValues(va/*:<Uint32Array>*/) {
    if(typeof crypto !== 'undefined' && crypto.getRandomValues)
      crypto.getRandomValues(va)
    else for(let i = 0, n = va.length; i < n; i += 1)
      va[i] = Math.random() * 0x1_0000_0000 >>> 0
  }
  static get a4() {return this.a4_ || (this.a4_ = new Uint32Array(4))}
  static ntohl(v)/*:<BigInt>*/{
    let r = '0x', sign = 1n, s = BigInt(v).toString(16)
    if(s[0] == '-') s = s.substr(1), sign = -1n
    for(let i = s.length; i > 0; i -= 2)
      r += (i == 1) ? ('0' + s[i-1]) : s[i-2] + s[i-1]
    return sign*BigInt(r)
  }
  static ntohl32(v)/*:<Number>*/{return Number(this.ntohl(v))}
} 
```

### 动机

虽然 v4`uuid`定义了一个基本随机的`uuid`，但希望有一个`uuid`可以支持一些附加特性的实现。

*   `uuid`快速有效地创造新价值*（使用`BigInt`）*
*   *实现为具有标称* `80 loc`可读的`class` 带注释的独立代码
*   在`uuid`一个`time`_`context`
*   字符串化使得字符串形式：
    *   整理基于`time`然后`context` *（使用`uuid`Variant-2）*
    *   转换回正确识别和恢复的二进制形式`time`
*   在可用的情况下采用`JavaScript`微秒时钟精度
*   支持基于 julian-day 纪元年 1582 Oct 15 的 100 纳秒单位的跨环境量子，V1 兼容性。能够在与*语言*模型 *一致* 的各种环境和用例中实现统一时间行为的选择。`EdgeS``ESS` *> *特别适合与 SQLite 等工具一起使用的数据库。** 
**   使用`es6 class`设计来简化名义工作的可扩展性以扩展它以提供其他`uuid` *变体**   *对于这篇文章*，统一并合并了基本`time`和*相关* **的 eswc**库 API。
    *   朱利安日 API
    *   ns7 *（100 纳秒量子）* API
    *   `ntohl`用于 endian 方便重新排序`BigInt`字符串表示的 API*   源自 QKS Smalltalk 1991，AOS® [Agile Object System;Agents Object System] 引擎系列技术，用于语言、框架和运行时，它保留了在各种当前和历史主机操作系统模型中的用例兼容性。
    *   特别是在`Xuid`大括号引用的标量字符串格式支持`guid`, `uuid`, 和`uid` *( `git`, `fossil`, `SqLite`repo-id)* 表示的地方`FILETIME`，等等。

        > *如：* `{1eb4a659-8bdc-4ce0-c002-b1d505d38ea8}`

        *   最后但并非最不重要的一点是，它为使用**indexedDb** `object stores`提供了一个理想的解决方案，其中使用 a`uuid`变得可取`primaryKey` 。
    *   启用自动排序功能
    *   自然字符串排序规则
        *   请注意*Variant-2的**巧妙*使用，以反转LHS 的*字符串*形式的值。`uuid` *`time`*

    ***   自然简单的`put`更新*   *（EdgeS 虚拟文件系统自动名称）的*自然模式`efs`**   `service-worker`以及`cloud-server` **同步和复制动作******

 ***### 概括

虽然很*简洁*，但希望这足以说明现在；**试试看**。

并且，*请*随时发表评论、提交反馈或建议。

当在**GitHub 上作为****EdgeS** Web 客户端`eswc` *库*的一部分发布时 ，**indexedDb**使用模式将作为其设计意图的示例，包括解决 **indexedDb**和*相关*PWA和场景的效率和可用性。****`efs`***`sync``replicate`*******

*******有关的

*   [*JavaScript 中的*儒略日计算](https://stackoverflow.com/questions/11759992/calculating-jdayjulian-day-in-javascript/64615612#64615612)

 *### 基准测试`uuid`秒/秒

```
const start = Xuid.ns7Now
for(let i = 100000; i; i -=1)
  Xuid.v4New
const end = Xuid.ns7Now
console.log(`Delta 7ns: ${(end-start)/100000n}`) 
```

**结果：** 16..20 => ~2 微秒 => **500,000** `uuid` s/sec 的值

* * *

## 回答 #55

> 赞同：2
> 
> 时间：2021-01-25T22:50:32.947

这只是一个概念，当然可以在很多方面进行改进，但并不像我想象的那么慢。

通常，此代码包含以毫秒为单位的十六进制编码时间戳（通过一些黑客攻击，它会给出 12 位数字，因此该代码即使在 2527-06-24 之后也可以工作，但在 5138-11-16 之后就不行），这意味着它是可排序的。这不是随机的，它使用最后 12 位的[MAC 地址](https://en.wikipedia.org/wiki/MAC_address)。第 13 个字母硬编码为 1，以保持可排序。

之后，接下来的 6 位数字来自半随机字符串，其中第一个数字来自该毫秒生成的记录数，其他数字是随机生成的。该 6 位数字部分包含一个破折号和硬编码字母“a”，以保持记录可排序。

我知道这可以缩短，性能也有所提高，但我对结果很满意（MAC 地址除外）。

```
currentNanoseconds = () => {
  return nodeMode ? process.hrtime.bigint() : BigInt(Date.now() * 1000000);
}

nodeFindMacAddress = () => {
  // Extract MAC address
  const interfaces = require('os').networkInterfaces();
  let result = null;
  for (index in interfaces) {
    let entry = interfaces[index];
    entry.forEach(item => {
      if (item.mac !== '00:00:00:00:00:00') {
        result = '-' + item.mac.replace(/:/g, '');
      }
    });
  }
  return result;
}

const nodeMode = typeof(process) !== 'undefined';
let macAddress = nodeMode ? nodeFindMacAddress() : '-a52e99ef5efc';
let startTime = currentNanoseconds();

let uuids = []; // Array for storing generated UUIDs, useful for testing
let currentTime = null; // Holds the last value of Date.now(), used as a base for generating the UUID
let timePart = null; // Part of the UUID generated from Date.now()
let counter = 0; // Used for counting records created at certain millisecond
let lastTime = null; // Used for resetting the record counter

const limit = 1000000;

for (let testCounter = 0; testCounter < limit; testCounter++) {
  let uuid = testMe();

  if (nodeMode || testCounter <= 50) {
    uuids.push(uuid);
  }
}

const timePassed = Number(currentNanoseconds() - startTime);

if (nodeMode) {
  const fs = require('fs');
  fs.writeFileSync('temp.txt', JSON.stringify(uuids).replace(/,/g, ',\n'));
} else {
  console.log(uuids);
}

console.log({
  operationsPerSecond: (1000 * limit / timePassed).toString() + 'm',
  nanosecondsPerCycle: timePassed / limit,
  milliSecondsPassed: timePassed / 1000000,
  microSecondsPassed: timePassed / 1000,
  nanosecondsPassed: timePassed
});

function testMe() {
  currentTime = Date.now();
  let uuid = null; // Function result

  if (currentTime !== lastTime) {
    // Added a 9 before timestamp, so that the hex-encoded timestamp is 12 digits long. Currently, it is 11 digits long, and it will be until 2527-06-24
    // console.log(Date.parse("2527-06-24").toString(16).length)
    // Code will stop working on 5138-11-17, because the timestamp will be 15 digits long, and the code only handles up to 14 digit timestamps
    // console.log((Date.parse("5138-11-17")).toString().length)
    timePart = parseInt(('99999999999999' + currentTime).substr(-14)).toString(16);
    timePart = timePart.substr(0, 8) + '-' + timePart.substr(8, 4) + '-1';
    counter = 0;
  }

  randomPart = ('000000' + Math.floor(10 * (counter + Math.random()))).slice(-6);
  randomPart = randomPart.substr(0, 3) + '-a' + randomPart.substr(3, 3);
  uuid = timePart + randomPart + macAddress;

  counter++;

  lastTime = currentTime;

  return uuid;
}
```

* * *

## 回答 #56

> 赞同：2
> 
> 时间：2021-06-16T14:14:07.910

此产品从 az,0-9 返回 5 组 8 位数字，其中大部分是随机的，但包含一天中的时间，并且有一个随机递增的计数器。您可以指定任何您喜欢的基数（十六进制、十进制、36），默认为每组 8 个随机选择一个基数，在基数 16 到 36 的范围内

```
function newId(base) {
return[
 Math.random,
 function (){ return (newId.last ? windowId.last + Math.random() : Math.random() ) },
 Math.random,
 Date.now,
 Math.random
].map(function(fn){
    return fn().toString(base||(16+(Math.random()*20))).substr(-8);
}).join('-');
}

var demo = function(base){
    document.getElementById('uuid').textContent = newId(base);
}
demo(16);
```

```
#uuid { font-family: monospace; font-size: 1.5em; }
```

```
<p id="uuid"></p>
<button onclick="demo(16);">Hex (base 16)</button>
<button onclick="demo(36);">Base 36</button>
<button onclick="demo(10);">Decimal (base 10)</button>
<button onclick="demo();">Random base</button>
```

* * *

## 回答 #57

> 赞同：1
> 
> 时间：2015-08-14T08:22:42.290

做同样事情的另一种方法：

```
function guid() {
  var chars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
  var str = "";
  for(var i=0; i<36; i++) {
    var str = str + ((i == 8 || i == 13 || i == 18 || i == 23) ? "-" : chars[Math.floor(Math.random()*chars.length)]);
  };
  return str;
} 
```

* * *

## 回答 #58

> 赞同：1
> 
> 时间：2020-06-03T06:47:23.917

在任何情况下都不要使用**Math.random**，因为它会生成非加密的随机数源。

下面使用**crypto.getRandomValues的解决方案**

```
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    // tslint:disable-next-line: no-bitwise
    const r =
      (window.crypto.getRandomValues(new Uint32Array(1))[0] *
        Math.pow(2, -32) * 16) |
      0;
    // tslint:disable-next-line: no-bitwise
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
} 
```

[此链接](https://help.semmle.com/wiki/display/JS/Insecure+randomness)可帮助您了解[Fortify Scanner](https://en.wikipedia.org/wiki/Fortify_Software)引发的*不安全随机性*。

* * *

## 回答 #59

> 赞同：1
> 
> 时间：2020-08-10T16:39:59.540

## 带有内置时间戳的 UUID（发射器/解析器）

这是我生成具有非常强的唯一性和快速运行时的有效 UUID v4 的简单方法。

基本思想并不新鲜，但方法不同。我使用`date.now()`（在 Node.js 库中，我稍后会指出，我使用纳秒时间戳`process.hrtime.bigint()`）中的以毫秒为单位的时间戳，然后`10000-90000`在时间戳字符串的末尾添加一个随机的 5 位数字 ( )。

合并字符串后，我只是从数字和一对特殊字符组成一个有效的 UUID，这样我的 UUID 只包含数字和一些非数字字符。请在下面查看：

```
/*
 * uuid-timestamp (emitter)
 * UUID v4 based on timestamp
 *
 * Created by tarkh
 * tarkh.com (C) 2020
 */
const uuidEmit = () => {
  // Get now time
  const n = Date.now();
  // Generate random
  const r = Math.random();
  // Stringify now time and generate additional random number
  const s = String(n) + String(~~(r*9e4)+1e4);
  // Form UUID and return it
  return `${s.slice(0,8)}-${s.slice(8,12)}-4${s.slice(12,15)}-${[8,9,'a','b'][~~(r*3)]}${s.slice(15,18)}-${s.slice(s.length-12)}`;
};

// Generate 5 UUIDs
console.log(`${uuidEmit()}
${uuidEmit()}
${uuidEmit()}
${uuidEmit()}
${uuidEmit()}`);
```

查看结果，您显然看到 UUID 的第一部分是相同的，然后是随机性。这是因为我将时间戳线性插入到 UUID 中。该代码将每毫秒（Node.js 库中的纳秒）生成一个新的 UUID + 在末尾添加一个随机的 5 位数字，因此我们最终得到非常近似的碰撞概率，大约为每秒千万分之一。如果我们使用 Node.js 库，我们非常近似的碰撞概率会达到每秒 100 亿分之一。

### UUID 中内置的时间戳

由于我们将时间戳线性插入到 UUID 中，因此我们获得了一个特性（好坏 - 取决于任务） - 能够轻松地从 UUID 中提取此时间戳。这样我们就可以了解 UUID 是什么时候发布的：

```
/*
 * uuid-timestamp (parser)
 * UUID v4 based on timestamp
 *
 * Created by tarkh
 * tarkh.com (C) 2020
 */
const uuidParse = (uuid) => {
  // Get current timestamp string length
  let tl = String(Date.now()).length;
  // Strip out timestamp from UUID
  let ts = '';
  let i = -1;
  while(tl--) {
    i++;
    if(i===8||i===13||i===14||i===18||i===19||i===23) {
      tl++;
      continue;
    }
    ts += uuid[i];
  }
  return Number(ts);
};

// Get the timestamp when UUID was emitted
const time = uuidParse('15970688-7109-4530-8114-887109530114');

// Covert timestamp to date and print it
console.log(new Date(time).toUTCString());
```

### 节点.js

我上面的代码的 NPM 版本作为[Node.js 模块](https://www.npmjs.com/package/uuid-timestamp)提供。这个版本在生成唯一值方面更加强大，因为它使用`nanoseconds`系统时间和`process.hrtime.bigint()`差异的组合而不是毫秒时间戳。

### 基准

在我的帖子的最后，我想根据这个主题的一些答案做一些性能测试。当然，我的决定不是最快的，但肯定是占据了最高位置。

[在这里检查 jsBench](https://jsben.ch/bvtX3)

* * *

## 回答 #60

> 赞同：1
> 
> 时间：2020-09-17T13:38:00.903

实际上，在非 Microsoft 圈子中称为 GUID 或 UUID 只是一个 128 位加密随机数，UUID 版本号 (1-5) 位于固定位置字节。

因此，当您生成一堆 0 到 65535 之间的随机数并对其进行十六进制编码时，如下所示：

```
function guid()
{
    function s4()
    {
        return Math.floor(Math.random() * 65536).toString(16).padStart(4, '0')
    } // End Function s4

    return s4() + s4() + '-' + s4() + '-' + "4" + s4().substr(1) + '-' + s4() + '-' + s4() + s4() + s4();
} // End Function guid 
```

你得到一个有效的 GUID，但由于随机实现，它不是加密安全的。

要生成加密安全的 GUID，您需要使用 window.crypto（或用于 Internet Explorer 的 window.msCrypto）。

事情是这样的：

```
function cryptGuid()
{
    var array = new Uint16Array(8);
    (window.crypto || window.msCrypto).getRandomValues(array);
    var dataView = new DataView(array.buffer);

    var parts = [];

    for(var i = 0; i < array.length; ++i)
    {
        // 0&1,2,3,4,5-7 dataView.getUint16(0-7)
        if(i>1 && i<6) parts.push("-");
        parts.push(dataView.getUint16(i).toString(16).padStart(4, '0'));
    }

    parts[5] = "4" + parts[5].substr(1);
    // console.log(parts);
    return parts.join('').toUpperCase();// .toLowerCase();
}

cryptGuid(); 
```

另外，您必须决定是否将数字作为小写或大写字符串返回。某些软件需要小写字符（例如，Reporting Service），而其他软件则生成大写字符（SQL Server）。

* * *

## 回答 #61

> 赞同：1
> 
> 时间：2021-08-30T20:49:37.173

最酷的方式：

```
function uuid(){
    var u = URL.createObjectURL(new Blob([""]))
    URL.revokeObjectURL(u);
    return u.split("/").slice(-1)[0]
} 
```

它在 IE2 中可能不快速、不高效或不支持，但它确实很酷

* * *

## 回答 #62

> 赞同：0
> 
> 时间：2016-08-31T15:57:47.207

这可能对某人有用...

```
var d = new Date().valueOf();
var n = d.toString();
var result = '';
var length = 32;
var p = 0;
var chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

for (var i = length; i > 0; --i){
    result += ((i & 1) && n.charAt(p) ? '<b>' + n.charAt(p) + '</b>' : chars[Math.floor(Math.random() * chars.length)]);
    if(i & 1) p++;
}; 
```

[https://jsfiddle.net/j0evrdf1/1/](https://jsfiddle.net/j0evrdf1/1/)

* * *

## 回答 #63

> 赞同：0
> 
> 时间：2016-09-07T08:47:35.730

```
function randomHex(length) {
    var random_string = '';
    if(!length){
        length = 1;
    }
    for(var i=0; i<length; i+=1){
        random_string += Math.floor(Math.random() * 15).toString(16);
    }
    return random_string;
}

function guid() {
    return randomHex(8);
} 
```

* * *

## 回答 #64

> 赞同：0
> 
> 时间：2018-11-30T20:23:48.993

以下内容不符合 v4，但可以轻松更改为。这只是扩展*Uint8Array*类型并使用*crypto.getRandomValues()*生成 UUID 字节值的示例。

```
class uuid extends Uint8Array {
    constructor() {
        super(16)
        /* Not v4, just some random bytes */
        window.crypto.getRandomValues(this)
    }
    toString() {
        let id = new String()
        for (let i = 0; i < this.length; i++) {
            /* Convert uint8 to hex string */
            let hex = this[i].toString(16).toUpperCase()

            /* Add zero padding */
            while (hex.length < 2) {
                hex = String(0).concat(hex)
            }
            id += hex

            /* Add dashes */
            if (i == 4 || i == 6 || i == 8 || i == 10 || i == 16) {
                id += '-'
            }
        }
        return id
    }
} 
```

* * *

## 回答 #65

> 赞同：0
> 
> 时间：2020-08-08T09:16:21.060

```
var guid = createMyGuid();

function createMyGuid()  
{  
   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {  
      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);  
      return v.toString(16);  
   });  
} 
```

* * *

## 回答 #66

> 赞同：0
> 
> 时间：2021-09-23T22:47:19.723

对于您已经通过使用[方法为某些资源创建 URL](https://w3c.github.io/FileAPI/#dfn-createObjectURL)[的`URL.createObjectURL`](https://w3c.github.io/FileAPI/#dfn-createObjectURL)情况，您可能不会比以下操作更快或更短：

```
const uuid = url => url.substr(-36); 
```

以上将适用于任何兼容的实现`createObjectURL`，因为[规范明确要求](https://w3c.github.io/FileAPI/#unicodeBlobURL)将 UUID 添加到前者返回的 URL 的末尾。所以你可以保证最后 36 个字符是生成的 URL 的 UUID 部分。

需要明确的是，有时——哎呀，也许大多数时候，考虑到所有事情——你想为其他东西生成一个 UUID，而不是为你创建 URL 的资源`createObjectURL`。在这些情况下，在某些情况下调用后一种方法`new Blob()`绝对会降低性能（并且会泄漏内存，除非您自己使用相应的`revokeObjectURL`. 不过，它仍然是一个“单线”。

我*不*建议您仅将上述方法用于生成 UUID，除非您已经通过获取的 URL`createObjectURL`或末尾具有 UUID 的东西。

为了完整起见，我只想提及上述变体。

* * *

## 回答 #67

> 赞同：0
> 
> 时间：2021-10-18T08:49:18.807

我用这个版本。它既安全又简单。它不是生成格式化的uid，它只是生成你需要的随机字符串。

```
export function makeId(length) {
  let result = '';
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  const charactersLength = characters.length;

  for (let i = 0; i < length; i++) {
    let letterPos = crypto.getRandomValues(new Uint8Array(1))[0] / 255 * charactersLength - 1
    result += characters[letterPos]
  }
  return result;
} 
```

* * *

## 回答 #68

> 赞同：0
> 
> 时间：2022-01-15T05:12:36.840

`RFC4122`这是一种使用真正随机生成的方法via `random.org`。如果获取失败，它会退回到浏览器的内置`crypto`库，这应该几乎一样好。最后，如果有问题的用户浏览器不支持它，它会使用`Math.random()`.

```
async function UUID() {
    //get 31 random hex characters
    return (await (async () => {
        let output;
        try {
            //try from random.org
            output = (await (
                await fetch('https://www.random.org/integers/?num=31&min=0&max=15&col=31&base=16&format=plain&rnd=new')
            ).text())
                //get rid of whitespace
                .replace(/[^0-9a-fA-F]+/g, '')
            ;
            if (output.length != 31)
                throw '';
        }
        catch {
            output = '';
            try {
                //failing that, try getting 16 8-bit digits from crypto
                for (let num of crypto.getRandomValues(new Uint8Array(16)))
                    //interpret as 32 4-bit hex numbers
                    output += (num >> 4).toString(16) + (num & 15).toString(16);
                //we only want 31
                output = output.substr(1);
            }
            catch {
                //failing THAT, use Math.random
                while (output.length < 31)
                    output += (0 | Math.random() * 16).toString(16);
            }
        }
        return output;
    })())
        //split into appropriate sections, and set the 15th character to 4
        .replace(/^(.{8})(.{4})(.{3})(.{4})/, '$1-$2-4$3-$4-')
        //force character 20 to the correct range
        .replace(/(?<=-)[^89abAB](?=[^-]+-[^-]+$)/, (num) => (
            (parseInt(num, 16) % 4 + 8).toString(16)
        ))
    ;
} 
```

[![在此处输入图像描述](https://i.stack.imgur.com/4pby2.png)](https://i.stack.imgur.com/4pby2.png)

* * *

## 回答 #69

> 赞同：0
> 
> 时间：2022-02-07T07:46:11.503

使用简单的 uuid 包即可轻松完成 [https://www.npmjs.com/package/uuid](https://www.npmjs.com/package/uuid)

```
const { v4: uuidv4 } = require('uuid');
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed' 
```

# windows - 如何将 .sh 文件与 Cygwin 关联？

> ID：105075
> 
> 赞同：49
> 
> 时间：2008-09-19T20:05:31.850
> 
> 标签：windows, bash, cygwin

我想通过双击 Windows 中的 .sh 文件在 Cygwin 中运行长 rsync 命令。它必须从文件的包含目录（例如/cygdrive/c/scripts/）开始，以便相对路径起作用。有人让这个工作吗？

注意：我刚刚在[这里](http://web.archive.org/web/20121204091631/http://blog.chavez.ws:80/2008/03/cygwin-command-here.html)找到了一个管理 Windows 上下文菜单的 Cygwin 包（Bash Prompt Here）。它可能有一些线索。

* * *

## 回答 #1

> 赞同：42
> 
> 时间：2008-09-19T23:14:59.713

好的，我发现了一些有用的东西。按照 Vladimir 的建议关联批处理文件不起作用，但 bash 参数是关键。

简短而甜蜜：与此命令相关联：**“C:\cygwin\bin\bash.exe”-li“%1”%***

如果您不知道如何使用长版本：

1.  在资源管理器中，转到工具/文件夹选项/文件类型。
2.  我已经有一个 Bash 脚本的 SH 条目。如果您没有，请单击新建并输入“SH”创建一个。
3.  选择 SH 扩展名后，单击高级。
4.  选择“打开”操作并单击编辑（或创建操作）。
5.  这是要使用的命令：**"C:\cygwin\bin\bash.exe" -li "%1" %***。请注意，如果没有**-li**，它会在我的脚本中返回“找不到命令”。

您可能还想将**SH**添加到**PATHEXT**环境变量中：

WinKey+Pause / 高级 / 环境变量 / 系统变量 / PATHEXT

谢谢你们的帮助，伙计们！

* * *

## 回答 #2

> 赞同：16
> 
> 时间：2009-03-06T23:50:55.867

这是我的解决方案。它适用于我的 *.sh 脚本，无论它们在目录层次结构中的什么位置。请注意，在 cygpath 上调用 bash 之前，我 cd 到了 cygpath 目录名。它只是工作。

```
assoc .sh=bashscript

ftype bashscript=C:\cygwin\bin\bash.exe --login -i -c 'cd "$(dirname "$(cygpath -u "%1")")"; bash "$(cygpath -u "%1")"' 
```

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2010-04-29T08:18:42.723

一段时间以来，我一直在使用 Dragos 的解决方案，我认为它是最好的解决方案，因为它消除了在 shell 脚本中使用“cygpath -u”的需要。

然后，我想拥有其他功能，例如对 .sh 和 .bash 文件的拖放支持。经过一番挖掘，我编写了一个 .bat，将 .sh 和 .bash 文件关联为“bashscript”，并为它们激活 Windows 资源管理器拖放处理程序。我必须编辑 Dragos 的命令以使其处理 1 个参数（放置在 shell 脚本上的项目的路径）。

.bat 文件大致如下：

```
echo Registering .sh and .bash files as "bashscript"...
assoc .sh=bashscript
assoc .bash=bashscript
echo.
echo Setting the run command for the file type "bashscript"...
ftype bashscript=C:\cygwin\bin\bash.exe --login -i -c 'cd "$(dirname "$(cygpath -u "%%1")")"; bash "$(cygpath -u "%%1")" "$(/argshandler.sh "%%2")"'
echo.
echo Activating the drag^&drop capability for "bashscript" files (only 1 dropped item
echo will be passed to the script, multiple items are not supported yet)...
reg add HKEY_CLASSES_ROOT\bashscript\shellex\DropHandler /v "" /t REG_SZ /d "{60254CA5-953B-11CF-8C96-00AA00B8708C}" /f 
```

Cygwin 根目录中的“argshandler.sh”脚本只是 cygpath 返回它接收到的第一个参数，如果没有任何参数则什么都没有（例如，如果你只是双击脚本文件）：

```
#!/bin/bash
if [ ! "$1" == "" ]
then
    cygpath -u "$1"
fi 
```

到目前为止，所有这些都非常有效。但是，仍然有一些缺点需要解决：

*   当涉及到位于 UNC 路径（例如 \\myserver\myshare\scriptfile.sh）上的脚本时，Dragos 的命令及其衍生命令会失败
*   只有 1 个丢弃的项目将传递给 shell 脚本。

不知何故，关于 1-dropped-item-only 问题，更改参数处理程序脚本以返回类似

```
"cygpathed-arg1" "cygpathed-arg2" "cygpathed-arg3" 
```

并将 Dragos 命令的设置器更改为类似

```
...; bash "$(cygpath -u "%%1")" $(/argshandler.sh "%%2" "%%3" ... "%%9")' 
```

（请注意，argshandler.sh 部分周围的“”已消失）似乎无法正常工作：如果拖到脚本上的某些项目在其路径中包含空白，则所述路径将在空白处分解为多个参数即使它们中的每一个都用双引号引起来……很奇怪。

是否有任何命令行专业人员愿意解决这些问题中的一个或两个？

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-19T20:36:46.877

这不会关联 .sh 文件，但它可能会为您提供所需的内容。我从启动 Cygwin bash shell 的 cygwin.bat 批处理文件开始，并对其进行了如下修改：

```
$ cat test.bat
@echo off

set MYDIR=C:\scripts

C:\cygwin\bin\bash --login -c "cd $MYDIR && echo 'Now in' `pwd`; sleep 15" 
```

这是一个玩具脚本，但您可以修改它以调用 rsync 或调用单独的 shell 脚本。我承认如果没有 MYDIR 硬编码会更好。可能有一种方法可以让它自动设置它。

哦，是的，当我在 Cygwin 的 bash shell 中创建 .bat 文件时，我注意到我实际上必须“chmod +x test.bat”才能通过双击启动它。我认为它正在设置 NTFS 权限。如果您只是使用记事本，则不需要这样做。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2015-08-14T13:35:55.033

这是我正在使用的命令：

```
"C:\cygwin\bin\mintty.exe" -w max -h always -t "%1" -e /bin/bash -li -c 'cd "$(dirname "$(cygpath -u "%1")")" && bash "$(cygpath -u "%1")"' 
```

它以 mintty 方式运行，最大化，将窗口标题设置为正在运行的脚本（Windows 路径），将目录更改为脚本所在的位置，运行它并在完成后保持打开状态。

或者，这会将标题设置为脚本的 cygwin 路径：

```
"C:\cygwin\bin\mintty.exe" -w max -h always -t "%1" -e /bin/bash -li -c 'printf "\033]0;$(cygpath -u "%1")\007" && cd "$(dirname "$(cygpath -u "%1")")" && bash "$(cygpath -u "%1")"' 
```

为您设置关联的批处理脚本：

标题中的 Windows 路径：

```
@echo off
assoc .sh=shellscript
ftype shellscript="C:\cygwin\bin\mintty.exe" -w max -h always -t "%%1" -e /bin/bash -li -c 'cd "$(dirname "$(cygpath -u "%%1")")" ^&^& bash "$(cygpath -u "%%1")"'
pause 
```

和标题中的cygwin路径：

```
@echo off
assoc .sh=shellscript
ftype shellscript="C:\cygwin\bin\mintty.exe" -w max -h always -t "%%1" -e /bin/bash -li -c 'printf "\033]0;$(cygpath -u "%%1")\007" ^&^& cd "$(dirname "$(cygpath -u "%%1")")" ^&^& bash "$(cygpath -u "%%1")"'
pause 
```

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2018-09-11T07:25:06.210

在环顾了不同的地方之后。我设法想出的是，首先`C:\cygwin64\bin\mintty.exe`从窗口中选择“打开方式...”对话框然后编辑注册表值

```
[Computer\HKEY_CLASSES_ROOT\Applications\mintty.exe\shell\open\command] 
```

到，

```
C:\cygwin64\bin\mintty.exe -t "%1" /bin/bash -l -i -c "v1=\"$(cygpath -u \"%0\" -a)\" && v2=\"$(dirname \"$v1\")\" && cd \"$v2\" ; exec bash  \"%1\" %*" 
```

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-19T20:34:05.713

您应该能够将 .sh 文件与 \CYGWIN\usr\bin\bash.exe 相关联。该脚本将不得不更改自己的工作目录，我建议在顶部粘贴这样的内容：

```
cd `dirname "$0"` 
```

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2010-03-04T10:41:56.430

我使用 PuttyCyg（Cygwin 窗口中的超棒腻子），这是如何让这一切顺利进行的：

创建一个批处理脚本，例如。在我使用的机器上

```
C:\Dev\scripts\cygbashrun.bat 
```

有内容

```
SET CYGWIN=nodosfilewarning
C:\Cygwin\bin\putty.exe -cygterm /bin/bash.exe %1 
```

显然适应包含您安装 PuttyCyg 的路径。

然后在 Windows 文件资源管理器中转到工具 - 文件夹选项 - 文件类型

如果还没有，则创建一个“.sh”条目（或 .bash，具体取决于您希望脚本拥有的内容）......然后是 Advanced..

[可选步骤] 更改图标并从您的安装中选择 Cygwin 图标

然后：

1.  新的..
2.  行动 = 运行 Bashscript..
3.  用于执行此操作的应用程序 = C:\Dev\scripts\cygbashrun.bat "%1"

对我来说就像一个魅力：O）

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2011-07-07T10:17:03.960

```
 Windows Registry Editor Version 5.00
    ;File:ConfigureShToBeRunUnderExplorer.reg v:1.0 docs at the end
    [HKEY_CLASSES_ROOT\Applications\bash.exe] 

    [HKEY_CLASSES_ROOT\Applications\bash.exe\shell]

    [HKEY_CLASSES_ROOT\Applications\bash.exe\shell\open]

    [HKEY_CLASSES_ROOT\Applications\bash.exe\shell\open\command]
    @="C:\\cygwin\\bin\\bash.exe -li \"%1\" %*"

    ; This is a simple registry file to automate the execution of sh via cygwin on windows 7, might work on other Windows versions ... not tested 
    ; you could add this setting by issueing the following command: reg import ConfigureShToBeRunUnderExplorer.reg 
    ; Note the path of your bash.exe
    ; Note that you still have to add the .sh to your %PATHTEXT%
            ; usage: double - click the file or reg import file 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-19T20:27:24.687

一种可行的解决方案是创建一个`.bat`文件，该文件将打开 cygwin 并执行您的脚本。

`go.sh`执行位于我的主目录中的脚本的脚本：

```
@echo off

C:
chdir C:\cygwin\bin

bash --login -i ./go.sh 
```

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-19T22:13:26.863

查看 dos 框中的 assoc 和 ftype 命令。这是我机器上 .jpg 的示例

```
c:\>assoc .jpg
.jpg=jpegfile

c:\>ftype jpegfile
jpegfile="C:\Program Files\Common Files\Microsoft Shared\PhotoEd\PHOTOED.EXE" "%1"

assoc .sh=bashscript

ftype bashscript="c:\cygwin\bin\bash.exe" "%1" 
```

确保在命令中更改 bash 的路径以*`ftype`*匹配您的*`cygwin`*安装位置

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2010-02-21T07:21:56.303

我只是没有打扰。我将 .sh 文件与 Crimson 编辑器相关联（因为我花费的时间与实际运行它们的时间一样多）。现在需要在文件类型>高级中获得正确的“打开方式/编辑方式”组合。如果我知道 Crimson Editor 使用的 DDE 代码，那会更容易；然而，截至这篇文章我还没有找到它。

这让我想起了我的 Mac 时代（1993-2008 年），那时我曾经尝试扫描应用程序以获得更多基本的 AppleScript 脚本能力。

BZT

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2014-07-15T10:43:12.647

我自己开发了一个 .bat 脚本（不是源自其他人的答案），以将要打开的文件类型（例如 *.cygwin）与此 .bat 相关联，如下所示：

=== 文件 run-script-with-Cygwin-in-same-dir.bat ===

```
@echo off
REM   Info: A script created by Johnny Wong.  (last modified on 2014-7-15)
REM   It is used to pass a file argument to run a bash script file.  The current directory is setting to the path of the script file for convenience.
REM   Could be copied to C:\cygwin;  and then you manually associate .cygwin file extension to open with this .bat file.
set CYGWIN=nodosfilewarning

C:\cygwin\bin\bash --login -i -c 'cd "`dirname "%~1"`"; exec bash "%~1" %2 %3 %4 %5 %6 %7 %8 %9'

REM finally pause the script (press any key to continue) to keep the window to see result
pause 
```

=== 文件 run-script-with-Cygwin-in-same-dir.bat ===

所用语法的详细说明（如果您有兴趣）：

1.  如果将要打开的文件与此 .bat 关联，则 %1 为“...”引用。将文件拖到此 .bat 时，仅当文件的路径有空格时才会引用“...”。
2.  %~1 与 %1 相同，去掉周围的双引号（如果存在）
3.  要从 %p% 中删除周围的双引号，请使用`for %%a in (%p%) do set p=%%~a`
4.  您必须使用`"%~1"`强制脚本文件的路径双引号，以便其文件夹分隔符'\'（在 %1 中）在被视为转义字符时不会被 bash 删除。否则，将路径中没有空格的文件拖动到此 .bat 时，它不起作用。
5.  “exec bash”可以只是“bash”，前者是为了节省更多的 bash 进程的资源。

喜欢:)

# ms-access - 将 Ms Access 应用程序转换为 .Net 应用程序有哪些好的技术？

> ID：105087
> 
> 赞同：7
> 
> 时间：2008-09-19T20:07:16.137
> 
> 标签：ms-access, legacy

我们有一个 12 岁的 Ms Access 应用程序，用于我们的核心库存仓储和发票系统。它已经在 SQL Server 后端运行，但所有“逻辑”、表单和报告都在 Access 中。在经历了将库存交易从非临时性转变为临时性所花费的大量维护污泥之后，我意识到有一天我需要将这个东西转换为代码，这样我才能在一个更易于维护和可测试的环境中更好地管理逻辑。

有哪些技术可以让我以可管理和有效的方式将其转换为 .Net 应用程序？

一个想法是将查询转换为存储过程，然后将应用程序转换为 Adp 项目。但我仍然对如何处理表单和报告一无所知。

此外，如果这很重要，我是我公司唯一的开发人员。

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-09-19T20:22:01.063

简短的回答：迁移似乎并不容易自动化。

我的猜测是，您最好的选择是一次重写（并安装）系统，即使（可能）它会迫使您的用户并排运行旧版本和新版本一段时间以使用不同的位的功能。您可以通过仔细考虑要迁移的功能以及迁移顺序来最大程度地减少麻烦。

例如，您可能有一位用户，其工作角色要求他或她整天只使用一个屏幕。如果您首先迁移带有附带功能的屏幕，则该用户可以立即进入新系统并留下旧系统，从而减少您的维护负担。

所以这些只是基于没有太多信息的一些想法。无论如何，我希望这会有所帮助。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-16T12:26:38.787

由于您已经拥有带有一些业务逻辑的 asp.net，因此您可以将其打开以作为 Web 服务（asmx 文件）访问。Google for the Microsoft Office Web Services Toolkit for your version of access (xp/2003 etc.) 这将为您编写 vba 代理类来调用 Web 服务。您可以通过代码（vba 读取和写入控件）将 Web 服务数据绑定到表单，或者使用来自 Web 服务的数据创建本地临时表并使用常规访问绑定。

根据您最熟悉的内容（代码/tsql），您可以将逻辑放入存储过程或业务逻辑层或混合（两者）中。我发现测试代码比存储过程更容易，并且喜欢不绑定到 sql server 的业务逻辑，即如果你想更改数据库或想在没有数据库的情况下离线开发/测试组件。新的 .net 功能（如 LINQ）具有相当好的性能，因此您不必依赖存储过程来进行数据库活动。

保留访问前端用户界面，直到您重构了对 Web 服务的所有业务逻辑/数据访问。然后，您可以根据需要创建一个使用 Web 服务的 asp.net 应用程序或一个 winform 应用程序。（暂时不要使用 wpf，作为 ui，因为它是一个陡峭的学习曲线，并且还没有可以与访问数据表视图进行比较的数据网格。）

**报告**

访问报告可以升级为sql server 报告服务（报告中的vba不会升级，最好在存储过程中编写一些tsql）。如果您没有完整的 sql server 产品，您仍然可以使用 reportviewer 控件在 asp.net（或标准版本的 winform 或[Visual](http://www.gotreportviewer.com/) Studio) 绑定到 ado.net 数据集。

**其他选项：** 您可以编写 .net dll 并使用 com 互操作。这种方法允许您逐渐开始编写功能。不要使用 .net ui，例如 winform，因为它不能很好地与 access ui 配合使用。您可以编写业务逻辑或数据访问逻辑，然后从 vba 调用这些类。然后，如果需要，您可以将此代码移至 asp.net 或 Web 服务。

**要排除的事情：**

我不喜欢使用并排版本编写新应用程序的方法。作为一个单一的开发人员，你有足够的担心。您最终可能会在两个版本中添加功能并调试两个版本而不是一个版本。

vb6 表单互操作不适用于访问。

如上所述的ADP已经死了。（我从不喜欢它们，因为我经常使用本地表来优化性能，它们只能通过代码调用而不是链接）

您可能能够使用 Visual Basic 升级向导（在 Visual Studio 中）将您的 vba 模块和类模块转换为 vb.net，但它不会放大所有内容（例如，dao/ado 代码到 ado.net 代码）并且不会创建针对 .net 优化的代码，并且可能不容易编写单元测试，具体取决于 vba 代码的设计。我建议重写代码（如果您对测试很认真，请尝试测试驱动开发，看看您是否喜欢它）。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T20:45:24.657

我会考虑查看[Interop Forms Toolkit](http://msdn.microsoft.com/en-us/vbasic/bb419144.aspx)。据我了解，这个工具使得在 VB6 中使用 .NET 表单变得非常容易，所以也许它也可以在 Microsoft Access 中使用？如果是这样，它可能会帮助您以增量方式将应用程序迁移到 .NET。快速搜索后，我找不到任何关于将它与 Microsoft Access 一起使用的指南，因此如果结果证明这是一条死胡同，我深表歉意。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-20T13:27:04.827

从长远来看，转换为 adp 并不是一个好的解决方案——这项技术已被微软抛弃。

如果你想切换到.net（为什么？你有理由偏爱.net吗？）我建议你开始阅读，尝试创建一些简单的应用程序，然后开始将这个数据库转换为应用程序的任务。

但...

我认为你和公司需要考虑这个项目所涉及的风险。如果您生病了，就在管理层需要一些尚不存在的报告的那一周，会发生什么？我建议你找一家本地的小型软件开发公司，他们会很乐意帮助你的。也许您可以安排您继续担任“首席开发人员”并仅将它们用作备份。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2019-02-15T09:13:42.607

我有一个类似的问题，并通过在 Access 前端创建版本化部署系统（抓取并提取 CAB 文件）来解决它，找出所需的 AppDomain 操作以便能够将正确的 CLR 版本加载到 Access 进程中，加载.config 文件，并**以两种方式**发布数据。

它使用标准的 C DLL 调用，因此不需要 COM 注册，但遗憾的是不支持 Unicode。

发送命令 - 通用，我可以用这个做所有事情。Open Form - 旨在成为 DoCmd.OpenForm 的“直接”替代品 Open Report - 旨在成为 DoCmd.OpenReport 的“直接”替代品

所以制作一个新的报表，或者将现有的报表迁移到SSRS，制定格式标准，然后在Access中将DoCmd.OpenReport更改为netDoCmd.OpenReport。

遵循命名约定以了解从何处加载报告，以及提取报告所需数据的标准方法。

现在，我正在迁移一个表单或报告，如果容量允许，或者需要对其进行更改。

因为谁能一举阻止功能开发一年？

MDI 不能正常工作。我认为围绕 SetParent 和 UPDATE_UISTYLE 我还需要做一些工作

所有这些都使 UI 处于进程中并在带有 Access 的窗口中。我在 DLL 中构建所有内容，最后一步是创建一个加载“第一个表单”的 EXE，并使用它来替换 Access 前端。

# python - 由于 GIL，多线程 Python 代码中是否不需要锁？

> ID：105095
> 
> 赞同：77
> 
> 时间：2008-09-19T20:07:37.540
> 
> 标签：python, multithreading, locking

如果您依赖于具有全局解释器锁（即 CPython）并编写多线程代码的 Python 实现，您真的需要锁吗？

如果 GIL 不允许并行执行多条指令，难道共享数据就不需要保护了吗？

抱歉，如果这是一个愚蠢的问题，但这是我一直想知道的关于多处理器/核心机器上的 Python 的问题。

同样的事情也适用于任何其他具有 GIL 的语言实现。

* * *

## 回答 #1

> 赞同：72
> 
> 时间：2008-09-19T20:34:40.610

如果您在线程之间共享状态，您仍然需要锁。GIL 只在内部保护解释器。您仍然可以在自己的代码中进行不一致的更新。

例如：

```
#!/usr/bin/env python
import threading

shared_balance = 0

class Deposit(threading.Thread):
    def run(self):
        for _ in xrange(1000000):
            global shared_balance
            balance = shared_balance
            balance += 100
            shared_balance = balance

class Withdraw(threading.Thread):
    def run(self):
        for _ in xrange(1000000):
            global shared_balance
            balance = shared_balance
            balance -= 100
            shared_balance = balance

threads = [Deposit(), Withdraw()]

for thread in threads:
    thread.start()

for thread in threads:
    thread.join()

print shared_balance 
```

在这里，您的代码可能会在读取共享状态 ( `balance = shared_balance`) 和将更改的结果写回 ( `shared_balance = balance`) 之间中断，从而导致更新丢失。结果是共享状态的随机值。

为了使更新保持一致，run 方法需要锁定 read-modify-write 部分（在循环内）周围的共享状态，或者有[一些方法来检测共享状态自读取后何时发生变化](http://en.wikipedia.org/wiki/Software_transactional_memory)。

* * *

## 回答 #2

> 赞同：24
> 
> 时间：2008-09-19T20:13:54.920

不——GIL 只是保护 python 内部免受多个线程改变它们的状态。这是一种非常低级的锁定，仅足以使 python 自己的结构保持一致状态。它不包括您需要执行的*应用程序级别锁定，以在您自己的代码中涵盖线程安全。*

锁定的本质是确保特定的代码*块*仅由一个线程执行。GIL 对单个字节码大小的块强制执行此操作，但通常您希望锁跨越比这更大的代码块。

* * *

## 回答 #3

> 赞同：11
> 
> 时间：2008-10-28T00:16:12.273

添加到讨论：

因为 GIL 的存在，一些操作在 Python 中是原子的，不需要锁。

[http://www.python.org/doc/faq/library/#what-kinds-of-global-value-mutation-are-thread-safe](http://www.python.org/doc/faq/library/#what-kinds-of-global-value-mutation-are-thread-safe)

但是，正如其他答案所述，只要应用程序逻辑需要锁（例如在生产者/消费者问题中） ，您*仍然需要使用锁。*

* * *

## 回答 #4

> 赞同：9
> 
> 时间：2008-09-19T20:16:33.963

这篇文章在相当高的层次上描述了 GIL：

*   [https://web.archive.org/web/20080516010343/http://www.pyzine.com/Issue001/Section_Articles/article_ThreadingGlobalInterpreter.html](https://web.archive.org/web/20080516010343/http://www.pyzine.com/Issue001/Section_Articles/article_ThreadingGlobalInterpreter.html)

这些引语特别有趣：

> 每十条指令（此默认值可以更改），核心释放当前线程的 GIL。此时，操作系统从所有竞争锁的线程中选择一个线程（可能选择刚刚释放 GIL 的同一个线程——您无法控制选择哪个线程）；该线程获取 GIL，然后再运行十个字节码。

和

> 请注意，GIL 仅限制纯 Python 代码。可以编写扩展（通常用 C 编写的外部 Python 库）来释放锁定，然后允许 Python 解释器与扩展分开运行，直到扩展重新获得锁定。

听起来 GIL 只是为上下文切换提供了更少的可能实例，并使多核/处理器系统对于每个 python 解释器实例表现为单核，所以是的，您仍然需要使用同步机制。

* * *

## 回答 #5

> 赞同：8
> 
> 时间：2008-09-19T20:24:50.620

全局解释器锁防止线程同时访问*解释*器（因此 CPython 只使用一个内核）。但是，据我了解，线程仍然被中断和*抢先*调度，这意味着您仍然需要锁定共享数据结构，以免您的线程踩到彼此的脚趾。

我一次又一次遇到的答案是，Python 中的多线程很少值得开销，正因为如此。我听说过[PyProcessing项目的好消息，它使运行多个进程像多线程一样“简单”，具有共享的数据结构、队列等。（PyProcessing 将作为](http://pyprocessing.berlios.de/)[多处理](http://www.python.org/dev/peps/pep-0371/)模块引入即将推出的 Python 2.6 的标准库中.) 这可以让您了解 GIL，因为每个进程都有自己的解释器。

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2008-12-22T09:49:35.747

这样想：

在单处理器计算机上，多线程通过暂停一个线程并以足够快的速度启动另一个线程以使其看起来同时运行而发生。这就像带有 GIL 的 Python：实际上只有一个线程在运行。

问题是线程可以在任何地方暂停，例如，如果我想计算 b = (a + b) * 3，这可能会产生如下指令：

```
1    a += b
2    a *= 3
3    b = a 
```

现在，假设它在一个线程中运行，并且该线程在第 1 行或第 2 行之后被挂起，然后另一个线程启动并运行：

```
b = 5 
```

然后当另一个线程恢复时， b 被旧的计算值覆盖，这可能不是预期的。

所以你可以看到，即使它们实际上没有同时运行，你仍然需要锁定。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-19T20:11:18.843

您仍然需要使用锁（您的代码可能随时中断以执行另一个线程，这可能导致数据不一致）。GIL 的问题在于它阻止 Python 代码同时使用更多内核（或多个处理器，如果它们可用）。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2013-12-05T19:01:46.660

仍然需要锁。我将尝试解释为什么需要它们。

任何操作/指令都在解释器中执行。GIL 确保解释器在**特定时刻**由单个线程持有。并且您的具有多个线程的程序在单个解释器中工作。在任何特定时刻，这个解释器都由一个线程持有。这意味着只有持有解释器的线程在任何时刻都在**运行。**

假设有两个线程，比如 t1 和 t2，并且都想执行两条指令，即读取全局变量的值并将其递增。

```
#increment value
global var
read_var = var
var = read_var + 1 
```

如上所述，GIL 仅确保两个线程不能同时执行一条指令，这意味着两个线程不能`read_var = var`在任何特定时刻执行。但是他们可以一个接一个地执行指令，你仍然会遇到问题。考虑这种情况：

*   假设 read_var 为 0。
*   GIL 由线程 t1 持有。
*   t1 执行`read_var = var`。因此，t1 中的 read_var 为 0。GIL 只会确保此时不会对任何其他线程执行此读取操作。
*   GIL 被赋予线程 t2。
*   t2 执行`read_var = var`。但是 read_var 仍然是 0。所以，t2 中的 read_var 是 0。
*   GIL 被赋予 t1。
*   t1 执行`var = read_var+1`并且 var 变为 1。
*   GIL 被赋予 t2。
*   t2 认为 read_var=0，因为这就是它读取的内容。
*   t2 执行`var = read_var+1`，var 变为 1。
*   我们的期望是`var`应该变成 2。
*   因此，必须使用锁来保持读取和递增作为原子操作。
*   Will Harris 的回答通过代码示例进行了解释。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-12-22T02:56:47.000

来自 Will Harris 的示例的一些更新：

```
class Withdraw(threading.Thread):  
def run(self):            
    for _ in xrange(1000000):  
        global shared_balance  
        if shared_balance >= 100:
          balance = shared_balance
          balance -= 100  
          shared_balance = balance 
```

在撤回中放置一个值检查语句，我不再看到负面信息，并且更新似乎是一致的。我的问题是：

如果 GIL 阻止在任何原子时间只能执行一个线程，那么陈旧的值在哪里？如果没有陈旧的值，为什么我们需要锁？（假设我们只谈纯python代码）

*如果我理解正确，上述条件检查在真正的*线程环境中是行不通的。当多个线程同时执行时，可能会创建陈旧的值，因此共享状态的不一致，那么你真的需要一个锁。但是如果python真的在任何时候只允许一个线程（时间切片线程），那么陈旧的值就不应该存在，对吧？

# css - CSS：显示属性差异

> ID：105100
> 
> 赞同：5
> 
> 时间：2008-09-19T20:08:28.397
> 
> 标签：css

display:block 和 display:inline 有什么区别

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-09-19T20:10:24.850

display: block
将导致对象将容器内的其他对象强制到新行。

display: inline
尝试将对象显示在与其他对象相同的行上。

显示：块

```
项目 1
第 2 项
第 3 项

```

显示：内联

```
项目 1 项目 2 项目 3

```

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-09-19T20:10:09.047

块元素通常会垂直堆叠，而内联元素会水平排列。

两个 Div 将相互堆叠，但如果将它们设置为 display:inline，它们将水平彼此相邻。反之亦然，使用 Span 标签。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-19T20:11:10.170

是的，

display:block 使元素表现得像块，例如：`<p>`

display:inline make 和元素布局内联。

这些可以应用于默认为相反显示类型的元素。

可能的值

```
* none - no display at all.
* inline - An inline box.
* block - A block box.
* inline-block - effectively a block box inside an inline box. Not supported by Mozilla at time of writing. IE will only apply inline-block to elements that are traditionally inline such as span or a but not p or div. Loopy.
* run-in - Either an inline or block box depending on the context. If a block box follows the run-in box, the run-in box becomes the first inline box of that block box, otherwise it becomes a block box itself. Crazy. Not supported by IE/Win or Mozilla at the time of writing.
* list-item - the equivalent of the default styling of the HTML li element.
* table - a block-level table - the equivalent of the default styling of the HTML table element. Not supported by IE.
* inline-table - an inline-level table. Not supported by IE.
* table-row-group - the equivalent of the default styling of the HTML tbody element. Not supported by IE.
* table-header-group - the equivalent of the default styling of the HTML thead element. Not supported by IE.
* table-footer-group - the equivalent of the default styling of the HTML tfoot element. Not supported by IE.
* table-row - the equivalent of the default styling of the HTML tr element. Not supported by IE.
* table-column-group - the equivalent of the default styling of the HTML colgroup element. Not supported by IE.
* table-column - the equivalent of the default styling of the HTML col element. Not supported by IE.
* table-cell - the equivalent of the default styling of the HTML td or th elements. Not supported by IE.
* table-caption - the equivalent of the default styling of the HTML caption element. Not supported by IE. 
```

*[来源](http://htmldog.com/reference/cssproperties/display/)

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-19T20:10:55.817

display: block 意味着元素显示为一个块，就像段落和标题一样。一个块的上下都有一些空格，并且它旁边不允许有任何 HTML 元素，除非有其他命令（例如，通过向另一个元素添加浮点声明）。display: inline 表示元素内联显示，在当前块内的同一行。只有当它在两个块之间时，元素才会形成一个“匿名块”，但是它具有最小的可能宽度。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-19T20:19:52.660

CSS 中有两种主要类型的绘图上下文可以分配给元素。一, `display: block`, 创建可定位的盒子。另`display: inline`一种是将内容作为框内的一系列线条流动。

默认情况下，一个块占据所有水平空间，因此一系列块将显示在另一个下方，垂直堆叠。当内联元素流入线条时，它们会水平呈现，一个字一个字。

通常，您使用块来布局页面，而内联保留用于在文本块中找到的文本内容，例如链接。

还有其他类型的绘图上下文，例如 ，`display: table`但是由于它们的特殊性质和/或缺乏浏览器支持，这些很少使用。

[CSS 2.1 规范](http://www.w3.org/TR/CSS21/visuren.html#normal-flow)中提供了更多详细信息。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-19T20:22:49.797

需要注意的是，内联元素不能分配自己的宽度、高度或垂直空白（边距/填充顶部/底部）。

如果你试图让块元素表现得像内联元素（它们彼此相邻堆叠），你应该使用`float`. 浮动将堆叠在相同方向的其他浮动旁边。此外，任何给出的内联元素都`float`将自动给出成为一个块。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T20:11:07.283

块使用可用的全宽，前后有一个新行。内联只使用它需要的宽度而不强制换行。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-19T20:34:27.117

一个 HTML 文档被认为是一个流，想想一堆堆在顶部的 HTML 元素。

块在流中定义为一个框（默认与页面一样大），并尽可能地推到顶部而不与另一个块重叠。示例：div、p、表格。

一个内联元素不定义一个盒子（这就是为什么你不能设置它的宽度和高度），它将被附加到当前块中的其他内联元素。示例：跨度、代码、a。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2016-02-21T07:30:40.590

```
display: block 
```

该元素将占据其父元素的整个容器。通常从新行开始。

```
display: inline-block 
```

这将创建一个只占用所需空间的内联元素。可以从线路的任何地方开始。

示例用法：在页面顶部创建菜单栏时（通常分配菜单项包装器`display: inline-block`）

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2021-04-05T16:19:43.497

考虑下面的示例：默认情况下是块级元素，将水平占用整个空间。并且默认是内联元素（下一个 span 元素将水平占用相同的行空间）

```
h1{
    background-color:yellow;
}

span{
    background-color:lightpink;
}
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Document</title>
</head>
<body>
    <h1>This is heading 1</h1>
    <h1> This is heading 2</h1>

    <span>Span1</span>
    <span>Span2</span>
</body>
</html>
```

让我们通过将内置内联元素转换为块级元素来更好地理解，反之亦然。

```
h1{
    background-color:yellow;
    display:inline;
}

span{
    background-color:lightpink;
    display:block;
}
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Document</title>
</head>
<body>
    <h1>This is heading 1</h1>
    <h1> This is heading 2</h1>

    <span>Span1</span>
    <span>Span2</span>
</body>
</html>
```

# design-patterns - 你遇到过的最有趣的设计模式是什么？

> ID：105113
> 
> 赞同：6
> 
> 时间：2008-09-19T20:09:46.303
> 
> 标签：design-patterns

我们大多数人已经使用过[MVC](https://stackoverflow.com/questions/26685/what-is-mvc-and-what-are-the-advantages-of-it)、[strategy](https://stackoverflow.com/questions/91932?sort=votes#sort-top)等休闲模式。

但是对于不寻常的问题，肯定有一些不寻常的解决方案，我很想听听。

* * *

## 回答 #1

> 赞同：16
> 
> 时间：2008-09-20T01:40:59.987

仅崩溃软件： [http](http://www.usenix.org/events/hotos03/tech/full_papers/candea/candea_html/) ://www.usenix.org/events/hotos03/tech/full_papers/candea/candea_html/ 摘要

仅崩溃程序安全崩溃并快速恢复。只有一种方法可以阻止此类软件——通过使其崩溃——并且只有一种方法可以启动它——通过启动恢复。仅崩溃系统是从仅崩溃组件构建的，并且使用透明组件级重试可隐藏最终用户的系统内组件崩溃。在本文中，我们提倡互联网系统的仅崩溃设计，表明它可以导致更可靠、可预测的代码和更快、更有效的恢复。我们提出了有关如何构建这种仅崩溃的 Internet 服务的想法，将成功的技术发挥到逻辑上的极致。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-09-19T20:17:32.447

这更像是一种反模式，但我已经看到了我所说的“将所有内容保存在一个地方”模式。这是一个大型应用程序，其中所有非本地变量，对于每个类，每个类，都存储在一个名为 P（用于参数）的类中。顺便说一句，所有静态变量都保存在一个名为...等待它... S 的类中。

无论如何，不​​知何故，这个项目变得相当大，突然之间，没有任何效果。（我是在这个时候被录用的）。令人惊讶的是，该程序并没有崩溃，它只是有大量的副作用，使应用程序运行起来很糟糕。可以想象，多个线程都访问 P 和修改变量，没有锁定或同步。

我告诉你，这真是一个值得一看的景象。

公司开了一个新办公室，雇了3个人来工作，我就是其中之一。我们得到了程序并被告知要修复它。我们花了几天时间坐在周围只是拍拍我们的额头。我现在脸上有一个永久性的掌纹。

其他有趣的...变量名为“fudgeFactor”。仍然不知道那做了什么。

获取下一个ASCII字符的方法...

```
char getNextChar(char previous) {

switch (previous)
case 'a': return b;
case 'b': return c;
...
case 'z': return a;
} 
```

不管怎样，这就是我的有趣模式……加上一些额外的有趣之处。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-12-24T19:10:58.793

去年我一直在维护一个用 LANSA 编写的 Windows 应用程序，其中焦点是通过将所有控件设置为 tabStop = false 来管理的，除了两个隐藏按钮（PrevFocus 和 NextFocus）。加载表单时，焦点被设置到一个字段，并且该字段的名称存储在跟踪变量中（恰当地命名为“FocusField”）。当用户使用 tabs（或 shift-tabs）改变焦点时，相应按钮的 GotFocus 事件就会运行。该函数内部是一个案例语句（选择案例 FocusField）。根据当前关注的字段，运行验证逻辑，并且可能，焦点更改为另一个字段。

大多数控件的 GotFocus 事件会查看 FocusField 的当前值，然后调用 LostFocus 函数，该函数对 FocusField 执行相同的 case 语句，以便验证先前聚焦的字段。

正如您可能猜到的那样，这使得将 UI 与逻辑分开是不可能的，并且维护起来令人难以置信。重写这些表单以使用简单的 Validate 方法来验证所有输入并让正常的选项卡属性（TabOrder、TabStop 等）发挥它们的魔力通常会导致代码减少 50% 并大大提高表单的可靠性。

我不知道这种模式起源于何处，尽管它可能是由 RPG/绿屏程序员转变为编写应用程序的 WinForms 开发人员的梦想。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-19T20:23:39.360

访问者第一次在处理大量图形程序时卡住了我，作为对复杂结构进行操作的一种非常优雅的方式。

除了 mvc（它本身不是模式）之外，就其复杂性和解决问题的潜力而言，它是“模式之王”。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-19T20:24:58.467

Fowler的[Fluent Interface](http://www.martinfowler.com/bliki/FluentInterface.html)是一个非常有趣的模式。我也一直对抽象工厂、策略和状态模式情有独钟。

如果可以的话，我最近编写了一个“模式”，我称之为[朋友类模式](http://moffdub.wordpress.com/2008/09/17/friend-classes-in-java-and-c-sharp/)，有些人可能会觉得它对限制没有 C++ 风格朋友类的语言中私有字段访问器的可见性很有趣或有用。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-10-12T23:48:11.580

与其说是一种模式，不如说是依赖注入和控制反转

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2012-11-08T00:09:04.190

我记得当我第一次阅读GOF 中的享元[模式时。](https://en.wikipedia.org/wiki/Flyweight_pattern)他们使用的例子是文字处理器；他们指出了使用独立对象来表示每个角色的缺点。享元模式鼓励将可共享的、内在的、不可变的状态与不可共享的、外在的、可变的状态分开。对我来说，当时，它是那些“啊哈！”之一。这些时刻真正拓宽了我的视野，并影响了我的设计至今。

我的一个朋友建议策略模式本质上是祖先模式。许多其他模式（桥接、装饰器、代理、状态等）只是策略的更精细应用。我记得我和他争论了很长时间，战略和状态之间确实存在差异。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-19T20:15:37.193

不，那是关于 DP 书籍的，而这个线程是关于特定模式的。

口译员和享元从 4 本书的帮派中浮现。

我认为 sw 开发人员工具箱中的 Bridge 和 Mediator 是强大而深入的模式。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-19T20:30:08.377

[在我不得不直接使用ASM](http://asm.objectweb.org/)库操作 Java 字节码之前，我从来没有看到访问者模式的意义。令人惊讶的是，这种模式在多大程度上简化了原本非常复杂的任务。

当您想编写自己的重构插件时，大多数 Java IDE 也使用该模式。[您提供一个访问者对象，它会在AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree)周围传递以进行所需的任何更改。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-19T20:27:57.163

出于显而易见的原因，您将遇到的最有趣的设计模式是您自己创建的。

这并不是说它将是最好的设计模式，只是最有趣的。

# apache-flex - Flex 中的生产日志记录

> ID：105121
> 
> 赞同：5
> 
> 时间：2008-09-19T20:11:01.183
> 
> 标签：apache-flex, logging

有什么方法可以在不以调试模式运行时捕获 Flex 应用程序的跟踪语句？

或者在不运行调试器时还有其他方法可以输出日志信息吗？

目前我正在尝试修复一个仅在非常特定的部署场景中出现的错误，但我可以看到这在某些情况下对客户在报告错误或其他问题时将日志发送给技术支持很有用。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-19T21:04:01.850

我想您是在谈论 Adob​​e Flex，针对 Flash Player？

如果是这样，您可以编写自己的日志记录包装类，将发送给它的日志消息传播到多个目标（如跟踪堆栈和内部存储器，以便您可以从应用程序内部访问日志，例如，当用户使用时将其发送到服务器同意发送错误报告）。另请参阅[Flex 日志框架](http://livedocs.adobe.com/flex/3/langref/mx/logging/package-detail.html)，了解已经存在的类似内容。

我实际上做过这样的事情——我有一个`Log`用静态方法调用的类`log()`，我在我的应用程序中使用，并且这个类将发送给它的所有消息通过, 转发到跟踪堆栈到“日志控制台" 应用程序通过 LocalConnection 和/或 Socket 在同一主机上运行（套接字连接显然比 LocalConnection 快很多），并将它们本地保存到一个数组中，以便用户可以直接从应用程序内发送错误报告和日志输出.`debug()``error()``trace()`

这种变化当然意味着您必须将`trace()`代码中的所有命令转换为对日志系统的调用，但这可以通过正则表达式搜索和替换轻松实现。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-10T14:19:39.263

Google Code 上有一个名为[Thunder Bolt](http://code.google.com/p/flash-thunderbolt/wiki/ThunderBoltAS3)的项目，它允许您编写在 Firefox 中运行应用程序时将出现在[FireBug](https://addons.mozilla.org/en-US/firefox/addon/1843)中的日志消息（当然假设您安装了该扩展程序。）

使用此工具进行日志记录非常简单：

```
import org.osflash.thunderbolt.Logger;

var myNumber: int = 5;
var myString: String = "Lorem ipsum";
Logger.error ("Logging two objects: A number typed as int and a string", myNumber, myString); 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-10T14:44:32.113

我以前用过alcon。

[http://blog.hexagonstar.com/alcon/](http://blog.hexagonstar.com/alcon/)

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-22T08:29:42.590

你可以试试 Farata Systems 的 XPanel。这是一个本机 Windows UI，它可以使用 Flex 3 Logging API 显示日志消息，即使对于在浏览器中运行的 Flex 应用程序也是如此。不幸的是，他们重新设计了他们的网站，我再也找不到它了……也许谷歌会帮助你。

我们使用 JavaScript 做了一些不同的事情。客户可以打开一个“特殊”页面，该页面显示使用 DHTML 的日志记录和跟踪语句。Flex 应用程序调用一个 JavaScript 函数，该函数告诉应用程序该页面是否打开。如果不是，则禁用日志记录。如果打开，则启用日志记录并将所有日志语句附加到此页面。

请注意，由于沙盒限制，无法始终将日志记录输出写入文件系统。但是，如上所述，客户可以轻松地复制和粘贴日志记录窗口的输出。

# java - 有没有一种简单的方法可以让 Apache Tomcat 在部署后自动重启？

> ID：105125
> 
> 赞同：3
> 
> 时间：2008-09-19T20:11:10.027
> 
> 标签：java, jsp, tomcat, cruisecontrol

我们的项目使用 Cruise Control 构建和热部署 Web 应用程序到远程服务器（通过 FTP）以 .war 文件的形式运行 Tomcat。不幸的是，“热”部署似乎无法正常工作，导致我们重新启动 Tomcat 以响应每个部署。我们真的很想自动执行此操作，就像构建本身一样。是否有捷径可寻？

旁注：两台机器都运行 Windows（我认为是 XP 或服务器）。

旁注2：性能并不重要。这是一个集成框。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T20:25:54.033

如果您定期安排构建，则可以像这样轻松地将某些内容放入 cron

```
crontab -e 
```

然后在凌晨 1:30 停止 tomcat

```
30 1 * * * ./path_to_tamcat/bin/catalina.sh stop 
```

然后 2 分钟后再次启动

```
32 1 * * * ./path_to_tamcat/bin/catalina.sh start 
```

当然这对于不定期部署来说不是最好的，但是您可以轻松地进行定期部署并计划重启。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T22:11:19.927

如果您查看 bin 目录中的 tomcat 启动和关闭 .bat（或 .sh）脚本，您会看到它们实际上运行了一个 java 进程来启动 tomcat 或者在关闭的情况下，连接到 tomcats 关闭端口 - 参见conf 目录中的 server.xml。您可以配置您的 build ant 任务以与脚本相同的方式调用 tomcat jar。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-20T01:47:43.480

tomcat 是否注册为 Windows 服务？

如果是这样，只需使用 netstart 和 netstop 编写一个 .bat 脚本，并将调用作为部署过程的最后一步。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T20:36:45.753

这听起来有点像您正在使用小型 Tomcat 部署管理器。我基本上没有这方面的经验，你知道的。也就是说，在我工作的地方，我们使用两种设置。

在 server.xml 文件中，上下文具有*reloadable="true"*属性。

我们所要做的就是将 WAR 文件放在正确的位置，然后 Tomcat 将其解压缩并重新加载，没问题。

现在当我查看它时，[官方配置参考](http://tomcat.apache.org/tomcat-5.5-doc/config/context.html)说：

> “此功能在应用程序开发过程中非常有用，但它需要大量运行时开销，不建议在已部署的生产应用程序中使用。”

就像我说的，我们从来没有遇到过问题。我们的系统处理大量请求，我们似乎没有问题。不过，我们从未对这两种配置进行过基准测试。

你可能想试一试。至少你会知道这样做是否足够高兴重新加载东西。您也可以检查性能，看看它是否对您有问题。

我应该注意，每隔一段时间，事情就会不正常，无论如何我们都必须重新启动 Tomcat，但这种情况相对较少。

如果这可行，您需要做的就是在正确的位置使用脚本复制 WAR 并监控以确保一切正常。在足够的部署之后，Tomcat 将用完 permgen 空间，因此您必须意识到您可能需要手动重新启动 Tomcat。

其他随机猜测：

1.  您是直接通过 FTP 进入最终的 WAR 位置吗？也许Tomcat只是试图过早打开它？
2.  您是否收到任何类型的错误消息？也许这可以帮助您追踪问题？
3.  您是否尝试过其他版本的 Tomcat（如果您可以使用）？也许 5.5 没有问题（或者 5.0 如果你在 5.5 上）？也许只是一个更新的点发布？

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T23:04:28.847

What version of tomcat are you using? What exactly happens to make it appear as if a "hot" deploy doesn't work?

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-12-05T11:52:45.867

可重新加载=“真”

不启用war-files的重新部署（这将自动工作），它可以监视WEB-INF/classes和WEB-INF/lib中文件的变化，这可能不是你想要的。

大多数情况下，在 Tomcat 中重新部署 war 文件时冻结，我能够将其追溯到类加载器泄漏，请参阅[Classloader leaks: the dreaded "java.lang.OutOfMemoryError: PermGen space" 异常](http://blogs.oracle.com/fkieviet/entry/classloader_leaks_the_dreaded_java)

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2010-01-21T16:06:30.133

您没有详细说明为什么您的热部署“无法正常工作”，但如果它实际上是由`/WEB-INF/lib`被锁定的资源引起的（这不是不常见的原因；您经常`mail.jar`在 JavaMail API 中看到这一点） , 然后只需将`Context`'`antiResourceLocking`属性设置为`true`. 这是一个示例 webapp 的`/META-INF/context.xml`外观：

```
<Context antiResourceLocking="true">
    <!-- Your stuff here. -->
</Context> 
```

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2020-10-21T09:15:58.360

在启动时启动 tomcat 的一种方法是使用 cron 使用 @reboot 属性运行它：

打开一个终端并输入：

```
sudo crontab -e 
```

在文件末尾输入命令：

```
@reboot /`PATH_TO_WHERE_TOMCAT_INSTALLED`/bin/startup.sh 
```

保存文件并退出。

上述命令将在每次计算机启动时运行一次。

# visual-studio - 为什么使用 WinDbg 与 Visual Studio (VS) 调试器？

> ID：105130
> 
> 赞同：62
> 
> 时间：2008-09-19T20:11:56.173
> 
> 标签：visual-studio, windbg

[使用WinDbg](http://en.wikipedia.org/wiki/WinDbg)与 Visual Studio 调试器的主要原因是什么？

它通常用作 Visual Studio 调试器的完全替代品，还是在需要时更多地使用。

* * *

## 回答 #1

> 赞同：71
> 
> 时间：2008-09-19T20:35:21.670

如果您想知道为什么应该使用 windbg 而不是 Visual Studio，那么您需要阅读[Advanced Windows Debugging](https://rads.stackoverflow.com/amzn/click/com/0321374460)。任何时候你需要调试一个真正丑陋的问题时，windbg 都有比 Visual Studio 更好的技术来解决它。Windbg 具有更强大的脚本语言，并允许您编写 DLL 来自动解决难题。它将安装 gflags.exe，它使您可以更好地控制堆以调试内存覆盖。

您实际上不需要运行安装，只需将文件复制过来即可开始安装。它还安装 adsplus.vb，因此您可以对正在运行的进程进行迷你转储。设置执行远程调试也很容易。没有什么比能够在自己的办公桌上调试问题而不是与测试 PC 上闪烁的 15 英寸显示器作斗争更好的了。

对于日常代码编写，我使用 Visual Studio，但是一旦您需要从其他计算机开始调试问题或发现自己处于非常丑陋的境地，windbg 是唯一的出路。花一些时间学习windbg是一项巨大的投资。此外，如果您查看故障转储，则有两个很好的资源，[http](http://www.dumpanalysis.org/blog) ://www.dumpanalysis.org/blog和[http://blogs.msdn.com/ntdebugging/default.aspx](http://blogs.msdn.com/ntdebugging/default.aspx)，它们使用 windbg 进行所有调试。

* * *

## 回答 #2

> 赞同：13
> 
> 时间：2008-09-24T13:04:15.287

以下是一些有助于使用[WinDbg](http://en.wikipedia.org/wiki/WinDbg)的进一步链接，大多数是特定于 .NET 的。

*   John Robbins 谈到使用[cmdtree](http://www.wintellect.com/CS/blogs/jrobbins/archive/2008/09/17/windbg-cmdtree-file-that-eases-some-sos-pain.aspx)创建命令窗口。
*   这是一个快速的[WinDbg/SOS 备忘单](http://geekswithblogs.net/.netonmymind/archive/2006/03/14/72262.aspx)( [webarchive](https://web.archive.org/web/20190325095634/http://geekswithblogs.net/.netonmymind/archive/2006/03/14/72262.aspx) )。
*   [如果它坏了，修复它你应该](http://blogs.msdn.com/tess/)有一堆与[WinDbg/Sos](http://blogs.msdn.com/tess/archive/2006/10/16/net-hang-debugging-walkthrough.aspx)相关的文章，主要是关于调试 ASP.NET。
*   [这](http://msdn.microsoft.com/en-us/magazine/cc164138.aspx)是来自 MSDN mag 的 SOS 的旧概述。它是关于 .NET 1.1 的，所以它的年龄正在显现。

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-09-23T09:11:03.780

您无需指定是在调试本机代码还是托管代码。它不影响答案，WinDbg 对两者都非常有用，但许多人认为 WinDbg 在调试 .NET 应用程序时的相关性较低。不是这样。作为奖励，您可以通过使用 SOS 扩展在 WinDbg 中调试您的 .NET 应用程序来了解很多关于 .NET 平台的工作原理。在 WinDbg 中运行（或附加到）您的 .NET 应用程序并键入...

```
.loadby sos mscorwks 
```

...确保为使用中的 CLR 版本加载正确的扩展。然后输入...

```
!help 
```

...查看 SOS 扩展中可用的命令。

我听有人开玩笑说微软只有一个开发工具，那就是 WinDbg。您可能想要进行调试的所有内容都在其中，或者在扩展中。当然，这些东西的一个子集也可以在具有更友好 UI 的 VS 中使用...... :-)

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-09-19T20:13:54.123

当我从 NT4.0 服务器发送 .dmp 文件时，我使用过它——MSVC 不会加载这些旧格式文件。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2009-02-11T07:21:10.317

混合内核调试和远程用户模式调试。

AFAIK，Visual Studio*仍然*无法在我描述为“解决方案”的模式下进行远程调试。这是使用windbg 的一个很好的理由。

问题：

*   跨 1394 设置 windbg。您的应用程序在“目标”上运行。Windbg 在“主机”上运行。
*   在主机上运行 Visual Studio
*   让 Visual Studio 使用远程工具在目标上启动您的应用程序。
*   闯入内核模式windbg以停止目标
*   等待足够长的时间让 Visual Studio 的 TCP 连接超时
*   windbg 中的“g”取消停止目标
*   当远程监视器意识到网络连接消失时，观察您的应用程序“弹出”
*   重新启动您的应用程序:(

解决方案：

*   不要使用视觉工作室。
*   使用“-server”在目标上运行用户模式windbg
*   让目标的 windbg 启动您的应用程序。
*   在主机上，启动第二个使用“-remote”连接到目标的windbg。
*   如果 TCP 连接中断，只需在主机上启动另一个 windbg 实例，不会丢失任何内容。您的应用程序没有死，因为控制用户模式的 windbg 进程正在目标上运行。

此外，我发现在内核模式和用户模式下使用相同的调试器更容易，windbg 即使在用户模式下也非常强大，而且我可以在内核模式和用户模式实例中利用我自己的 windbg 扩展。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-19T20:16:04.120

轻量级，无需安装在客户端机器上即可运行，速度快，可调试内核模式。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2009-02-11T07:24:05.990

最新的 Visual Studio 是否仍然缺少与 Windbg 的“-o”等效的功能，它使调试器自动附加到子进程？对于必须从复杂的 .bat 文件运行的应用程序或派生并退出父进程的应用程序非常有用。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2010-07-17T05:18:12.470

我一直很喜欢监视和跟踪功能：'wt' -> 它会在所有函数调用发生时将它们打印到输出窗口。那是很酷的东西！

# javascript - 我如何检查以确保窗口正在被积极使用，如果没有提醒最终用户他们即将被注销？

> ID：105147
> 
> 赞同：0
> 
> 时间：2008-09-19T20:13:57.463
> 
> 标签：javascript, session

为我的公司开发一个新的后端系统，他们的一个请求是锁定一个窗口，如果用户长时间闲置，则将其发送到登录屏幕。

我想我会通过将监听器附加到点击、鼠标移动和按键来使用 JavaScript 来做到这一点，但我担心会弄乱其他脚本。

有什么建议么？

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2008-09-19T20:18:18.623

如果用户在这么长时间后没有更改页面，您可以让它注销。这就是天使学习课件系统似乎要做的事情。

但是，您将面临的另一个问题是某些用户禁用了 JavaScript。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T20:24:27.920

如果您可以将代码放在页面上，那么有两件事：

*   查找鼠标移动、键盘活动和滚动的 Javascript。
*   在 html 中放置一个元刷新标签 - 如果他们在该页面上的时间超过 X 分钟，它将自动重定向到登录页面。

如果只能在服务器上放代码：

*   保留一个会话（cookie 或其他）来跟踪页面更改之间的时间间隔。如果自上次请求以来请求页面的时间超过 X 分钟，则不提供请求的页面，提供登录页面。

您可以一起使用元刷新和服务器技术。刷新后的页面会出现“您的会话即将到期，请点击此处返回并在 30 秒内继续工作”。

他们单击的按钮会重置您的服务器会话，并执行页面返回功能，因此他们拥有的任何数据（在大多数浏览器中）仍然存在。在刷新页面上需要 javascript，但在原始页面上不需要 - 只是元刷新。Javascript 活动跟踪将是最好的。

-亚当

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T20:24:49.917

在页面的加载事件中，您可以使用 setTimeout 触发一个函数，警告用户如果他们不刷新页面，他们将被注销。

使用 5 分钟会话超时，您可以在 4 分钟后发出警告：

```
setTimeout(timeoutWarning, 240000);

function timeoutWarning() {
  if(confirm('You have been idle for a while.  Would you like to remain logged in?'))
    window.location.refresh();
} 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-21T04:38:51.640

首先，要使其生效，您必须确保用户在此空闲时间结束时在服务器上注销。否则，您在客户端所做的任何事情都是无效的。如果您将他们发送到登录页面，他们只需单击后退按钮即可。

其次，执行此操作的常规方法是使用“元刷新”标签。将此添加到页面：

```
<meta http-equiv="refresh" content="900;url=http://example.com/login"/> 
```

将在 15 分钟（900 秒）后将它们发送到登录页面。即使他们在页面上做某事，这也会将他们发送到那里。它不检测活动。它只知道页面在浏览器中运行了多长时间。这通常已经足够好了，因为人们不需要 15 分钟来填写一个页面（我猜 stackoverflow.com 是一个明显的例外。）

如果您真的需要检测页面上的活动，那么我认为您的第一直觉是正确的。您将不得不为几件事添加事件处理程序。如果您担心为了验证或其他事情而弄乱其他脚本，您应该考虑以编程方式而不是内联方式添加事件处理程序。也就是说，而不是使用

```
<input type="text" onClick="doSomething;"> 
```

直接访问对象模型

```
Mozilla way:   element.addEventListener('click' ...)
Microsoft way: element.attachEvent('onclick' ...) 
```

然后确保在收到事件后传递事件，以便现有代码仍然执行它应该执行的任何操作（验证？）。

[http://www.quirksmode.org/js/introevents.html](http://www.quirksmode.org/js/introevents.html)有一篇关于如何做到这一点的文章。

--
bmb

# sql - 您如何处理数据库表的配置管理？

> ID：105174
> 
> 赞同：5
> 
> 时间：2008-09-19T20:16:32.590
> 
> 标签：sql, sql-server, database, tsql

您如何处理数据库表的源代码控制管理和自动化部署（配置管理）。我在 SQL Server 环境中工作，很容易为存储过程/触发器/函数甚至作业编写删除脚本和创建文件。处理创建新数据库表的脚本也很容易。但是，如果稍后您想修改该表，则不一定只删除它并使用新字段重新创建它，以免丢失数据。有没有一种自动化的方法来处理这个问题？您是否在更新新更改的表后编写临时表并回填？（如果有很多数据可能会很粗糙）

任何建议将不胜感激。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T21:21:02.917

Red-gate 的 SQL 比较等工具在确保您拥有完整的脚本方面非常有用。您仍然可能需要手动调整它以确保对象以正确的顺序编写脚本。确保编写触发器和约束等脚本以及表。通常，您将希望使用alter 命令而不是drop 和create，尤其是在表很大的情况下。

我们所有的表和函数以及存储的过程也需要在源代码控制下，所以如果需要我们可以返回旧版本。此外，我们的 dbas 会定期删除他们在 Source COntrol 中找不到的任何内容，以防止开发人员忘记这样做。

当然，所有升级到生产的开发脚本都应该首先在 QA 或登台服务器上运行，以确保脚本在 prod 上运行之前能够正常运行（并且不需要更改）。此外，还需要考虑在 prod 上运行的时间，您不想锁定用户，尤其是在繁忙时段，而且时间表明，在周五下午晚些时候将脚本加载到生产环境通常是个坏主意。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2012-12-21T11:09:23.630

我们在使用 Oracle DB 时也有类似的经历。我们建立了采用 SVN 和自动化脚本（从 SVN 中提取更改）以构建补丁的程序。有关详细信息，请参阅[http://www.scmsupport.com/scm.php?go=home.html](http://www.scmsupport.com/scm.php?go=home.html)和[http://scmsupport.wordpress.com/ 。](http://scmsupport.wordpress.com/)

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T20:21:46.243

有一些工具可以帮助您开发架构、开发更改、版本化这些更改，并帮助您比较版本之间的差异，甚至生成 SQL 以进行 DDL 更改。

例如，查看[Embarcadero Change Manager](http://www.embarcadero.com/products/changemanager/index.html "Embarcadero 变更经理")和 Embarcardero 提供的其他产品。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T20:24:26.813

您可以自动创建初始创建脚本，但 ALTER 脚本确实需要根据具体情况手动编码，因为实际上您需要在其中执行自定义操作。

在任何情况下，您都需要某种方法来为每个更改创建应用和回滚脚本，并拥有一个运行它们的安装程序脚本（当然还有一个回滚来回滚它们）。这样的安装程序可能应该记住架构所在的版本，并以正确的顺序运行所有必要的迁移。

在这里查看我的文章：

[http://marksverbiage.blogspot.com/2008/07/versioning-your-schema.html](http://marksverbiage.blogspot.com/2008/07/versioning-your-schema.html)

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T20:19:39.477

它会有所不同，具体取决于您希望如何处理现有数据以及架构更改的广泛程度，但即使在 Management Studio 中，在提交更改之前，您也可以生成所有更改的脚本。

对于大量数据或存在约束或外键的情况，即使是简单的 ALTER 操作也可能需要大量时间。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-19T21:23:24.440

哦忘了说，在将架构更改加载到生产环境之前，请确保您有一组良好的数据库备份。安全总比后悔好。

# ruby - Ruby Soap4R Web 服务，.NET 消费者

> ID：105177
> 
> 赞同：4
> 
> 时间：2008-09-19T20:16:36.240
> 
> 标签：ruby, web-services, soap4r

如何使用 .NET 使用的 Soap4R (SOAP::RPC::StandaloneServer) 从 Ruby 中的 Web 服务生成 WSDL？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-20T13:18:24.410

不幸的是，没有办法通过 SOAP4R 做到这一点。SOAP4R 更多地用于与 SOAP 端点交互，或者通过 WSDL 规范生成您自己的端点。

我知道这样做的唯一 Ruby 代码来自 ActionWebService，它是 Rails 的一部分，Rails 2 之前的版本。如果您安装 gem （很可能必须强制安装） ，`actionwebservice`您可以查看`to_wsdl`文件`lib/action_web_service/dispatcher/action_controller_dispatcher.rb`. 这将使用 Builder 库构建 WSDL。WSDL 的定义是使用`ActionWebService::API`. 将该代码提取到可用于项目的内容中应该不会太难。

# c# - 在 C# 中锁定

> ID：105198
> 
> 赞同：14
> 
> 时间：2008-09-19T20:19:01.273
> 
> 标签：c#, multithreading, concurrency, synchronization

我仍然有点不清楚什么时候在一些代码周围*加锁。*我的一般经验法则是在读取或写入静态变量时将操作包装在锁中。但是当一个静态变量只被读取时（例如，它是在类型初始化期间设置的只读），访问它不需要包含在锁定语句中，对吗？我最近看到一些类似于以下示例的代码，这让我觉得我的多线程知识可能存在一些差距：

```
class Foo
{
    private static readonly string bar = "O_o";

    private bool TrySomething()
    {
        string bar;

        lock(Foo.objectToLockOn)
        {
            bar = Foo.bar;          
        }       

        // Do something with bar
    }
} 
```

这对我来说没有意义——为什么会出现读取寄存器的并发问题？

此外，这个例子提出了另一个问题。其中一个比另一个更好吗？（例如，两个持有锁的时间更短？）我想我可以拆卸 MSIL ......

```
class Foo
{
    private static string joke = "yo momma";

    private string GetJoke()
    {
        lock(Foo.objectToLockOn)
        {
            return Foo.joke;
        }
    }
} 
```

对比

```
class Foo
{
    private static string joke = "yo momma";

        private string GetJoke()
        {
            string joke;

            lock(Foo.objectToLockOn)
            {
                joke = Foo.joke;
            }

            return joke;
        }
} 
```

* * *

## 回答 #1

> 赞同：23
> 
> 时间：2008-09-19T21:10:36.110

由于您编写的代码在初始化后都没有修改静态字段，因此不需要任何锁定。只需用新值替换字符串也不需要同步，除非新值取决于读取旧值的结果。

静态字段不是唯一需要同步的东西，任何可以修改的共享引用都容易受到同步问题的影响。

```
class Foo
{
    private int count = 0;
    public void TrySomething()    
    {
        count++;
    }
} 
```

您可能会认为执行 TrySomething 方法的两个线程会很好。但它不是。

1.  线程 A 将 count (0) 的值读入寄存器，以便递增。
2.  上下文切换！线程调度程序决定线程 A 有足够的执行时间。下一行是线程 B。
3.  线程 B 将 count (0) 的值读入寄存器。
4.  线程 B 递增寄存器。
5.  线程 B 将结果 (1) 保存到计数。
6.  上下文切换回 A。
7.  线程 A 使用保存在其堆栈中的 count (0) 值重新加载寄存器。
8.  线程 A 递增寄存器。
9.  线程 A 将结果 (1) 保存到计数。

因此，即使我们调用了 count++ 两次，count 的值也刚刚从 0 变为 1。让我们让代码线程安全：

```
class Foo
{
    private int count = 0;
    private readonly object sync = new object();
    public void TrySomething()    
    {
        lock(sync)
            count++;
    }
} 
```

现在，当线程 A 被中断时，线程 B 不能弄乱计数，因为它会命中 lock 语句然后阻塞，直到线程 A 释放同步。

顺便说一句，有另一种方法可以使递增 Int32s 和 Int64s 线程安全：

```
class Foo
{
    private int count = 0;
    public void TrySomething()    
    {
        System.Threading.Interlocked.Increment(ref count);
    }
} 
```

Regarding the second part of your question, I think I would just go with whichever is easier to read, any performance difference there will be negligible. Early optimisation is the root of all evil, etc.

[Why threading is hard](https://docs.microsoft.com/en-us/archive/blogs/jmstall/why-threading-is-hard)

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2008-09-19T20:24:58.683

读取或写入 32 位或更小的字段是 C# 中的原子操作。据我所知，您提供的代码不需要锁定。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-19T20:26:42.423

在我看来，在您的第一种情况下，锁是不必要的。使用静态初始化器来初始化 bar 保证是线程安全的。由于您只读取过该值，因此无需锁定它。如果值永远不会改变，就永远不会有任何争用，为什么要锁定呢？

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T20:21:04.420

如果您只是将值写入指针，则不需要锁定，因为该操作是原子的。通常，您应该在需要执行涉及至少两个原子操作（读取或写入）的事务时锁定任何时间，这些原子操作取决于状态在开始和结束之间不发生变化。

也就是说——我来自 Java 领域，所有变量的读取和写入都是原子操作。这里的其他答案表明.NET 是不同的。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-19T20:22:20.143

脏读？

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-19T20:24:59.980

在我看来，您应该非常努力地不要将静态变量放在需要从不同线程读取/写入它们的位置。在这种情况下，它们本质上是免费的全局变量，而全局变量几乎总是一件坏事。

话虽如此，如果您确实将静态变量放在这样的位置，您可能希望在读取期间锁定，以防万一 - 请记住，另一个线程可能在读取*期间*突然介入并更改了值，如果确实如此，您最终可能会收到损坏的数据。读取不一定是原子操作，除非您通过锁定确保它们。与写入相同 - 它们也不总是原子操作。

编辑：正如 Mark 指出的，对于 C# 中的某些原语读取总是原子的。但要小心其他数据类型。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T20:25:03.473

至于您的“哪个更好”的问题，它们是相同的，因为函数范围不用于其他任何事情。

# linux - 递归列出目录中的所有文件，包括符号链接目录中的文件

> ID：105212
> 
> 赞同：172
> 
> 时间：2008-09-19T20:20:32.360
> 
> 标签：linux

假设我有一个目录`/dir`，其中有 3 个指向其他目录的符号链接 `/dir/dir11`,`/dir/dir12`和`/dir/dir13`. 我想列出所有文件，包括`dir`和 中的文件。`dir11``dir12``dir13`

为了更通用，我想列出所有文件，包括目录中的符号链接文件。`find .`, `ls -R`, 等在符号链接处停止，而不导航到它们以进一步列出。

* * *

## 回答 #1

> 赞同：267
> 
> 时间：2008-09-19T20:23:23.290

`-L`选项将`ls`完成您想要的。它取消引用符号链接。

所以你的命令是：

```
ls -LR 
```

你也可以用

```
find -follow 
```

该`-follow`选项指示 find 遵循指向目录的符号链接。

在 Mac OS X 上使用

```
find -L 
```

已`-follow`被弃用。

* * *

## 回答 #2

> 赞同：121
> 
> 时间：2008-09-19T20:34:14.840

[树](http://mama.indstate.edu/users/ice/tree)呢？`tree -l`将遵循符号链接。

**免责声明**：我写了这个包。

* * *

## 回答 #3

> 赞同：53
> 
> 时间：2008-09-19T20:23:44.273

```
find /dir -type f -follow -print 
```

`-type f`意味着它将显示真实文件（不是符号链接）

`-follow`意味着它将遵循您的目录符号链接

`-print` 将导致它显示文件名。

如果你想要一个 ls 类型的显示，你可以执行以下操作

```
find /dir -type f -follow -print|xargs ls -l 
```

* * *

## 回答 #4

> 赞同：11
> 
> 时间：2008-09-19T20:23:33.913

使用 ls：

```
 ls -LR 
```

来自“男人 ls”：

```
 -L, --dereference
          when showing file information for a symbolic link, show informa‐
          tion  for  the file the link references rather than for the link
          itself 
```

或者，使用查找：

```
find -L . 
```

从查找手册页：

```
-L     Follow symbolic links. 
```

如果您发现您只想关注*一些*符号链接（可能只是您提到的顶级链接），您应该查看 -H 选项，它只关注您在命令行上传递给它的符号链接。

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2012-08-02T20:55:40.263

```
find -L /var/www/ -type l

# man find 
```

> ```
> -L     Follow  symbolic links.  When find examines or prints information about files, the information used shall be taken from the 
> ```
> 
> 链接指向的文件的属性，而不是链接本身（除非它是损坏的符号链接或 find 无法检查链接指向的文件）。使用此选项意味着 -noleaf。如果您稍后使用 -P 选项，-noleaf 仍将有效。如果 -L 有效并且 find 在其搜索过程中发现了指向子目录的符号链接，则将搜索符号链接指向的子目录。

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2014-07-31T12:55:14.763

我知道`tree`是合适的，但我没有安装树。所以，我在[这里有一个非常接近的替代品](http://systembash.com/content/one-line-linux-command-to-print-out-directory-tree-listing/)

```
find ./ | sed -e 's/[^-][^\/]*\//--/g;s/--/ |-/' 
```

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-19T20:23:59.997

```
ls -R -L 
```

`-L`取消引用符号链接。不过，这也将导致无法看到文件的任何符号链接 - 它们看起来像指向的文件。

* * *

## 回答 #8

> 赞同：-1
> 
> 时间：2018-07-27T16:32:50.173

如果您想打印所有文件**内容**： `find . -type f -exec cat {} +`

# language-agnostic - 什么开源 CMS：生成干净的 xhtml，可以用 css 换肤，并且有一个轻量级的标记内容编辑器？

> ID：105223
> 
> 赞同：3
> 
> 时间：2008-09-19T20:21:20.863
> 
> 标签：language-agnostic, content-management-system

见标题。我所说的轻量级标记是指markdown 或wikitext 之类的东西。

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-09-19T20:54:24.497

好吧，silverstripe [http://www.silverstripe.com/](http://www.silverstripe.com/)被认为是关心网络标准的人的好选择，modx [http://modxcms.com/也是如此](http://modxcms.com/)

对于更轻量级的编辑器，请查看使用纺织品（如降价）的 textpattern.com。如果你在 Rails 上，[http://webby.rubyforge.org/](http://webby.rubyforge.org/)可能会成功。

[http://www.madebyfrog.com](http://www.madebyfrog.com)是 ruby​​ CMS radiant 的一个端口，旨在快速、轻便和最小化。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-21T13:48:27.653

[WordPress](http://wordpress.org)越来越好。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-11-04T06:03:34.030

我爱[modx](http://modxcms.com)。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-11-08T01:31:44.267

我是 Joomla 的用户。我认为 Joomla 是前五名的 CMS。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2009-02-13T08:09:20.697

我喜欢[Radiant CMS](http://radiantcms.org/)。简单，易于使用且灵活，并且集成了降价过滤器。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2009-02-13T08:11:27.323

[Umbraco](http://umbraco.org/) asp.net c# cms

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2009-07-08T18:32:18.090

[Plone](http://plone.org)满足所有这些要求，尽管使用降价是不寻常的。（Zope底层平台肯定是支持markdown的，但是在Plone用户界面中，更常用的是Kupu编辑器）

编辑：自从我写了之后，事情发生了变化。Plone 仍然支持[Kupu](http://www.tinymce.com/)，但是现在你也可以选择使用[tinymce](http://plone.org)作为你的标记编辑器。

# c++ - 如何在 C++ 中的大端和小端值之间进行转换？

> ID：105252
> 
> 赞同：234
> 
> 时间：2008-09-19T20:23:36.363
> 
> 标签：c++, endianness

如何在 C++ 中的大端和小端值之间进行转换？

为清楚起见，我必须将二进制数据（双精度浮点值以及 32 位和 64 位整数）从一种 CPU 架构转换为另一种。这不涉及网络，因此 ntoh() 和类似的功能在这里不起作用。

* * *

注意：我接受的答案直接适用于我所针对的编译器（这就是我选择它的原因）。但是，这里还有其他非常好的、更便携的答案。

* * *

## 回答 #1

> 赞同：200
> 
> 时间：2008-09-19T20:31:38.887

如果您使用**Visual C++**，请执行以下操作：包含 intrin.h 并调用以下函数：

对于 16 位数字：

```
unsigned short _byteswap_ushort(unsigned short value); 
```

对于 32 位数字：

```
unsigned long _byteswap_ulong(unsigned long value); 
```

对于 64 位数字：

```
unsigned __int64 _byteswap_uint64(unsigned __int64 value); 
```

8 位数字（字符）不需要转换。

此外，这些仅针对无符号值定义，它们也适用于有符号整数。

对于浮点数和双精度数，与普通整数一样困难，因为它们可能会或不会在主机字节顺序中。您可以在大端机器上获得小端浮点数，反之亦然。

其他编译器也有类似的内在函数。

例如，在**GCC**中，您可以直接调用[此处记录的一些内置](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html)函数：

```
uint32_t __builtin_bswap32 (uint32_t x)
uint64_t __builtin_bswap64 (uint64_t x) 
```

（无需包含某些内容）。Afaik bits.h 也以非 gcc 为中心的方式声明了相同的函数。

16位交换它只是一个位旋转。

调用内部函数而不是自己滚动可以为您提供最佳性能和代码密度顺便说一句..

* * *

## 回答 #2

> 赞同：102
> 
> 时间：2011-02-10T11:27:13.820

简单的说：

```
#include <climits>

template <typename T>
T swap_endian(T u)
{
    static_assert (CHAR_BIT == 8, "CHAR_BIT != 8");

    union
    {
        T u;
        unsigned char u8[sizeof(T)];
    } source, dest;

    source.u = u;

    for (size_t k = 0; k < sizeof(T); k++)
        dest.u8[k] = source.u8[sizeof(T) - k - 1];

    return dest.u;
} 
```

用法：`swap_endian<uint32_t>(42)`。

* * *

## 回答 #3

> 赞同：86
> 
> 时间：2012-04-27T06:51:22.537

来自Rob Pike**[的字节顺序谬误](http://commandcenter.blogspot.fr/2012/04/byte-order-fallacy.html)**：

> 假设您的数据流有一个小端编码的 32 位整数。以下是如何提取它（假设无符号字节）：

```
i = (data[0]<<0) | (data[1]<<8) | (data[2]<<16) | (data[3]<<24); 
```

> 如果它是大端的，这里是如何提取它：

```
i = (data[3]<<0) | (data[2]<<8) | (data[1]<<16) | (data[0]<<24); 
```

**TL;DR：**不要担心您的平台本机顺序，重要的是您正在读取的流的字节顺序，您最好希望它定义明确。

*注意：在注释中指出，如果没有显式类型转换，重要的是要成为or`data`的数组。使用或（如果有符号）将导致被提升为整数并可能将 1 移入符号位，即 UB。`unsigned char``uint8_t``signed char``char``data[x]``data[x] << 24`*

* * *

## 回答 #4

> 赞同：59
> 
> 时间：2008-09-19T20:38:18.090

如果您出于网络/主机兼容性的目的这样做，您应该使用：

```
ntohl() //Network to Host byte order (Long)
htonl() //Host to Network byte order (Long)

ntohs() //Network to Host byte order (Short)
htons() //Host to Network byte order (Short) 
```

如果您出于其他原因这样做，这里介绍的 byte_swap 解决方案之一可以正常工作。

* * *

## 回答 #5

> 赞同：28
> 
> 时间：2010-08-19T14:36:13.650

我从这篇文章中得到了一些建议，并将它们组合在一起形成了这个：

```
#include <boost/type_traits.hpp>
#include <boost/static_assert.hpp>
#include <boost/detail/endian.hpp>
#include <stdexcept>
#include <cstdint>

enum endianness
{
    little_endian,
    big_endian,
    network_endian = big_endian,

    #if defined(BOOST_LITTLE_ENDIAN)
        host_endian = little_endian
    #elif defined(BOOST_BIG_ENDIAN)
        host_endian = big_endian
    #else
        #error "unable to determine system endianness"
    #endif
};

namespace detail {

template<typename T, size_t sz>
struct swap_bytes
{
    inline T operator()(T val)
    {
        throw std::out_of_range("data size");
    }
};

template<typename T>
struct swap_bytes<T, 1>
{
    inline T operator()(T val)
    {
        return val;
    }
};

template<typename T>
struct swap_bytes<T, 2>
{
    inline T operator()(T val)
    {
        return ((((val) >> 8) & 0xff) | (((val) & 0xff) << 8));
    }
};

template<typename T>
struct swap_bytes<T, 4>
{
    inline T operator()(T val)
    {
        return ((((val) & 0xff000000) >> 24) |
                (((val) & 0x00ff0000) >>  8) |
                (((val) & 0x0000ff00) <<  8) |
                (((val) & 0x000000ff) << 24));
    }
};

template<>
struct swap_bytes<float, 4>
{
    inline float operator()(float val)
    {
        uint32_t mem =swap_bytes<uint32_t, sizeof(uint32_t)>()(*(uint32_t*)&val);
        return *(float*)&mem;
    }
};

template<typename T>
struct swap_bytes<T, 8>
{
    inline T operator()(T val)
    {
        return ((((val) & 0xff00000000000000ull) >> 56) |
                (((val) & 0x00ff000000000000ull) >> 40) |
                (((val) & 0x0000ff0000000000ull) >> 24) |
                (((val) & 0x000000ff00000000ull) >> 8 ) |
                (((val) & 0x00000000ff000000ull) << 8 ) |
                (((val) & 0x0000000000ff0000ull) << 24) |
                (((val) & 0x000000000000ff00ull) << 40) |
                (((val) & 0x00000000000000ffull) << 56));
    }
};

template<>
struct swap_bytes<double, 8>
{
    inline double operator()(double val)
    {
        uint64_t mem =swap_bytes<uint64_t, sizeof(uint64_t)>()(*(uint64_t*)&val);
        return *(double*)&mem;
    }
};

template<endianness from, endianness to, class T>
struct do_byte_swap
{
    inline T operator()(T value)
    {
        return swap_bytes<T, sizeof(T)>()(value);
    }
};
// specialisations when attempting to swap to the same endianess
template<class T> struct do_byte_swap<little_endian, little_endian, T> { inline T operator()(T value) { return value; } };
template<class T> struct do_byte_swap<big_endian,    big_endian,    T> { inline T operator()(T value) { return value; } };

} // namespace detail

template<endianness from, endianness to, class T>
inline T byte_swap(T value)
{
    // ensure the data is only 1, 2, 4 or 8 bytes
    BOOST_STATIC_ASSERT(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8);
    // ensure we're only swapping arithmetic types
    BOOST_STATIC_ASSERT(boost::is_arithmetic<T>::value);

    return detail::do_byte_swap<from, to, T>()(value);
} 
```

然后，您将按如下方式使用它：

```
// swaps val from host-byte-order to network-byte-order
auto swapped = byte_swap<host_endian, network_endian>(val); 
```

反之亦然

```
// swap a value received from the network into host-byte-order
auto val = byte_swap<network_endian, host_endian>(val_from_network); 
```

* * *

## 回答 #6

> 赞同：17
> 
> 时间：2008-09-19T20:31:54.567

从大端到小端的过程与从小端到大端的过程相同。

这是一些示例代码：

```
void swapByteOrder(unsigned short& us)
{
    us = (us >> 8) |
         (us << 8);
}

void swapByteOrder(unsigned int& ui)
{
    ui = (ui >> 24) |
         ((ui<<8) & 0x00FF0000) |
         ((ui>>8) & 0x0000FF00) |
         (ui << 24);
}

void swapByteOrder(unsigned long long& ull)
{
    ull = (ull >> 56) |
          ((ull<<40) & 0x00FF000000000000) |
          ((ull<<24) & 0x0000FF0000000000) |
          ((ull<<8) & 0x000000FF00000000) |
          ((ull>>8) & 0x00000000FF000000) |
          ((ull>>24) & 0x0000000000FF0000) |
          ((ull>>40) & 0x000000000000FF00) |
          (ull << 56);
} 
```

* * *

## 回答 #7

> 赞同：16
> 
> 时间：2008-09-19T20:34:46.913

有一个名为 BSWAP 的汇编指令会为您进行交换，*速度非常快*。你可以在[这里](http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-1.html#HEADING1-291)阅读。

Visual Studio，或更准确地说是 Visual C++ 运行时库，为此具有平台内在函数，称为`_byteswap_ushort(), _byteswap_ulong(), and _byteswap_int64()`. 其他平台也应该存在类似的情况，但我不知道它们会被称为什么。

* * *

## 回答 #8

> 赞同：12
> 
> 时间：2008-09-19T20:29:23.433

我们已经使用模板完成了这项工作。你可以这样做：

```
// Specialization for 2-byte types.
template<>
inline void endian_byte_swapper< 2 >(char* dest, char const* src)
{
    // Use bit manipulations instead of accessing individual bytes from memory, much faster.
    ushort* p_dest = reinterpret_cast< ushort* >(dest);
    ushort const* const p_src = reinterpret_cast< ushort const* >(src);
    *p_dest = (*p_src >> 8) | (*p_src << 8);
}

// Specialization for 4-byte types.
template<>
inline void endian_byte_swapper< 4 >(char* dest, char const* src)
{
    // Use bit manipulations instead of accessing individual bytes from memory, much faster.
    uint* p_dest = reinterpret_cast< uint* >(dest);
    uint const* const p_src = reinterpret_cast< uint const* >(src);
    *p_dest = (*p_src >> 24) | ((*p_src & 0x00ff0000) >> 8) | ((*p_src & 0x0000ff00) << 8) | (*p_src << 24);
} 
```

* * *

## 回答 #9

> 赞同：8
> 
> 时间：2008-09-19T20:26:48.197

如果您这样做是为了在不同平台之间传输数据，请查看 ntoh 和 hton 函数。

* * *

## 回答 #10

> 赞同：8
> 
> 时间：2008-09-19T20:30:07.517

与您在 C 中执行的方式相同：

```
short big = 0xdead;
short little = (((big & 0xff)<<8) | ((big & 0xff00)>>8)); 
```

您还可以声明一个无符号字符向量，将输入值 memcpy 到其中，将字节反转为另一个向量并将字节 memcpy 出来，但这将比位旋转要长几个数量级，尤其是对于 64 位值。

* * *

## 回答 #11

> 赞同：8
> 
> 时间：2008-09-19T20:33:14.327

在大多数 POSIX 系统上（通过它不在 POSIX 标准中）都有 endian.h，它可以用来确定您的系统使用什么编码。从那里开始是这样的：

```
unsigned int change_endian(unsigned int x)
{
    unsigned char *ptr = (unsigned char *)&x;
    return (ptr[0] << 24) | (ptr[1] << 16) | (ptr[2] << 8) | ptr[3];
} 
```

这交换了顺序（从大端到小端）：

如果您有数字 0xDEADBEEF（在存储为 0xEFBEADDE 的小端系统上），ptr[0] 将为 0xEF，ptr[1] 为 0xBE，等等。

但是如果你想将它用于网络，那么 htons、htonl 和 htonll（以及它们的倒数 ntohs、ntohl 和 ntohll）将有助于从主机顺序转换为网络顺序。

* * *

## 回答 #12

> 赞同：7
> 
> 时间：2013-08-20T10:45:38.080

请注意，至少对于 Windows，htonl() 比它们固有的对应 _byteswap_ulong() 慢得多。前者是对ws2_32.dll 的DLL 库调用，后者是一条BSWAP 汇编指令。因此，如果您正在编写一些依赖于平台的代码，则更喜欢使用内部函数来提高速度：

```
#define htonl(x) _byteswap_ulong(x) 
```

这对于 .PNG 图像处理可能特别重要，其中所有整数都保存在 Big Endian 中，并说明“可以使用 htonl()...”{如果您没有准备好，可以减慢典型的 Windows 程序的速度}。

* * *

## 回答 #13

> 赞同：5
> 
> 时间：2011-02-10T12:02:30.463

大多数平台都有一个提供高效字节交换功能的系统头文件。在 Linux 上，它位于`<endian.h>`. 你可以用 C++ 很好地包装它：

```
#include <iostream>

#include <endian.h>

template<size_t N> struct SizeT {};

#define BYTESWAPS(bits) \
template<class T> inline T htobe(T t, SizeT<bits / 8>) { return htobe ## bits(t); } \
template<class T> inline T htole(T t, SizeT<bits / 8>) { return htole ## bits(t); } \
template<class T> inline T betoh(T t, SizeT<bits / 8>) { return be ## bits ## toh(t); } \
template<class T> inline T letoh(T t, SizeT<bits / 8>) { return le ## bits ## toh(t); }

BYTESWAPS(16)
BYTESWAPS(32)
BYTESWAPS(64)

#undef BYTESWAPS

template<class T> inline T htobe(T t) { return htobe(t, SizeT<sizeof t>()); }
template<class T> inline T htole(T t) { return htole(t, SizeT<sizeof t>()); }
template<class T> inline T betoh(T t) { return betoh(t, SizeT<sizeof t>()); }
template<class T> inline T letoh(T t) { return letoh(t, SizeT<sizeof t>()); }

int main()
{
    std::cout << std::hex;
    std::cout << htobe(static_cast<unsigned short>(0xfeca)) << '\n';
    std::cout << htobe(0xafbeadde) << '\n';

    // Use ULL suffix to specify integer constant as unsigned long long 
    std::cout << htobe(0xfecaefbeafdeedfeULL) << '\n';
} 
```

输出：

```
cafe
deadbeaf
feeddeafbeefcafe 
```

* * *

## 回答 #14

> 赞同：5
> 
> 时间：2014-08-07T08:07:29.387

说真的......我不明白为什么所有的解决方案都那么***复杂***！**在任何操作系统中的任何情况下交换任何类型的任何大小的最简单、最通用的模板函数怎么样？？？？**

```
template <typename T>
void SwapEnd(T& var)
{
    static_assert(std::is_pod<T>::value, "Type must be POD type for safety");
    std::array<char, sizeof(T)> varArray;
    std::memcpy(varArray.data(), &var, sizeof(T));
    for(int i = 0; i < static_cast<int>(sizeof(var)/2); i++)
        std::swap(varArray[sizeof(var) - 1 - i],varArray[i]);
    std::memcpy(&var, varArray.data(), sizeof(T));
} 
```

这就是 C 和 C++ 的魔力！只需逐个字符交换原始变量。

**第 1 点**：无运算符：请记住，我没有使用简单的赋值运算符“=”，因为当翻转字节序时某些对象会被弄乱，并且复制构造函数（或赋值运算符）将不起作用。因此，逐个字符地复制它们更可靠。

**第 2 点**：注意对齐问题：请注意，我们正在向数组复制和从数组复制，这是正确的做法，因为 C++ 编译器不保证我们可以访问未对齐的内存（此答案已从其原始更新为此的形式）。例如，如果你 allocate `uint64_t`，你的编译器不能保证你可以访问它的第 3 个字节作为`uint8_t`. 因此，正确的做法是将其复制到 char 数组，交换它，然后将其复制回来（所以 no `reinterpret_cast`）。`reinterpret_cast`请注意，如果编译器能够访问单个字节而不管对齐方式，编译器大多足够聪明，可以将您所做的转换回 a 。

**要使用此功能**：

```
double x = 5;
SwapEnd(x); 
```

现在`x`在字节序上有所不同。

* * *

## 回答 #15

> 赞同：4
> 
> 时间：2008-09-20T04:25:11.150

我有这段代码允许我从 HOST_ENDIAN_ORDER（不管它是什么）转换为 LITTLE_ENDIAN_ORDER 或 BIG_ENDIAN_ORDER。我使用模板，所以如果我尝试从 HOST_ENDIAN_ORDER 转换为 LITTLE_ENDIAN_ORDER 并且它们恰好与我编译的机器相同，则不会生成任何代码。

这是带有一些注释的代码：

```
// We define some constant for little, big and host endianess. Here I use 
// BOOST_LITTLE_ENDIAN/BOOST_BIG_ENDIAN to check the host indianess. If you
// don't want to use boost you will have to modify this part a bit.
enum EEndian
{
  LITTLE_ENDIAN_ORDER,
  BIG_ENDIAN_ORDER,
#if defined(BOOST_LITTLE_ENDIAN)
  HOST_ENDIAN_ORDER = LITTLE_ENDIAN_ORDER
#elif defined(BOOST_BIG_ENDIAN)
  HOST_ENDIAN_ORDER = BIG_ENDIAN_ORDER
#else
#error "Impossible de determiner l'indianness du systeme cible."
#endif
};

// this function swap the bytes of values given it's size as a template
// parameter (could sizeof be used?).
template <class T, unsigned int size>
inline T SwapBytes(T value)
{
  union
  {
     T value;
     char bytes[size];
  } in, out;

  in.value = value;

  for (unsigned int i = 0; i < size / 2; ++i)
  {
     out.bytes[i] = in.bytes[size - 1 - i];
     out.bytes[size - 1 - i] = in.bytes[i];
  }

  return out.value;
}

// Here is the function you will use. Again there is two compile-time assertion
// that use the boost librarie. You could probably comment them out, but if you
// do be cautious not to use this function for anything else than integers
// types. This function need to be calles like this :
//
//     int x = someValue;
//     int i = EndianSwapBytes<HOST_ENDIAN_ORDER, BIG_ENDIAN_ORDER>(x);
//
template<EEndian from, EEndian to, class T>
inline T EndianSwapBytes(T value)
{
  // A : La donnée à swapper à une taille de 2, 4 ou 8 octets
  BOOST_STATIC_ASSERT(sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8);

  // A : La donnée à swapper est d'un type arithmetic
  BOOST_STATIC_ASSERT(boost::is_arithmetic<T>::value);

  // Si from et to sont du même type on ne swap pas.
  if (from == to)
     return value;

  return SwapBytes<T, sizeof(T)>(value);
} 
```

* * *

## 回答 #16

> 赞同：3
> 
> 时间：2011-06-26T22:13:17.547

我喜欢这个，只是为了风格:-)

```
long swap(long i) {
    char *c = (char *) &i;
    return * (long *) (char[]) {c[3], c[2], c[1], c[0] };
} 
```

* * *

## 回答 #17

> 赞同：3
> 
> 时间：2014-09-06T21:06:09.760

如果一个大端序的 32 位无符号整数看起来像等于 2864434397 的 0xAABBCCDD，那么同样的 32 位无符号整数在一个也等于 2864434397 的小端序处理器上看起来像 0xDDCCBBAA。

如果一个 big-endian 16 位 unsigned short 看起来像等于 43707 的 0xAABB，那么同样的 16 位 unsigned short 在一个也等于 43707 的 little-endian 处理器上看起来像 0xBBAA。

这里有几个方便的#define 函数可以将字节从小端交换到大端，反之亦然 -->

```
// can be used for short, unsigned short, word, unsigned word (2-byte types)
#define BYTESWAP16(n) (((n&0xFF00)>>8)|((n&0x00FF)<<8))

// can be used for int or unsigned int or float (4-byte types)
#define BYTESWAP32(n) ((BYTESWAP16((n&0xFFFF0000)>>16))|((BYTESWAP16(n&0x0000FFFF))<<16))

// can be used for unsigned long long or double (8-byte types)
#define BYTESWAP64(n) ((BYTESWAP32((n&0xFFFFFFFF00000000)>>32))|((BYTESWAP32(n&0x00000000FFFFFFFF))<<32)) 
```

* * *

## 回答 #18

> 赞同：3
> 
> 时间：2016-01-29T19:30:25.850

只是想我在这里添加了自己的解决方案，因为我在任何地方都没有看到它。它是一个小型且可移植的 C++ 模板化函数，可移植，仅使用位操作。

```
template<typename T> inline static T swapByteOrder(const T& val) {
    int totalBytes = sizeof(val);
    T swapped = (T) 0;
    for (int i = 0; i < totalBytes; ++i) {
        swapped |= (val >> (8*(totalBytes-i-1)) & 0xFF) << (8*i);
    }
    return swapped;
} 
```

* * *

## 回答 #19

> 赞同：2
> 
> 时间：2008-09-19T21:07:01.627

这是我想出的一个通用版本，用于交换适当的值。如果性能有问题，其他建议会更好。

```
 template<typename T>
    void ByteSwap(T * p)
    {
        for (int i = 0;  i < sizeof(T)/2;  ++i)
            std::swap(((char *)p)[i], ((char *)p)[sizeof(T)-1-i]);
    } 
```

**免责声明：**我还没有尝试编译或测试它。

* * *

## 回答 #20

> 赞同：2
> 
> 时间：2013-08-20T11:45:02.260

如果您采用通用模式来反转单词中的位顺序，并剔除反转每个字节中位的部分，那么您将得到仅反转单词中字节的部分。对于 64 位：

```
x = ((x & 0x00000000ffffffff) << 32) ^ ((x >> 32) & 0x00000000ffffffff);
x = ((x & 0x0000ffff0000ffff) << 16) ^ ((x >> 16) & 0x0000ffff0000ffff);
x = ((x & 0x00ff00ff00ff00ff) <<  8) ^ ((x >>  8) & 0x00ff00ff00ff00ff); 
```

编译器*应该*清除多余的位屏蔽操作（我将它们保留以突出显示模式），但如果没有，您可以这样重写第一行：

```
x = ( x                       << 32) ^  (x >> 32); 
```

在大多数架构上，这通常应该简化为一条循环指令（忽略整个操作可能是一条指令）。

在 RISC 处理器上，大而复杂的常量可能会导致编译器困难。不过，您可以从前一个常数中轻松计算出每个常数。像这样：

```
uint64_t k = 0x00000000ffffffff; /* compiler should know a trick for this */
x = ((x & k) << 32) ^ ((x >> 32) & k);
k ^= k << 16;
x = ((x & k) << 16) ^ ((x >> 16) & k);
k ^= k << 8;
x = ((x & k) <<  8) ^ ((x >>  8) & k); 
```

如果你愿意，你可以把它写成一个循环。它不会有效率，但只是为了好玩：

```
int i = sizeof(x) * CHAR_BIT / 2;
uintmax_t k = (1 << i) - 1;
while (i >= 8)
{
    x = ((x & k) << i) ^ ((x >> i) & k);
    i >>= 1;
    k ^= k << i;
} 
```

为了完整起见，这里是第一种形式的简化 32 位版本：

```
x = ( x               << 16) ^  (x >> 16);
x = ((x & 0x00ff00ff) <<  8) ^ ((x >>  8) & 0x00ff00ff); 
```

* * *

## 回答 #21

> 赞同：2
> 
> 时间：2014-09-24T01:47:38.117

哇，我简直不敢相信我在这里读到的一些答案。实际上，汇编中有一条指令比其他任何指令都快。交换。你可以简单地写一个这样的函数......

```
__declspec(naked) uint32_t EndianSwap(uint32 value)
{
    __asm
    {
        mov eax, dword ptr[esp + 4]
        bswap eax
        ret
    }
} 
```

它比建议的内在函数快得多*。*我把它们拆开看了看。上述功能没有序言/尾声，因此几乎没有任何开销。

```
unsigned long _byteswap_ulong(unsigned long value); 
```

做 16 位同样容易，除了你会使用 xchg al，啊。bswap 仅适用于 32 位寄存器。

64 位有点棘手，但并不过分。比上面所有带有循环和模板等的示例要好得多。

这里有一些注意事项...首先 bswap 仅适用于 80x486 CPU 及更高版本。有人打算在 386 上运行它吗？！？如果是这样，您仍然可以将 bswap 替换为...

```
mov ebx, eax
shr ebx, 16
xchg al, ah
xchg bl, bh
shl eax, 16
or eax, ebx 
```

此外，内联汇编仅在 Visual Studio 的 x86 代码中可用。裸函数不能被衬里，并且在 x64 版本中也不可用。在那个实例中，您将不得不使用编译器内在函数。

* * *

## 回答 #22

> 赞同：2
> 
> 时间：2016-09-17T15:58:44.057

使用下面的代码，您可以轻松地在 BigEndian 和 LittleEndian 之间进行切换

```
#define uint32_t unsigned 
#define uint16_t unsigned short

#define swap16(x) ((((uint16_t)(x) & 0x00ff)<<8)| \
(((uint16_t)(x) & 0xff00)>>8))

#define swap32(x) ((((uint32_t)(x) & 0x000000ff)<<24)| \
(((uint32_t)(x) & 0x0000ff00)<<8)| \
(((uint32_t)(x) & 0x00ff0000)>>8)| \
(((uint32_t)(x) & 0xff000000)>>24)) 
```

* * *

## 回答 #23

> 赞同：2
> 
> 时间：2017-05-11T19:15:28.647

我真的很惊讶没有人提到 htobeXX 和 betohXX 功能。它们在 endian.h 中定义，与网络函数 htonXX 非常相似。

* * *

## 回答 #24

> 赞同：1
> 
> 时间：2016-12-17T07:15:36.217

我最近在 C 中编写了一个宏来执行此操作，但它在 C++ 中同样有效：

```
#define REVERSE_BYTES(...) do for(size_t REVERSE_BYTES=0; REVERSE_BYTES<sizeof(__VA_ARGS__)>>1; ++REVERSE_BYTES)\
    ((unsigned char*)&(__VA_ARGS__))[REVERSE_BYTES] ^= ((unsigned char*)&(__VA_ARGS__))[sizeof(__VA_ARGS__)-1-REVERSE_BYTES],\
    ((unsigned char*)&(__VA_ARGS__))[sizeof(__VA_ARGS__)-1-REVERSE_BYTES] ^= ((unsigned char*)&(__VA_ARGS__))[REVERSE_BYTES],\
    ((unsigned char*)&(__VA_ARGS__))[REVERSE_BYTES] ^= ((unsigned char*)&(__VA_ARGS__))[sizeof(__VA_ARGS__)-1-REVERSE_BYTES];\
while(0) 
```

它接受任何类型并反转传递参数中的字节。示例用法：

```
int main(){
    unsigned long long x = 0xABCDEF0123456789;
    printf("Before: %llX\n",x);
    REVERSE_BYTES(x);
    printf("After : %llX\n",x);

    char c[7]="nametag";
    printf("Before: %c%c%c%c%c%c%c\n",c[0],c[1],c[2],c[3],c[4],c[5],c[6]);
    REVERSE_BYTES(c);
    printf("After : %c%c%c%c%c%c%c\n",c[0],c[1],c[2],c[3],c[4],c[5],c[6]);
} 
```

哪个打印：

```
Before: ABCDEF0123456789
After : 8967452301EFCDAB
Before: nametag
After : gateman 
```

以上是完全可以复制/粘贴的，但是这里有很多事情要做，所以我将逐个分解它是如何工作的：

首先值得注意的是整个宏被封装在一个`do while(0)`块中。这是一个[常见的习惯用法](https://gcc.gnu.org/onlinedocs/cpp/Swallowing-the-Semicolon.html)，允许在宏之后使用正常的分号。

接下来是使用一个名为`REVERSE_BYTES`循环`for`计数器的变量。宏本身的名称用作变量名称，以确保它不会与使用宏的范围内可能存在的任何其他符号冲突。由于该名称在宏的扩展中使用，因此在此处用作变量名时不会再次扩展。

在`for`循环中，有两个字节被引用和[异或交换](https://en.wikipedia.org/wiki/XOR_swap_algorithm)（因此不需要临时变量名）：

```
((unsigned char*)&(__VA_ARGS__))[REVERSE_BYTES]
((unsigned char*)&(__VA_ARGS__))[sizeof(__VA_ARGS__)-1-REVERSE_BYTES] 
```

[`__VA_ARGS__`](https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html)表示赋予宏的任何内容，并用于增加可能传入的内容的灵活性（尽管幅度不大）。然后获取该参数的地址并将其转换为一个`unsigned char`指针，以允许通过数组`[]`下标交换其字节。

最后一个特殊点是没有`{}`大括号。它们不是必需的，因为每个交换中的所有步骤都与[逗号运算符](https://en.wikipedia.org/wiki/Comma_operator)连接，使它们成为一个语句。

最后，值得注意的是，如果速度是重中之重，这不是理想的方法。如果这是一个重要因素，那么其他答案中引用的某些特定于类型的宏或特定于平台的指令可能是更好的选择。然而，这种方法可移植到所有类型、所有主要平台以及 C 和 C++ 语言。

* * *

## 回答 #25

> 赞同：1
> 
> 时间：2020-04-10T18:42:59.707

如果您有 C++ 17，则添加此标头

```
#include <algorithm> 
```

使用此模板函数交换字节：

```
template <typename T>
void swapEndian(T& buffer)
{
    static_assert(std::is_pod<T>::value, "swapEndian support POD type only");
    char* startIndex = static_cast<char*>((void*)buffer.data());
    char* endIndex = startIndex + sizeof(buffer);
    std::reverse(startIndex, endIndex);
} 
```

像这样称呼它：

```
swapEndian (stlContainer); 
```

* * *

## 回答 #26

> 赞同：0
> 
> 时间：2016-05-23T08:47:44.067

用于实现优化器友好的未对齐非就地字节序访问器的便携式技术。它们适用于每个编译器、每个边界对齐和每个字节排序。根据本机字节序和对齐方式，对这些未对齐的例程进行补充或讨论。部分上市，但你明白了。BO* 是基于本机字节顺序的常量值。

```
uint32_t sw_get_uint32_1234(pu32)
uint32_1234 *pu32;
{
  union {
    uint32_1234 u32_1234;
    uint32_t u32;
  } bou32;
  bou32.u32_1234[0] = (*pu32)[BO32_0];
  bou32.u32_1234[1] = (*pu32)[BO32_1];
  bou32.u32_1234[2] = (*pu32)[BO32_2];
  bou32.u32_1234[3] = (*pu32)[BO32_3];
  return(bou32.u32);
}

void sw_set_uint32_1234(pu32, u32)
uint32_1234 *pu32;
uint32_t u32;
{
  union {
    uint32_1234 u32_1234;
    uint32_t u32;
  } bou32;
  bou32.u32 = u32;
  (*pu32)[BO32_0] = bou32.u32_1234[0];
  (*pu32)[BO32_1] = bou32.u32_1234[1];
  (*pu32)[BO32_2] = bou32.u32_1234[2];
  (*pu32)[BO32_3] = bou32.u32_1234[3];
}

#if HAS_SW_INT64
int64 sw_get_int64_12345678(pi64)
int64_12345678 *pi64;
{
  union {
    int64_12345678 i64_12345678;
    int64 i64;
  } boi64;
  boi64.i64_12345678[0] = (*pi64)[BO64_0];
  boi64.i64_12345678[1] = (*pi64)[BO64_1];
  boi64.i64_12345678[2] = (*pi64)[BO64_2];
  boi64.i64_12345678[3] = (*pi64)[BO64_3];
  boi64.i64_12345678[4] = (*pi64)[BO64_4];
  boi64.i64_12345678[5] = (*pi64)[BO64_5];
  boi64.i64_12345678[6] = (*pi64)[BO64_6];
  boi64.i64_12345678[7] = (*pi64)[BO64_7];
  return(boi64.i64);
}
#endif

int32_t sw_get_int32_3412(pi32)
int32_3412 *pi32;
{
  union {
    int32_3412 i32_3412;
    int32_t i32;
  } boi32;
  boi32.i32_3412[2] = (*pi32)[BO32_0];
  boi32.i32_3412[3] = (*pi32)[BO32_1];
  boi32.i32_3412[0] = (*pi32)[BO32_2];
  boi32.i32_3412[1] = (*pi32)[BO32_3];
  return(boi32.i32);
}

void sw_set_int32_3412(pi32, i32)
int32_3412 *pi32;
int32_t i32;
{
  union {
    int32_3412 i32_3412;
    int32_t i32;
  } boi32;
  boi32.i32 = i32;
  (*pi32)[BO32_0] = boi32.i32_3412[2];
  (*pi32)[BO32_1] = boi32.i32_3412[3];
  (*pi32)[BO32_2] = boi32.i32_3412[0];
  (*pi32)[BO32_3] = boi32.i32_3412[1];
}

uint32_t sw_get_uint32_3412(pu32)
uint32_3412 *pu32;
{
  union {
    uint32_3412 u32_3412;
    uint32_t u32;
  } bou32;
  bou32.u32_3412[2] = (*pu32)[BO32_0];
  bou32.u32_3412[3] = (*pu32)[BO32_1];
  bou32.u32_3412[0] = (*pu32)[BO32_2];
  bou32.u32_3412[1] = (*pu32)[BO32_3];
  return(bou32.u32);
}

void sw_set_uint32_3412(pu32, u32)
uint32_3412 *pu32;
uint32_t u32;
{
  union {
    uint32_3412 u32_3412;
    uint32_t u32;
  } bou32;
  bou32.u32 = u32;
  (*pu32)[BO32_0] = bou32.u32_3412[2];
  (*pu32)[BO32_1] = bou32.u32_3412[3];
  (*pu32)[BO32_2] = bou32.u32_3412[0];
  (*pu32)[BO32_3] = bou32.u32_3412[1];
}

float sw_get_float_1234(pf)
float_1234 *pf;
{
  union {
    float_1234 f_1234;
    float f;
  } bof;
  bof.f_1234[0] = (*pf)[BO32_0];
  bof.f_1234[1] = (*pf)[BO32_1];
  bof.f_1234[2] = (*pf)[BO32_2];
  bof.f_1234[3] = (*pf)[BO32_3];
  return(bof.f);
}

void sw_set_float_1234(pf, f)
float_1234 *pf;
float f;
{
  union {
    float_1234 f_1234;
    float f;
  } bof;
  bof.f = (float)f;
  (*pf)[BO32_0] = bof.f_1234[0];
  (*pf)[BO32_1] = bof.f_1234[1];
  (*pf)[BO32_2] = bof.f_1234[2];
  (*pf)[BO32_3] = bof.f_1234[3];
}

double sw_get_double_12345678(pd)
double_12345678 *pd;
{
  union {
    double_12345678 d_12345678;
    double d;
  } bod;
  bod.d_12345678[0] = (*pd)[BO64_0];
  bod.d_12345678[1] = (*pd)[BO64_1];
  bod.d_12345678[2] = (*pd)[BO64_2];
  bod.d_12345678[3] = (*pd)[BO64_3];
  bod.d_12345678[4] = (*pd)[BO64_4];
  bod.d_12345678[5] = (*pd)[BO64_5];
  bod.d_12345678[6] = (*pd)[BO64_6];
  bod.d_12345678[7] = (*pd)[BO64_7];
  return(bod.d);
}

void sw_set_double_12345678(pd, d)
double_12345678 *pd;
double d;
{
  union {
    double_12345678 d_12345678;
    double d;
  } bod;
  bod.d = d;
  (*pd)[BO64_0] = bod.d_12345678[0];
  (*pd)[BO64_1] = bod.d_12345678[1];
  (*pd)[BO64_2] = bod.d_12345678[2];
  (*pd)[BO64_3] = bod.d_12345678[3];
  (*pd)[BO64_4] = bod.d_12345678[4];
  (*pd)[BO64_5] = bod.d_12345678[5];
  (*pd)[BO64_6] = bod.d_12345678[6];
  (*pd)[BO64_7] = bod.d_12345678[7];
} 
```

如果不与访问器一起使用，这些类型定义的好处是会引发编译器错误，从而减少被遗忘的访问器错误。

```
typedef char int8_1[1], uint8_1[1];

typedef char int16_12[2], uint16_12[2]; /* little endian */
typedef char int16_21[2], uint16_21[2]; /* big endian */

typedef char int24_321[3], uint24_321[3]; /* Alpha Micro, PDP-11 */

typedef char int32_1234[4], uint32_1234[4]; /* little endian */
typedef char int32_3412[4], uint32_3412[4]; /* Alpha Micro, PDP-11 */
typedef char int32_4321[4], uint32_4321[4]; /* big endian */

typedef char int64_12345678[8], uint64_12345678[8]; /* little endian */
typedef char int64_34128756[8], uint64_34128756[8]; /* Alpha Micro, PDP-11 */
typedef char int64_87654321[8], uint64_87654321[8]; /* big endian */

typedef char float_1234[4]; /* little endian */
typedef char float_3412[4]; /* Alpha Micro, PDP-11 */
typedef char float_4321[4]; /* big endian */

typedef char double_12345678[8]; /* little endian */
typedef char double_78563412[8]; /* Alpha Micro? */
typedef char double_87654321[8]; /* big endian */ 
```

* * *

## 回答 #27

> 赞同：0
> 
> 时间：2019-04-11T14:18:39.897

使用 ye olde 3-step-xor 技巧围绕模板函数中的枢轴进行字节交换提供了一种灵活、快速的 O(ln2) 解决方案，不需要库，这里的样式也拒绝 1 字节类型：

```
template<typename T>void swap(T &t){
    for(uint8_t pivot = 0; pivot < sizeof(t)/2; pivot ++){
        *((uint8_t *)&t + pivot) ^= *((uint8_t *)&t+sizeof(t)-1- pivot);
        *((uint8_t *)&t+sizeof(t)-1- pivot) ^= *((uint8_t *)&t + pivot);
        *((uint8_t *)&t + pivot) ^= *((uint8_t *)&t+sizeof(t)-1- pivot);
    }
} 
```

* * *

## 回答 #28

> 赞同：0
> 
> 时间：2019-04-19T03:40:25.687

似乎安全的方法是在每个单词上使用 htons。所以，如果你有...

```
std::vector<uint16_t> storage(n);  // where n is the number to be converted

// the following would do the trick
std::transform(word_storage.cbegin(), word_storage.cend()
  , word_storage.begin(), [](const uint16_t input)->uint16_t {
  return htons(input); }); 
```

如果您在大端系统上，上述内容将是无操作的，因此我会寻找您的平台用作编译时条件的任何内容来确定 htons 是否为无操作。毕竟是 O(n)。在 Mac 上，它会类似于...

```
#if (__DARWIN_BYTE_ORDER != __DARWIN_BIG_ENDIAN)
std::transform(word_storage.cbegin(), word_storage.cend()
  , word_storage.begin(), [](const uint16_t input)->uint16_t {
  return htons(input); });
#endif 
```

* * *

## 回答 #29

> 赞同：0
> 
> 时间：2020-07-26T22:27:28.147

这是交换小端和大端的基本功能。它是基本的，但不需要补充库。

```
void endianness_swap(uint32_t& val) {
    uint8_t a, b, c;
    a = (val & 0xFF000000) >> 24;
    b = (val & 0x00FF0000) >> 16;
    c = (val & 0x0000FF00) >> 8;
    val=(val & 0x000000FF) << 24;
    val = val + (c << 16) + (b << 8) + (a);
} 
```

* * *

## 回答 #30

> 赞同：0
> 
> 时间：2021-05-09T14:32:36.423

```
void writeLittleEndianToBigEndian(void* ptrLittleEndian, void* ptrBigEndian , size_t bufLen )
{
    char *pchLittleEndian = (char*)ptrLittleEndian;

    char *pchBigEndian = (char*)ptrBigEndian;

    for ( size_t i = 0 ; i < bufLen ; i++ )    
        pchBigEndian[bufLen-1-i] = pchLittleEndian[i];
}

std::uint32_t row = 0x12345678;

char buf[4]; 

writeLittleEndianToBigEndian( &row, &buf, sizeof(row) ); 
```

* * *

## 回答 #31

> 赞同：0
> 
> 时间：2021-05-25T02:34:05.473

不如使用内在函数高效，但肯定是可移植的。我的答案：

```
#include <cstdint>
#include <type_traits>

/**
 * Perform an endian swap of bytes against a templatized unsigned word.
 *
 * @tparam value_type The data type to perform the endian swap against.
 * @param value       The data value to swap.
 *
 * @return value_type The resulting swapped word.
 */
template <typename value_type>
constexpr inline auto endian_swap(value_type value) -> value_type
{
    using half_type = typename std::conditional<
        sizeof(value_type) == 8u,
        uint32_t,
        typename std::conditional<sizeof(value_type) == 4u, uint16_t, uint8_t>::
            type>::type;

    size_t const    half_bits  = sizeof(value_type) * 8u / 2u;
    half_type const upper_half = static_cast<half_type>(value >> half_bits);
    half_type const lower_half = static_cast<half_type>(value);

    if (sizeof(value_type) == 2u)
    {
        return (static_cast<value_type>(lower_half) << half_bits) | upper_half;
    }

    return ((static_cast<value_type>(endian_swap(lower_half)) << half_bits) |
            endian_swap(upper_half));
} 
```

* * *

## 回答 #32

> 赞同：0
> 
> 时间：2021-10-08T19:11:44.523

现在存在 std::endian 但在 c++23 添加 std::byteswap 之前的 c++20 无分支版本

```
#include <bit>
#include <type_traits>
#include <concepts>
#include <array>
#include <cstring>
#include <iostream>
#include <bitset>

template <int LEN, int OFF=LEN/2>
class do_swap
{
    // FOR 8 bytes:
    // LEN=8 (LEN/2==4)       <H><G><F><E><D><C><B><A>
    // OFF=4: FROM=0, TO=7 => [A]<G><F><E><D><C><B>[H]
    // OFF=3: FROM=1, TO=6 => [A][B]<F><E><D><C>[G][H]
    // OFF=2: FROM=2, TO=5 => [A][B][C]<E><D>[F][G][H]
    // OFF=1: FROM=3, TO=4 => [A][B][C][D][E][F][G][H]
    // OFF=0: FROM=4, TO=3 => DONE
public:
    enum consts {FROM=LEN/2-OFF, TO=(LEN-1)-FROM};
    using NXT=do_swap<LEN, OFF-1>;
// flip the first and last for the current iteration's range
    static void flip(std::array<std::byte, LEN>& b)
    {
        std::byte tmp=b[FROM];
        b[FROM]=b[TO];
        b[TO]=tmp;
        NXT::flip(b);
    }
};
template <int LEN>
class do_swap<LEN, 0> // STOP the template recursion
{
public:
    static void flip(std::array<std::byte, LEN>&)
    {
    }
};

template<std::integral T, std::endian TO, std::endian FROM=std::endian::native>
        requires ((TO==std::endian::big) || (TO==std::endian::little))
              && ((FROM==std::endian::big) || (FROM==std::endian::little))
class endian_swap
{
public:
    enum consts {BYTE_COUNT=sizeof(T)};
    static T cvt(const T integral)
    {
    // if FROM and TO are the same -- nothing to do
        if (TO==FROM)
        {
                return integral;
        }

    // endian::big --> endian::little is the same as endian::little --> endian::big
    // the bytes have to be reversed
    // memcpy seems to be the most supported way to do byte swaps in a defined way
        std::array<std::byte, BYTE_COUNT> bytes;
        std::memcpy(&bytes, &integral, BYTE_COUNT);
        do_swap<BYTE_COUNT>::flip(bytes);
        T ret;
        std::memcpy(&ret, &bytes, BYTE_COUNT);
        return ret;
    }
};

std::endian big()
{
    return std::endian::big;
}

std::endian little()
{
    return std::endian::little;
}

std::endian native()
{
    return std::endian::native;
}

long long swap_to_big(long long x)
{
    return endian_swap<long long, std::endian::big>::cvt(x);
}

long long swap_to_little(long long x)
{
    return endian_swap<long long, std::endian::little>::cvt(x);
}

void show(std::string label, long long x)
{
    std::cout << label << "\t: " << std::bitset<64>(x) << " (" << x << ")" << std::endl;
}

int main(int argv, char ** argc)
{
    long long init=0xF8FCFEFF7F3F1F0;
    long long to_big=swap_to_big(init);
    long long to_little=swap_to_little(init);
    show("Init", init);
    show(">big", to_big);
    show(">little", to_little);
} 
```

* * *

## 回答 #33

> 赞同：-1
> 
> 时间：2017-05-22T22:40:33.593

以下是如何读取以 IEEE 754 64 位格式存储的双精度数据，即使您的主机使用不同的系统也是如此。

```
/*
* read a double from a stream in ieee754 format regardless of host
*  encoding.
*  fp - the stream
*  bigendian - set to if big bytes first, clear for little bytes
*              first
*
*/
double freadieee754(FILE *fp, int bigendian)
{
    unsigned char buff[8];
    int i;
    double fnorm = 0.0;
    unsigned char temp;
    int sign;
    int exponent;
    double bitval;
    int maski, mask;
    int expbits = 11;
    int significandbits = 52;
    int shift;
    double answer;

    /* read the data */
    for (i = 0; i < 8; i++)
        buff[i] = fgetc(fp);
    /* just reverse if not big-endian*/
    if (!bigendian)
    {
        for (i = 0; i < 4; i++)
        {
            temp = buff[i];
            buff[i] = buff[8 - i - 1];
            buff[8 - i - 1] = temp;
        }
    }
    sign = buff[0] & 0x80 ? -1 : 1;
    /* exponet in raw format*/
    exponent = ((buff[0] & 0x7F) << 4) | ((buff[1] & 0xF0) >> 4);

    /* read inthe mantissa. Top bit is 0.5, the successive bits half*/
    bitval = 0.5;
    maski = 1;
    mask = 0x08;
    for (i = 0; i < significandbits; i++)
    {
        if (buff[maski] & mask)
            fnorm += bitval;

        bitval /= 2.0;
        mask >>= 1;
        if (mask == 0)
        {
            mask = 0x80;
            maski++;
        }
    }
    /* handle zero specially */
    if (exponent == 0 && fnorm == 0)
        return 0.0;

    shift = exponent - ((1 << (expbits - 1)) - 1); /* exponent = shift + bias */
    /* nans have exp 1024 and non-zero mantissa */
    if (shift == 1024 && fnorm != 0)
        return sqrt(-1.0);
    /*infinity*/
    if (shift == 1024 && fnorm == 0)
    {

#ifdef INFINITY
        return sign == 1 ? INFINITY : -INFINITY;
#endif
        return  (sign * 1.0) / 0.0;
    }
    if (shift > -1023)
    {
        answer = ldexp(fnorm + 1.0, shift);
        return answer * sign;
    }
    else
    {
        /* denormalised numbers */
        if (fnorm == 0.0)
            return 0.0;
        shift = -1022;
        while (fnorm < 1.0)
        {
            fnorm *= 2;
            shift--;
        }
        answer = ldexp(fnorm, shift);
        return answer * sign;
    }
} 
```

对于其余的函数套件，包括写入和整数例程，请参阅我的 github 项目

[https://github.com/MalcolmMcLean/ieee754](https://github.com/MalcolmMcLean/ieee754)

* * *

## 回答 #34

> 赞同：-4
> 
> 时间：2008-09-19T20:30:37.673

查找位移，因为这基本上是从 little -> big endian 交换所需要做的一切。然后根据位大小，您可以更改进行位移的方式。

# templates - 如何为 WCSF (.NET 2.0) 创建自定义模板？

> ID：105264
> 
> 赞同：0
> 
> 时间：2008-09-19T20:24:26.080
> 
> 标签：templates, wcsf

我是 WCSF 的新手，似乎找不到与“构建自定义模板”相关的任何内容，以创建具有自己风格的视图/演示者/代码隐藏/等...

谁能指出我正确的方向？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-20T13:28:30.877

[您可以在WCSF 文档的](http://msdn.microsoft.com/en-us/library/bb264518.aspx)[修改指导包](http://msdn.microsoft.com/en-us/library/cc304884.aspx)主题中找到有关如何修改指导包的有用信息。在那里，您将找到有关如何创建/更新模板的指南。

让我知道这是否有帮助，

埃齐奎尔·贾迪布

[http://blogs.southworks.net/ejadib](http://blogs.southworks.net/ejadib)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2010-01-26T20:44:28.827

可以在此处找到 T4 模板的默认安装位置 C:\Program Files\Microsoft Web Client Factory\WCSF Guidance Package\Templates\T4\

# java - 学习Maven的思考

> ID：105307
> 
> 赞同：8
> 
> 时间：2008-09-19T20:27:38.147
> 
> 标签：java, maven-2

我有一个我用Java做的副业。这是一个非常简单的网络应用程序。它在 Linux 服务器上的 Tomcat 中运行，并使用 MySQL 数据库。大部分代码是用 Spring 框架编写的。它有很多单元测试。当我在 Eclipse 中编码时。当我部署应用程序时，我会运行一些 shell 脚本来将 WAR 文件移动到 Web 服务器，进行数据库更新，并对 apache 配置进行更改。我是唯一的开发人员，现在它只部署到 1 个环境（生产），尽管有一天我可能也想要一个测试或登台环境。我通过 Eclipse 插件使用 SVN 版本控制。

我总是听说有人在他们的项目中使用 Maven。既然这么多人都在用，我就对自己说一定不错。我想在业余时间学习它。唯一的问题是我不太明白为什么要使用 Maven？我的第一段听起来像是适合 Maven 的项目吗？对于与数据库交互的项目，它是否有任何特定优势？

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-09-19T20:36:40.483

Maven 非常适合您的项目 IMO。Maven 是一个全方位的构建和部署管理工具。它的最大优势在于它使构建脚本比功能上可比较的 Ant 文件或 shell 脚本更易于维护。

使用 maven 有很多优点，最大的优点是约定优于配置。这意味着，如果您的项目使用 Maven 目录结构进行布局，则几乎不需要任何配置来构建和运行您的 JUnit 测试。

Maven 为您带来的另一大胜利是依赖管理。您可以在称为项目对象模型 (POM) 的 Maven 配置文件中以声明方式定义项目的依赖项，并且 Maven 将所有 jar 存储在它维护的本地目录结构中。对于公开可用的工件，jar 会自动从 Maven 中央存储库下载，对于内部或专有的 3rd 方 jar，您可以使用单个命令将它们安装到您的存储库中。

除了组织这些工件并自动设置构建类路径以包含所有必要的 jar 之外，maven 还将管理依赖层次结构。这意味着如果您的项目依赖于 jar A 并且 A 依赖于 jar B，则 jar B 将自动与您的 WAR 捆绑在一起，即使您没有在构建配置中明确将其列为依赖项。

另外，从专业开发的角度来看，学习 Maven 是有意义的，因为根据我的经验，Maven 已经取代 Ant，成为开源和专有 Java 项目中首选的构建工具。

话虽如此，如果您有一个对您来说快速且可靠的构建系统，那么仅仅为了使用其他所有人都使用的相同工具而转换为 Maven 可能不值得。

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2008-09-19T20:57:39.760

Maven 非常适合您想做的事情。与大多数构建工具不同，maven 明智地使用约定（嗯，至少比许多其他工具更好），并且它为您提到的每个领域都有“插件”：

单元测试：[maven surefire 插件](http://maven.apache.org/plugins/maven-surefire-plugin/)

Eclipse 集成：[m2eclipse](http://m2eclipse.codehaus.org/)

部署 WAR 文件：[WAR 插件](http://maven.apache.org/maven-1.x/plugins/war/)和[Deploy 插件](http://maven.apache.org/plugins/maven-deploy-plugin/)

Maven 还可以帮助您在 Tomcat 上进行集成测试（如果您有的话），因为您可以使用[cargo 插件](http://cargo.codehaus.org/Maven2+plugin)启动、停止或部署战争。

无论如何，如果您打算在业余时间阅读，这里有一本免费的书（PDF 格式）：[Maven 权威指南](http://www.sonatype.com/book/pdf/maven-definitive-guide.pdf)

希望能帮助到你！

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-09-19T20:33:03.050

我在工作中愤怒地使用maven。这是一个严厉的情妇。只要您在做许多其他人都有的事情，它就会使事情变得容易，这很重要，只要您按照 maven 认为您应该做的方式来做。走出那条狭窄的道路，它会在每一步都与你抗争。

[BuildR](http://incubator.apache.org/buildr/)的使用给我留下了深刻的印象。它像 ANT 一样灵活，同时利用了 maven 的依赖系统。此外，它正在孵化中，所以边缘有点粗糙。

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2008-09-19T22:15:36.673

您的项目听起来不像是适合 Maven 的项目。你似乎有一个工作的开发环境。为什么要设置另一个？它只会给你一个额外的项目文件来维护，它打破了良好的 ol' [DRY](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself)原则。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2008-12-16T22:21:11.960

我曾经开始一项使用 Maven 的新临时工作。花了 2 天时间试图弄清楚他们的 Maven 构建是如何工作的。原来他们都在 Windows 上使用 maven 1.01，而我无意中试图在 1.02 上构建，所以它对我不起作用。这个地方没有人知道它是如何工作的，他们已经使用了几个月并且对它很满意。几个月后，在同一个项目中，我不得不深入研究 jelly 脚本以更改单个构建变量。这不好玩。

当我第一次开始使用它时，我阅读了“约定优于配置”和“使用一组标准目录”。这些不是我在文档中可以找到的任何地方。我猜你应该猜到了。

我的意见：

*   您使用的任何您不完全理解的工具都是错误的，并且是您开发过程的潜在船锚。如果这个工具真的非常复杂，你可能会使用它最简单的部分，而不是深入掌握它。如果您没有使用或回避该工具最强大的部分，您可能会违背使用它的目的。
*   Maven 是一个典型的例子，它充满了自动魔法，以至于你不知道它在做什么，除非你投入比构建工具更多的时间来成为一个 maven maven。寻找问题的过度设计的解决方案。
*   我没有找到任何我需要做的事情的实例，这些事情我不能用 ant 做而需要 maven 做。我知道有一些，我只是从不需要它们。如果我这样做了，我可能会对处理 maven 所需的努力更加慈善。
*   它使您的构建依赖于互联网。现在下载一个小项目，运行 mvn 并让 maven 下载 10 个插件，甚至在它开始构建你想要构建的东西之前，这种情况并不少见。它在做什么？没有办法真正知道，但你最好希望它不会破裂。当它确实失败时，失败的复杂性和堆积的依赖层使其基本上无法调试。我不明白为什么这在任何方面都是对更简单的构建工具的改进，或者出于任何原因甚至是可取的。

总而言之，它几乎是魔法，只是当它不起作用时，你可能不知道为什么。这似乎是一个糟糕的权衡。公平地说，这是几年前的事了。我知道我不友善，并且在后续版本中得到了改进（我也使用过）。尽管如此，我讨厌它（你能说出来吗？）

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-09-19T20:33:49.833

我们完全按照您在我们的项目中所做的工作，并且我们使用 maven。您希望使用 maven 拥有标准化的布局和构建项目的方式。您永远不必将所有这些 jar 依赖项存储在 SVN 中或将它们保存在特殊的地方，maven 会为您做到这一点。Maven 还可以作为让其他开发人员轻松了解您的项目的一种方式。一旦你开始使用它，你就再也不想回头了 :)

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-19T22:33:13.527

除了许多 oss 项目正在使用（或转换为）maven 并且一些闭源项目正在迁移到 maven 的事实之外，您的项目不一定会从使用 Maven 中受益很多。

但是，如果您考虑将其开源，那么您项目的用户可能会从您的项目使用 maven 中受益。

Maven（jar 依赖项）的一些重要好处可以通过 ivy（[http://ant.apache.org/ivy/](http://ant.apache.org/ivy/)）获得。

再说一次，因为您似乎表明您是唯一的开发人员。如果 maven 不适合您，您可以快速恢复。

BR，
~A

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-12-16T21:48:20.827

不。看看别人怎么[说](https://stackoverflow.com/questions/303853/what-are-your-impressions-of-maven)，仔细研究。还可以考虑在 SO 上查看我对 Maven 的其他一些评论。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-12-16T22:12:55.597

前段时间我使用maven进行依赖管理，因为我厌倦了添加所有的jar，如果我想在另一个盒子上测试它。您实际上不必为此“学习”它，学习它不需要太多时间。

然而，最简单的方法是询问已经了解 mvn 的人，这样他就可以向您展示它是如何工作的，然后您很快就会学会它。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-12-16T23:10:48.833

Maven 的一大优势是它可以进行大量的构建/依赖管理，而无需您编写任何构建脚本，甚至不必描述您的构建过程。您已经完成了项目设置，因此您不会受益于 Maven 为您设置项目 shell 或下载您指定的依赖项，而无需单独下载它们。如果您的目标是学习如何使用和管理 Maven，那么对于像这样没有其他开发人员并且构建过程非常简单（据我所知）的项目这样做也无济于事。所以我建议不要在现有项目中使用 Maven。

I would however setup a simple test application similar to yours using Maven and compare it to your project's structure to see if you follow best practices(at least as the Maven developers see them) and if your application follows standard web application conventions.

# apache - 如何使用 mod_rewrite 更改 URL 的路径和文件名

> ID：105308
> 
> 赞同：2
> 
> 时间：2008-09-19T20:27:39.007
> 
> 标签：apache, mod-rewrite

我要取网址： [http ://www.mydomain.com/signup-12345](http://www.mydomain.com/signup-12345)

实际上给他们： [http ://www.mydomain.com/signup/?aff=12345](http://www.mydomain.com/signup/?aff=12345)

我没有使用 mod_rewrite 的历史，帮助！

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-19T20:31:15.410

试试这个 ：

重写规则 ^/signup-(\d+)/$ /signup/?aff=$1 [I]

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-21T13:23:04.203

我发现相对难以找到的是如何做与你正在做的相反的事情，即你需要找出部分查询字符串的值。

例如：

如果您想重写 Url： [http :](http://www.example.com/signup-) **//www.example.com/signup-old-script**。**ASP** ? **亲**=12345

至： [http :](http://www.example.com/signup-) **//www.example.com/signup-new-script**。**php** ? **affID** = 12345

你可以使用：

```
RewriteCond %{query_string}& ^aff=((.+&)|&)$   
RewriteRule ^/signup-old-script.asp$    /signup-new-script.php?affID=%2 [L,R] 
```

注意重写规则中的**%符号而不是****$**符号。

我必须这样做，以便我可以在一个新站点中支持旧的闪存映射，该站点具有指向“.cfm”文件的链接，该文件在查询字符串中具有 ID。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2011-03-02T16:40:33.337

据我所知，

*flag 导致 RewriteCond 被忽略。*- 对于“忽略大小写” - 从`IsapiRewrite`版本 2

# asp.net - 我的通用 ActionLink 去哪儿了？

> ID：105310
> 
> 赞同：4
> 
> 时间：2008-09-19T20:28:02.407
> 
> 标签：asp.net, asp.net-mvc

从预览 2 移动到预览 5，现在我的 Html.ActionLink 调用都失败了。似乎通用版本已被非类型安全版本取代。

```
// used to work
<li>
  <%= Html.ActionLink<HomeController>(c => c.Index(), "Home")%>
</li>
// what appears I can only do now
<li>
  <%= Html.ActionLink<HomeController>("Index", "Home")%>
</li> 
```

顾家为什么要这么做？它是否已作为“未来”转移到 Microsoft.Web.Mvc 或其他地方？有没有通用的替代品？哈！

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-19T20:34:17.943

不要责怪GU，是我的错。该方法已移至 MvcFutures。这是一篇[博客文章，它为为什么进行此更改提供了基础](http://haacked.com/archive/2008/08/29/how-a-method-becomes-an-action.aspx)。

# design-patterns - 什么是表驱动方法？

> ID：105311
> 
> 赞同：12
> 
> 时间：2008-09-19T20:28:10.033
> 
> 标签：design-patterns, table-driven

什么是“表驱动方法”？

正如比尔盖茨在[第二个 Windows Vista 广告](https://www.youtube.com/watch?v=nNOohFst9Lc)中 1:05 所述。

* * *

## 回答 #1

> 赞同：21
> 
> 时间：2008-09-19T20:32:22.693

> 表驱动方法是允许您在表中查找信息而不是使用逻辑语句（即 case、if）的方案。在简单的情况下，使用逻辑语句更快更容易，但是随着逻辑链变得越来越复杂，表驱动的代码比复杂的逻辑更简单，更容易修改，效率更高。

参考：[麦康奈尔，史蒂夫。代码完成，第二版。雷德蒙德（华盛顿）：微软，2004 年。印刷。第 411 页，第 1 段。](https://rads.stackoverflow.com/amzn/click/com/0735619670)

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2015-02-01T22:23:08.730

引用的视频中有比尔·盖茨阅读史蒂夫·麦康奈尔 (Steve McConnell) 的《代码完成》一书。[Jeff Atwood 在他的博客中提到了这一点（YouTube 链接匹配）。](http://blog.codinghorror.com/bill-gates-and-code-complete/)

来自 Code Complete，第 2 版：

> 表驱动方法是一种允许您在表中查找信息而不是使用逻辑语句（*if*和*case*）来找出它的方案。

McConnell 在他的示例中使用数组作为他的“表”，但我认为这个概念可以应用于数据库表或任何其他类似表的东西。

这个概念最好通过一个例子来解释。

假设您正在经营一家餐厅，并且每个桌号有不同数量的座位。

您获取特定桌子座位数的逻辑可能类似于

```
if table number == 1
    table has 4 seats
else if table number == 2
    table has 8 seats
. . . 
```

因此，如果您有 50 张桌子，那么您将有 100 行代码来确定座位数。

使用表驱动方法，您可以创建一个数组，其索引表示表号，值表示座位数，因此您的逻辑看起来像

```
tables [] = {4, 8, 2, 4, ...}
table seats = tables[table number] 
```

它更简单，更短，更容易维护。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-23T00:50:52.560

表驱动方法非常简单。使用数据结构而不是 if-then 语句来驱动程序逻辑。例如，如果您正在处理两种类型的记录（电视与有线电视），您可以这样做：

```
hash[tv] = process_tv_records
hash[cable] = process_cable_records 
```

在某些语言中，例如 Ruby 或 Perl，这种技术很简单。在 Java 中，您需要使用反射来查找方法句柄。

如果您想了解决策表，请查看[http://fitnesse.org/](http://fitnesse.org/)上的 Fitnesse 测试框架。

# java - C++ 中的 Gsoap 错误

> ID：105326
> 
> 赞同：0
> 
> 时间：2008-09-19T20:30:31.557
> 
> 标签：java, c++, soap, gsoap

我正在使用 gsoap 在 C++ 中创建一个肥皂服务器。消息通过用 Java 编写的总线进行路由。服务器和总线都是多线程的。一切正常，一次通过系统发送一条消息。如果我启动 3 个客户端，每个客户端都尽可能快地发送消息，那么对于大约 3500 条消息来说一切都很好。然后我开始定期收到“一次只允许一个套接字连接”。gsoap 代码中的错误。典型的 4000 条消息中约有 3950 条通过 OK。在最后 500 次发送中发生所有 50 次失败。

1.  为什么这些错误会在多次发送后出现，而不是在发送开始时出现？发送速率不会增加。

2.  它在说什么？我找不到该错误的任何解释，我也不清楚它的含义。

3.  有人成功地多线程了一个 gsoap 应用程序吗？

这是我的服务器代码。

```
long WINAPI threadGO(soap *x);

int main(int argc, char* argv[])
{
HANDLE thread1;
int m, s; /* master and slave sockets */
struct soap *soap = soap_new();
if (argc < 2)
soap_serve(soap); /* serve as CGI application */
else
{ 
  m = soap_bind(soap, NULL, atoi(argv[1]), 100); 
  if (m < 0)
  { 
      soap_print_fault(soap, stderr);
      exit(-1);
  }
  fprintf(stderr, "Socket connection successful: master socket = %d\n", m);
  for (;;)
  {
     s = soap_accept(soap);
     thread1 =    CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)threadGO,soap_copy(soap),0,NULL);
  }
}
soap_done(soap);
free(soap);
return 0;
}

long WINAPI threadGO(soap *x)
{
soap_serve(x);
soap_end(x);
return 0

;
} 
```

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-20T04:40:47.977

我相信您在 threadGO 中存在资源泄漏。

用 复制soap 结构后`soap_copy()`，我认为需要通过调用以下所有内容来释放它：

```
soap_destroy(x);
soap_end(x);
soap_free(x); 
```

具体来说，丢失的调用`soap_done()`（调用 from `soap_free()`）调用`soap_closesock()`，它关闭了套接字。

# testing - 检测不会失败的测试的自动化方法，通过最小代码覆盖率签入？

> ID：105330
> 
> 赞同：3
> 
> 时间：2008-09-19T20:30:50.497
> 
> 标签：testing, build-automation

我有一个开发人员，它将通过编写永不失败的测试来绕过我们的代码覆盖率。

代码很糟糕，但测试永远不会捕捉到它，因为它们断言（真）。

我进行代码审查，但我不能一直为每个人工作。你如何让这样的人有动力去开发好的软件？

是否有用于检测不会失败的测试的构建插件？

C#，mbUnit 测试。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-19T20:35:16.913

真正的动力来自内心。有些人会利用他们获得的每一个机会来玩这个系统，有时他们只是出于他们的原因。其他人这样做只是因为他们是黑客。

也就是说，假设您的经理，与开发人员“来找耶稣”会面。如果这仍然不起作用，那么门总是存在的。

如果您不是经理，请使用适当的渠道。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T20:36:27.080

我想你几乎已经为自己回答了这个问题。如果您有人为您或与您一起工作（您不清楚您是否是该开发人员的经理），那么如果他们没有正确地完成工作，那么肯定有一些程序可以让这个人清楚地知道他们没有按照可接受的标准生产工作。

开发人员是 TDD 的新手吗？也许他们需要一些关于编写好的测试等的辅导。否则他们需要踢屁股并向他们强调测试似乎并不比他/她正在生成的代码更重要。

哦，是的，在插件方面，忘记这一点，你正在做的相同的代码审查应该足够好。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T20:33:02.457

您应该真正指定您正在使用的语言/框架。

在最简单的情况下，我想用简单的-ping检测`assert(true)`字符串应该很容易。`grep`

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T20:33:39.833

对于应用程序配置值，您始终可以尝试使用垃圾进行测试运行。

任何通过的测试都是可疑的？

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T21:01:31.547

与其花时间寻找不会失败的测试，不如稍微扩展测试——让代码在很多方面都失败。那会

*   向他展示如何编写更好的测试
*   强制他修复他的代码，并防止签入更多的错误代码

您必须使用的一段错误代码将是一个很好的起点——您必须确保它有效......

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-20T00:04:51.433

取他正在测试的界面并将其简化为最简单的形式。换句话说，获取类/方法签名并仅添加编译所需的代码。对此进行测试。问他为什么程序什么都不做时他的测试通过了。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-21T05:05:32.793

由两个或多个已经被测试感染的开发人员进行的代码审查可能是让有问题的开发人员看到自动化单元测试真的没有那么困难或不寻常的最佳方式。每次审查都有两个受测试感染的开发人员将加强质量单元测试对他的重要性。此外，分配他对经过良好测试的其他开发人员代码的评论将帮助他学习如何进行单元测试。

你应该看看做一些[突变测试](http://en.wikipedia.org/wiki/Mutation_testing)，以检测弱测试。[Nester](http://nester.sourceforge.net/)（[Jester](http://jester.sourceforge.net/)的 .Net 等价物）是一种您可能会发现有用的工具。

请告诉我们你的进展情况！

更新：我遇到了：[“为什么大多数开发人员仍然不编写单元测试？”](http://weblogs.asp.net/rosherove/archive/2008/09/20/goodbye-mocks-farewell-stubs.aspx) 并认为在这里阅读也会很好。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2010-11-15T22:26:15.143

我认为您需要先尝试让他写一个失败的测试。试着让他养成这个习惯。通常，单元测试的新手很难编写它们。

还有一些工具可以帮助您“探索所有可能的代码路径”。我建议你看一下，**PEX**会生成自动化测试，它很可能会破坏他的代码......虽然这可能不是一个最佳方案，但尝试推广共享代码库的概念。

让您的开发人员配对程序，当您与其他人一起使用相同的功能时，“偷懒”会困难得多，并且会分散代码所有权。您似乎没有这样做，因为您谈论“**他的**”代码。如果有 2 个人从事同一份工作，您可以完成多少工作，这可能会令人惊讶，这将大大提高质量。

此外，单元测试并不是消除所有问题的圣杯……它们应该是您可以使用的工具之一。

你的代码覆盖要求是什么？

# java - 是否有基于 Java 的光线追踪模型可以适用于水下声学？

> ID：105340
> 
> 赞同：3
> 
> 时间：2008-09-19T20:31:41.307
> 
> 标签：java, raytracing, acoustics

我正在寻找一种基于 Java 的开源光线追踪系统，适用于对基于水下光线的声学进行建模。这样的软件包可能类似于带有高斯射线束 (GRAB) 的综合声学系统仿真 (CASS)，但我更喜欢可以在演示文稿中使用的开源、免费使用或免费修改模型到一个开放的论坛（例如，JavaOne）。

满足我需求的最佳模型将提供基于环境模型、水深测量（也称为海底地形）和发射器频谱的射线路径建模。注意：多路径效果（包括反射和折射）是我的主要兴趣点，所以最好的包会提供开箱即用的效果。

稍微不太理想的是标准的基于 Java 的光线跟踪包（光学或声学），它可以处理通过介质的变化速度。另一种说法是折射率在整个介质中以连续的方式变化（尽管它的一阶导数可能不是连续的）。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2010-03-17T20:56:56.267

RaPSor项目似乎是一个基于 java 的光线追踪模拟器[。](http://sourceforge.net/projects/rapsor)它实际上代表无线电传播模拟器，最初是为了支持无线电信号传播而开发的，例如在建筑物的 WiFi 覆盖范围内投射死点。

阅读它的一些[用例文件](http://sourceforge.net/projects/rapsor/files/RaPSor.pdf/download)表明它可以进行射线追踪，并且可以扩展以支持声学射线追踪。提示我的[博客](http://netbeans.org/community/articles/interviews/ray-simulation-analysis.html)文章提到了找出房间的声场的想法，但我不明白为什么需要将其限制在空气传播中。

此外，它是使用 NetBeans 项目构建的。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-20T11:01:11.823

你会考虑一个非常有据可查的 C++ 光线追踪器吗？

[pbrt](http://www.pbrt.org)是一个以文学风格编写的基于物理的光线追踪器，它附带一本很好的书，非常详细地描述了代码。快速搜索显示它已用于学生[项目](http://www.sfu.ca/~pkarimia/courses/cmpt770graphics/proj)的声学建模。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-25T19:05:01.383

你看过[Rings](http://j3d.sourceforge.net/)项目吗？我对光线追踪知之甚少，无法判断 Rings 是否以您需要的方式实现，以获得最大的实用性。文档和示例看起来相当不错。

# macos - OS X 终端中的 Bash 提示已损坏

> ID：105349
> 
> 赞同：7
> 
> 时间：2008-09-19T20:32:30.290
> 
> 标签：macos, bash, unix

我在 os X Terminal 应用程序中使用 bash，当我滚动浏览历史记录时，我的自定义 $PS1 中断。

```
PS1="${BLUE}\u${CYAN}@${RED}\h${BLUE}\w\n\[${red}\$${NC}\]" 
```

也试过 PS1="${BLUE}\u${CYAN}@${RED}\h${BLUE}\w\r\n[${red}\$${NC}]"

问题似乎出在换行符中。我在 Slackware 上使用过这个 bash 提示，没有问题。

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-09-19T21:48:56.877

每个转义序列都需要 [ 和 ] ；$BLUE 之类的是否包括这些？如果没有，它们需要被这些调用括起来。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2009-12-16T01:32:45.463

为了避免这种“逃避”困难，因为你提示需要进化得更复杂，这应该是一个开始成长的骨架：

```
function _my_prompt ()
{ 
  # magic goes here
  my_prmpt=.... 
}
PROMPT_COMMAND='_my_prompt'
PS1="[\$my_prmpt] \$" 
```

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2010-01-10T22:22:59.470

登录远程（debian）系统时，我遇到了同样的问题。由于 .bashrc 中的转义值都被很好地括起来了，我做了一些谷歌搜索，发现原因可能是本地和远程系统上的窗口大小不同。添加

shopt -s checkwinsize

到远程系统上的 .bashrc 为我解决了这个问题。

来源：[http ://forums.macosxhints.com/showthread.php?t=17068](http://forums.macosxhints.com/showthread.php?t=17068)

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T20:33:57.913

如果问题似乎出在换行符上，请尝试使用 \r\n 而不是 \n 并查看它是否有所作为。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T21:11:47.230

我在你的 PS1 上遇到了同样的问题（在 OS X 上）。如果我删除`\[`和`\]`

```
PS1="${BLUE}\u${CYAN}@${RED}\h${BLUE}\w\n${red}\$${NC}" 
```

这很好用。需要方括号吗？我从未使用过它们，但来自[文档](http://www.gnu.org/software/bash/manual/bashref.html#Printing-a-Prompt)：

> `\[` 开始一系列非打印字符。这可用于将终端控制序列嵌入到提示中。
> 
> `\]` 结束一系列非打印字符。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-19T21:48:12.463

我现在已经尝试过

```
PS1="${BLUE}\u${CYAN}@${RED}\h${BLUE}\w${RED}\r\n\$\[${blue}\]" 
```

这似乎有效 使以前的命令起作用所需的括号。

# c# - 如何枚举一个枚举

> ID：105372
> 
> 赞同：4148
> 
> 时间：2008-09-19T20:34:50.797
> 
> 标签：c#, .net, loops, enums, enumeration

你如何`enum`在 C# 中枚举一个？

例如，以下代码无法编译：

```
public enum Suit
{
    Spades,
    Hearts,
    Clubs,
    Diamonds
}

public void EnumerateAllSuitsDemoMethod()
{
    foreach (Suit suit in Suit)
    {
        DoSomething(suit);
    }
} 
```

它给出了以下编译时错误：

> “西装”是一种“类型”，但用作“变量”

它在关键字上失败`Suit`，第二个。

* * *

## 回答 #1

> 赞同：5050
> 
> 时间：2008-09-19T20:37:18.187

```
foreach (Suit suit in (Suit[]) Enum.GetValues(typeof(Suit)))
{
} 
```

**注意**：强制转换`(Suit[])`不是绝对必要的，[但它确实使代码快了 0.5 ns](https://gist.github.com/bartoszkp/9e059c3edccc07a5e588#gistcomment-2625454)。

* * *

## 回答 #2

> 赞同：783
> 
> 时间：2008-09-19T20:39:39.117

在我看来，您真的想打印出每个枚举的名称，而不是值。在这种情况下`Enum.GetNames()`似乎是正确的方法。

```
public enum Suits
{
    Spades,
    Hearts,
    Clubs,
    Diamonds,
    NumSuits
}

public void PrintAllSuits()
{
    foreach (string name in Enum.GetNames(typeof(Suits)))
    {
        System.Console.WriteLine(name);
    }
} 
```

顺便说一句，增加值并不是枚举枚举值的好方法。你应该这样做。

我会`Enum.GetValues(typeof(Suit))`改用。

```
public enum Suits
{
    Spades,
    Hearts,
    Clubs,
    Diamonds,
    NumSuits
}

public void PrintAllSuits()
{
    foreach (var suit in Enum.GetValues(typeof(Suits)))
    {
        System.Console.WriteLine(suit.ToString());
    }
} 
```

* * *

## 回答 #3

> 赞同：373
> 
> 时间：2009-06-03T12:03:51.663

我做了一些扩展以便于枚举使用。也许有人可以使用它...

```
public static class EnumExtensions
{
    /// <summary>
    /// Gets all items for an enum value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="value">The value.</param>
    /// <returns></returns>
    public static IEnumerable<T> GetAllItems<T>(this Enum value)
    {
        foreach (object item in Enum.GetValues(typeof(T)))
        {
            yield return (T)item;
        }
    }

    /// <summary>
    /// Gets all items for an enum type.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="value">The value.</param>
    /// <returns></returns>
    public static IEnumerable<T> GetAllItems<T>() where T : struct
    {
        foreach (object item in Enum.GetValues(typeof(T)))
        {
            yield return (T)item;
        }
    }

    /// <summary>
    /// Gets all combined items from an enum value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="value">The value.</param>
    /// <returns></returns>
    /// <example>
    /// Displays ValueA and ValueB.
    /// <code>
    /// EnumExample dummy = EnumExample.Combi;
    /// foreach (var item in dummy.GetAllSelectedItems<EnumExample>())
    /// {
    ///    Console.WriteLine(item);
    /// }
    /// </code>
    /// </example>
    public static IEnumerable<T> GetAllSelectedItems<T>(this Enum value)
    {
        int valueAsInt = Convert.ToInt32(value, CultureInfo.InvariantCulture);

        foreach (object item in Enum.GetValues(typeof(T)))
        {
            int itemAsInt = Convert.ToInt32(item, CultureInfo.InvariantCulture);

            if (itemAsInt == (valueAsInt & itemAsInt))
            {
                yield return (T)item;
            }
        }
    }

    /// <summary>
    /// Determines whether the enum value contains a specific value.
    /// </summary>
    /// <param name="value">The value.</param>
    /// <param name="request">The request.</param>
    /// <returns>
    ///     <c>true</c> if value contains the specified value; otherwise, <c>false</c>.
    /// </returns>
    /// <example>
    /// <code>
    /// EnumExample dummy = EnumExample.Combi;
    /// if (dummy.Contains<EnumExample>(EnumExample.ValueA))
    /// {
    ///     Console.WriteLine("dummy contains EnumExample.ValueA");
    /// }
    /// </code>
    /// </example>
    public static bool Contains<T>(this Enum value, T request)
    {
        int valueAsInt = Convert.ToInt32(value, CultureInfo.InvariantCulture);
        int requestAsInt = Convert.ToInt32(request, CultureInfo.InvariantCulture);

        if (requestAsInt == (valueAsInt & requestAsInt))
        {
            return true;
        }

        return false;
    }
} 
```

枚举本身必须用[FlagsAttribute](http://msdn.microsoft.com/en-us/library/system.flagsattribute.aspx)装饰：

```
[Flags]
public enum EnumExample
{
    ValueA = 1,
    ValueB = 2,
    ValueC = 4,
    ValueD = 8,
    Combi = ValueA | ValueB
} 
```

* * *

## 回答 #4

> 赞同：194
> 
> 时间：2009-09-03T18:48:59.000

.NET 框架的某些版本不支持`Enum.GetValues`. 这是 Ideas 2.0 中的一个很好的解决方法[：紧凑框架中的 Enum.GetValues](https://web.archive.org/web/20100530072822/http://ideas.dalezak.ca/2008/11/enumgetvalues-in-compact-framework.html)：

```
public Enum[] GetValues(Enum enumeration)
{
    FieldInfo[] fields = enumeration.GetType().GetFields(BindingFlags.Static | BindingFlags.Public);
    Enum[] enumerations = new Enum[fields.Length];

    for (var i = 0; i < fields.Length; i++)
        enumerations[i] = (Enum) fields[i].GetValue(enumeration);

    return enumerations;
} 
```

与任何涉及[反射](https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection)的代码一样，您应该采取措施确保它只运行一次并缓存结果。

* * *

## 回答 #5

> 赞同：139
> 
> 时间：2013-03-17T04:15:08.950

使用`Cast<T>`：

```
var suits = Enum.GetValues(typeof(Suit)).Cast<Suit>(); 
```

给你，`IEnumerable<Suit>`.

* * *

## 回答 #6

> 赞同：109
> 
> 时间：2012-02-02T13:36:08.250

我认为这比其他建议更有效，因为`GetValues()`每次循环时都不会调用它。它也更简洁。如果`Suit`不是`enum`.

```
EnumLoop<Suit>.ForEach((suit) => {
    DoSomethingWith(suit);
}); 
```

`EnumLoop`有这个完全通用的定义：

```
class EnumLoop<Key> where Key : struct, IConvertible {
    static readonly Key[] arr = (Key[])Enum.GetValues(typeof(Key));
    static internal void ForEach(Action<Key> act) {
        for (int i = 0; i < arr.Length; i++) {
            act(arr[i]);
        }
    }
} 
```

* * *

## 回答 #7

> 赞同：85
> 
> 时间：2010-11-17T01:29:29.440

你不会`Enum.GetValues()`进入[Silverlight](http://en.wikipedia.org/wiki/Microsoft_Silverlight)。

[Einar Ingebrigtsen 的原始博客文章](http://web.archive.org/web/20101105013136/http://www.dolittle.no/blogs/einar/archive/2008/01/13/missing-enum-getvalues-when-doing-silverlight-for-instance.aspx)：

```
public class EnumHelper
{
    public static T[] GetValues<T>()
    {
        Type enumType = typeof(T);

        if (!enumType.IsEnum)
        {
            throw new ArgumentException("Type '" + enumType.Name + "' is not an enum");
        }

        List<T> values = new List<T>();

        var fields = from field in enumType.GetFields()
                     where field.IsLiteral
                     select field;

        foreach (FieldInfo field in fields)
        {
            object value = field.GetValue(enumType);
            values.Add((T)value);
        }

        return values.ToArray();
    }

    public static object[] GetValues(Type enumType)
    {
        if (!enumType.IsEnum)
        {
            throw new ArgumentException("Type '" + enumType.Name + "' is not an enum");
        }

        List<object> values = new List<object>();

        var fields = from field in enumType.GetFields()
                     where field.IsLiteral
                     select field;

        foreach (FieldInfo field in fields)
        {
            object value = field.GetValue(enumType);
            values.Add(value);
        }

        return values.ToArray();
    }
} 
```

* * *

## 回答 #8

> 赞同：65
> 
> 时间：2010-07-07T13:37:41.177

我的解决方案适用于[.NET Compact Framework](https://en.wikipedia.org/wiki/.NET_Compact_Framework) (3.5) 并支持**编译时的**类型检查：

```
public static List<T> GetEnumValues<T>() where T : new() {
    T valueType = new T();
    return typeof(T).GetFields()
        .Select(fieldInfo => (T)fieldInfo.GetValue(valueType))
        .Distinct()
        .ToList();
}

public static List<String> GetEnumNames<T>() {
    return typeof (T).GetFields()
        .Select(info => info.Name)
        .Distinct()
        .ToList();
} 
```

*   如果有人知道如何摆脱`T valueType = new T()`，我很乐意看到解决方案。

调用如下所示：

```
List<MyEnum> result = Utils.GetEnumValues<MyEnum>(); 
```

* * *

## 回答 #9

> 赞同：63
> 
> 时间：2008-09-19T20:37:17.390

我认为你可以使用

```
Enum.GetNames(Suit) 
```

* * *

## 回答 #10

> 赞同：55
> 
> 时间：2008-09-19T21:05:02.240

```
public void PrintAllSuits()
{
    foreach(string suit in Enum.GetNames(typeof(Suits)))
    {
        Console.WriteLine(suit);
    }
} 
```

* * *

## 回答 #11

> 赞同：53
> 
> 时间：2009-11-16T17:19:51.917

> ```
> foreach (Suit suit in Enum.GetValues(typeof(Suit))) { } 
> ```
> 
> 我听说过一些模糊的传言，说这非常慢。有人知道吗？– Orion Edwards 2008 年 10 月 15 日 1:31 7

我认为缓存数组会大大加快速度。看起来你每次都得到一个新数组（通过反射）。相当：

```
Array enums = Enum.GetValues(typeof(Suit));
foreach (Suit suitEnum in enums) 
{
    DoSomething(suitEnum);
} 
```

那至少快一点，ja？

* * *

## 回答 #12

> 赞同：52
> 
> 时间：2020-12-02T06:28:52.927

# 新的 .NET 5 解决方案：

[.NET 5为该`GetValues`](https://docs.microsoft.com/en-us/dotnet/api/system.enum.getvalues?view=net-5.0#System_Enum_GetValues__1)方法引入了一个新的通用版本：

```
Suit[] suitValues = Enum.GetValues<Suit>(); 
```

这是迄今为止最方便的方法。

foreach 循环中的用法：

```
foreach (Suit suit in Enum.GetValues<Suit>())
{

} 
```

并获取枚举名称：

```
string[] suitNames = Enum.GetNames<Suit>(); 
```

* * *

## 回答 #13

> 赞同：38
> 
> 时间：2013-06-15T08:22:46.090

只需结合最重要的答案，我就组合了一个非常简单的扩展：

```
public static class EnumExtensions
{
    /// <summary>
    /// Gets all items for an enum value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="value">The value.</param>
    /// <returns></returns>
    public static IEnumerable<T> GetAllItems<T>(this T value) where T : Enum
    {
        return (T[])Enum.GetValues(typeof (T));
    }
} 
```

它干净、简单，而且根据@Jeppe-Stig-Nielsen 的评论，速度很快。

* * *

## 回答 #14

> 赞同：38
> 
> 时间：2013-08-12T15:36:47.980

三种方式：

1.  `Enum.GetValues(type)`// 从 .NET 1.1 开始，不在 Silverlight 或 .NET Compact Framework 中
2.  `type.GetEnumValues()`// 仅在 .NET 4 及更高版本上
3.  `type.GetFields().Where(x => x.IsLiteral).Select(x => x.GetValue(null))`// 无处不在

*我不确定为什么要`GetEnumValues`在类型实例上引入。它对我来说根本不是可读的。*

* * *

像这样的助手类`Enum<T>`对我来说是最易读和最难忘的：

```
public static class Enum<T> where T : struct, IComparable, IFormattable, IConvertible
{
    public static IEnumerable<T> GetValues()
    {
        return (T[])Enum.GetValues(typeof(T));
    }

    public static IEnumerable<string> GetNames()
    {
        return Enum.GetNames(typeof(T));
    }
} 
```

现在你打电话：

```
Enum<Suit>.GetValues();

// Or
Enum.GetValues(typeof(Suit)); // Pretty consistent style 
```

如果性能很重要，也可以使用某种缓存，但我认为这根本不是问题。

```
public static class Enum<T> where T : struct, IComparable, IFormattable, IConvertible
{
    // Lazily loaded
    static T[] values;
    static string[] names;

    public static IEnumerable<T> GetValues()
    {
        return values ?? (values = (T[])Enum.GetValues(typeof(T)));
    }

    public static IEnumerable<string> GetNames()
    {
        return names ?? (names = Enum.GetNames(typeof(T)));
    }
} 
```

* * *

## 回答 #15

> 赞同：34
> 
> 时间：2016-01-22T18:50:07.490

有两种方法可以迭代一个`Enum`：

```
1\. var values =  Enum.GetValues(typeof(myenum))
2\. var values =  Enum.GetNames(typeof(myenum)) 
```

第一个将以 ** `object`**s 数组的形式为您提供值，第二个将以 ** `String`**s 数组的形式为您提供值。

`foreach`在循环中使用它，如下所示：

```
foreach(var value in values)
{
    // Do operations here
} 
```

* * *

## 回答 #16

> 赞同：25
> 
> 时间：2012-07-26T09:22:23.830

我使用 ToString() 然后拆分并解析标志中的吐出数组。

```
[Flags]
public enum ABC {
   a = 1,
   b = 2,
   c = 4
};

public IEnumerable<ABC> Getselected (ABC flags)
{
   var values = flags.ToString().Split(',');
   var enums = values.Select(x => (ABC)Enum.Parse(typeof(ABC), x.Trim()));
   return enums;
}

ABC temp= ABC.a | ABC.b;
var list = getSelected (temp);
foreach (var item in list)
{
   Console.WriteLine(item.ToString() + " ID=" + (int)item);
} 
```

* * *

## 回答 #17

> 赞同：19
> 
> 时间：2013-01-25T00:05:04.427

### 我不认为这更好，甚至更好。我只是在说明另一种解决方案。

如果枚举值的范围严格从 0 到 n - 1，则通用替代方案是：

```
public void EnumerateEnum<T>()
{
    int length = Enum.GetValues(typeof(T)).Length;
    for (var i = 0; i < length; i++)
    {
        var @enum = (T)(object)i;
    }
} 
```

如果枚举值是连续的并且您可以提供枚举的第一个和最后一个元素，则：

```
public void EnumerateEnum()
{
    for (var i = Suit.Spade; i <= Suit.Diamond; i++)
    {
        var @enum = i;
    }
} 
```

但这不是严格枚举，只是循环。第二种方法比任何其他方法都快得多......

* * *

## 回答 #18

> 赞同：17
> 
> 时间：2012-10-25T21:20:52.817

这是为[DDL](https://en.wikipedia.org/wiki/Data_definition_language)创建选择选项的工作示例：

```
var resman = ViewModelResources.TimeFrame.ResourceManager;

ViewBag.TimeFrames = from MapOverlayTimeFrames timeFrame
      in Enum.GetValues(typeof(MapOverlayTimeFrames))
      select new SelectListItem
      {
         Value = timeFrame.ToString(),
         Text = resman.GetString(timeFrame.ToString()) ?? timeFrame.ToString()
      }; 
```

* * *

## 回答 #19

> 赞同：17
> 
> 时间：2013-11-15T20:13:12.910

如果您需要在构建和运行时进行速度和类型检查，则此辅助方法比使用 LINQ 强制转换每个元素要好：

```
public static T[] GetEnumValues<T>() where T : struct, IComparable, IFormattable, IConvertible
{
    if (typeof(T).BaseType != typeof(Enum))
    {
        throw new ArgumentException(string.Format("{0} is not of type System.Enum", typeof(T)));
    }
    return Enum.GetValues(typeof(T)) as T[];
} 
```

你可以像下面这样使用它：

```
static readonly YourEnum[] _values = GetEnumValues<YourEnum>(); 
```

当然，您可以退货`IEnumerable<T>`，但这对您没有任何好处。

* * *

## 回答 #20

> 赞同：15
> 
> 时间：2017-03-31T07:08:44.860

将方法添加`public static IEnumerable<T> GetValues<T>()`到您的类中，例如：

```
public static IEnumerable<T> GetValues<T>()
{
    return Enum.GetValues(typeof(T)).Cast<T>();
} 
```

调用并传递您的枚举。现在您可以使用以下方法迭代它`foreach`：

```
 public static void EnumerateAllSuitsDemoMethod()
 {
     // Custom method
     var foos = GetValues<Suit>();
     foreach (var foo in foos)
     {
         // Do something
     }
 } 
```

* * *

## 回答 #21

> 赞同：13
> 
> 时间：2014-01-20T10:37:55.113

```
foreach (Suit suit in Enum.GetValues(typeof(Suit)))
{
} 
```

（当前接受的答案有一个我认为不需要的演员表（尽管我可能错了）。）

* * *

## 回答 #22

> 赞同：13
> 
> 时间：2014-04-08T15:44:35.690

我知道这有点乱，但如果你是单线的粉丝，这里有一个：

```
((Suit[])Enum.GetValues(typeof(Suit))).ToList().ForEach(i => DoSomething(i)); 
```

* * *

## 回答 #23

> 赞同：12
> 
> 时间：2015-06-28T06:12:48.770

这个问题出现在“ [C# Step by Step 2013](http://www.amazon.ca/Microsoft-Visual-2013-Step/dp/073568183X) ”​​的第 10 章

作者使用双 for 循环遍历一对 Enumerators（以创建一副完整的纸牌）：

```
class Pack
{
    public const int NumSuits = 4;
    public const int CardsPerSuit = 13;
    private PlayingCard[,] cardPack;

    public Pack()
    {
        this.cardPack = new PlayingCard[NumSuits, CardsPerSuit];
        for (Suit suit = Suit.Clubs; suit <= Suit.Spades; suit++)
        {
            for (Value value = Value.Two; value <= Value.Ace; value++)
            {
                cardPack[(int)suit, (int)value] = new PlayingCard(suit, value);
            }
        }
    }
} 
```

在这种情况下，`Suit`和`Value`都是枚举：

```
enum Suit { Clubs, Diamonds, Hearts, Spades }
enum Value { Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King, Ace} 
```

and`PlayingCard`是一个带有定义`Suit`and的卡片对象`Value`：

```
class PlayingCard
{
    private readonly Suit suit;
    private readonly Value value;

    public PlayingCard(Suit s, Value v)
    {
        this.suit = s;
        this.value = v;
    }
} 
```

* * *

## 回答 #24

> 赞同：10
> 
> 时间：2014-09-12T18:06:51.983

一种将枚举转换为您可以交互的东西的简单而通用的方法：

```
public static Dictionary<int, string> ToList<T>() where T : struct
{
   return ((IEnumerable<T>)Enum
       .GetValues(typeof(T)))
       .ToDictionary(
           item => Convert.ToInt32(item),
           item => item.ToString());
} 
```

进而：

```
var enums = EnumHelper.ToList<MyEnum>(); 
```

* * *

## 回答 #25

> 赞同：9
> 
> 时间：2015-10-01T10:14:30.743

如果您知道类型将是 an `enum`，但在编译时不知道确切的类型是什么怎么办？

```
public class EnumHelper
{
    public static IEnumerable<T> GetValues<T>()
    {
        return Enum.GetValues(typeof(T)).Cast<T>();
    }

    public static IEnumerable getListOfEnum(Type type)
    {
        MethodInfo getValuesMethod = typeof(EnumHelper).GetMethod("GetValues").MakeGenericMethod(type);
        return (IEnumerable)getValuesMethod.Invoke(null, null);
    }
} 
```

该方法`getListOfEnum`使用反射来获取任何枚举类型并返回`IEnumerable`所有枚举值中的一个。

用法：

```
Type myType = someEnumValue.GetType();

IEnumerable resultEnumerable = getListOfEnum(myType);

foreach (var item in resultEnumerable)
{
    Console.WriteLine(String.Format("Item: {0} Value: {1}",item.ToString(),(int)item));
} 
```

* * *

## 回答 #26

> 赞同：4
> 
> 时间：2017-10-11T04:50:31.340

`enum`类型被称为“枚举类型”不是因为它们是“枚举”值的容器（它们不是），而是因为它们是通过*枚举*该类型变量的可能值来定义的。

（实际上，这比这要复杂一些 - 枚举类型被认为具有“基础”整数类型，这意味着每个枚举值对应一个整数值（这通常是隐式的，但可以手动指定）。C# 被设计在某种程度上，您可以将该类型的*任何*整数填充到枚举变量中，即使它不是“命名”值。）

顾名思义，[System.Enum.GetNames 方法](https://msdn.microsoft.com/en-us/library/system.enum.getnames(v=vs.110).aspx)可用于检索作为枚举值名称的字符串数组。

编辑：应该建议使用[System.Enum.GetValues](https://msdn.microsoft.com/en-us/library/system.enum.getvalues(v=vs.110).aspx)方法。哎呀。

* * *

## 回答 #27

> 赞同：4
> 
> 时间：2019-10-05T14:53:31.907

要从枚举中获取 int 列表，请使用以下命令。有用！

```
List<int> listEnumValues = new List<int>();
YourEnumType[] myEnumMembers = (YourEnumType[])Enum.GetValues(typeof(YourEnumType));
foreach ( YourEnumType enumMember in myEnumMembers)
{
    listEnumValues.Add(enumMember.GetHashCode());
} 
```

* * *

## 回答 #28

> 赞同：3
> 
> 时间：2021-02-08T22:04:17.277

当你有这样的枚举时

```
enum DemoFlags
{
    DemoFlag = 1,
    OtherFlag = 2,
    TestFlag = 4,
    LastFlag = 8,
} 
```

有了这个任务

```
DemoFlags demoFlags = DemoFlags.DemoFlag | DemoFlags.TestFlag; 
```

需要这样的结果

```
"DemoFlag | TestFlag" 
```

此方法有助于：

```
public static string ConvertToEnumString<T>(T enumToConvert, string separator = " | ") where T : Enum
{
    StringBuilder convertedEnums = new StringBuilder();

    foreach (T enumValue in Enum.GetValues(typeof(T)))
    {
        if (enumToConvert.HasFlag(enumValue)) convertedEnums.Append($"{ enumValue }{separator}");
    }

    if (convertedEnums.Length > 0) convertedEnums.Length -= separator.Length;

    return convertedEnums.ToString();
} 
```

* * *

## 回答 #29

> 赞同：2
> 
> 时间：2022-02-07T23:33:41.893

一个简单的 Enum.GetNames( *EnumType* ) 应该可以工作

* * *

## 回答 #30

> 赞同：1
> 
> 时间：2017-01-09T23:39:34.143

您还可以使用反射直接绑定到枚举的公共静态成员：

```
typeof(Suit).GetMembers(BindingFlags.Public | BindingFlags.Static)
    .ToList().ForEach(x => DoSomething(x.Name)); 
```

* * *

## 回答 #31

> 赞同：1
> 
> 时间：2019-11-21T11:45:10.013

如果你有：

```
enum Suit
{
   Spades,
   Hearts,
   Clubs,
   Diamonds
} 
```

这：

```
foreach (var e in Enum.GetValues(typeof(Suit)))
{
    Console.WriteLine(e.ToString() + " = " + (int)e);
} 
```

将输出：

```
Spades = 0
Hearts = 1
Clubs = 2
Diamonds = 3 
```

* * *

## 回答 #32

> 赞同：0
> 
> 时间：2019-11-21T12:52:15.187

[LINQ](http://en.wikipedia.org/wiki/Language_Integrated_Query)通用方式：

```
 public static Dictionary<int, string> ToList<T>() where T : struct =>
        ((IEnumerable<T>)Enum.GetValues(typeof(T))).ToDictionary(value => Convert.ToInt32(value), value => value.ToString()); 
```

用法：

```
 var enums = ToList<Enum>(); 
```

* * *

## 回答 #33

> 赞同：-1
> 
> 时间：2021-02-02T10:36:01.853

我认为它可以帮助您尝试。

```
public class Program
{

    public static List<T> GetEnamList<T>()
    {
        var enums = Enum.GetValues(typeof(T)).Cast<T>().Select(v => v).ToList();
        return enums;
    }
    private void LoadEnumList()
    {
        List<DayofWeek> dayofweeks = GetEnamList<DayofWeek>();

        foreach (var item in dayofweeks)
        {
            dayofweeks.Add(item);
        }
    }
}

    public enum DayofWeek
    {
        Monday,
        Tuesday,
        Wensday,
        Thursday,
        Friday,
        Sturday,
        Sunday
    } 
```

# sharing - 您如何在线存储/共享您的个人文档？

> ID：105389
> 
> 赞同：1
> 
> 时间：2008-09-19T20:36:28.953
> 
> 标签：sharing, documents, storage

对于照片，我使用 Flickr。但是对于其他文档...您使用哪个基于 Web 的在线应用程序（托管或安装在您的个人网站上）来处理 PDF 或 word 文件？如果有用户管理，那也很棒（例如，您决定某些人或每个人都可以看到您的某些文档……）。

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-19T20:39:09.650

谷歌文档？
它能够存储 PDF，但您的 word 文档将被转换为 google doc 格式。（然后可以转换回 Word 或 RTF 或 PDF 等'

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T20:38:38.997

我个人使用[DropBox](http://www.getdropbox.com/)，但它没有访问控制。[但是， drop.io](http://drop.io/)具有密码保护，因此可以用于访问控制。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-27T14:48:46.147

我使用颠覆存储库。如果需要，我可以在 Web 上浏览它，但我通常使用 TortoiseSVN 在 Windows 机器上访问它。它受密码保护，甚至还具有版本控制功能！:-)

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T20:37:58.107

我用 ：

*   [下载.io](http://www.drop.io)
*   [投递箱](http://www.getdropbox.com)

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-20T17:20:06.390

Google Docs 的问题在于，它以自己的格式改变了上传文档的格式，带来了灾难性的后果（页面布局、链接、摘要......）。如果我愿意，我想要保持我的原始文件不变。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2009-09-19T05:16:09.510

过去，我创建了一个小型 TrueCrypt 容器，将我的文档压缩，将它们添加到 TrueCrypt 容器中，然后通过电子邮件将它们发送到我的 GMail 帐户。

繁琐但有效。您可以在桌面上设置 Ant 脚本来创建/更新 zip 并复制到 TrueCrypt 文件夹，然后执行电子邮件。

我也使用过并且正在使用 DropBox 来做同样的事情。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2009-10-20T06:15:33.570

我使用Microsoft Live 的[SkyDrive](http://skydrive.live.com/)；充足的空间和方便的访问，我可以使用我的 Hotmail 登录（无需记住单独的用户名/密码组合）。

# sql - 什么是索引以及如何使用它们来优化数据库中的查询？

> ID：105400
> 
> 赞同：33
> 
> 时间：2008-09-19T20:37:11.870
> 
> 标签：sql, sql-server, database-design

我正在维护一个相当大的应用程序和数据库，并注意到我们的一些存储过程中的一些数据库性能不佳。

我总是听说可以通过“添加索引”来提高性能。我当然不是 DBA，我不明白什么是索引，它们为什么有用，以及如何创建它们。

我基本上需要一个索引 101。

谁能给我资源让我学习？

* * *

## 回答 #1

> 赞同：34
> 
> 时间：2008-09-19T21:12:02.987

根据经验，索引应该位于您在连接或 where 子句中使用的任何字段上（如果它们有足够的不同值以使使用索引值得，那么只有少数可能值的字段不会从索引中受益为什么尝试索引位字段毫无意义）。

如果您的结构已经正式创建了主键（它应该这样做，我从不创建没有主键的表），那么根据定义，这些都是索引的，因为主键需要在其上具有唯一索引。人们经常忘记他们必须索引外键，因为在设置外键关系时不会自动创建索引。由于外键的目的是为您提供一个要加入的字段，因此大多数外键可能应该被索引。

索引一旦创建就需要维护。如果您有大量数据更改活动，它们可能会变得碎片化且性能下降，并且需要刷新。阅读有关索引的在线书籍。您还可以在此处找到创建索引语句的语法。

索引是一种平衡行为，您添加的每个索引通常都会增加数据插入、更新和删除的时间，但可能会加速复杂插入、更新和删除中的选择和连接。尽管上面的经验法则是一个很好的起点，但没有一个关于什么是最佳索引的公式。

* * *

## 回答 #2

> 赞同：25
> 
> 时间：2008-09-19T20:40:22.003

想一个类似于图书馆卡片目录的索引。索引使您不必在每个小岛或书架上搜索一本书。相反，您可能能够从常用字段中找到您想要的项目，例如 ID、名称等。当您构建索引时，数据库基本上会创建一些单独的内容，查询可以访问而不是扫描整个表. 您可以通过允许它搜索较小的数据子集或优化的数据集来加快查询速度。

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-09-19T20:47:36.960

索引是数据库系统用来快速查找数据的一种方法。现实世界的类比是书中的索引。如果作者/出版商在索引他们的书方面做得很好，那么读者只需查看索引就可以很容易地直接转到他们想要阅读的页面。数据库也是如此。如果在字段上创建索引，则数据库会对数据进行预排序。当对数据发出请求时，数据库使用索引来识别数据存储在硬盘上的哪个位置，并直接到那里。如果没有索引，数据库需要查看每条记录，以确定它是否符合查询条件。

查看索引的一种简单方法是考虑一副纸牌。没有索引的数据库就像一副牌，一张牌已经洗过。如果你想找到黑桃K，你需要一张一张地看每一张牌才能找到它。你可能很幸运，它可能是第一个，或者你可能很不幸，它可能是最后一个。

一个被索引的数据库，将一副牌中的所有牌从 A 到 K 排序，并且每个套件都放在自己的一堆中。现在寻找黑桃王要简单得多，因为您只需要查看包含黑桃的牌堆底部即可。

我希望这有帮助。请注意，尽管索引在关系数据库系统中是必需的，但如果您编写太多索引，它们可能会适得其反。网络上有很多很棒的文章，您可以在索引上阅读。我建议您在深入了解它们之前先阅读一些内容。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-09-19T20:40:10.520

索引基本上对给定列上的数据进行排序，然后存储该顺序，因此当您想要查找项目时，数据库可以通过使用二进制搜索（或其他一些优化的搜索方式）进行优化，而不是查看每一行.

因此，如果您要搜索的数据量很大，您绝对需要添加一些索引。

大多数数据库都有一个工具来解释您的查询将如何工作（对于 db2，它是 db2expln，对于 sqlserver 可能类似），以及一个建议索引和其他优化的工具（对于 db2，db2advis 可能与 sqlserver 类似）。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-19T21:58:00.163

如前所述，您可以拥有一个聚集索引和多个非聚集索引。在 SQL 2005 中，您还可以将其他列添加到非聚集索引中，这可以提高性能，因为索引中包含一些常用检索的​​列但不是键的一部分，从而完全消除了对表的访问。

用于确定 SQL Server 数据库正在做什么的#1 工具是分析器。您可以分析整个工作负载，然后查看它推荐的索引。您还可以查看执行计划以了解索引的影响。

索引过多的问题是由于写入数据库，并且必须更新所有将具有该行记录的索引。如果您有读取性能，可能不是因为索引太多，而是因为索引太少或太不合适。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-19T20:40:14.140

索引可以解释为寄存器中项目的排序列表。通过在索引中查找它的键，可以非常快速地在寄存器中查找项目的位置。接下来，索引中的键是指向寄存器中可以找到其余记录的位置的指针。

你可以在一个寄存器上有很多索引，但是你拥有的索引越多，插入新记录的速度就越慢（因为每个索引也需要一个新记录——按排序顺序，这也会增加时间）。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-19T20:42:20.063

在现有表中创建索引以更快、更有效地定位行。可以在表的一个或多个列上创建索引，并且每个索引都有一个名称。用户看不到索引，它们只是用来加快查询速度。

基本上，您的 DBMS 将创建某种树结构，以排序方式指向数据（来自一列）。这样更容易搜索该列上的数据。

[http://en.wikipedia.org/wiki/Index_(数据库)](http://en.wikipedia.org/wiki/Index_(database))

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-19T20:58:16.170

更多索引信息！

聚集索引是表中记录的实际物理布局。因此，每张桌子只能有一个。

非聚集索引就是前面提到的卡片目录。当然，书籍是按特定顺序排列的，但您可以按书本大小、页数或姓氏字母顺序排列目录中的卡片。

需要考虑的事情——创建过多的索引是一个常见的陷阱。每次更新数据时，您的数据库都必须搜索该索引并对其进行更新，将一条记录插入该表的每个索引中以获取该新行。在交易系统中（想想：纽约证券交易所的股票交易！），这可能是一个应用程序杀手。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-19T20:47:54.463

对于 mssql（可能还有其他），语法如下：

```
create index <indexname> on <tablename>(<column1>[,<column2>...]) 
```

# reporting-services - MS SQL 2005 Reporting Services 的第 3 方控件

> ID：105408
> 
> 赞同：2
> 
> 时间：2008-09-19T20:38:02.087
> 
> 标签：reporting-services, reportingservices-2005

任何人都可以为 MS SQL 2005 Reporting Services 推荐一个好的第 3 方控件。如果您知道一些开放库或此类控件的实现，它们也可能非常有用。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-19T20:59:55.497

如果您有预算，Dundas 会做很棒的 RS 插件：

[http://www.dundas.com/index.aspx](http://www.dundas.com/index.aspx)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T21:21:28.220

我同意，Dundas 有很好的控制。我在我的一个项目中使用了它。

这是我用来测试 CRI 的示例： http: [//www.codeplex.com/MSFTRSProdSamples/Wiki/View.aspx? title=SS2005%21Custom%20Report%20Item%20Sample&referringTitle=Home](http://www.codeplex.com/MSFTRSProdSamples/Wiki/View.aspx?title=SS2005%21Custom%20Report%20Item%20Sample&referringTitle=Home)

# windows - 给定程序使用什么端口？

> ID：105418
> 
> 赞同：100
> 
> 时间：2008-09-19T20:39:04.407
> 
> 标签：windows, networking

我希望能够弄清楚特定程序正在使用哪个端口。是否有任何可用的在线程序或 Windows 附带的程序可以告诉我哪些进程正在使用我计算机上的哪些端口？

PS - 在你因为不是编程问题而对它进行降级之前，我正在寻找测试一些网络代码的程序。

* * *

## 回答 #1

> 赞同：149
> 
> 时间：2008-09-19T20:41:49.283

`netstat -b -a`列出正在使用的端口，并为您提供正在使用每个端口的可执行文件。我相信您需要在管理员组中才能执行此操作，而且我不知道 Vista 上存在哪些安全隐患。

我通常`-n`也会添加以使其更快一点，但添加`-b`会使它变得很慢。

*编辑*：如果您需要的功能比 netstat 提供的更多，[vasac 建议](https://stackoverflow.com/questions/105418/what-port-is-a-given-program-using#105487)您尝试[TCPView](http://technet.microsoft.com/en-us/sysinternals/bb897437.aspx)。

* * *

## 回答 #2

> 赞同：42
> 
> 时间：2008-09-19T20:45:44.767

[TCPView](http://technet.microsoft.com/en-us/sysinternals/bb897437.aspx)可以做你所要求的。

* * *

## 回答 #3

> 赞同：25
> 
> 时间：2008-09-20T00:00:07.047

在 Vista 上，您确实需要提升权限才能将 -b 选项与 netstat 一起使用。为了解决这个问题，您可以运行“netstat -ano”，它将显示所有打开的端口以及相关的进程 ID。然后，您可以使用 tasklist 来查找哪个进程具有相应的 id。

```
C:\>netstat -ano

Active Connections

  Proto  Local Address          Foreign Address        State           PID
  ...
  TCP    [::]:49335             [::]:0                 LISTENING       1056
  ...

C:\>tasklist /fi "pid eq 1056"

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
sqlservr.exe                  1056 Services                   0     66,192 K 
```

* * *

## 回答 #4

> 赞同：13
> 
> 时间：2008-09-19T23:46:02.867

您可能已经安装了 Process Explorer（来自 Sysinternals，现在是 Microsoft 的一部分）。如果没有，请立即安装它 - 真是太酷了。

在 Process Explorer 中：找到有问题的进程，右键单击并选择 TCP/IP 选项卡。它甚至会为每个套接字显示一个堆栈跟踪，表示打开该套接字的代码。

* * *

## 回答 #5

> 赞同：7
> 
> 时间：2008-09-19T20:59:29.227

如果您更喜欢 GUI 界面[CurrPorts](http://www.nirsoft.net/utils/cports.html)是免费的，并且适用于所有版本的 windows。显示端口以及打开它们的进程。

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2008-09-19T20:48:49.593

“netstat -natp”是我一直使用的。

* * *

## 回答 #7

> 赞同：4
> 
> 时间：2013-08-03T02:03:55.197

Windows 8（可能还有 7 + Vista）也在资源监视器中提供了一个视图。如果您选择“网络”选项卡，则会有一个名为“侦听端口”的部分。可以按端口号排序，看看哪个进程在使用它。

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2008-09-19T20:41:47.147

Windows 附带该`netstat`实用程序，它应该完全符合您的要求。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-19T20:41:22.920

在命令行中， netstat -a 会给你很多信息。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-09-19T20:42:03.387

您可以为此使用“netstat”命令。[这里](http://www.petri.co.il/quickly_find_local_open_ports.htm)有做这种事情的描述。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-19T22:04:37.573

[开放端口扫描仪](http://www.download.com/Open-Ports-Scanner/3000-2085_4-10725872.html)为我工作。

* * *

## 回答 #12

> 赞同：-1
> 
> 时间：2008-09-19T20:41:06.040

大多数体面的防火墙程序应该允许您访问这些信息。我知道 Agnitum OutpostPro 防火墙可以。

# c - 函数调用中的 Malloc 似乎在返回时被释放？

> ID：105477
> 
> 赞同：16
> 
> 时间：2008-09-19T20:44:51.413
> 
> 标签：c, pointers, malloc

我想我已经把它归结为最基本的情况：

```
int main(int argc, char ** argv) {
  int * arr;

  foo(arr);
  printf("car[3]=%d\n",arr[3]);
  free (arr);
  return 1;
}

void foo(int * arr) {
  arr = (int*) malloc( sizeof(int)*25 );
  arr[3] = 69;
} 
```

输出是这样的：

```
> ./a.out 
 car[3]=-1869558540
 a.out(4100) malloc: *** error for object 0x8fe01037: Non-aligned pointer
                         being freed
 *** set a breakpoint in malloc_error_break to debug
> 
```

如果有人能阐明我的理解失败的地方，将不胜感激。

* * *

## 回答 #1

> 赞同：47
> 
> 时间：2008-09-19T20:48:17.473

您通过值而不是通过引用传递指针，因此无论您在 foo 中使用 arr 做什么都不会在 foo 函数之外产生影响。正如 m_pGladiator 所写的那样，一种方法是声明对指针的引用（顺便说一句，只有在 C++ 中才有可能。C 不知道引用）：

```
int main(int argc, char ** argv) {
  int * arr;

  foo(arr);
  printf("car[3]=%d\n",arr[3]);
  free (arr);
  return 1;
}

void foo(int * &arr ) {
  arr = (int*) malloc( sizeof(int)*25 );
  arr[3] = 69;
} 
```

另一种（更好的恕我直言）方法是不将指针作为参数传递，而是返回一个指针：

```
int main(int argc, char ** argv) {
  int * arr;

  arr = foo();
  printf("car[3]=%d\n",arr[3]);
  free (arr);
  return 1;
}

int * foo(void ) {
  int * arr;
  arr = (int*) malloc( sizeof(int)*25 );
  arr[3] = 69;
  return arr;
} 
```

您可以将指针传递给指针。这是通过引用传递的 C 方式。语法有点复杂，但很好 - 这就是 C 的方式......

```
int main(int argc, char ** argv) {
  int * arr;

  foo(&arr);
  printf("car[3]=%d\n",arr[3]);
  free (arr);
  return 1;
}

void foo(int ** arr ) {
  (*arr) = (int*) malloc( sizeof(int)*25 );
  (*arr)[3] = 69;
} 
```

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-09-19T20:48:12.467

您已在 foo 中分配了 arr，但该指针值存储在调用堆栈中。如果您想这样做，请这样做：

```
void foo( int ** arr) {
    *arr = (int *)malloc( sizeof(int) * 25 );
    (*arr)[3] = 69;
} 
```

主要是传递一个指向 foo 的指针（比如 foo(&arr)）

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-19T20:53:26.150

foo 接收 int 指针的本地副本，为其分配内存并在超出范围时泄漏该内存。

解决此问题以使 foo 返回指针的一种方法：

```
int * foo() {
  return (int*) malloc( sizeof(int)*25 );
}

int main() {
    int* arr = foo();
} 
```

另一种是将 foo 传递给一个指针

```
void foo(int ** arr) {
   *arr = malloc(...);
}

int main() {
    foo(&arr);
} 
```

在 C++ 中，修改 foo 以接受对指针的引用更简单。您在 C++ 中需要的唯一更改是将 foo 更改为

```
void foo(int * & arr) 
```

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T21:00:27.647

由于您按值传递指针，因此 main 内的 arr 指针并未指向分配的内存。这意味着两件事：你有一个内存泄漏（不，在函数 foo 完成后内存没有被释放），当你访问 main 内的 arr 指针时，你正在访问一些任意范围的内存，因此你不要't get 3 打印出来，因此 free() 拒绝工作。很幸运，在 main 中访问 arr[3] 时没有遇到分段错误。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T20:50:26.080

如果参数 (arr) 不是通过引用 (&) 传入的，则不能更改它的值。一般来说，你会想要返回指针，所以你的方法应该是：

arr=foo();

尝试重新分配参数是不好的。我不推荐 (&) 解决方案。

# c# - 您如何为开发/阶段/生产维护单独的 Web 服务

> ID：105479
> 
> 赞同：3
> 
> 时间：2008-09-19T20:45:03.723
> 
> 标签：c#, .net, asp.net, web-services

我们想为部署的不同步骤维护 3 个 Web 服务，但是我们如何在应用程序中定义要使用的服务呢？我们是否只维护 3 个 Web 引用并 ifdef 以某种方式使用它们？

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-09-19T20:46:22.800

不要维护代码中的差异，而是通过配置文件。这样，它们都运行相同的代码，只是具有不同的配置值（即要绑定的端口、要回答的主机名等）

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-19T21:10:24.300

正如其他人所提到的，您需要将此信息存储在配置文件中。事实上，我建议为每个环境使用不同的配置文件。这将解决每个环境有多个设置的不可避免的问题，例如，您可能对 Web 服务 URL 和 Web 服务端口有单独的设置，或者有一些额外的设置来处理 https/security。

综上所述，请确保您解决了这些潜在问题：

如果 Web 服务对应用程序做了任何特别重要的事情，您可能希望将应用程序与每个环境中的 Web 服务结合起来（即在每个环境中都有一个应用程序版本）。当然，当您这样做时，对界面的任何更改都会更容易。

确保您正在使用的 Web 服务版本对某人来说是显而易见的。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-19T20:48:54.697

我的建议是将这些信息保存在应用程序的配置文件中。更好的是在构建过程中将给定环境的适当值注入到配置中，假设您的构建过程具有某种宏替换功能。通过这种方式，您可以为给定环境创建有针对性的构建，而不必在每次为不同环境进行构建时都更改配置。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-20T04:16:41.127

当我上次使用 Web 服务器进行项目时，我们处理此问题如下：

*   `msbuild /t:deploy`将构建和部署到一个测试环境，该环境部分由团队共享，部分是特定于开发的。`$(SERVER)`的默认值为`$(USERNAME)`。
*   `msbuild /t:deploy /p:server=test`将部署到非开发人员可以查看的共享测试环境。
*   `msbuild /t:deploy /p:server=live`将部署到实时服务器。我想我添加了一个额外的握手，就像一个错误，除非你有`/p:secret=foo`，只是为了确保你没有意外地这样做。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-19T21:11:59.273

所有可以从开发到测试再到生产的东西都必须是可配置的。如果您有能力在产品安装过程中构建更新这些变量的过程，那就去做吧。（将自定义内容烘焙到构建中似乎是一个低劣的想法——对于相同版本的源代码，您最终会得到一堆不同的不兼容构建）

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-19T21:14:28.643

仅供参考，这是昨天在这里解决的：

[您如何在不同的暂存环境中维护 java webapps？](https://stackoverflow.com/questions/93944/how-do-you-maintain-java-webapps-in-different-staging-environments)

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T20:57:30.400

将服务地址和端口放入应用程序的配置中。在服务的配置中做同样的事情可能是个好主意，至少对于端口，这样您的开发服务就可以在正确的端口上进行侦听。这样，您不必仅仅为了更改您要访问的服务器/端口而修改您的代码。

使用配置而不是代码在开发、阶段和生产之间切换对于测试非常有价值。当您部署到生产环境时，您要确保部署的代码与测试过的完全相同，而不是稍有不同。您应该在开发和生产之间更改的只是配置。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-20T00:00:03.877

不使用 Web 引用，而是使用[wsdl.exe](http://msdn.microsoft.com/en-us/library/7h3ystb6(VS.80).aspx)从 Web 服务 WSDL 生成代理类。生成的类将具有一个 Url 属性，可以根据部署步骤（开发、质量保证、生产等）进行设置。

# wpf - 如何停止 Blend 2.5 June Preview 在 SL1.0 XAML 上用 Panel.ZIndex 替换 Canvas.ZIndex？

> ID：105480
> 
> 赞同：0
> 
> 时间：2008-09-19T20:45:15.547
> 
> 标签：wpf, silverlight, xaml, blend

我有一个使用 Blend 2.5 编辑的 Silverlight 1.0 应用程序。每当我在设计器中触摸`UIElement`具有 Canvas 属性的 a`Canvas.ZIndex="1"`时，当它更新 XAML 时，它会将 Canvas 前缀更改为 Panel，离开`Panel.ZIndex="1"`，导致页面无法加载。

我如何让它停止精神错乱！？！

我已经卸载了 2.5 并重新安装了较旧的 Blend 2 预览版，效果更好，但是与 VS2k8 的兼容性不太好，而且我不时也在处理一些 SL2.0 项目以及 WPF 应用程序，两者都有其中我更喜欢 Blend 2.5。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-20T17:12:23.117

看起来这是2.5中报告的错误，

[http://social.expression.microsoft.com/forums/en-US/blend/thread/db02b75c-922e-4de1-8943-bd525d9862c0/](http://social.expression.microsoft.com/forums/en-US/blend/thread/db02b75c-922e-4de1-8943-bd525d9862c0/)

他们建议的解决方法是为 SL1 使用 2.0。不过，我预计会很快发布新版本的 Blend，因为 SL2 可能会在今年（10 月底）的 PDC 前后发布。

# wcf - 如何使用凭据设置代理到生成的 WCF 客户端？

> ID：105499
> 
> 赞同：12
> 
> 时间：2008-09-19T20:47:36.227
> 
> 标签：wcf

如果客户使用带凭据的代理，我无法连接到我的 WCF 服务。我无法找到将凭据设置为生成的客户端代理的方法。

如果我使用网络服务，那么可以设置代理。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-20T15:45:32.687

我不完全确定这是否是您正在寻找的东西，但是您可以。

```
 MyClient client = new MyClient();
  client.ClientCredentials.UserName.UserName = "u";
  client.ClientCredentials.UserName.Password = "p"; 
```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2011-06-15T07:01:23.167

我通过将 Active Directory 用户添加到应用程序池>身份而不是网络服务来解决此问题。该用户也属于有权通过代理服务器浏览 Internet 的组。还要将此用户添加到客户端主机服务器上的 IIS_WPG 组。

在下面的代码中，第一位使用 WCF 服务对客户端进行身份验证。第二位假设将凭证传递给内部代理服务器，以便客户端调用 DMZ 服务器上的 WCF 服务。但我认为代理部分不起作用。无论如何，我要留下代码。

```
 // username token credentials
        var clientCredentials = new ClientCredentials();
        clientCredentials.UserName.UserName = ConfigurationManager.AppSettings["Client.Mpgs.Username"];
        clientCredentials.UserName.Password = ConfigurationManager.AppSettings["Client.Mpgs.Password"];
        proxy.ChannelFactory.Endpoint.Behaviors.Remove(typeof(ClientCredentials));
        proxy.ChannelFactory.Endpoint.Behaviors.Add(clientCredentials);

        // proxy credentials 
        //http://kennyw.com/indigo/143
        //http://blogs.msdn.com/b/stcheng/archive/2008/12/03/wcf-how-to-supply-dedicated-credentials-for-webproxy-authentication.aspx
        proxy.ChannelFactory.Credentials.Windows.ClientCredential = new System.Net.NetworkCredential
                                                                    (
                                                                        ConfigurationManager.AppSettings["Client.ProxyServer.Username"]
                                                                       , ConfigurationManager.AppSettings["Client.ProxyServer.Password"]
                                                                       , ConfigurationManager.AppSettings["Client.ProxyServer.DomainName"]
                                                                     ); 
```

在我的 web.config 中，我使用了以下内容，

```
<system.net>
    <defaultProxy useDefaultCredentials="true">
        <proxy usesystemdefault="True" proxyaddress="http://proxyServer:8080/" bypassonlocal="False" autoDetect="False"  />     </defaultProxy>
</system.net>
<system.serviceModel>
    <bindings>
        <wsHttpBinding>
            <binding name="WSHttpBinding_ITest" closeTimeout="00:01:00" openTimeout="00:01:00" receiveTimeout="00:10:00" sendTimeout="00:01:00" bypassProxyOnLocal="false" transactionFlow="false" hostNameComparisonMode="StrongWildcard" maxBufferPoolSize="524288" maxReceivedMessageSize="65536" messageEncoding="Text" textEncoding="utf-8" useDefaultWebProxy="true" allowCookies="false">
                <readerQuotas maxDepth="32" maxStringContentLength="8192" maxArrayLength="16384" maxBytesPerRead="4096" maxNameTableCharCount="16384"/>
                <reliableSession ordered="true" inactivityTimeout="00:10:00" enabled="false"/>
                <security mode="TransportWithMessageCredential">
                    <transport clientCredentialType="None" proxyCredentialType="None" realm=""/>
                    <message clientCredentialType="UserName" negotiateServiceCredential="true" algorithmSuite="Default"/>
                </security>
            </binding>
        </wsHttpBinding>
    </bindings>
    <client>
        <endpoint address="https://wcfservice.organisation.com/test/test.svc" binding="wsHttpBinding" bindingConfiguration="WSHttpBinding_ITest" contract="Test.Test" name="WSHttpBinding_ITest"/>
    </client>
</system.serviceModel> 
```

上面的代码在我的本地机器上工作。当我将代码上传到开发服务器时，它不起作用。我查看了代理服务器日志，它显示在下面，

2011-06-14 05:21:10 2 11.11.11.11 - - authentication_failed DENIED “组织/财务” - 407 TCP_DENIED CONNECT - tcp wcfservice.organisation.com 443 / - - - 11.11.11.11 612 161 -

2011-06-14 05:21:10 6 11.11.11.152 ServerName$ - policy_denied DENIED “组织/财务” - 403 TCP_DENIED CONNECT - tcp wcfservice.organisation.com 443 / - - - 11.11.11.205 185 361 -

我们的智能系统管理员 DF 将 Active Directory 用户添加到应用程序池>身份而不是网络服务。该用户也属于有权通过代理服务器浏览 Internet 的组。还要将此用户添加到客户端主机服务器上的 IIS_WPG 组。

这对我有用。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-20T15:44:46.790

不确定这是否是您要查找的内容，但以下是使用客户端凭据进行身份验证的工作代码示例。

```
 Dim client As ProductServiceClient = New ProductServiceClient("wsHttpProductService")
    client.ClientCredentials.UserName.UserName = "username"
    client.ClientCredentials.UserName.Password = "password"
    Dim ProductList As List(Of Product) = client.GetProducts()
    mView.Products = ProductList
    client.Close() 
```

# .net - .NET 中的“链接”语句是否有任何性能优势？

> ID：105504
> 
> 赞同：3
> 
> 时间：2008-09-19T20:47:55.633
> 
> 标签：.net, performance

从表中检索查找代码值时，有些人会这样做......

```
Dim dtLookupCode As New LookupCodeDataTable()
Dim taLookupCode AS New LookupCodeTableAdapter()
Dim strDescription As String

dtLookupCode = taLookupCode.GetDataByCodeAndValue("EmpStatus", "FULL")
strDescription = dtLookupCode.Item(0).Meaning 
```

...但是，我也看到像这样“链式”完成的事情...

```
strDescription = taLookupCode.GetDataByCodeAndValue("EmpStatus", "FULL").Item(0).Meaning 
```

...它首先绕过了查找代码数据表，因为表适配器知道其结果集的结构是什么样的。

使用“链式”方法是否节省了创建数据表对象的开销，或者它是否有效地被创建以正确处理 .Item(0).Meaning 语句？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-19T20:50:31.057

这两行将编译为同一件事。我会选择你更容易阅读的那个。内联通常指的是[有点不同](http://en.wikipedia.org/wiki/Inline_function)的东西。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-19T20:58:09.743

偏离“内联”部分，实际上，这两组代码不会编译成相同的东西。问题出现在：

```
Dim dtLookupCode As New LookupCodeDataTable()
Dim taLookupCode AS New LookupCodeTableAdapter() 
```

在 VB 中，这将使用适当命名的引用创建新对象。其次是：

```
dtLookupCode = taLookupCode.GetDataByCodeAndValue("EmpStatus", "FULL") 
```

我们立即用一个新对象替换原始`dtLookupCode`引用，这会创建要收集的垃圾（RAM 中无法访问的对象）。

因此，在确切的原始场景中，所谓的“内联”技术在*技术上*具有更高的性能。（但是，您不太可能在这个小示例中实际看到这种差异。）

如果原始示例如下所示，则代码基本相同的地方是：

```
Dim taLookupCode AS New LookupCodeTableAdapter
Dim dtLookupCode As LookupCodeDataTable
Dim strDescription As String

dtLookupCode = taLookupCode.GetDataByCodeAndValue("EmpStatus", "FULL")
strDescription = dtLookupCode.Item(0).Meaning 
```

在这个世界上，我们只有现有的引用，而不是创建垃圾对象。为了便于阅读，我稍微重新排序了这些语句，但要点是相同的。此外，您可以使用类似这样的方式轻松地对引用进行单行初始化，并且具有相同的基本思想：

```
Dim taLookupCode AS New LookupCodeTableAdapter
Dim dtLookupCode As LookupCodeDataTable = taLookupCode.GetDataByCodeAndValue("EmpStatus", "FULL")
Dim strDescription As String = dtLookupCode.Item(0).Meaning 
```

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T20:49:51.667

是的，不要说“内联”，因为这意味着其他语言中的特定内容。性能差异很可能为零或很小，这无关紧要，这只是一个偏好问题。您是想将其写在单独的语句中以使其更清晰，还是将其全部写在一行以更快地输入？

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-19T20:55:30.000

通常它只会降低代码的可读性。

通常，当人们使用这种“内联”（即链接）时，他们会多次重新访问类的属性或字段，而不是只获取一次并存储在局部变量中。这通常是一个坏主意，因为人们通常不知道该字段或属性是如何返回的。比如可能每次都计算一次，也可能计算一次后私下存放在类中。

这里有两个插图。第一个片段是要避免的：

```
if (ConfigurationManager.AppSettings("ConnectionString") == null)
{
    throw new MissingConfigSettingException("ConnectionString");
}

string connectionString = ConfigurationManager.AppSettings("ConnectionString"); 
```

第二种更可取：

```
string connectionString = ConfigurationManager.AppSettings("ConnectionString")

if (connectionString == null)
{
    throw new MissingConfigSettingException("ConnectionString");
} 
```

这里的问题是 AppSettings() 实际上必须在每次检索到值时对 AppSettings 集合进行拆箱：

```
// Disassembled AppSettings member of ConfigurationManager 

public static NameValueCollection AppSettings
{
    get
    {
        object section = GetSection("appSettings");

        if ((section == null) || !(section is NameValueCollection))
        {
            throw new
                ConfigurationErrorsException(SR.GetString("Config_appsettings_declaration_invalid"));
        }

        return (NameValueCollection) section;
    }
} 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-19T20:55:58.127

如果您想查看中间状态并单步完成各个阶段，则调试后者将变得更加困难。

我会考虑这里使用的屏幕空间数量的可读性，因为性能是一种洗涤。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-19T21:08:51.450

我称之为链式。

你问错问题了。

您需要问的是：哪个更具可读性？

如果链接使代码更易于阅读和理解，那么就去做吧。

但是，如果它混淆了，那么不要。

任何性能优化都不存在。不要优化代码，优化算法。

因此，如果您要调用 Item(1) 和 Item(2)，那么通过链接，您将一遍又一遍地创建相同的对象，这是一个糟糕的算法。

在这种情况下，第一个选项更好，因为您不需要每次都重新创建适配器。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-19T21:29:22.150

反对“链接”的一个原因是得[墨忒耳定律](http://en.wikipedia.org/wiki/Law_of_Demeter)表明您的代码在面对 LookupCodeDataTable 的更改时很脆弱。

您应该添加这样的函数：

```
function getMeaning( lookupCode as LookupCodeDataTable)
 getMeaning=lookupCode.Item(0).Meaning
end function 
```

并这样称呼它：

```
strDescription=getMeaning(taLookupCode.GetDataByCodeAndValue("EmpStatus", "FULL")) 
```

现在 getMeaning() 可以在许多其他地方调用，如果 LookupCodeDataTable 发生变化，那么您只需更改 getMeaning() 即可修复它。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-19T20:51:51.333

该结构仍在创建中，您只是没有它的参考。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-19T20:58:15.983

这：

```
dtLookupCode = taLookupCode.GetDataByCodeAndValue("EmpStatus", "FULL")
strDescription = dtLookupCode.Item(0).Meaning 
```

还有这个：

```
strDescription = taLookupCode.GetDataByCodeAndValue("EmpStatus", "FULL").Item(0).Meaning 
```

是完全等价的。

在第一个示例中，您有一个显式临时引用 (dtLookupTable)。在第二个示例中，临时引用是隐式的。在幕后，编译器几乎肯定会为这两者创建相同的代码。即使它*没有*发出相同的代码，额外的临时引用也非常便宜。

但是，我不确定这条线是否：

```
Dim dtLookupCode As New LookupCodeDataTable() 
```

是有效的。在我看来，这会创建一个新`LookupCodeDataTable`的，然后在您在后面的语句中覆盖变量时将其丢弃。我没有在 VB 中编程，但我希望这一行应该是：

```
Dim dtLookupCode As LookupCodeDataTable 
```

参考很便宜（可能是免费的），但构建一个额外的查找表可能不是。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-19T21:35:26.427

除非您需要通过 taLookupCode.GetDataByCodeAndValue("EmpStatus", "FULL") 或 Item(0) 多次引用返回的对象，否则它是相同的。否则，您不知道此函数的运行时是 log(n) 还是 n，所以最好的选择是，我会为其分配一个引用。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2009-12-09T21:35:20.423

除了可维护性之外，还有一个避免链接的原因：错误检查。

是的，您可以将整个事情包装在 try/catch 中，并捕获*链的任何部分*可以抛出的每个异常。

但是如果你想在没有 try/catch 的情况下在调用之间验证结果，你必须把事情分开。例如：

*   当 GetDataByCodeAndValue 返回 null 时会发生什么？
*   如果它返回一个空列表怎么办？

如果您正在链接，则无法在没有 try/catch 的情况下检查这些值。

# c# - F# 和企业软件

> ID：105515
> 
> 赞同：3
> 
> 时间：2008-09-19T20:49:11.293
> 
> 标签：c#, f#, functional-programming, enterprise

作为 1.0 版以来的 C# 开发人员，F# 占据了我过去几周的空闲时间。现在出售的计算机有 2、4 .. 内核和多线程并不总是很容易实现。

目前，我看到 F# 在处理复杂和/或繁重的工作负载方面具有巨大潜力。您认为 F# 会（曾经是 RTM）成为企业软件市场的重要参与者吗？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-19T21:40:44.103

我认为 F# 有很好的机会进入企业应用程序的一些利基领域，例如数学建模（例如，用于银行/交易应用程序）。从函数中消除副作用也为并行性和记忆化带来了巨大的机会。很难说这些语言是否会在主流开发中起飞很难说，但在我看来，问题更有可能是面向人的（即，对于熟悉 c# 等更典型语言的人来说，缺乏技能和高学习曲线/java/c++) 而不是技术。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T20:57:19.200

我认为无论 F# 是否成为企业软件的导入，能够以任何语言隔离代码的纯功能部分将是利用多核计算机潜力的关键。例如，Microsoft 的 .NET Parallel Extensions 非常棒，但由于并行化无法并行执行的代码，仍然存在很大的出错空间。如果代码是纯函数式语言或纯函数式语言的子集，那么您可以确保可以并行执行它。然后，诀窍是找出分配工作的最有效方法。

我想说，F# 在这方面所扮演的角色更像是一种催化剂，可以让人们的脚湿透，并开始以更具声明性的方式思考。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-21T11:35:11.953

我认为我们将看到一些功能性的东西将迁移到 C# 中，例如增加使用不可变类型和将函数标记为纯等。我看不到 F# 在企业开发中发挥更广泛的作用，这太神秘了对于普通的开发人员。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2009-11-17T04:14:01.880

C#/VB 将永远是主要语言，但 F# 更擅长处理复杂问题。C# 更通用，而 F# 更擅长 IA、统计、科学（例如寻找癌症的治愈方法）等。F# 永远不会取代 C#，但它将使 .NET 在更多的计算机科学领域竞争。至于数据挖掘和处理大量数据，最好直接在数据库中进行开发——比如 SQL Server 或 oracle。

至于 F# 难学，那只是因为我们被大多数其他语言的命令式思维方式“腐蚀”了。5年的时间，你很难忘记你所做的事情！此外，根据我的经验，ocaml 和 F# 使用起来很有趣。我对 F#/Ocaml 的唯一抱怨是大多数时候人们过度使用类型推断，这使得代码不可读。我宁愿声明变量类型以使其更易于维护。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-22T13:23:47.033

与 VB/C#/Java 相比，我认为 F# 将始终是一种小众语言，因为它确实需要更多的数学或计算机科学背景。然而，它是一种 CLR 语言这一事实​​意味着它将比早期的函数式语言具有更大的曝光率。

我在一家投资银行工作，我们已经将 F# 用于一些临时脚本目的，我们非常渴望看到 F# 的发布版本，以便我们可以考虑更正式地集成到我们的系统中（尽管它们很可能从根本上保持不变）基于 C#）。

# visual-studio - DSL图中未显示的隔间项目

> ID：105522
> 
> 赞同：0
> 
> 时间：2008-09-19T20:50:28.047
> 
> 标签：visual-studio, diagram, dsl

好的，自从我几天前提出[这个问题](https://stackoverflow.com/questions/82776/how-do-i-reference-a-diagram-in-a-dsl-t4-template)以来，我的 DSL 取得了显着进展。

一旦我重构了我的代码，我就会发布我自己的答案，但是现在，我遇到了另一个问题。

我从 DSL 创建的模型动态生成子图，将这些图保存为图像，然后生成嵌入这些图像的 Word 文档。到现在为止还挺好。

但是在我的形状有隔间的地方（例如，服务合同上的操作 - 你能猜到它是什么吗？），隔间标题会显示，但**没有任何项目**。

如果我检查我的形状对象，它有一个嵌套的子对象 - 一个 ElementListCompartment ，它又具有许多我期望显示的项目。ElementListCompartment.IsExpanded 属性设置为 true（并且隔间标题上有一个小“折叠”图标）但是我的物品在哪里，哦，在哪里？

形状被添加到图表中使用

```
parentShape.FixupChildShapes(modelElement); 
```

那么，谁能引导我走上我的快乐之路？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2009-07-01T10:40:45.440

我最近遇到了一个相关的问题，并设法使它工作，所以这就是故事。

我正在执行的任务是加载和显示由 ActiveWriter 的 DSL 包生成的域模型和关联图。

以下是我实现所需功能的方式（以下所有方法都属于我创建的 Form1 类）：

```
private Store LoadStore()
{
    var store = new Store();
    store.LoadDomainModels(typeof(CoreDesignSurfaceDomainModel), typeof(ActiveWriterDomainModel));
    return store;
}

private void LoadDiagram(Store store)
{
    using (var tx = store.TransactionManager.BeginTransaction("tx", true))
    {
        var validator = new ValidationController();
        var deserializer = ActiveWriterSerializationHelper.Instance;
        deserializer.LoadModelAndDiagram(store,
            @"..\..\ActiveWriter1.actiw", @"..\..\ActiveWriter1.actiw.diagram", null, validator);
        tx.Commit();
    }
}

private DiagramView CreateDiagramView()
{
    var store = LoadStore();
    LoadDiagram(store);

    using (var tx = store.TransactionManager.BeginTransaction("tx2", true))
    {
        var dir = store.DefaultPartition.ElementDirectory;
        var diag = dir.FindElements<ActiveRecordMapping>().SingleOrDefault();
        var view = new DiagramView(){Diagram = diag};
        diag.Associate(view);
        tx.Commit();

        view.Dock = DockStyle.Fill;
        return view;
    }
}

protected override void OnLoad(EventArgs e)
{
    var view = CreateDiagramView();
    this.Controls.Add(view);
} 
```

这些东西工作得很好：它正确地从用 Visual Studio 创建的文件中加载图表，在我的自定义窗口窗体中绘制图表，支持滚动画布，甚至允许我在这里拖动形状。然而，有一件事困扰着我——隔间是空的，并且有默认名称，即“隔间”。

谷歌根本没有帮助，所以我不得不自己挖掘。这不是很容易，但在 Reflector 的帮助下，花了几个小时后，我设法让这个场景按预期工作！

问题如下。令我惊讶的是，DSL 库在将某些图表元素添加到图表后不会立即正确地绘制它们。有时，只绘制某些形状的存根（如第一张图片所示）。因此，有时我们需要手动要求库重新绘制图表形状。

此功能可以使用所谓的“规则”来实现，这些“规则”实际上是由某些图表事件触发的事件处理程序。基本上我们要做的就是将某些处理程序附加到图表的元素添加事件并确保形状初始化。

幸运的是，我们甚至不需要编写任何代码，因为 DSL 设计器会自动生成修复规则和将这些规则附加到图表的实用方法（请参阅下面的 EnableDiagramRules）。我们所要做的就是在商店创建之后（在加载模型和图表之前）立即调用这个方法。

```
private Store LoadStore()
{
    var store = new Store();
    store.LoadDomainModels(typeof(CoreDesignSurfaceDomainModel), typeof(ActiveWriterDomainModel));
    ActiveWriterDomainModel.EnableDiagramRules(store);
    return store;
}

/// <summary>
/// Enables rules in this domain model related to diagram fixup for the given store.
/// If diagram data will be loaded into the store, this method should be called first to ensure
/// that the diagram behaves properly.
/// </summary>
public static void EnableDiagramRules(DslModeling::Store store)
{
    if(store == null) throw new global::System.ArgumentNullException("store");

    DslModeling::RuleManager ruleManager = store.RuleManager;
    ruleManager.EnableRule(typeof(global::Altinoren.ActiveWriter.FixUpDiagram));
    ruleManager.EnableRule(typeof(global::Altinoren.ActiveWriter.ConnectorRolePlayerChanged));
    ruleManager.EnableRule(typeof(global::Altinoren.ActiveWriter.CompartmentItemAddRule));
    ruleManager.EnableRule(typeof(global::Altinoren.ActiveWriter.CompartmentItemDeleteRule));
    ruleManager.EnableRule(typeof(global::Altinoren.ActiveWriter.CompartmentItemRolePlayerChangeRule));
    ruleManager.EnableRule(typeof(global::Altinoren.ActiveWriter.CompartmentItemRolePlayerPositionChangeRule));
    ruleManager.EnableRule(typeof(global::Altinoren.ActiveWriter.CompartmentItemChangeRule));
} 
```

上面的代码工作如下：

1.  在向图表添加新元素时（例如在图表的反序列化期间），规则“FixUpDiagram”被触发。

2.  然后该规则调用`Diagram.FixUpDiagram(parentElement, childElement)`， where`childElement`代表要添加的元素并`parentElement`代表其逻辑父级（使用棘手的条件逻辑确定，因此我没有尝试自己重现它）。

3.  向下堆栈跟踪 FixUpDiagram 方法调用`EnsureCompartments`图中所有类形状的方法。

4.  EnsureCompartments 方法重绘类的隔间，将存根“[-] 隔间”图形转换为完整的“属性”形状，如上面链接的图片所示。

PS史蒂夫，我注意到你确实调用了修复程序，但它仍然没有工作。好吧，我不是 DSL SDK 的专家（几天前才开始使用它），所以无法解释为什么你可能会遇到麻烦。

也许，您使用错误的参数调用了修复程序。或者，Diagram.FixupDiagram(parent, newChild) 的作用与 parent.FixupChildShapes(newChild) 的作用不同。但是，这是我的变体，它可以正常工作。希望这也有帮助。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-29T17:31:41.223

也许我的回答有点晚了，但是您是否使用 DSL Explorer 确认您的隔间有物品？

# vmware - VmWare 主硬盘扩展

> ID：105535
> 
> 赞同：3
> 
> 时间：2008-09-19T20:52:50.660
> 
> 标签：vmware, partitioning

我有一个 VmWare 虚拟机，它危险地接近它的主要 HDD 的限制，我需要扩展它。我该怎么做呢？我正在使用 VmWare Workstation 6.0.5

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-19T20:55:12.013

[该链接](http://www.seandeasy.com/expanding-a-drive-within-a-vmware-image/)提供了两种应该有所帮助的方法。

看起来这是最直接的方法：

```
vmware-vdiskmanager -x 12GB path\to\disk.vmdk 
```

其中 12GB 是扩展卷的所需大小。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T20:56:41.853

我不知道 6.0.5，但在以前的版本中，在 VMWare 的程序目录中曾经有一个名为 vmware-vdiskmanager 的程序。您可以使用它来扩展虚拟磁盘容器。

扩展容器后，您需要扩展客户机中的分区，您必须从“内部”执行此操作，这取决于您在客户机和文件系统上使用的操作系统。我经常使用 Ubuntu Life-CD 或 System-Rescue-CD ISO 以及 qtparted 来根据需要扩展分区。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2011-09-21T05:18:06.997

对我来说最简单的方法昨天工作了。我的同事给我建议。

1.  关闭连接了主 HDD 的主虚拟机（如果它正在运行）。
2.  在主要虚拟机首选项中扩展您的磁盘。（右键单击设置，右键单击主硬盘，选择实用程序，展开，...）
3.  将主磁盘附加到另一个虚拟机。启动另一个虚拟机。如果你去磁盘管理器，你可以看到，你的磁盘比分区大，调整它的大小。现在它可以工作了，因为你在不同的其他虚拟机上，而你的扩展磁盘不是你启动系统的地方，所以你可以在磁盘管理器（win GUI）中调整磁盘的大小。
4.  将主磁盘与其他虚拟机分离。
5.  启动您的主系统，您的主分区更大。

诀窍是您无法更改从 Windows 启动的分区的大小，因此您必须将其附加到另一个系统，调整它的大小，仅此而已。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T20:57:52.227

假设这是在 Windows 下，通常在“C:\Program Files\VMWare\VMware Workstation\”中有一个名为 vmware-vdiskmanager.exe 的程序，您可以使用它来执行此操作。打开 DOS 提示符和 CD 到该目录。扩展驱动器的命令是：

```
vmware-vdiskmanager.exe -x 50Gb NameOfDisk.vmdk 
```

此外，这不是您可以使用此命令执行的唯一操作。如果您只键入不带任何参数的命令，您将看到一堆其他可用选项。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T21:12:09.540

我在使用 vmware-vdiskmanager 应用程序时有时会遇到问题（它创建了额外的空间，但我无法使用它）。那时，我使用了 GParted live CD，效果很好。

# java - EJB 3 的最佳特性

> ID：105544
> 
> 赞同：21
> 
> 时间：2008-09-19T20:54:26.087
> 
> 标签：java, jakarta-ee, ejb-3.0

场景

*   您已经使用 EJB 版本 3 开发了一个 webapp。
*   该系统由客户部署、交付和使用。

如果您必须从头开始重写系统，您会再次使用 EJB 吗？

**否**：不要回答这个问题，而是回答[这个](https://stackoverflow.com/questions/161349/top-reason-not-to-use-ejb-30-again)问题。

**是**：根据您的个人经验，提供 EJB 解决的一个重要的、真实的问题。

让答案只包含**一个**问题。这将让其他读者投票选出 EJB 的最佳特性。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-19T21:18:50.897

我认为这取决于您正在谈论的 EJB 版本。让我们讨论仅有的两个相关（IMO）版本。

EJB 2.1 可能仍被遗留系统中的某些人使用。它们确实最常用作 RPC 抽象。他们还提供了一个基本的 ORM（对象关系映射）系统。正如您所提到的，提供了事务支持。因此，如果您正在构建一个希望与远程系统通信、传输面向对象数据并以事务方式进行的系统，您可能会发现 EJB 值得付出努力。否则，我会说远离。

然而，EJB 3.0 已经有了很大的改进。它具有以前版本的所有功能，但以更直接的方式实现。它还提供了一个与 Spring 不同的相当简单的 Inversion-Of-Control 框架，以及一个相当不错的 JPA（Java Persistence API）形式的 ORM。我使用过 EJB 3.0 并且非常喜欢它。您可以像使用 Spring 一样主张使用 EJB 3.0，而且它还有一些更高级或企业级的可用功能。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T21:02:13.370

嗯，这实际上取决于我们谈论的是哪些 EJB。我想说的是，即使是现在，MDB 仍然有用。对于实体 bean 和会话 bean，您肯定可以找到更好的方法。也许我仍然喜欢 EJB 的一个特性是可伸缩性。如果需要，您可以使用“远程”选项将 EJB 部署到不同的服务器。但是，我不认为这真的有必要，而且我只见过一个非常有用的大型项目。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T21:42:26.313

过去使用 EJB 2.1 做了很多工作，很高兴将其抛在脑后。

EJB 价值主张在 3.0 中仍然适用，并带有一个很好的轻量级编程模型。事务管理、并发、数据版本控制、状态管理，这些都是要正确解决的重要问题，Java EE 框架继续做得很好。

诚然，我使用 Hibernate 和 Seam 来进一步构建 Java EE 的一些特性，所以说 EJB 3.0 本身就是圣地对我来说是不公平的。然而，我发现有太多的开发人员在完全放弃 Java 并转向像 Rails 这样更流行的东西时，就把众所周知的婴儿扔了出去。

Seam 提供了一个很好的胶合框架，它使程序员的工作量非常低。当 EJB 与 POJO 更有意义时，还可以让您逐个项目地决定，而不必改变您的编程风格。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2014-09-02T02:05:15.937

使用 java ee 平台的主要原因是根据定义。您需要一个在经过全面审查、合规和兼容的平台中解决并发、可用性、事务管理、消息传递和管理问题的平台。是的，您可以通过将大量库粘合在一起并将其放在 tomcat 之上来自己完成这一切，但是当您可以写入执行标准、经过全面审查的平台时，为什么还要浪费所有时间审查和管理兼容性和功能集。任何 ee 容器都必须通过 tck，否则它不能携带 Java EE 名字对象。

各种人提出的关于ejb的“轻量级”，“类型”等的东西都是多余的。如果您不需要平台的功能集或保证所利用库的完全内部兼容性，那么 ejb（又名 java ee 平台）就过分了。但如果你真的要解决企业质量问题（见第一段），那么 ejb 和 java ee 平台将为你提供你所需要的。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-20T18:46:51.783

在使用 EJB 或一般的 J2EE 时，让很多人感到困扰的一件事是对运行 EJB 的应用程序服务器的依赖性。应用服务器倾向于支持一组特定的操作系统版本和 JVM 版本。没有运行时环境的重要部分的源代码也可能会变成一个挑战。

虽然原则上可以从一个供应商迁移到另一个供应商，但您需要非常了解它们在实现规范方面的细微差别，并远离供应商特定的扩展。

话虽如此，我接触过的应用服务器可以处理其中运行的代码的大量滥用，并且性能非常好。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2009-05-26T08:14:07.277

约定优于配置。

EJB 3 的默认行为通常是所需的行为。我认为 EJB 2.1 的主要问题是冗长配置文件的必要性，新的基于注释的配置解决了大部分问题。

# php - LAMP 中的 XAMPP 和 WAMP，哪个最好？

> ID：105546
> 
> 赞同：55
> 
> 时间：2008-09-19T20:54:43.433
> 
> 标签：php, mysql, apache

我们有很多`php + MySQL + Apache`组合选项......其中哪个是最好的组合？

让我们把我们的想法限制在`WAMP vs XAMPP`，有更好的选择吗？

我创建了一个名为 的在线编程竞赛网络应用程序`CodeFire`，`XAMPP`后来我不得不切换到`WAMP`，其中没有一个`php`脚本正常工作......我应该遵循什么标准？

* * *

## 回答 #1

> 赞同：35
> 
> 时间：2008-09-19T21:07:13.263

我个人喜欢 XAMPP。我有一个运行在我随身携带的拇指驱动器上的安装，这几乎是我在我碰巧在的任何机器上的 LAMP Web 开发的开发环境（我主要在 Windows 客户端机器上）。

小巧、功能齐全且稳定 - 非常适合我的需求。

* * *

## 回答 #2

> 赞同：19
> 
> 时间：2008-12-15T10:29:11.633

我喜欢[WAMP](http://www.wampserver.com/en/)最好的、真正简单的界面，我可以轻松地在 PHP 5.26/4.44/4.3.9、MySQL 5/4 和 Apache 2/1.3 的不同版本之间切换

* * *

## 回答 #3

> 赞同：11
> 
> 时间：2008-09-19T20:59:52.877

XAMPP 有利于开发和可移植性，这是肯定的。

LAMP 最适合性能和安全性（以及无处不在）。

WAMP ......好吧，如果你不想学习 Linux，我猜。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-09-19T20:59:34.000

LAMP 似乎是这些选项中最常见的一种，因此在严格找到您的问题的解决方案时，我会推荐 LAMP。

不过，这真的归结为最适合您的选择。如果您不了解 Linux，那么运行 WAMP 设置可能会使该过程更易于维护。尝试将您的经验和服务器所需的维护因素考虑到您的决定中。

就我个人而言，我为我的目的运行了一个 LAMP 服务器，因为我知道足够多的 Linux 来维护它，它最终成为我的目的的最佳解决方案。

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2010-02-02T02:27:47.363

我尝试了 XAMPP 并放弃了...我遇到了反斜杠问题（寡妇使用正斜杠）..因此，我的脚本都无法将任何文件保存到文件夹中，因为路径类似于 dir1\dir2\folder/image_folder/ image.jpg ...我尝试了 WAMP，它就像一个魅力..它没有抛出任何错误并按原意保存图像文件......所以..我想我会坚持使用 WAMP...如果有人可以，我将不胜感激告诉我 XAMPP 上的“madslashes”问题是如何解决的 ..我疯狂地用谷歌搜索..没有任何运气..谢谢

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2008-09-19T21:01:29.487

Xampp 是一个独立的开发包。

后两者将是安装在您的服务器上的完整生产堆栈 gnu/linux 或 windows server 2k*

因此，如果您想要一个可以删除的程序安装，请使用 xampp 进行开发，否则您可以在系统上完全安装它们。后者也会（显然）产生更好的性能。

就标准而言，lamp 更广泛的行业，windows 服务器倾向于运行 IIS 而不是 apache，但这并不意味着它们不能。他们是关于 php over windows 的书籍，但我认为易于使用和广泛适用于灯阵营。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-19T20:58:56.293

这完全取决于您管理的舒适度。如果正确设置，这些设置中的任何一个都可以是稳定、健壮和安全的。

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2008-09-19T21:03:33.507

我已经使用 WAMP 有一段时间了，从我收集的资料来看，它非常可靠。安装轻而易举，用户界面非常友好。

* * *

## 回答 #9

> 赞同：3
> 
> 时间：2010-11-15T17:16:01.583

[http://www.formboss.net/blog/2010/02/hosting-php-linux-vs-windows-benchmarks/](http://www.formboss.net/blog/2010/02/hosting-php-linux-vs-windows-benchmarks/)

他似乎对库存 mysql/apache/php 很满意

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2011-03-28T02:33:05.450

使用Wamp，新版本预装了xdebug，这对我来说很好，因为我第一次尝试安装xdebug，花了我很多时间<_<

没有尝试过 Xampp，但只是看到它没有捆绑 xdebug，我放弃了尝试：P

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-12-15T10:33:14.230

我在一个项目上使用 WIMP，没关系，没有什么可以写回家的：

WIMP：Windows、IIS、MySQL、PHP

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2010-08-25T07:27:45.480

对我来说，这取决于你的专业。它们都是伟大而可靠的。

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2011-01-05T18:43:11.593

我最喜欢 WAMP，直到我尝试卸载它，并意识到它留下了大量的垃圾，所以选择 XAMPP。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2009-05-14T06:22:11.803

我使用 xampp，因为它提供了简单的可升级性和可移植性。您可以轻松升级版本而无需麻烦。

我使用 xampp 的 7zip 安装程序版本，它非常适合频繁升级 php 和 phpmyadmin，以修复以前版本中引入的错误并具有新功能。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2010-09-26T08:34:53.207

我喜欢 xampp lite 作为开发服务器。我只是拿一台旧电脑，重新安装windows并下载并安装。把网卡改成静态，启动时开启Apacie和mysql。它们作为服务运行。我将驱动器设置为共享，当我想使用它时，我将文件复制到 htdocs 区域并将浏览器转到该 IP。

好简单。

# exception - 是什么导致 Tomcat 中带有 EOF 或 isHexDigit 消息的 java.io.CharConversionException？

> ID：105551
> 
> 赞同：12
> 
> 时间：2008-09-19T20:55:39.953
> 
> 标签：exception, tomcat, encoding

这个异常在我们的生产 catalina 日志中添加了一个简单的“getParameter()”调用。

```
警告：参数：字符解码失败。参数被跳过。

java.io.CharConversionException：EOF
    在 org.apache.tomcat.util.buf.UDecoder.convert(UDecoder.java:82)
    在 org.apache.tomcat.util.buf.UDecoder.convert(UDecoder.java:48)
    在 org.apache.tomcat.util.http.Parameters.urlDecode(Parameters.java:411)
    在 org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:393)
    在 org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:509)
    在 org.apache.tomcat.util.http.Parameters.handleQueryParameters(Parameters.java:266)
    在 org.apache.catalina.connector.Request.parseParameters(Request.java:2361)
    在 org.apache.catalina.connector.Request.getParameter(Request.java:1005)
    在 org.apache.catalina.connector.RequestFacade.getParameter(RequestFacade.java:353)
    在 javax.servlet.ServletRequestWrapper.getParameter(ServletRequestWrapper.java:158)

```

或者有时：

```
java.io.CharConversionException: isHexDigit
    在 org.apache.tomcat.util.buf.UDecoder.convert(UDecoder.java:87)
    在 org.apache.tomcat.util.buf.UDecoder.convert(UDecoder.java:48)
    在 org.apache.tomcat.util.http.Parameters.urlDecode(Parameters.java:411)
    在 org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:393)
    在 org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:509)
    在 org.apache.tomcat.util.http.Parameters.handleQueryParameters(Parameters.java:266)
    在 org.apache.catalina.connector.Request.parseParameters(Request.java:2361)
    在 org.apache.catalina.connector.Request.getParameter(Request.java:1005)
    在 org.apache.catalina.connector.RequestFacade.getParameter(RequestFacade.java:353)
    在 javax.servlet.ServletRequestWrapper.getParameter(ServletRequestWrapper.java:158)

```

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-19T21:54:23.727

这里只是假设。似乎参数或其值的 URL 解码失败（URL 编码意味着使用 %XX 或 %XXXX 符号对某些字符进行编码，其中 XX 或 XXXX 是 ISO-8859-1 或 Unicode 中字符的十六进制代码）。在第一种情况下，可能会发生错误，因为 % 字符后没有足够的十六进制字符。在第二种情况下，这可能会发生，因为 % 字符之后的字符不是十六进制的。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-24T16:38:39.530

要调查的另一件事是[Tomcat“连接器”配置中的 URIEncoding。](http://tomcat.apache.org/tomcat-5.5-doc/config/http.html)如果链接在 UTF-8 编码的页面中，它将使用 UTF-8 将 URL 编码为字节，然后 URL 对需要它的任何字节进行编码。但是，默认情况下，Tomcat 认为这些字节是 ISO-8859-1，这可能会导致问题。

反之亦然：如果页面是 ISO-8859-1，并且 Tomcat 的 URIEncoding 已设置为 UTF-8，则可能会导致类似的错误。

以下是关于该领域问题的有用讨论：[JSP/Servlet 容器中的字符集陷阱](http://weblogs.java.net/blog/joconner/archive/2005/07/charset_traps.html)

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2010-08-13T03:11:10.730

当用户通过 ajax 请求发送 '%' 时，我开始收到此错误。原来我在发出请求之前并没有转义参数。[此博客文章](http://ninadgawad.wordpress.com/2008/08/21/character-decoding-error-while-retriving-parameters-in-servlet/)中涵盖了此方案和修复的完整记录

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2009-04-10T15:57:24.747

也可能是这样的（来自维基百科）：

Unicode 字符存在非标准编码：%uxxxx，其中 xxxx 是表示为四个十六进制数字的 Unicode 值。此行为未由任何 RFC 指定，并且已被 W3C 拒绝。第三版 ECMA-262 仍然包括一个使用这种语法的 escape(string) 函数，还有一个 encodeURI(uri) 函数，它可以转换为 UTF-8 并对每个八位字节进行百分比编码。

所以你可以在 Javascript 中使用旧的转义函数，但由于 Tomcat 的更高版本对这些事情更严格（5.5.17 让这个编码滑动），现在你才开始看到异常。

# sql - 从 XML 自动生成 SQL 模式

> ID：105556
> 
> 赞同：2
> 
> 时间：2008-09-19T20:56:18.813
> 
> 标签：sql, xml, unit-testing

我们正在尝试将 SQL Server 2003 数据库用于我们的测试记录，并希望有一种快速的方法来获取 NUnit 和 NAnt 输出并生成 SQL 模式和数据。有没有一种简单的方法可以使用描述这些 XML 文档的 XSD 文件生成 SQL Schema？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T21:00:43.747

您可以使用 XSD。不，我认真的。转到命令提示符并键入 xsd 并按 Enter。

这是您将看到的（截断的）：

```
I:\>xsd
Microsoft (R) Xml Schemas/DataTypes support utility
[Microsoft (R) .NET Framework, Version 1.0.3705.0]
Copyright (C) Microsoft Corporation 1998-2001\. All rights reserved.

xsd.exe -
    Utility to generate schema or class files from given source.

xsd.exe <schema>.xsd /classes|dataset [/e:] [/l:] [/n:] [/o:] [/uri:]
xsd.exe <assembly>.dll|.exe [/outputdir:] [/type: [...]]
xsd.exe <instance>.xml [/outputdir:]
xsd.exe <schema>.xdr [/outputdir:] 
```

只需按照说明进行操作。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-11-28T12:48:22.483

由于 XSD 在主从关系方面模棱两可，我怀疑自动生成是可能的。

例如，声明如

```
<xs:element name="foo" type="footype" minOccurs="0" maxOccurs="unbounded" /> 
```

可以解释为子表 "foo" (1:n) 或 n:m 关系。

minOccurs="0" maxOccurs="1" 可以是可为空的列，或可选的 1:1 关系。

type="xs:string" maxOccurs="1" 是字符串 ((n)varchar) 列，或可选查找；但 type="xs:string" maxOccurs="unbounded" 是一个带有 (n)varchar 列的详细信息表。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2009-12-05T11:05:56.377

有一个名为[ShreX](http://shrex.sourceforge.net/)的工具可以从 xsd 生成模式并从 XML 插入。它会尝试自己执行此操作（您可以对 xsd 进行注释以控制它）。如果你想自己决定结构，它可能不是你想要的。

# sql - 是否可以构建以下 SQL 查询

> ID：105564
> 
> 赞同：4
> 
> 时间：2008-09-19T20:57:17.220
> 
> 标签：sql, mysql, database

原始查询如下所示（MySQL）：

```
SELECT * 
FROM books 
WHERE title LIKE "%text%" OR description LIKE "%text%" 
ORDER BY date 
```

是否可以重写它（没有联合或过程），所以结果将如下所示：

*   标题匹配查询的书籍列表，按日期排序，后跟：
*   描述与按日期排序的查询匹配的书籍列表

因此，基本上只是将匹配标题置于描述之上。

* * *

## 回答 #1

> 赞同：18
> 
> 时间：2008-09-19T21:00:12.187

在 sql server 中，我会执行以下操作：

```
select * from books 
where title like '%text%' or description like '%text%'
order by case when title like '%text%' then 1 else 2 end, date 
```

我不确定您是否可以在 mysql 的 ORDER BY 中包含不在 SELECT 中的列，但这是我使用的原则。否则，只需在 SELECT 中包含派生列。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-19T21:00:20.377

```
select * from books 
where title like "%text%" or description like "%text%" 
order by date, case when title like "%text%" then 0 else 1 end 
```

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T21:03:25.533

rjk 的建议是正确的方法。但是请记住，这个查询（有或没有联合）不能使用索引，所以它不能很好地扩展。您可能想查看 MySQL 的全文索引，它可以更好地扩展，允许更复杂的查询，甚至有助于结果排名。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T21:05:42.613

您可以使用案例进行排序：

```
order by case when title like '%text%' then 0 else 1 end 
```

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T21:06:28.787

像这样的东西怎么样...

```
select *  
from books  
where title like "%text%"  
or description like "%text%"  
order by case when title like "%text%" then 1 else 0 end desc, date 
```

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-20T17:36:10.720

```
DECLARE @Books TABLE
(
    [ID] INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
    [Title] NVARCHAR(MAX) NOT NULL,
    [Description] NVARCHAR(MAX) NOT NULL,
    [Date] DATETIME NOT NULL
)

INSERT INTO @Books
SELECT 'War and Peace','A Russian Epic','2008-01-01' UNION
SELECT 'Dogs of War','Mercenary Stories','2006-01-01' UNION
SELECT 'World At Arms','A Story of World War Two','2007-01-01' UNION
SELECT 'The B Team','Street Wars','2005-01-01' 

SELECT * FROM
(
    SELECT *, CASE WHEN [Title] LIKE '%war%' THEN 1 WHEN [Description] LIKE '%war%' THEN 2 END AS Ord
    FROM @Books
    WHERE [Title] LIKE '%war%' OR [Description] LIKE '%war%'
) AS Derived
ORDER BY Ord ASC, [Date] ASC 
```

我相信这会给你你想要的，但是由于派生的 CASE 语句中的额外工作量，它可能没有很好的性能。

* * *

## 回答 #7

> 赞同：-2
> 
> 时间：2008-09-19T20:59:14.483

union 命令会帮助你。这些方面的东西：

```
SELECT *, 1 as order from books where title like '%text%'
union
SELECT *, 2 as order from books where description like '%text%'
ORDER BY order, date 
```

# windows - 哪种 RTOS 最适合在装有 Windows 的同一台 PC 上工作？

> ID：105568
> 
> 赞同：3
> 
> 时间：2008-09-19T20:57:34.300
> 
> 标签：windows, rtos

哪种 RTOS 最适合在装有 Windows 的同一台 PC 上工作？

我知道 RTX 和 INtime，但没有使用它们。还有其他人吗？你最喜欢哪一个，为什么？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2009-11-20T01:22:58.263

我会尝试eCos。它在 i386 上运行，免费，具有强大的工具支持，并且包括现成的板级支持包。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T21:55:19.920

QNX 广泛用于飞机电子设备。但是，几乎任何操作系统都可以使用 VMWare 或双引导在 Windows 内部运行。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2014-05-05T21:41:01.500

如果您希望在实时系统中获得很多乐趣，为什么不尝试使用 Ubuntu 的实时补丁并将您拥有的旧计算机变成实时桌面或使用 virtualbox 或其他东西。这是一个链接，您会发现它对设置很有用：

[http://viswanathj.wordpress.com/2011/02/15/real-time-operating-system-installation-on-ubuntu-linux/](http://viswanathj.wordpress.com/2011/02/15/real-time-operating-system-installation-on-ubuntu-linux/)

[https://help.ubuntu.com/community/UbuntuStudio/RealTimeKernel](https://help.ubuntu.com/community/UbuntuStudio/RealTimeKernel)

这适用于 10.04 LTS、带有 Intel、AMD 和 ARM 处理器等的 x86 架构。

干杯！！

# php - 将所有表和字段更改为 MYSQL 中的 utf-8-bin 排序规则的脚本

> ID：105572
> 
> 赞同：57
> 
> 时间：2008-09-19T20:58:02.023
> 
> 标签：php, sql, mysql, utf-8, collation

`SQL`是否有`PHP`我可以运行的脚本来更改数据库中所有表和字段中的默认排序规则？

我可以自己写一个，但我认为这应该是在这样的网站上很容易获得的东西。如果我能在有人发布之前自己想出一个，我会自己发布。

* * *

## 回答 #1

> 赞同：86
> 
> 时间：2009-03-21T18:41:36.047

可以在单个命令中完成（而不是 PHP 的 148 个）：

```
mysql --database=dbname -B -N -e "SHOW TABLES" \
| awk '{print "SET foreign_key_checks = 0; ALTER TABLE", $1, "CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci; SET foreign_key_checks = 1; "}' \
| mysql --database=dbname & 
```

您必须喜欢命令行...（您可能需要使用`--user`和`--password`选项`mysql`）。

编辑：为了避免外键问题，添加`SET foreign_key_checks = 0;`和`SET foreign_key_checks = 1;`

* * *

## 回答 #2

> 赞同：41
> 
> 时间：2010-06-22T05:16:30.120

我认为在运行 PhpMyAdmin 的两个步骤中很容易做到这一点。
**第1步：**

```
SELECT CONCAT('ALTER TABLE `', t.`TABLE_SCHEMA`, '`.`', t.`TABLE_NAME`,
 '` CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci;') as stmt 
FROM `information_schema`.`TABLES` t
WHERE 1
AND t.`TABLE_SCHEMA` = 'database_name'
ORDER BY 1 
```

**第 2 步：**
此查询将输出一个查询列表，每个表一个。您必须复制查询列表，并将它们粘贴到命令行或 PhpMyAdmin 的 SQL 选项卡以进行更改。

* * *

## 回答 #3

> 赞同：27
> 
> 时间：2008-09-19T22:59:52.213

好的，我写这个是考虑到这个线程中所说的。感谢您的帮助，我希望这个脚本能帮助其他人。我对其使用没有任何保证，因此请在运行前备份。它*应该*适用于所有数据库；它对我自己很好。

编辑：在顶部添加了要转换为的字符集/整理的变量。EDIT2：更改数据库和表的默认字符集/整理

```
<?php

function MysqlError()
{
    if (mysql_errno())
    {
        echo "<b>Mysql Error: " . mysql_error() . "</b>\n";
    }
}

$username = "root";
$password = "";
$db = "database";
$host = "localhost";

$target_charset = "utf8";
$target_collate = "utf8_general_ci";

echo "<pre>";

$conn = mysql_connect($host, $username, $password);
mysql_select_db($db, $conn);

$tabs = array();
$res = mysql_query("SHOW TABLES");
MysqlError();
while (($row = mysql_fetch_row($res)) != null)
{
    $tabs[] = $row[0];
}

// now, fix tables
foreach ($tabs as $tab)
{
    $res = mysql_query("show index from {$tab}");
    MysqlError();
    $indicies = array();

    while (($row = mysql_fetch_array($res)) != null)
    {
        if ($row[2] != "PRIMARY")
        {
            $indicies[] = array("name" => $row[2], "unique" => !($row[1] == "1"), "col" => $row[4]);
            mysql_query("ALTER TABLE {$tab} DROP INDEX {$row[2]}");
            MysqlError();
            echo "Dropped index {$row[2]}. Unique: {$row[1]}\n";
        }
    }

    $res = mysql_query("DESCRIBE {$tab}");
    MysqlError();
    while (($row = mysql_fetch_array($res)) != null)
    {
        $name = $row[0];
        $type = $row[1];
        $set = false;
        if (preg_match("/^varchar\((\d+)\)$/i", $type, $mat))
        {
            $size = $mat[1];
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} VARBINARY({$size})");
            MysqlError();
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} VARCHAR({$size}) CHARACTER SET {$target_charset}");
            MysqlError();
            $set = true;

            echo "Altered field {$name} on {$tab} from type {$type}\n";
        }
        else if (!strcasecmp($type, "CHAR"))
        {
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} BINARY(1)");
            MysqlError();
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} VARCHAR(1) CHARACTER SET {$target_charset}");
            MysqlError();
            $set = true;

            echo "Altered field {$name} on {$tab} from type {$type}\n";
        }
        else if (!strcasecmp($type, "TINYTEXT"))
        {
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} TINYBLOB");
            MysqlError();
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} TINYTEXT CHARACTER SET {$target_charset}");
            MysqlError();
            $set = true;

            echo "Altered field {$name} on {$tab} from type {$type}\n";
        }
        else if (!strcasecmp($type, "MEDIUMTEXT"))
        {
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} MEDIUMBLOB");
            MysqlError();
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} MEDIUMTEXT CHARACTER SET {$target_charset}");
            MysqlError();
            $set = true;

            echo "Altered field {$name} on {$tab} from type {$type}\n";
        }
        else if (!strcasecmp($type, "LONGTEXT"))
        {
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} LONGBLOB");
            MysqlError();
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} LONGTEXT CHARACTER SET {$target_charset}");
            MysqlError();
            $set = true;

            echo "Altered field {$name} on {$tab} from type {$type}\n";
        }
        else if (!strcasecmp($type, "TEXT"))
        {
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} BLOB");
            MysqlError();
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} TEXT CHARACTER SET {$target_charset}");
            MysqlError();
            $set = true;

            echo "Altered field {$name} on {$tab} from type {$type}\n";
        }

        if ($set)
            mysql_query("ALTER TABLE {$tab} MODIFY {$name} COLLATE {$target_collate}");
    }

    // re-build indicies..
    foreach ($indicies as $index)
    {
        if ($index["unique"])
        {
            mysql_query("CREATE UNIQUE INDEX {$index["name"]} ON {$tab} ({$index["col"]})");
            MysqlError();
        }
        else
        {
            mysql_query("CREATE INDEX {$index["name"]} ON {$tab} ({$index["col"]})");
            MysqlError();
        }

        echo "Created index {$index["name"]} on {$tab}. Unique: {$index["unique"]}\n";
    }

    // set default collate
    mysql_query("ALTER TABLE {$tab}  DEFAULT CHARACTER SET {$target_charset} COLLATE {$target_collate}");
}

// set database charset
mysql_query("ALTER DATABASE {$db} DEFAULT CHARACTER SET {$target_charset} COLLATE {$target_collate}");

mysql_close($conn);
echo "</pre>";

?> 
```

* * *

## 回答 #4

> 赞同：23
> 
> 时间：2008-09-19T21:01:16.383

当心！如果您实际上将 utf 存储为另一种编码，那么您的手上可能会一团糟。先备份。然后尝试一些标准方法：

例如 [http://www.cesspit.net/drupal/node/898](http://www.cesspit.net/drupal/node/898) [http://www.hackszine.com/blog/archive/2007/05/mysql_database_migration_latin.html](http://www.hackszine.com/blog/archive/2007/05/mysql_database_migration_latin.html)

我不得不求助于将所有文本字段转换为二进制，然后再转换回 varchar/text。这救了我的屁股。

我的数据是 UTF8，存储为 latin1。我做了什么：

删除索引。将字段转换为二进制。转换为 utf8 通用 ci

如果您在 LAMP 上，请不要忘记在与数据库交互之前添加 set NAMES 命令，并确保设置字符编码标头。

* * *

## 回答 #5

> 赞同：13
> 
> 时间：2008-09-19T21:04:35.827

此 PHP 片段将更改数据库中所有表的排序规则。（取自[本站](http://www.webhostingtalk.com/showthread.php?t=682119)。）

```
<?php
// your connection
mysql_connect("localhost","root","***");
mysql_select_db("db1");

// convert code
$res = mysql_query("SHOW TABLES");
while ($row = mysql_fetch_array($res))
{
    foreach ($row as $key => $table)
    {
        mysql_query("ALTER TABLE " . $table . " CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci");
        echo $key . " =&gt; " . $table . " CONVERTED<br />";
    }
}
?> 
```

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2013-04-18T09:26:19.377

另一种使用命令行的方法，基于@david，没有`awk`

```
for t in $(mysql --user=root --password=admin  --database=DBNAME -e "show tables";);do echo "Altering" $t;mysql --user=root --password=admin --database=DBNAME -e "ALTER TABLE $t CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci;";done 
```

美化了

```
 for t in $(mysql --user=root --password=admin  --database=DBNAME -e "show tables";);
    do 
       echo "Altering" $t;
       mysql --user=root --password=admin --database=DBNAME -e "ALTER TABLE $t CONVERT TO CHARACTER SET utf8 COLLATE utf8_unicode_ci;";
    done 
```

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2011-06-03T01:58:01.323

可以在此处找到上述脚本的更完整版本：

[http://www.zen-cart.com/index.php?main_page=product_contrib_info&products_id=1937](http://www.zen-cart.com/index.php?main_page=product_contrib_info&products_id=1937)

请在此处留下有关此贡献的任何反馈：[http ://www.zen-cart.com/forum/showthread.php?p=1034214](http://www.zen-cart.com/forum/showthread.php?p=1034214)

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-19T21:46:38.397

字符集和排序规则不是一回事。排序规则是一组关于如何对字符串进行排序的规则。字符集是一组关于如何表示字符的规则。排序规则取决于字符集。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2012-06-03T18:00:46.600

在所有选择转换的表格上方的脚本中（使用`SHOW TABLES`），但这是一种在转换表格之前检查表格排序规则的更方便和可移植的方式。这个查询做到了：

```
SELECT table_name
     , table_collation 
FROM information_schema.tables 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2013-10-11T07:33:00.547

使用我的自定义外壳[collat​​edb](https://github.com/abdennour/miscs.sh/blob/master/collatedb)，它应该可以工作：

```
collatedb <username> <password> <database> <collation> 
```

例子 ：

```
collatedb root 0000 myDatabase utf8_bin 
```

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2014-06-17T02:29:15.733

感谢@nlaq 的代码，这让我开始使用以下解决方案。

我发布了一个 WordPress 插件，却没有意识到 WordPress 不会自动设置排序规则。所以很多使用插件的人最终`latin1_swedish_ci`都得到了应该是`utf8_general_ci`.

这是我添加到插件中的代码，用于检测`latin1_swedish_ci`整理并将其更改为`utf8_general_ci`.

在您自己的插件中使用之前测试此代码！

```
// list the names of your wordpress plugin database tables (without db prefix)
$tables_to_check = array(
    'social_message',
    'social_facebook',
    'social_facebook_message',
    'social_facebook_page',
    'social_google',
    'social_google_mesage',
    'social_twitter',
    'social_twitter_message',
);
// choose the collate to search for and replace:
$convert_fields_collate_from = 'latin1_swedish_ci';
$convert_fields_collate_to = 'utf8_general_ci';
$convert_tables_character_set_to = 'utf8';
$show_debug_messages = false;
global $wpdb;
$wpdb->show_errors();
foreach($tables_to_check as $table) {
    $table = $wpdb->prefix . $table;
    $indicies = $wpdb->get_results(  "SHOW INDEX FROM `$table`", ARRAY_A );
    $results = $wpdb->get_results( "SHOW FULL COLUMNS FROM `$table`" , ARRAY_A );
    foreach($results as $result){
        if($show_debug_messages)echo "Checking field ".$result['Field'] ." with collat: ".$result['Collation']."\n";
        if(isset($result['Field']) && $result['Field'] && isset($result['Collation']) && $result['Collation'] == $convert_fields_collate_from){
            if($show_debug_messages)echo "Table: $table - Converting field " .$result['Field'] ." - " .$result['Type']." - from $convert_fields_collate_from to $convert_fields_collate_to \n";
            // found a field to convert. check if there's an index on this field.
            // we have to remove index before converting field to binary.
            $is_there_an_index = false;
            foreach($indicies as $index){
                if ( isset($index['Column_name']) && $index['Column_name'] == $result['Field']){
                    // there's an index on this column! store it for adding later on.
                    $is_there_an_index = $index;
                    $wpdb->query( $wpdb->prepare( "ALTER TABLE `%s` DROP INDEX %s", $table, $index['Key_name']) );
                    if($show_debug_messages)echo "Dropped index ".$index['Key_name']." before converting field.. \n";
                    break;
                }
            }
            $set = false;

            if ( preg_match( "/^varchar\((\d+)\)$/i", $result['Type'], $mat ) ) {
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` VARBINARY({$mat[1]})" );
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` VARCHAR({$mat[1]}) CHARACTER SET {$convert_tables_character_set_to} COLLATE {$convert_fields_collate_to}" );
                $set = true;
            } else if ( !strcasecmp( $result['Type'], "CHAR" ) ) {
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` BINARY(1)" );
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` VARCHAR(1) CHARACTER SET {$convert_tables_character_set_to} COLLATE {$convert_fields_collate_to}" );
                $set = true;
            } else if ( !strcasecmp( $result['Type'], "TINYTEXT" ) ) {
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` TINYBLOB" );
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` TINYTEXT CHARACTER SET {$convert_tables_character_set_to} COLLATE {$convert_fields_collate_to}" );
                $set = true;
            } else if ( !strcasecmp( $result['Type'], "MEDIUMTEXT" ) ) {
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` MEDIUMBLOB" );
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` MEDIUMTEXT CHARACTER SET {$convert_tables_character_set_to} COLLATE {$convert_fields_collate_to}" );
                $set = true;
            } else if ( !strcasecmp( $result['Type'], "LONGTEXT" ) ) {
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` LONGBLOB" );
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` LONGTEXT CHARACTER SET {$convert_tables_character_set_to} COLLATE {$convert_fields_collate_to}" );
                $set = true;
            } else if ( !strcasecmp( $result['Type'], "TEXT" ) ) {
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` BLOB" );
                $wpdb->query( "ALTER TABLE `{$table}` MODIFY `{$result['Field']}` TEXT CHARACTER SET {$convert_tables_character_set_to} COLLATE {$convert_fields_collate_to}" );
                $set = true;
            }else{
                if($show_debug_messages)echo "Failed to change field - unsupported type: ".$result['Type']."\n";
            }
            if($set){
                if($show_debug_messages)echo "Altered field success! \n";
                $wpdb->query( "ALTER TABLE `$table` MODIFY {$result['Field']} COLLATE $convert_fields_collate_to" );
            }
            if($is_there_an_index !== false){
                // add the index back.
                if ( !$is_there_an_index["Non_unique"] ) {
                    $wpdb->query( "CREATE UNIQUE INDEX `{$is_there_an_index['Key_name']}` ON `{$table}` ({$is_there_an_index['Column_name']})", $is_there_an_index['Key_name'], $table, $is_there_an_index['Column_name'] );
                } else {
                    $wpdb->query( "CREATE UNIQUE INDEX `{$is_there_an_index['Key_name']}` ON `{$table}` ({$is_there_an_index['Column_name']})", $is_there_an_index['Key_name'], $table, $is_there_an_index['Column_name'] );
                }
            }
        }
    }
    // set default collate
    $wpdb->query( "ALTER TABLE `{$table}` DEFAULT CHARACTER SET {$convert_tables_character_set_to} COLLATE {$convert_fields_collate_to}" );
    if($show_debug_messages)echo "Finished with table $table \n";
}
$wpdb->hide_errors(); 
```

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2015-07-07T13:46:27.683

一个简单的（愚蠢的？:) 解决方案，使用您的 IDE 的多选功能：

1.  运行“显示表格；” 查询和复制结果列（表名）。
2.  多选开头并添加“ALTER TABLE”。
3.  多选结尾并添加“CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci;”
4.  运行创建的查询。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2015-11-03T08:54:42.583

我认为最快的方法是使用 phpmyadmin 和控制台上的一些 jQuery。

转到表的结构并打开 chrome/firefox 开发人员控制台（通常在键盘上按 F12）：

1.  运行此代码以选择所有字符集不正确的字段并开始修改：

    ```
    var elems = $('dfn'); var lastID = elems.length - 1;
    elems.each(function(i) {
        if ($(this).html() != 'utf8_general_ci') { 
           $('input:checkbox', $('td', $(this).parent().parent()).first()).attr('checked','checked');
        }       

        if (i == lastID) {
            $("button[name='submit_mult'][value='change']").click();
        }
    }); 
    ```

2.  加载页面时，在控制台上使用此代码选择正确的编码：

    ```
    $("select[name*='field_collation']" ).val('utf8_general_ci'); 
    ```

3.  节省

4.  在“操作”选项卡上的“排序规则”字段中更改表格的字符集

在 phpmyadmin 4.0 和 4.4 上测试，但我认为适用于所有 4.x 版本

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2016-02-06T01:24:53.127

如果您没有命令行访问权限或编辑 INFORMATION_SCHEMA 的访问权限，这是一个简单的方法，只需 phpmyadmin。

首先，听听这里许多其他答案的建议——你真的可以把事情搞砸，所以做一个备份。现在备份您的备份。此外，如果您的数据编码不同于您将其更改为的编码，这也不太可能起作用。

请注意，您需要在开始之前找到需要更改的违规模式和字符编码的确切名称。

1.  将数据库导出为 SQL；制作副本；在您选择的文本编辑器中打开它
2.  首先查找和替换架构，例如 - find: **latin1_swedish_ci** , replace: **utf8_general_ci**
3.  如果需要，查找并替换字符编码，例如 - find: **latin1** , replace: **utf8**
4.  创建一个新的测试数据库并将新的 SQL 文件上传到 phpmyadmin

这是一种超级简单的方法，但同样，这不会改变数据的编码，所以它只在某些情况下有效。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2017-03-02T02:00:54.730

我更新了 nlaq 的答案以使用 PHP7 并正确处理多列索引、二进制整理数据（例如`latin1_bin`）等，并稍微清理了代码。这是我发现/尝试的唯一将我的数据库从 latin1 成功迁移到 utf8 的代码。

```
<?php

/////////// BEGIN CONFIG ////////////////////

$username = "";
$password = "";
$db = "";
$host = "";

$target_charset = "utf8";
$target_collation = "utf8_unicode_ci";
$target_bin_collation = "utf8_bin";

///////////  END CONFIG  ////////////////////

function MySQLSafeQuery($conn, $query) {
    $res = mysqli_query($conn, $query);
    if (mysqli_errno($conn)) {
        echo "<b>Mysql Error: " . mysqli_error($conn) . "</b>\n";
        echo "<span>This query caused the above error: <i>" . $query . "</i></span>\n";
    }
    return $res;
}

function binary_typename($type) {
    $mysql_type_to_binary_type_map = array(
        "VARCHAR" => "VARBINARY",
        "CHAR" => "BINARY(1)",
        "TINYTEXT" => "TINYBLOB",
        "MEDIUMTEXT" => "MEDIUMBLOB",
        "LONGTEXT" => "LONGBLOB",
        "TEXT" => "BLOB"
    );

    $typename = "";
    if (preg_match("/^varchar\((\d+)\)$/i", $type, $mat))
        $typename = $mysql_type_to_binary_type_map["VARCHAR"] . "(" . (2*$mat[1]) . ")";
    else if (!strcasecmp($type, "CHAR"))
        $typename = $mysql_type_to_binary_type_map["CHAR"] . "(1)";
    else if (array_key_exists(strtoupper($type), $mysql_type_to_binary_type_map))
        $typename = $mysql_type_to_binary_type_map[strtoupper($type)];
    return $typename;
}

echo "<pre>";

// Connect to database
$conn = mysqli_connect($host, $username, $password);
mysqli_select_db($conn, $db);

// Get list of tables
$tabs = array();
$query = "SHOW TABLES";
$res = MySQLSafeQuery($conn, $query);
while (($row = mysqli_fetch_row($res)) != null)
    $tabs[] = $row[0];

// Now fix tables
foreach ($tabs as $tab) {
    $res = MySQLSafeQuery($conn, "SHOW INDEX FROM `{$tab}`");
    $indicies = array();

    while (($row = mysqli_fetch_array($res)) != null) {
        if ($row[2] != "PRIMARY") {
            $append = true;
            foreach ($indicies as $index) {
                if ($index["name"] == $row[2]) {
                    $index["col"][] = $row[4];
                    $append = false;
                }
            }
            if($append)
                $indicies[] = array("name" => $row[2], "unique" => !($row[1] == "1"), "col" => array($row[4]));
        }
    }

    foreach ($indicies as $index) {
        MySQLSafeQuery($conn, "ALTER TABLE `{$tab}` DROP INDEX `{$index["name"]}`");
        echo "Dropped index {$index["name"]}. Unique: {$index["unique"]}\n";
    }

    $res = MySQLSafeQuery($conn, "SHOW FULL COLUMNS FROM `{$tab}`");
    while (($row = mysqli_fetch_array($res)) != null) {
        $name = $row[0];
        $type = $row[1];
        $current_collation = $row[2];
        $target_collation_bak = $target_collation;
        if(!strcasecmp($current_collation, "latin1_bin"))
            $target_collation = $target_bin_collation;
        $set = false;
        $binary_typename = binary_typename($type);
        if ($binary_typename != "") {
            MySQLSafeQuery($conn, "ALTER TABLE `{$tab}` MODIFY `{$name}` {$binary_typename}");
            MySQLSafeQuery($conn, "ALTER TABLE `{$tab}` MODIFY `{$name}` {$type} CHARACTER SET '{$target_charset}' COLLATE '{$target_collation}'");
            $set = true;
            echo "Altered field {$name} on {$tab} from type {$type}\n";
        }
        $target_collation = $target_collation_bak;
    }

    // Rebuild indicies
    foreach ($indicies as $index) {
         // Handle multi-column indices
         $joined_col_str = "";
         foreach ($index["col"] as $col)
             $joined_col_str = $joined_col_str . ", `" . $col . "`";
         $joined_col_str = substr($joined_col_str, 2);

         $query = "";
         if ($index["unique"])
             $query = "CREATE UNIQUE INDEX `{$index["name"]}` ON `{$tab}` ({$joined_col_str})";
         else
             $query = "CREATE INDEX `{$index["name"]}` ON `{$tab}` ({$joined_col_str})";
         MySQLSafeQuery($conn, $query);

        echo "Created index {$index["name"]} on {$tab}. Unique: {$index["unique"]}\n";
    }

    // Set default character set and collation for table
    MySQLSafeQuery($conn, "ALTER TABLE `{$tab}`  DEFAULT CHARACTER SET '{$target_charset}' COLLATE '{$target_collation}'");
}

// Set default character set and collation for database
MySQLSafeQuery($conn, "ALTER DATABASE `{$db}` DEFAULT CHARACTER SET '{$target_charset}' COLLATE '{$target_collation}'");

mysqli_close($conn);
echo "</pre>";

?> 
```

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2017-05-06T06:07:59.290

# 对于 Windows 用户

除了@davidwinterbottom 答案，Windows 用户还可以使用以下命令：

```
mysql.exe --database=[database] -u [user] -p[password] -B -N -e "SHOW TABLES" \
| awk.exe '{print "SET foreign_key_checks = 0; ALTER TABLE", $1, "CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci; SET foreign_key_checks = 1; "}' \
| mysql.exe -u [user] -p[password] --database=[database] & 
```

将 [database]、[user] 和 [password] 占位符替换为实际值。

**Git-bash**用户可以下载这个[bash 脚本](https://gist.github.com/motammem/b57a93ae986d469b8dbb6b9264130a60)并轻松运行它。

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2021-05-12T12:58:17.777

[对于它的价值，这里是https://stackoverflow.com/a/42545503/6226915](https://stackoverflow.com/a/42545503/6226915)作为 Yii2 ConsoleController 类的扩展版本，它也可以独立使用：[https](https://gist.github.com/cboulanger/d30c197235a53d9a2331f19a96d6e00d) ://gist.github.com/cboulanger/d30c197235a53d9a2331f19a96d6e00d 。

该脚本修复了一些错误并添加了对全文索引的支持；它还处理 3kb 的常规索引键长度约束。它还将所有表转换为 InnoDB。

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2022-01-03T14:21:03.387

对于 PHP [Laravel 框架](https://laravel.com/docs/8.x)：

1.  使用迁移：`php artisan make:migration update_character_set_utf8_m4`

2.  迁移文件逻辑

    ```
    $DBNAME = config('database.connections.mysql.database');
    $CHARACTER = 'utf8mb4';
    $COLLATE = 'utf8mb4_unicode_ci';

    echo "Altering DB $DBNAME\n";
    DB::unprepared("ALTER DATABASE $DBNAME CHARACTER SET $CHARACTER COLLATE $COLLATE;");

    $tables = DB::select("SELECT table_name FROM information_schema.tables WHERE table_schema = '{$DBNAME}'");
    foreach ($tables as $table) {
        echo "Altering $table->table_name\n";
        DB::unprepared("ALTER TABLE $table->table_name CONVERT TO CHARACTER SET $CHARACTER COLLATE $COLLATE;");
    } 
    ```

3.  `php artisan migrate`

# if-statement - 需要重构 Arrow 反模式的想法

> ID：105602
> 
> 赞同：12
> 
> 时间：2008-09-19T21:02:31.263
> 
> 标签：if-statement, nested, refactoring, anti-patterns

我继承了一个怪物。

它伪装成 .NET 1.1 应用程序处理符合医疗保健索赔支付 (ANSI 835) 标准的文本文件，但它是一个怪物。正在处理的信息涉及医疗保健索赔、EOB 和报销。这些文件由在前几个位置具有标识符的记录和根据该类型记录的规范格式化的数据字段组成。一些记录 ID 是控制段 ID，用于分隔与特定类型事务相关的记录组。

为了处理一个文件，我的小怪物读取第一条记录，确定即将发生的事务类型，然后根据当前正在处理的事务类型开始处理其他记录。为此，它使用嵌套的 if。由于有许多记录类型，因此需要做出许多决定。每个决策都涉及一些处理和 2-3 个其他决策，需要根据之前的决策做出。这意味着嵌套的 if 有很多嵌套。这就是我的问题所在。

这个嵌套的 if 有 715 行长。是的，这是正确的。七百五十条线。我不是代码分析专家，所以我下载了几个免费软件分析工具，得出的 McCabe 循环复杂度等级为 49。他们告诉我这是一个相当高的数字。与亚特兰大地区的花粉计数一样高，其中 100 是高标准，新闻称“今天的花粉计数为 1,523”。这是我有幸看到的箭头反模式最好的例子之一。在其最高处，缩进深度为 15 个制表符。

我的问题是，你会建议用什么方法来重构或重组这样的东西？

我花了一些时间寻找想法，但没有什么能让我站稳脚跟。例如，用保护条件代替级别是一种方法。我只有其中一个。一窝下来，十四走。

也许有一种设计模式可能会有所帮助。指挥链会是解决这个问题的一种方式吗？请记住，它必须保留在 .NET 1.1 中。

感谢您的任何想法。

* * *

## 回答 #1

> 赞同：20
> 
> 时间：2008-09-20T00:01:30.787

本周我刚刚有一些遗留代码在工作，与您所描述的相似（尽管没有那么可怕）。

没有一件事能让你摆脱困境。[状态机](http://en.wikipedia.org/wiki/Finite_state_machine)可能是您的代码采用的最终形式，但这*不会*帮助您实现目标，您也不应该在解决已经存在的混乱之前决定这样的解决方案。

我要采取的第一步是为现有代码编写一个测试。这个测试不是为了证明代码是正确的，而是为了确保你在开始重构时没有破坏一些东西。获取大量数据进行处理，将其提供给怪物，然后获得输出。那是你的试金石。如果您可以使用代码覆盖率工具执行此操作，您将看到您的测试未涵盖的内容。如果可以，构建一些人工记录，这些记录也将执行此代码，然后重复。一旦你觉得你已经完成了这项任务，输出数据将成为你测试的预期结果。

重构不应改变代码的行为。记住这一点。这就是为什么您知道输入和输出数据集来验证您不会破坏事情的原因。这是你的安全网。

现在重构！

我做了几件我觉得有用的事情：

**反转`if`语句**

我遇到的一个大问题是我刚刚阅读代码时找不到相应的`else`语句，我注意到很多块看起来像这样

```
if (someCondition)
{
  100+ lines of code
  {
    ...
  }
}
else
{
  simple statement here
} 
```

通过反转`if`我可以看到简单的情况，然后知道另一个已经做了什么，然后转到更复杂的块。变化不大，但帮助我理解。

**提取方法**

我经常使用这个。拿一些复杂的多线块，摸索它，然后用它自己的方法把它推到一边。这让我更容易看到代码重复的地方。

现在，希望您没有破坏您的代码（测试仍然通过，对吧？），并且您拥有更具可读性和更好理解的*过程*代码。看它已经改进了！但是你之前写的那个测试还不够好......它只告诉你你复制了原始代码的功能（错误和所有），而这只是你所覆盖的那一行，因为我相信你会发现你无法弄清楚如何命中或永远无法命中的代码块（我在我的工作中都见过）。

现在，所有大牌模式都发挥作用的重大变化是当您开始考虑如何以适当的 OO 方式对其进行重构时。给这只猫剥皮的方法不止一种，而且会涉及多种模式。不知道您正在解析的这些文件的格式的详细信息，我只能提出一些有用的建议，这些建议可能是也可能不是最佳解决方案。

[Refactoring to Patterns](https://rads.stackoverflow.com/amzn/click/com/0321213351)是一本很棒的书，可以帮助解释在这些情况下有用的模式。

你想吃一头大象，除了一次咬一口，别无他法。祝你好运。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T21:05:05.420

[状态机](http://en.wikipedia.org/wiki/Finite_state_machine)似乎是合乎逻辑的起点，如果可以摆动它，就使用 WF（听起来你不能）。

你仍然可以在没有 WF 的情况下实现一个，你只需要自己做。但是，从一开始就将其视为状态机可能会给您一个更好的实现，然后创建一个检查每个动作的内部状态的程序怪物。

画出你的状态，是什么导致了转变。处理记录的实际代码应该被分解出来，并在状态执行时调用（如果该特定状态需要它）。

因此 State1 的执行调用您的“读取记录”，然后根据该记录转换到另一个状态。

下一个状态可能会读取多条记录并调用记录处理指令，然后转换回State1。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T21:16:55.627

在这些情况下，我做的一件事是使用“组合方法”模式。请参阅[Jeremy Miller](http://codebetter.com/blogs/jeremy.miller/archive/2006/12/03/Composed-Method-Pattern.aspx)关于此主题的博客文章。基本思想是使用 IDE 中的重构工具来提取有意义的小方法。完成此操作后，您可能能够进一步重构并提取有意义的类。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-20T00:17:22.573

我将从不受限制地使用提取方法开始。如果您当前的 Visual Studio IDE 中没有它，您可以获取第 3 方插件，或在较新的 VS 中加载您的项目。（它会尝试升级您的项目，但您会小心地忽略这些更改而不是将它们签入。）

您说您的代码缩进了 15 个级别。从大约 1/2 处开始，然后提取方法。如果你能想出一个好名字，就使用它，但如果你不能，无论如何都要提取。再次分成两半。您不会在这里寻求理想的结构。您正试图将代码分解成适合您大脑的片段。我的大脑不是很大，所以我会不停地折断，直到不再疼为止。

在你进行的过程中，寻找任何看起来与其他方法不同的新长方法；将这些纳入新课程。只需使用一个现在只有一个方法的简单类。哎呀，使方法静态很好。不是因为你认为它们是好课程，而是因为你非常渴望某种组织。

经常签到，这样您就可以检查您的工作，稍后了解历史，准备好做一些“真正的工作”而无需合并，并为您的队友省去艰难合并的麻烦。

最终，您需要返回并确保方法名称正确，您创建的方法集有意义，清理新类等。

如果你有一个高度可靠的提取方法工具，你可以在没有好的自动化测试的情况下逃脱。（例如，我相信 VS。）否则，请确保你没有破坏任何东西，否则你最终会比你开始时更糟：使用一个根本不起作用的程序。

配对伙伴在这里会有所帮助。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-19T21:36:44.643

有时我将状态模式与堆栈结合起来。

它适用于分层结构；父元素知道要压入堆栈以处理子元素的状态，但子元素不必知道有关其父元素的任何信息。换句话说，孩子不知道下一个状态是什么，它只是发出“完成”的信号并从堆栈中弹出。这有助于通过保持依赖单向来将状态彼此分离。

它非常适合使用 SAX 解析器处理 XML（内容处理程序只是在输入和退出元素时推送和弹出状态以更改其行为）。EDI 也应该适用于这种方法。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-19T21:07:30.220

从描述来看，状态机可能是处理它的最佳方式。有一个枚举变量来存储当前状态，并将处理实现为对记录的循环，使用 switch 或 if 语句根据当前状态和输入数据选择要采取的操作。如果它变得过于庞大，您也可以使用函数指针轻松地将工作分派到基于状态的单独函数。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-19T21:08:41.670

[在 Coding Horror 上有一篇非常好的博客文章](http://www.codinghorror.com/blog/archives/000486.html)。我只遇到过这种反模式一次，而且我几乎只是按照他的步骤进行操作。

# mysql - 我可以在安装后从 MediaWiki 撤销一些数据库权限吗？

> ID：105604
> 
> 赞同：6
> 
> 时间：2008-09-19T21:02:54.490
> 
> 标签：mysql, mediawiki

我刚刚在网络服务器上安装了 MediaWiki。显然，它在安装过程中需要很多权限才能正确设置其数据库。现在它已经安装，我可以安全地撤销一些权限（例如创建表，删除表？）或者它可能需要稍后创建更多表（当它们第一次需要时？）如果不是那么我宁愿授予它尽可能少的权限.

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T21:51:52.953

安装后，MediaWiki 不再需要创建任何表格。我建议给用户插入、选择和锁定权限。

```
grant select,lock tables,insert on media_wiki_db.* to 'wiki'@'localhost' identified by 'password'; 
```

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T21:47:41.467

在 LocalSettings.php 中更改 mediawiki 连接的用户，然后使用 phpMyAdmin，您可以编辑该用户的权限（也就是说，如果您不习惯从 mysql 控制台授予和撤销权限）。

[http://www.phpmyadmin.net/home_page/index.php](http://www.phpmyadmin.net/home_page/index.php)

# blogengine.net - 如何扩展 Blogengine.Net 以收集访问者的统计信息？

> ID：105607
> 
> 赞同：5
> 
> 时间：2008-09-19T21:03:27.767
> 
> 标签：blogengine.net, visitor-statistic

我喜欢博客引擎。但据我所知，它没有收集关于我想看到的访问者的标准信息（推荐人、浏览器类型等）。

当我以管理员身份登录时，我有一个名为“Referrer”的菜单项。我可以选择一个工作日，然后我会看到 1 或 2 行

“google.com 4 hits,”itmaskinen.se 6 hits”等等，但这不是我想要的，我想知道我的访问者来自哪里，国家，IP（如果可能），有多少访问者等等。

如果你们中的某个人熟悉 Blogengine.Net 并且可以指出我将放置我自己的日志代码的正确方向，或者如果您知道任何可以为我做的访问者统计扩展，我会非常高兴要知道。我更喜欢扩展，因为如果我自己对 BlogEngine 进行更改，它可能会破坏我以后安装的更新。

Blogengine.Net 是一个用 .Net 制作的博客软件，在这里可以找到：http: [//www.dotnetblogengine.net/](http://www.dotnetblogengine.net/)

是的，我更喜欢在这里而不是在 Blogengine.Net 论坛中提出这个问题，你知道为什么。;)

（任何人，请随时在这篇文章中编辑我的（糟糕的）英语，然后删除这句话）

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-09-20T02:28:12.040

这不是一个扩展，但它是我用来收集我所有 blogengine.net 数据的工具，它应该是安全升级的。

当您登录到 Blogengine.NET 管理屏幕时，您可以转到“设置 > 客户代码 > 跟踪脚本”，在这里您可以放置​​您的[http://www.google.com/analytics/](http://www.google.com/analytics/)日志记录脚本。谷歌分析提供了所有你想要的引荐来源、浏览器类型等。如果您愿意，您可以为其他网站创建额外的帐户，这很好。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-22T01:52:57.407

我使用 Google Analytics 和 StatCounter 来跟踪访问者统计数据。我发现每一个都提供了另​​一个没有的有用信息。它们在一定程度上都是免费的。

我将他们的 javascript 代码放在我的自定义 BE.Net 皮肤的 site.master 文件中。

对于 Google Analytics，我更进一步，将经过身份验证的用户的用户名作为自定义变量传递。这样我就可以将用户名与统计信息相匹配。为此，您可以使用 GA pageTracker 上的 _setVar javascript 方法，如下所示：

```
<script type="text/javascript">
    var pageTracker = _gat._getTracker("UA-129049-25");
    var userDefinedValue = '<%= System.Web.Security.Membership.GetUser() != null ? System.Web.Security.Membership.GetUser().UserName : "" %>';
    pageTracker._setVar(userDefinedValue);
    pageTracker._trackPageview();
</script> 
```

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2009-01-01T09:31:07.070

有人注意到我们错过了来自 RSS 阅读器的所有点击吗？Syndication.axd 不运行分析 javascript。因此，我们错过了统计数据中的绝大多数观众。我们很高兴地分析这并不重要 - 临时访问者。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2009-01-01T11:21:45.507

对于绝大多数情况，谷歌分析做得很好。这完全取决于您想要多少数据。例如，如果您想记录 IP 地址并解析它们以获取域名，并突出显示来自您所在公司的同事对您博客的所有访问，则您必须编写一些自定义代码你自己。然而，这一切都是相当原始的——这些事情很容易使用 ASP.NET 实现。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2012-06-11T15:47:59.520

我在我的 BlogEngine 实例的 IIS 网站上设置了收集统计信息，然后使用 WebLog Expert - [http://www.weblogexpert.com](http://www.weblogexpert.com)分析日志。

它比谷歌分析更可靠，因为我确实看到了所有进入我的 IIS 的请求，无论这是对 axd 的请求还是对某些静态内容的请求。而且，一旦我发现谷歌在访问次数上欺骗了我。在那之后，我比谷歌更信任我的 IIS 统计数据。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2013-07-27T05:31:00.213

有一个小部件可用于显示访问和在线用户统计信息。
您可以从以下链接中找到它：
[http ://www.nuget.org/packages/Statistics/](http://www.nuget.org/packages/Statistics/)
[http://www.itnerd.ir/post/2013/07/25/Visits-and-Online-Users-Statistics- widget-for-BlogEngine-2](http://www.itnerd.ir/post/2013/07/25/Visits-and-Online-Users-Statistics-widget-for-BlogEngine-2)
但要查看说明，请转到第二个链接。

# c# - 我需要一个辅助方法来比较一个字符枚举和一个装箱的字符到一个对象

> ID：105609
> 
> 赞同：2
> 
> 时间：2008-09-19T21:03:37.860
> 
> 标签：c#, enums, casting

我有一个如下所示的枚举：

```
public enum TransactionStatus { Open = 'O', Closed = 'C'}; 
```

我正在从数据库中提取数据，用一个字符表示 - 你猜对了 - 'O' 事务是打开的还是 'C' 事务是关闭的。

现在因为数据作为对象从数据库中出来，所以我在编写比较代码时花了不少时间。

我能做的最好的就是写：

```
protected bool CharEnumEqualsCharObj(TransactionStatus enum_status, object obj_status) {
    return ((char)enum_status).ToString() == obj_status.ToString();
} 
```

但是，这不是我必须处理的唯一字符枚举，我有 5 或 6 个，并且为它们编写相同的方法至少可以说很烦人。 [据说所有枚举都继承自 System.Enum](http://blogs.msdn.com/abhinaba/archive/2006/01/14/enumerting-all-values-of-an-enum.aspx)但如果我尝试将其设置为输入类型，则会出现编译错误。这也在 .NET 1.1 中，所以泛型是不可能的。

我已经为此苦苦挣扎了一段时间。有没有人有更好的方法来编写这种方法？另外，任何人都可以澄清整个枚举继承自 System.Enum 但不是多态的东西吗？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-19T21:53:59.033

```
static void Main(string[] args)
{
    object val = 'O';
    Console.WriteLine(EnumEqual(TransactionStatus.Open, val));

    val = 'R';
    Console.WriteLine(EnumEqual(DirectionStatus.Left, val));

    Console.ReadLine();
}

public static bool EnumEqual(Enum e, object boxedValue)
{                        
    return e.Equals(Enum.ToObject(e.GetType(), (char)boxedValue));
}

public enum TransactionStatus { Open = 'O', Closed = 'C' };
public enum DirectionStatus { Left = 'L', Right = 'R' }; 
```

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T21:16:22.320

枚举在 C# 中通常很混乱，因此在使用 .NET 2.0 时，通常使用泛型包装语法以避免编写此类笨拙的代码。

在 .NET 1.1 中，您可以执行以下操作，尽管它并不比原始代码段更整洁：

```
protected bool CharEnumEqualsCharObj(TransactionStatus enum_status, object obj_status)
{
    return (enum_status == Enum.Parse(typeof(TransactionStatus), obj_status.ToString()));
} 
```

这大约是相同数量的代码，但您现在正在进行枚举而不是字符串比较。

您还可以使用调试器/文档来查看是否`obj_status`真的是一个对象，或者您是否可以安全地将其转换为字符串。

* * *

## 回答 #3

> 赞同：-1
> 
> 时间：2008-09-19T21:08:16.583

我会看看 Enum.Parse。它会让你将你的 char 解析回正确的枚举。我相信它可以一直追溯到 C# 1.0。你的代码看起来有点像这样：

```
TransactionStatus status = (TransactionStatus)Enum.Parse(typeof(TransactionStatus), obj.ToString()); 
```

* * *

## 回答 #4

> 赞同：-2
> 
> 时间：2008-09-19T21:29:33.973

如果您只需要比较值，则可以使用以下内容：

```
protected bool CharEnumEqualsCharObj(TransactionStatus enum_status, object obj_status) {
    return (char)enum_status == (char)obj_status;
} 
```

# c# - VSTO Excel 2007 数据透视表，在多列中具有数据透视字段

> ID：105610
> 
> 赞同：0
> 
> 时间：2008-09-19T21:03:57.063
> 
> 标签：c#, .net-3.5, vsto, excel-2007

我在 Excel 2007 中使用 VSTO 来动态生成数据透视表和数据透视图。当我需要在多个列中使用 PivotField 时，我遇到了问题。

为此，我在 Excel 中创建了一个数据透视表，并将其属性序列化为一个 XML 文档，然后我用它来重建数据透视表。

即：作为一个值和一个列

在 Excel 中构建数据透视表时，这是可能的。找到使用 C# 的方法了吗？

[以编程方式创建数据透视表](http://blogs.msdn.com/andreww/archive/2008/07/25/creating-a-pivottable-programmatically.aspx)

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T22:09:56.950

如果您将计算字段添加到数据透视表，并使公式只是您需要复制的字段的名称，允许您使用相同的字段两次，则计算字段必须是值字段。

或许您可以通过编程方式执行此操作。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-29T15:04:04.557

拥有数据集后，您可以将其转换为 object[,] 并将其插入 Excel 文档。然后，您可以将文档保存到磁盘并将其流式传输给用户。

```
for (int cIndex = 1; cIndex < 1 + columns; cIndex++)
    sheet.Cells.set_Item(4, cIndex, data.Columns[cIndex - 1].Caption);
if (rows > 0)
{

    //select the range where the data will be pasted
    Range r = sheet.get_Range(sheet.Cells[5, 1], sheet.Cells[5 + (rows - 1), columns]);

    //Convert the datatable to an object array
    object[,] workingValues = new object[rows, columns];

    for (int rIndex = 0; rIndex < rows; rIndex++)
        for (int cIndex = 0; cIndex < columns; cIndex++)
            workingValues[rIndex, cIndex] = data.Rows[rIndex][cIndex].ToString();

    r.Value2 = workingValues;
} 
```

# xml - XPath 可以只返回具有 X 子节点的节点吗？

> ID：105613
> 
> 赞同：37
> 
> 时间：2008-09-19T21:04:34.440
> 
> 标签：xml, xslt, xpath

是否可以使用 XPath 仅选择具有特定子元素的节点？例如，从这个 XML 中，我只想要 pets 中具有“bar”子项的元素。因此，生成的数据集将包含此示例中的`lizard`和`pig`元素：

```
<pets>
  <cat>
    <foo>don't care about this</foo>
  </cat>
  <dog>
   <foo>not this one either</foo>
  </dog>
  <lizard>
   <bar>lizard should be returned, because it has a child of bar</bar>
  </lizard>
  <pig>
   <bar>return pig, too</bar>
  </pig>
</pets> 
```

这个 Xpath 给了我所有的 pets: `"/pets/*"`，但我只想要具有 name 子节点的 pets `'bar'`。

* * *

## 回答 #1

> 赞同：55
> 
> 时间：2008-09-19T21:06:27.463

在这里，它的所有荣耀

```
/pets/*[bar] 
```

`pets`把所有有孩子的孩子都给我`bar`

* * *

## 回答 #2

> 赞同：26
> 
> 时间：2009-01-11T17:20:01.440

```
/pets/child::*[child::bar] 
```

对不起，我没有看到上一个回复的评论。

但在这种情况下，我宁愿使用`descendant::`轴，它包括指定以下的所有元素：

```
/pets[descendant::bar] 
```

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2014-09-10T14:50:02.280

以防万一您想更具体地了解孩子 - 您也可以在他们身上使用选择器。

例子：

```
<pets>
    <cat>
        <foo>don't care about this</foo>
    </cat>
    <dog>
        <foo>not this one either</foo>
    </dog>
    <lizard>
        <bar att="baz">lizard should be returned, because it has a child of bar</bar>
    </lizard>
    <pig>
        <bar>don't return pig - it has no att=bar </bar>
    </pig>
</pets> 
```

现在，您只关心所有具有**value****属性**`pets`的孩子。您可以使用以下 xpath 表达式：`bar` **`att``baz`**

```
//pets/*[descendant::bar[@att='baz']] 
```

结果

```
<lizard>
    <bar att="baz">lizard should be returned, because it has a child of bar</bar>
</lizard> 
```

# c# - 使用 ADO.Net 的查询的连接超时异常

> ID：105642
> 
> 赞同：9
> 
> 时间：2008-09-19T21:08:46.410
> 
> 标签：c#, .net, ado.net, timeout

**更新**：看起来查询不会引发任何超时。连接超时。

这是执行查询的示例代码。有时，在执行耗时的查询时，它会引发超时异常。

我**不能**使用这些技术中的任何一个：1）增加超时。2）使用回调异步运行它。这需要以同步方式运行。

请建议任何其他技术以在执行耗时的查询时保持连接活跃？

```
private static void CreateCommand(string queryString,
    string connectionString)
{
    using (SqlConnection connection = new SqlConnection(
               connectionString))
    {
        SqlCommand command = new SqlCommand(queryString, connection);
        command.Connection.Open();
        command.ExecuteNonQuery();
    }
} 
```

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2008-09-19T22:33:24.447

由于您使用的是不返回任何行的 ExecuteNonQuery，因此您可以尝试这种基于轮询的方法。它以异步方式（没有回调）执行查询，但应用程序将等待（在 while 循环内）直到查询完成。来自[MSDN](http://msdn.microsoft.com/en-us/library/ca56w9se(VS.80).aspx)。这应该可以解决超时问题。请试一试。

但是，我同意其他人的观点，即您应该更多地考虑优化查询以在 30 秒内执行。

```
 IAsyncResult result = command.BeginExecuteNonQuery();

        int count = 0;
        while (!result.IsCompleted)
        {
            Console.WriteLine("Waiting ({0})", count++);
            System.Threading.Thread.Sleep(1000);
        }
        Console.WriteLine("Command complete. Affected {0} rows.",
        command.EndExecuteNonQuery(result)); 
```

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-19T21:33:46.490

您应该首先检查您的查询，看看它是否经过优化，并且它没有以某种方式在丢失的索引上运行。**大多数查询分配 30 秒**，即使在大型数据库上，如果它们经过适当调整。如果您使用查询计划有充分的证据表明查询不能比这更快地执行，那么您应该增加超时，没有其他方法可以保持连接，这就是超时终止连接的目的，如果查询未在该时间范围内完成。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T21:28:09.703

我必须同意 Terrapin 的观点。

你有几个选择来减少你的时间。首先，如果您的公司雇用 DBA，我建议向他们征求建议。

如果这不是一个选项，或者如果您想先尝试其他一些事情，这里是您的三个主要选项：

1.  将查询分解为在超时下运行的组件。这可能是最简单的。
2.  更改查询以优化通过数据库的访问路径（通常：尽可能接近索引）
3.  更改或添加索引以影响查询的访问路径。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T21:34:35.880

如果您被限制使用更改超时值的默认过程，您很可能需要做更多的工作。想到以下选项

1.  与您的 DBA 和另一次代码审查一起验证您是否已经尽可能地优化了查询
2.  在底层数据库结构上工作，看看您是否可以在数据库方面获得任何收益，创建/修改一个 idex(es)。
3.  将它分成多个部分，即使这意味着运行具有多个返回参数的过程，这些参数只是调用另一个参数。（这个选项并不优雅，老实说，如果你的代码真的要花这么多时间，我会去管理并重新讨论 30 秒超时）

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-09-19T22:23:04.750

我们最近在 SQL Server 2000 数据库上遇到了类似的问题。

在查询期间，在 db 服务器上的主数据库上运行此查询，看看是否有任何锁需要解决：

```
select 
  spid,
  db_name(sp.dbid) as DBname,
  blocked as BlockedBy,
  waittime as WaitInMs,
  lastwaittype,
  waitresource,
  cpu,
  physical_io,
  memusage,
  loginame,
  login_time,
  last_batch,
  hostname,
  sql_handle
from sysprocesses sp
where (waittype > 0 and spid > 49) or spid in (select blocked from sysprocesses where blocked > 0) 
```

SQL Server Management Studio 2008 还包含一个非常酷的活动监视器，可让您在查询期间查看数据库的运行状况。

在我们的例子中，它是一个使数据库保持忙碌的网络锁。这是一些遗留的 VB 代码，它没有足够快地断开其结果集。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2009-05-06T02:49:44.857

如果你被禁止使用数据访问 API 的特性让查询持续超过 30 秒，那么我们需要查看 SQL。

与优化 SQL 的收益相比，通过优化 ADO.NET 的使用所获得的性能收益是微不足道的。

而且您已经在使用最有效的 SQL 执行方法。其他技术的速度会慢得多（尽管，如果您使用 DataSet 快速检索行并进行一些非常慢的客户端处理，您可能能够将初始检索时间缩短到 30 秒以下，但我对此表示怀疑。 )

如果我们知道您是否在进行插入，那么也许您应该使用批量插入。但是我们不知道你的sql的内容。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2009-05-09T14:16:10.433

这是一个 UGLY hack，但可能有助于暂时解决您的问题，直到您可以解决真正的问题

```
 private static void CreateCommand(string queryString,string connectionString)
    {
        int maxRetries = 3;
        int retries = 0;
        while(true)
        {
            try
            {
                using (SqlConnection connection = new SqlConnection(connectionString))
                {
                    SqlCommand command = new SqlCommand(queryString, connection);
                    command.Connection.Open();
                    command.ExecuteNonQuery();
                }
                break;
            }
            catch (SqlException se)
            {
                if (se.Message.IndexOf("Timeout", StringComparison.InvariantCultureIgnoreCase) == -1)
                    throw; //not a timeout

                if (retries >= maxRetries)
                    throw new Exception( String.Format("Timedout {0} Times", retries),se);

                //or break to throw no error

                retries++;
            }
        }
    } 
```

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-19T21:11:24.500

```
command.CommandTimeout *= 2; 
```

这将使默认超时时间增加一倍，即 30 秒。

或者，将 CommandTimeout 的值放在配置文件中，这样您就可以根据需要调整它而无需重新编译。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-09-19T21:12:57.417

如果您绝对不能增加超时，您唯一的选择是减少查询在默认的 30 秒超时内执行的时间。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-19T21:20:21.657

您应该将查询分成多个块，每个块在超时期限内执行。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-09-19T22:24:31.580

我倾向于不喜欢增加连接/命令超时，因为在我看来，这将是处理症状的问题，而不是问题

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2009-05-06T19:36:10.977

只需将 sqlcommand 的 CommandTimeout 属性设置为 0，这将导致命令等待查询完成...例如：

```
SqlCommand cmd = new SqlCommand(spName,conn);
cmd.CommandType = CommandType.StoredProcedure;
cmd.CommandTimeout = 0; 
```

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2009-05-12T01:55:12.073

你有没有想过将查询分解成几个更小的块？

此外，您是否针对以下数据库引擎优化顾问运行了查询：

Management Studio > 工具 > 数据库引擎优化顾问

最后，我们可以看看查询本身吗？

干杯

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2009-05-12T06:27:14.907

您是否尝试过将 sql 包装在存储过程中，它们似乎有更好的内存管理。以前在使用经典 ADO 进行内部查询的计划 sql 语句中看到过这样的超时。即 select * from (select ....) t inner join somthingTable。内部查询返回大量结果的地方。

其他提示 1\. 使用 with(nolock) 执行提示执行读取，它很脏，我不推荐它，但它往往会更快。2.还要查看您尝试运行的sql的执行计划并减少行扫描，您加入表的顺序。3\. 考虑为您的表添加一些索引以加快读取速度。4\. 我还发现删除行非常昂贵，您可以尝试限制每次调用的行数。5\. 用#temporary 表交换@table 变量过去也对我有用。6\. 你也可能保存了糟糕的执行计划（听说过，没见过）。

希望这可以帮助

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2009-05-12T15:33:03.003

> 更新：看起来查询不会引发任何超时。连接超时。

Iow，即使您不执行查询，连接也会超时？因为有两个超时：连接和查询。每个人似乎都专注于查询，但是如果您遇到连接超时，那是网络问题，与查询无关：显然，必须先建立连接，然后才能运行查询。

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2009-10-30T18:05:59.480

可能值得尝试将结果分页。

# mysql - 将用户帐户注入 mySQL

> ID：105645
> 
> 赞同：5
> 
> 时间：2008-09-19T21:09:32.027
> 
> 标签：mysql, account

在这里处理一个奇怪的场景。

我们使用专有的工作站管理应用程序，该应用程序使用 mySQL 来存储其数据。在应用程序中，它们提供了许多报告，例如哪个用户在什么时间登录了哪台机器，安装在被监控机器上的所有软件产品等等。我们正在寻找一组不同的报告，但是，它们不支持自定义报告。

由于他们的数据存储在 mySQL 中，我认为我可以手动进行报告。我没有有效的凭据来连接到 mySQL 服务器。**无论如何我可以在 mySQL 服务器中创建用户帐户吗？**我不想重置 root 密码或任何可能存在的帐户，因为它可能会破坏应用程序。

* * *

我拥有对 Windows 2003 服务器的完全访问权限。我可以停止和重新启动服务，包括 mySQL 服务器。对于实际的 mySQL 服务器，我只能通过软件提供的 GUI 进行基本访问。我无法通过 CLI 或其他工具直接连接到它（由于缺少凭据）。

* * *

如果它像我试图未经授权访问 mySQL 服务器一样脱落，我深表歉意。我已经联系了软件公司，到今天已经两周没有收到他们的回复。我需要获取数据。我对物理盒子有完全的访问权限，我对它有管理员权限。

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-09-19T21:31:32.300

您需要使用 MySQL 密码恢复过程。遵循[这些说明](http://dev.mysql.com/doc/refman/5.0/en/resetting-permissions.html#resetting-permissions-windows)，除了将密码重置查询替换为[添加新用户](http://dev.mysql.com/doc/refman/5.0/en/adding-users.html)的查询。新的用户查询将类似于：

```
GRANT ALL ON *.* TO 'myuser'@'localhost' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; 
```

这将创建一个密码为“mypassword”的新用户“myuser”，该用户可以通过本地系统的 CLI 登录 MySQL。然后，您可以使用 MySQL 管理员 GUI（[在此处下载](http://dev.mysql.com/downloads/gui-tools/5.0.html)）并更新用户权限，以便您可以从网络上的其他系统登录。或者使用 CLI 中的[`GRANT`语句](http://dev.mysql.com/doc/refman/5.0/en/grant.html)，如果这更符合您的风格。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T21:11:42.363

您是否有权访问相关的 MySQL 服务器？

例如，除了普通用户之外，您还有哪些访问权限？在“破解”你的方式之前，你应该尝试通过这些路线，因为使用该软件可能会也可能不会。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T21:13:55.057

我想我真的不应该回答这个问题，但这太有趣了。

查看有关 SQL 注入的[此页面。](http://en.wikipedia.org/wiki/Sql_injection)那应该可以满足您的需求。 [此](http://dev.mysql.com/doc/refman/5.0/en/adding-users.html)页面显示如何将用户帐户添加到 mySQL

我会尝试在随机用户输入字段中输入以下内容：

```
p'; INSERT INTO user VALUES 
```

('localhost','myNewAdmin',PASSWORD('some_pass'),'Y','Y','Y','Y','Y','Y','Y','Y','Y ','Y','Y','Y','Y','Y');

进而

```
p'; FLUSH PRIVILEGES; 
```

p'; 旨在关闭常规问题。例如 - 正常问题是：

```
"Select Adress from cusomers where custName = ' + $INPUT + '; 
```

变成

```
 Select Adress from cusomers where custName = 'p'; INSERT INTO user 
VALUES('localhost','myNewAdmin',PASSWORD('some_pass'), 
'Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y'); 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T21:15:01.357

想到的一件事是嗅探数据库通信并希望它没有被加密。如果已加密，请尝试更改配置以不使用 SSL 并重新启动 mysql。我使用的一个很好的嗅探器是[Wireshark](http://www.wireshark.org/)

来自[mysql 5.0 文档](http://dev.mysql.com/doc/refman/5.0/en/secure-connections.html)：

> MySQL 使用安全套接字层 (SSL) 协议支持 MySQL 客户端和服务器之间的安全（加密）连接。本节讨论如何使用 SSL 连接。它还描述了一种在 Windows 上设置 SSH 的方法。有关如何要求用户使用 SSL 连接的信息，请参阅第 12.5.1.3 节，“GRANT 语法”中对 GRANT 语句的 REQUIRE 子句的讨论。
> 
> MySQL 的标准配置旨在尽可能快，因此默认情况下不使用加密连接。这样做会使客户端/服务器协议慢得多。加密数据是一项 CPU 密集型操作，需要计算机执行额外的工作，并且可能会延迟其他 MySQL 任务。对于需要加密连接提供的安全性的应用程序，需要额外的计算。
> 
> MySQL 允许在每个连接的基础上启用加密。您可以根据个别应用的需求选择普通的未加密连接或安全的加密 SSL 连接。
> 
> 安全连接基于 OpenSSL API，可通过 MySQL C API 获得。复制使用 C API，因此可以在主服务器和从服务器之间使用安全连接。

您可能已经这样做了，但仍然 - 尝试搜索应用程序配置文件。如果什么都没有 - 尝试搜索可执行文件/源代码 - 如果幸运的话，也许它是纯文本的。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T21:19:39.567

很可能在数据库端有触发器来保存日志，因此当您将自己侵入数据库时​​，他们会知道您何时以及如何做到这一点。不是一个好主意。

# gdb - 如何在 gdb 中打印 wstring

> ID：105651
> 
> 赞同：9
> 
> 时间：2008-09-19T21:11:05.157
> 
> 标签：gdb, wstring

如何在 gdb 中打印 wstring？

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2009-09-10T16:48:49.287

`call printf %ls`有时只能工作，但要让它在 gdb 6.3 中工作，你需要这里显示的强制转换`void`和换行`\n`：

```
调用 (void)printf("\"%ls\"\n",str.c_str())
```

这是一个更可靠的命令，您可以将其放入您的 .gdbinit 中，该命令还显示非 ASCII 代码点：

```
定义 wc_print
回声“
设置 $c = (wchar_t*)$arg0
而 ( *$c )
  如果 ( *$c > 0x7f )
    printf "[%x]", *$c
  别的
    printf "%c", *$c
  结尾
  设置 $c++
结尾
回声“\n
结尾
```

只需使用 a或输入`wc`（缩写） 。`wc_print``std::wstring``wchar_t*`

更多详细信息，[请访问 http://www.firstobject.com/wchar_t-gdb.htm](http://www.firstobject.com/wchar_t-gdb.htm)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T21:45:10.350

假设你有一个`std::wstring str`. 以下应该在 gdb 中工作：

```
call printf("%ls", str._M_data()) 
```

（ printf 中的 -l 选项使它成为一个长字符串，我相信您需要 " `call`" 语句，因为普通的 gdb printf 不喜欢该选项。）

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T21:45:54.917

我做了一些研究，这是 gdb [PR716](http://sourceware.org/cgi-bin/gnatsweb.pl?cmd=view&database=gdb&pr=716)，[PR1998](http://sourceware.org/cgi-bin/gnatsweb.pl?cmd=view&database=gdb&pr=1998)，[PR2264](http://sourceware.org/cgi-bin/gnatsweb.pl?cmd=view&database=gdb&pr=2264)。显然，这是一个经常被请求但尚未实现的功能。

# c - 带有 C 中指针的 int 矩阵 - 内存分配混乱

> ID：105653
> 
> 赞同：6
> 
> 时间：2008-09-19T21:11:17.917
> 
> 标签：c, pointers, memory-management, matrix

我在不产生内存泄漏的情况下生成 int 矩阵时遇到了一些问题。我希望能够通过 read_matrix() 将给定的（全局）矩阵动态地制成任何大小。但是我希望以后能够释放内存。所以在我的主要方法中，第二个 printf 应该导致总线错误，因为它不应该分配任何内存。我将如何去创造这个？

```
int**       first_matrix;
int**       second_matrix;
int**       result_matrix;

int** read_matrix(int size_x, int size_y)
{
    int** matrix;
    matrix = calloc(size_x, sizeof(int*));
    for(int i = 0;i<size_x;i++) {
        matrix[i] = calloc(size_y, sizeof(int));
    }
    for(int i = 0;i<size_x;i++) {
        for(int j = 0;j<size_y;j++) {
            matrix[i][j] = i*10+j;
        }
    }
    return matrix;
}

int main(int stackc, char** stack)
{
    first_matrix = read_matrix(10,10);
    printf("9:3 %d - 4:6 %d \n", first_matrix[9][3], first_matrix[4][6]);
    free(*first_matrix);
    free(first_matrix);
    printf("9:3 %d - 4:6 %d \n", first_matrix[9][3], first_matrix[4][6]);
} 
```

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-09-19T21:18:00.320

仅仅因为内存已被释放并不意味着您无法访问它！当然，在它被释放后访问它是一个**非常糟糕**的主意，但这就是它在您的示例中起作用的原因。

请注意，`free( *first_matrix )`只有 free's `first_matrix[0]`，而不是其他数组。您可能需要某种标记来表示最后一个数组（除非您总是知道释放外部数组时分配了多少内部数组）。就像是：

```
int** read_matrix(int size_x, int size_y)
{
    int** matrix;
    matrix = calloc(size_x, 1+sizeof(int*)); // alloc one extra ptr
    for(int i = 0;i<size_x;i++) {
        matrix[i] = calloc(size_y, sizeof(int));
    }
    matrix[size_x] = NULL; // set the extra ptr to NULL
    for(int i = 0;i<size_x;i++) {
        for(int j = 0;j<size_y;j++) {
            matrix[i][j] = i*10+j;
        }
    }
    return matrix;
} 
```

然后当你释放它们时：

```
// keep looping until you find the NULL one
for( int i=0; first_matrix[i] != NULL; i++ ) {
    free( first_matrix[i] );
}
free( first_matrix ); 
```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T21:14:08.177

您需要单独释放每一行：

```
 void free_matrix(int **matrix, int size_x)
{
    for(int i = 0; i < size_x; i++)
        free(matrix[i]);
    free(matrix);
} 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T21:15:21.997

释放内存并不会让它消失，它只是意味着另一个分配可能会占用相同的内存块。无论您放入什么，它都会一直存在，直到有其他东西覆盖它。

此外，您并没有释放您分配的所有内容。您只释放指针数组和第一行。但即使你正确地释放了所有东西，你仍然会有同样的效果。

如果要创建“总线错误”，则需要指向不属于您的进程的内存。你为什么要这样做呢？

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T21:14:59.923

您只释放了 first_matrix 的第一行（或列）。编写另一个这样的函数：

```
void free_matrix(int **matrix, int rows)
{
    int i;
    for(i=0; i<rows; i++)
    {
        free(matrix[i]);
    }
    free(matrix);
} 
```

您可能希望将矩阵制作成一个结构来存储它的行数和列数。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T21:15:28.797

我建议使用 valgrind 来追踪未释放的内存，而不是试图让总线错误发生。它也适用于许多其他东西。

山姆

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-19T21:16:57.047

您正在获得内存泄漏，因为您正在释放矩阵的第一行和行列表，但没有释放第 1 到第 n 行。您需要循环调用 free 。

但是，有几种选择： - 分配 sizeof(int*) *rows + rows* cols*sizeof(int) 字节并将第一个字节用作行指针。这样，您只有一块内存可以释放（并且在分配器上也更容易） - 使用包含行数的结构。然后你可以完全避免行列表（节省内存）。唯一的缺点是您必须使用函数、宏或一些杂乱的符号来处理矩阵。

如果你选择第二个选项，你可以在任何 C99 编译器中使用这样的结构，并且只需要分配一个内存块（大小为 numints*sizeof(int)+sizeof(int)）：

```
struct matrix {
    int rows;
    int data[0];
} 
```

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T21:21:08.753

您在这里缺少的概念是，对于每个 calloc，都必须有一个 free。并且该 free 必须应用于从 calloc 传回的指针。

我建议您创建一个函数（名为 delete_matrix），它使用循环来释放您在此处分配的所有指针

**for(int i = 0;i < size_x;i++) { matrix[i] = calloc(size_y, sizeof(int)); }**

然后，一旦完成，释放 this 分配的指针。

**矩阵 = calloc(size_x, sizeof(int*));**

你现在的做法，

**免费（*first_matrix）；免费（first_matrix）；**

不会做你想做的事。

# c - 如何在 C 中获取堆栈跟踪？

> ID：105659
> 
> 赞同：86
> 
> 时间：2008-09-19T21:11:54.220
> 
> 标签：c, windows, debugging, cross-platform, stack-trace

我知道没有标准的 C 函数可以做到这一点。我想知道在 Windows 和 *nix 上对此有什么技术？（Windows XP 是我现在最重要的操作系统。）

* * *

## 回答 #1

> 赞同：82
> 
> 时间：2008-09-19T21:15:32.027

glibc 提供`backtrace()`函数。

[http://www.gnu.org/software/libc/manual/html_node/Backtraces.html](http://www.gnu.org/software/libc/manual/html_node/Backtraces.html)

* * *

## 回答 #2

> 赞同：32
> 
> 时间：2010-02-25T19:07:58.157

有`backtrace()`和`backtrace_symbols()`：

从手册页：

```
#include <execinfo.h>
#include <stdio.h>
...
void* callstack[128];
int i, frames = backtrace(callstack, 128);
char** strs = backtrace_symbols(callstack, frames);
for (i = 0; i < frames; ++i) {
    printf("%s\n", strs[i]);
}
free(strs);
... 
```

以更方便/OOP 方式使用它的一种方法是将结果保存`backtrace_symbols()`在异常类构造函数中。因此，每当您抛出该类型的异常时，您都会获得堆栈跟踪。然后，只需提供一个打印出来的功能。例如：

```
class MyException : public std::exception {

    char ** strs;
    MyException( const std::string & message ) {
         int i, frames = backtrace(callstack, 128);
         strs = backtrace_symbols(callstack, frames);
    }

    void printStackTrace() {
        for (i = 0; i < frames; ++i) {
            printf("%s\n", strs[i]);
        }
        free(strs);
    }
}; 
```

...

```
try {
   throw MyException("Oops!");
} catch ( MyException e ) {
    e.printStackTrace();
} 
```

达达！

注意：启用优化标志可能会使生成的堆栈跟踪不准确。理想情况下，可以在打开调试标志和关闭优化标志的情况下使用此功能。

* * *

## 回答 #3

> 赞同：22
> 
> 时间：2008-09-24T13:07:58.227

对于 Windows，请检查 StackWalk64() API（也在 32 位 Windows 上）。对于 UNIX，您应该使用操作系统的本地方式来执行此操作，或者回退到 glibc 的 backtrace()（如果可用）。

但是请注意，在本机代码中使用 Stacktrace 很少是一个好主意 - 不是因为它不可能，而是因为您通常试图实现错误的事情。

大多数时候，人们试图在异常情况下获取堆栈跟踪，例如当捕获到异常时，断言失败或者 - 最糟糕和最错误的 - 当您遇到致命的“异常”或信号时分割违规。

考虑到最后一个问题，大多数 API 将要求您显式分配内存，或者可能在内部进行。在您的程序当前可能处于的脆弱状态下这样做可能会使事情变得更糟。例如，崩溃报告（或 coredump）不会反映问题的实际原因，但您尝试处理它失败）。

我假设您正在尝试实现致命错误处理，因为大多数人似乎都在尝试获取堆栈跟踪。如果是这样，我将依赖调试器（在开发期间）并让进程在生产中进行核心转储（或在 Windows 上进行迷你转储）。加上适当的符号管理，您应该可以毫不费力地找出导致指令的事后分析。

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-10-01T21:35:37.657

对于 Windows，`CaptureStackBackTrace()`这也是一种选择，它需要的用户端准备代码比`StackWalk64()`它少。（此外，对于我遇到的类似情况，`CaptureStackBackTrace()`最终效果更好（更可靠）`StackWalk64()`。）

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2010-01-31T06:31:55.703

您应该使用[unwind 库](http://www.nongnu.org/libunwind/)。

```
unw_cursor_t cursor; unw_context_t uc;
unw_word_t ip, sp;
unw_getcontext(&uc);
unw_init_local(&cursor, &uc);
unsigned long a[100];
int ctr = 0;

while (unw_step(&cursor) > 0) {
  unw_get_reg(&cursor, UNW_REG_IP, &ip);
  unw_get_reg(&cursor, UNW_REG_SP, &sp);
  if (ctr >= 10) break;
  a[ctr++] = ip;
} 
```

除非您从共享库进行调用，否则您的方法也可以正常工作。

在 Linux 上可以使用该`addr2line`命令获取对应 PC 的源函数/行号。

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2008-09-19T21:15:16.473

没有平台独立的方式来做到这一点。

您可以做的最接近的事情是在没有优化的情况下运行代码。这样，您可以附加到进程（使用可视化 c++ 调试器或 GDB）并获得可用的堆栈跟踪。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-22T02:15:34.567

Solaris 有[pstack](http://linuxcommand.org/man_pages/pstack1.html)命令，该命令也被复制到 Linux 中。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-19T21:15:13.773

你可以通过向后走堆栈来做到这一点。但实际上，通常更容易在每个函数的开头将标识符添加到调用堆栈并在结尾弹出它，然后只需执行打印内容即可。这有点像 PITA，但效果很好，最终会节省你的时间。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2018-02-08T10:57:03.927

在过去的几年里，我一直在使用 Ian Lance Taylor 的 libbacktrace。它比 GNU C 库中需要导出所有符号的函数要干净得多。它比 libunwind 提供了更多用于生成回溯的实用程序。最后但并非最不重要的一点是，它并没有像需要外部工具（如`addr2line`.

Libbacktrace 最初是 GCC 发行版的一部分，但现在作者在 BSD 许可下将其作为独立库提供：

[https://github.com/ianlancetaylor/libbacktrace](https://github.com/ianlancetaylor/libbacktrace)

在撰写本文时，除非我需要在 libbacktrace 不支持的平台上生成回溯，否则我不会使用其他任何东西。

# .net - (any == System.DBNull.Value) vs (any is System.DBNull)

> ID：105671
> 
> 赞同：11
> 
> 时间：2008-09-19T21:13:10.410
> 
> 标签：.net, null, dbnull

有没有人对如何检查一个值是否有偏好`DBNull`？我发现这两个陈述给了我想要的结果，但只是想知道是否有偏好？

`if (any is System.DBNull)`

如同：

`if (any == System.DBNull.Value)`

谢谢！

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-09-19T21:20:12.267

我倾向于使用

```
if (DBNull.Value.Equals(value)) {
    //
} 
```

或者

```
if (Convert.IsDBNull(value)) {
    //
} 
```

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-09-20T22:41:43.433

`is`不像 Kevlar623 所说的那样使用反射。它映射到`isinst`IL 中的操作。在那个层面上，比较性能是完全愚蠢的，除非你正在研究导弹制导系统。

**我用`value is DBNull`.** 这听起来很对，作为一个偏执的开发人员，我不能相信存在的唯一价值是`DBNull.Value`. 错误发生。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-09-19T21:14:19.860

```
if (any == System.DBNull.Value) ... 
```

我更喜欢那个，只是因为我把它看作是比较值，而不是类型。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T21:16:15.660

如果你在 C# 中，你应该使用`==`; `is`使用计算成本更高的反射，特别是因为只有一个`System.DBNull`.

* * *

## 回答 #5

> 赞同：-1
> 
> 时间：2008-09-19T21:17:13.597

我更喜欢“is System.DBNull”，因为我讨厌将某些东西与 NULL 进行比较并让它为真的想法。许多其他语法（那到底是什么复数？）anything==NULL 返回 NULL。

我知道有 DBNull.Value 是有原因的。我知道。我列出了我的偏好:)

* * *

## 回答 #6

> 赞同：-2
> 
> 时间：2008-12-23T18:46:21.747

这是形式跟随功能的一个很好的例子。无论哪一个执行效率更高，都是要走的路。它看起来像什么，读起来像什么，或者它叫你的坏名字是无关紧要的。有效地使用语言，不要将语言塑造成一种新的语言。

# c# - 获取没有 DNS 的网络上所有计算机的列表

> ID：105676
> 
> 赞同：3
> 
> 时间：2008-09-19T21:13:56.150
> 
> 标签：c#, .net, networking, batch-file

问候，

我需要一种方法（通过 C# 或在 .bat 文件中）来获取给定网络上所有计算机的列表。通常，我使用“网络视图”，但这往往只在您的域内起作用（据我的理解）。我需要网络上所有可用计算机的名称（或至少是 IP 地址）。

能够获取不是我的域上的所有计算机（在这种情况下，我会使用 WORKGROUP，或者任何默认值）也可以。

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-19T21:17:28.840

[Nmap](http://nmap.org/)对此很有用 - 使用 -O 选项进行操作系统指纹识别，使用 -oX "filename.xml"[输出](http://nmap.org/book/man-output.html)为 xml，然后您可以从 c# 解析。

合适的命令行是（其中 192.168.0.0/24 是要扫描的子网）：

```
nmap -O -oX "filename.xml" 192.168.0.0/24 
```

如果您对猜测操作系统不感兴趣，请忽略 -O - 如果您只想进行 ping 扫描，请使用 -sP，或阅读文档以了解无数其他选项。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-22T12:30:41.000

为了扩展Unkwntech所说的-

您还可以进行“广播”ping，以避免必须单独 ping 每个 IP 地址。

之后，您可以立即使用“arp”检查 ARP 缓存并获取哪些 IP 地址在哪个 MAC 地址上的列表。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T21:15:49.327

Ping 愤怒的一切，然后您可以从响应识别它的名称的系统中获取 netbios 信息。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T22:16:26.623

在我的一个网络应用程序中，我使用 NetApi32 功能进行网络浏览。

代码： http: [//gist.github.com/11668](http://gist.github.com/11668)

# tcp - TCP 发送队列深度

> ID：105681
> 
> 赞同：1
> 
> 时间：2008-09-19T21:14:54.400
> 
> 标签：tcp, network-programming

我如何发现有多少字节已发送到 TCP 套接字但尚未在线上？

看这里的图表： [![http://www.tcpipguide.com/free/diagrams/tcpswpointers.png](https://i.stack.imgur.com/pHB5a.png)](https://i.stack.imgur.com/pHB5a.png)

我想知道类别 2、3 和 4 的总数或 3 和 4 的总数。这是在 C(++) 和 Windows 和 Linux 上。理想情况下，我可以使用一个 ioctl，但似乎没有。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-09-19T21:28:50.187

在 Linux 下，请参见 tcp(7) 的手册页。

看来您可以通过 ioctl(sock,SIOCINQ ...

TCP_INFO getsockopt() 调用返回的结构成员可能会提供其他统计信息。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T21:36:31.117

如果你想确定是否添加数据：别担心，send 会阻塞，直到数据在队列中。如果你不想让它阻塞，你可以告诉它发送（2）：

```
send(socket, buf, buflen, MSG_DONTWAIT); 
```

但这仅适用于 Linux。

您还可以将套接字设置为非阻塞：

```
fcntl(socket, F_SETFD, O_NONBLOCK); 
```

如果无法将数据写入流，这种方式 write 将返回错误（EAGAIN）。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T21:17:33.147

一些 Unix 风格可能有一个 API 方法来做到这一点，但没有办法做到这一点，可以跨不同的变体移植。

# xml - 对于声明为 nillable 的字段，我应该发送什么 XML？

> ID：105688
> 
> 赞同：1
> 
> 时间：2008-09-19T21:15:24.397
> 
> 标签：xml, xsd, xml-nil

我有一个带有 REST 样式接口的应用程序，它通过 POST 从客户端获取 XML 文档。此应用程序是用 Java 编写的，并使用 XML bean 来处理发布的消息。

消息中字段的 XML 模式定义如下所示：

```
<xs:element name="value" type="xs:string" nillable="true" /> 
```

如何发送符合此规范的空值？

我发送`<value xsi:nil="true" />` 了，但这导致 XML 解析器出错。

* * *

## 回答 #1

> 赞同：15
> 
> 时间：2008-09-19T21:18:53.657

怎么样`<value xsi:nil="true"></value>`？这就是[规范中的](http://www.w3.org/TR/xmlschema-0/#Nils)内容。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T21:19:05.043

过去，当我的 XML 元素为空时，我既不能包含它们，也不能将它们发送为空，因此，在您的情况下，它是： `<value />`

你试过吗？

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T21:21:30.670

这是发送 nil 值的正确方法（假设默认命名空间和`xsi`命名空间设置为正确的值，即`"http://www.w3.org/2001/XMLSchema-instance"`for `xsi`.），因此看起来您可能遇到了您正在使用的 CML 解析器中的错误。错误信息是什么？

您可以尝试使用`xsi:nil="1"`或使用单独的打开和关闭标记 ( `<value xsi:nil="true"></value>`) 来尝试解决该错误。

# java - 有没有办法在 Java 应用程序中启用鼠标滚轮（用于滚动）？

> ID：105698
> 
> 赞同：2
> 
> 时间：2008-09-19T21:16:37.610
> 
> 标签：java, scroll, mouse, mousewheel

理想情况下，我想要一种方法来启用鼠标滚轮以在旧编译的 java 运行时应用程序中滚动，但 java 代码明确地将其用于单个应用程序就足够了。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-20T00:08:16.247

除非您编写了自定义组件，否则您不必针对 1.5 或 1.6 重新编译以获得鼠标滚轮。鼠标滚轮行为已添加到 swing 类中，因此只需针对新 JRE 运行旧的 Java 应用程序就应该支持鼠标滚轮，而无需做任何事情（至少在可滚动/基于 JScrollPane 的东西中）

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T21:20:22.030

当前的 Swing 应用程序支持鼠标滚轮滚动。您可以尝试使用 JDK 1.4、1.5 或 1.6 编译您的应用程序。根据复杂性和环境，迁移到新版本可能是也可能不是可行的选择。

[如果您想要与正常行为不同的东西，本教程](http://java.sun.com/docs/books/tutorial/uiswing/events/mousewheellistener.html)将展示如何编写自己的鼠标滚轮侦听器。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T21:28:03.103

看看 Pushing Pixels 博客：[http ://www.pushing-pixels.org/index.php?s=mouse+wheel](http://www.pushing-pixels.org/index.php?s=mouse+wheel)

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T21:26:31.143

如果没有访问源代码，您将无法做到这一点。如果您确实可以访问源代码，那么按照 RichH 所说的去做。

# python - 为公共 django 站点制作 beta 代码

> ID：105702
> 
> 赞同：11
> 
> 时间：2008-09-19T21:17:20.820
> 
> 标签：python, django, authentication, django-authentication

我即将在网络上发布我正在开发的网站的测试版。它需要有一个测试代码来限制访问。该网站是用 django 编写的。

我不想改变基本的 Auth 系统以适应 beta 代码，我也不特别关心 beta 代码的安全性是铁定的，只是它是一个重要的绊脚石。

我该怎么做？这是一个相当大的项目，因此向每个视图添加代码远非理想。

* * *

该解决方案效果很好。我最终得到的中间件类是这样的：

```
from django.http import HttpResponseRedirect

class BetaMiddleware(object):
    """
    Require beta code session key in order to view any page.
    """
    def process_request(self, request):
        if request.path != '/beta/' and not request.session.get('in_beta'):
            return HttpResponseRedirect('%s?next=%s' % ('/beta/', request.path)) 
```

* * *

## 回答 #1

> 赞同：21
> 
> 时间：2008-09-19T22:43:40.303

[从这个 Django 片段](http://www.djangosnippets.org/snippets/136/)开始，但修改它以检查`request.session['has_beta_access']`。如果他们没有，则让它返回一个重定向到“输入 beta 代码”页面，当使用正确的代码发布到该页面时，将该会话变量设置为`True`.

然后将其设为公开测试版，只需从您的`MIDDLEWARE_CLASSES`设置中删除该中间件即可。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-19T21:25:38.990

您可能可以使用 htaccess 通过 apache 限制对整个站点的访问，从而将问题完全排除在 django 的项目空间之外。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T21:51:26.403

做 StackOverflow 所做的。

他们有一个简单的电子邮件/密码表格。它有一个硬编码密码（falkensmaze）。当用户获得正确的密码时设置一个cookie。例如。授权=1

不用担心它不安全。谁在乎是否有人入侵了测试版？

Apache/htaccess 也是一个不错且简单的解决方案。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T21:24:56.670

您应该能够全面添加`@login_required`装饰器并完成它。除非你有大量的视图功能，否则它不应该太可怕。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2009-08-08T17:56:36.847

我不确定您使用的是哪个版本的 Pinax 代码，但它们内置了关闭网站以进行私人测试版的功能，因此您无需自己做太多工作。

私人测试版网站的特定项目模板的链接在这里：http: [//github.com/pinax/pinax/tree/3ad73d1ba44f37365333bae17b507668b0eb7e16/pinax/projects/private_beta_project](http://github.com/pinax/pinax/tree/3ad73d1ba44f37365333bae17b507668b0eb7e16/pinax/projects/private_beta_project)尽管我认为他们可能已经将该功能添加到所有项目中模板。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2009-11-20T14:47:12.457

很棒的片段，但它给我带来了很多与 OpenId 相关的问题。所以我最终依赖 Cookies 而不是 Session：

```
class BetaMiddleware(object):
    """
    Require beta code cookie key in order to view any page.
    """
    set_beta = False
    def process_request(self, request):
        referer = request.META.get('HTTP_REFERER', '')

        if request.method == 'GET' and not 'is_in_beta' in request.COOKIES:
            return HttpResponseRedirect('%s?next=%s' % ('/beta/', request.path))

        if request.method == 'POST' and 'pass' in request.POST:
            code = request.POST['pass']

            if code=='beta':
                self.set_beta = True
                return HttpResponseRedirect('%s' % '/')

    def process_response(self, request, response):        

        if self.set_beta is True:
            response.set_cookie('is_in_beta', '1')
        return response 
```

这并不安全，但这对我来说已经足够了。这也仅适用于 beta html 页面。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2020-01-17T15:25:53.870

使用这个中间件：

```
class BetaForm(Form):
    beta_pass = CharField(required=True)

    def clean_beta_pass(self):
        data = self.cleaned_data['beta_pass']
        if data != settings.BETA_PASS:
            raise forms.ValidationError("Invalid Beta pass!")
        return data

class BetaView(FormView):
    form_class = BetaForm
    template_name = "beta.html"

    def form_valid(self, form):
        response = HttpResponseRedirect(self.request.GET.get("next", "/"))
        response.set_cookie(settings.BETA_PASS, '')
        return response

def beta_middleware(get_response):
    def middleware(request):

        if request.path == reverse("beta"):
            return get_response(request)
        else:
            if settings.BETA_PASS in request.COOKIES:
                return get_response(request)
            else:
                return HttpResponseRedirect(
                    '%s?%s' % (reverse("beta"), urlencode({"next": request.get_full_path()})))
    return middleware 
```

这个模板：

```
<!doctype html>
<title>Welcome to the beta!</title>
<style>
  body { text-align: center; padding: 150px; }
  h1 { font-size: 50px; }
  body { font: 20px Helvetica, sans-serif; color: #333; }
  article { display: block; text-align: left; width: 650px; margin: 0 auto; }
  a { color: #dc8100; text-decoration: none; }
  a:hover { color: #333; text-decoration: none; }
</style>

<article>

    <h1>>Welcome to the beta lucky user!</h1>
    <div>
        <form method="POST">
            {% csrf_token %}
            {{form}}
            <input type="submit">
        </form>
    </div>
</article> 
```

这个设置：

```
BETA_PASS="beta" 
```

这条路：

```
path("beta",BetaView.as_view(),name="beta"), 
```

# report - 简单报告的网页设计师

> ID：105716
> 
> 赞同：0
> 
> 时间：2008-09-19T21:19:36.213
> 
> 标签：report, designer

我的网络应用程序的用户需要编辑和“另存为”他们的报告，然后执行并将它们导出为 PDF 或 Excel 文件。我需要知道是否有简单报告的设计器（网络）（开源会更好）。报表并不复杂：只是数据字段、主从、标签、简单的公式、线条、静态图像……有吗？（问太多了？）谢谢

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T22:43:10.163

我只是从信息中生成一个 csv 文件并将其保存在 excel 方面。

在 PHP 中，是这样的：

```
<?php
// load info from database into an array
header("Content-type: application/vnd.ms-excel");
header( "Content-disposition: report.csv");

// loop through array and export each entry as so
echo ($item[1].",".$item[2].",".$item[3]."\n");
// end loop
?> 
```

显然，这只是准系统，但你可以看到我在说什么。

或者，PEAR 中的 PHP 库可以让您保存为 xls 或 pdf，但是当我可以摆脱它时，我总是更喜欢简单而不是复杂的库！

# javascript - 网络上的用户注册表单有哪些出色的示例？

> ID：105720
> 
> 赞同：2
> 
> 时间：2008-09-19T21:19:43.670
> 
> 标签：javascript, html, css, usability

我正在尝试获取人们认为最好的注册表单的样本。良好的设计，可用性。智能工程。有用的反馈。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-09-19T21:22:57.937

我一直以来最喜欢的注册表单之一是最初的[Vox](http://www.vox.com/)注册表单，后来它已被更改。它在网上发布[了一个很好的分解](http://www.askthecssguy.com/2007/03/form_field_hints_with_css_and.html)，它涉及到它对我来说如此伟大的事情。他们如何实现表单的 CSS 布局，如何使用带有弹出提示的表单内验证，等等——这很好。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-19T21:42:05.927

两个很好的链接开始：

[基于 CSS 的表单：现代解决方案](http://www.smashingmagazine.com/2006/11/11/css-based-forms-modern-solutions/)

[表单中的标签放置](http://www.uxmatters.com/MT/archives/000107.php)

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-19T21:49:35.580

我喜欢 Geni 的（www.geni.com）。这是一个不像注册表单的例子。您可以立即开始使用该站点，并且可以在需要时添加更多信息。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-09-19T21:37:29.773

我认为[Reddit的注册](http://www.reddit.com/login)很不错。如果您尝试使用需要您登录的操作，它将在所有 Javascripty 前面弹出。它只需要您的用户名和密码，只需几秒钟。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-09-19T21:48:16.863

令人惊讶的是，我在野外遇到的最喜欢的是戴尔的**[IdeaStorm](http://www.dellideastorm.com)**。

如果您单击需要登录的控件（例如，投票赞成一个想法），它会自动重新关注登录元素。如果您还没有帐户，您可以点击“注册”选项卡，无需加载页面。

注册表是完全轻量级的（我认为是四个字段），并使用 AJAX 检查名称是否已被占用。注册后，您将自动登录。

最重要的是，它在视觉上很紧凑，只需要最少的信息，并且让您无需离开原始页面即可登录或注册。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-09-21T16:30:38.950

在我看来，登录表单的完美示例是[2chan](http://www.wikipedia.org/wiki/2ch)上的那个。阅读链接的维基百科文章以了解。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-09-19T21:34:57.830

[37signals 的 Screens Around Town 专栏](http://www.google.com/search?q=site%3A37signals.com+%22screens+around+town%22)经常有有趣的内容。值得一看。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-19T21:38:58.257

flickr 中有一些不错[的注册表单照片，](http://www.flickr.com/photos/rosenfeldmedia/sets/72157604272550634/)与 Luke Wroblewski 的“Web 表单设计”一书相得益彰。

（这很好——如果你对这类事情感兴趣，值得一试）。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-19T21:31:53.937

建议我自己的是徒劳的吗？它并不完美，但我认为它是简单、友好和可选彻底的完美结合：

[https://www.woot.com/User/Register.aspx](https://www.woot.com/User/Register.aspx)

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-09-21T16:03:08.000

我觉得有趣的几个例子是[Tripit](http://www.tripit.com)，一个组织你的旅行计划的网站。虽然有一个注册服务的链接，但最简单快捷的方法是转发来自旅行服务（orbitz、travelocity、united.com、hertz.com 等）的确认电子邮件，这样做会自动让您注册并让你开始（一旦你登录到该网站，它会询问更多信息）。

另一个快速简便的注册是 Marco Arment 的[Instapaper](http://www.instapaper.com/user/register)。您只需填写您的电子邮件地址或用户名。

# vim - 如何在 Vim 中移动到行尾？

> ID：105721
> 
> 赞同：1336
> 
> 时间：2008-09-19T21:19:47.227
> 
> 标签：vim, editor, keyboard-shortcuts, vi

我知道通常如何在命令模式下移动，特别是跳转到行等。但是跳转到我当前所在行末尾的命令是什么？

* * *

## 回答 #1

> 赞同：2274
> 
> 时间：2008-09-19T21:20:48.503

只是`$` *（美元符号）*键。您可以使用`A`移动到行尾并切换到编辑模式（追加）。要跳转最后一个非空白字符，可以按`g`then`_`键。

与之相反的`A`是`I`（在行首插入模式），作为旁白。仅按`^`会将光标放在该行的第一个非空白字符处。

* * *

## 回答 #2

> 赞同：326
> 
> 时间：2008-09-19T22:22:49.087

正如很多人所说：

*   `$`让你走到最后

但是也：

*   `^`或`_`让您到达该行中的第一个非空白字符，并且
*   `0`（零）将您带到行首，包括。空白

* * *

## 回答 #3

> 赞同：142
> 
> 时间：2010-09-28T11:04:58.223

*   `$`移动到该行的最后一个字符。
*   `g` `_`转到最后一个非空白字符。

*   `g` `$`转到屏幕行的末尾（当缓冲行跨越多个屏幕行时）

* * *

## 回答 #4

> 赞同：83
> 
> 时间：2015-02-07T11:02:51.260

主要问题 - 行尾

`$`到行尾，保持在命令模式

`A`走到行尾，切换到插入模式

相反 - 行首（技术上是第一个*非空白*字符）

`^`转到行首，保持在命令模式

`I`（大写 i）转到行首，切换到插入模式

进一步 - 行首（技术上第一列与*空格无关*）

`0`（零）转到行首，保持在命令模式

`0i`（零后跟小写 i）进入行首，切换到插入模式

对于那些开始学习 vi 的人，这里是 vi 的一个很好的介绍，通过并排列出 vi 命令到典型的 Windows GUI 编辑器光标移动和快捷键。

[适用于 Windows 用户的 vi 编辑器](https://cognitivewaves.wordpress.com/vi-editor/)

* * *

## 回答 #5

> 赞同：47
> 
> 时间：2008-09-19T22:49:56.823

如果当前行环绕可见屏幕到下一行，则可以使用**g$**到达*屏幕*行的末尾。

* * *

## 回答 #6

> 赞同：36
> 
> 时间：2019-05-08T14:58:39.800

我看不到在标准终端中使用 vim 的 macbook 热键。希望它会帮助某人。对于 macOS 用户（在 macbook pro 2018 上测试）：

> `fn`+ `←` - 移动到开始行
> 
> `fn`+ `→` - 移动到结束行
> 
> `fn`+ `↑` - 向上移动页面
> 
> `fn`+ `↓` - 向下移动页面
> 
> `fn`+ `g` - 将光标移动到文档的开头
> 
> `fn`+ `shift` + `g` - 将光标移动到文档末尾

对于最后两个命令，有时需要点击两次。

* * *

## 回答 #7

> 赞同：18
> 
> 时间：2008-09-19T21:20:51.203

按下`A`以从行尾开始进入编辑模式。

* * *

## 回答 #8

> 赞同：17
> 
> 时间：2008-09-19T21:20:26.430

美元符号：$

* * *

## 回答 #9

> 赞同：15
> 
> 时间：2008-09-19T22:05:58.100

“结束”键的优点是它可以在正常和插入模式下工作。

'$' 仅适用于普通/命令模式，但它也适用于经典 vi 编辑器（很高兴知道 vim 何时不可用）。

* * *

## 回答 #10

> 赞同：13
> 
> 时间：2010-11-27T07:04:55.670

在许多情况下，当我们在一个字符串中时，我们用双引号括起来，或者在编写语句时，我们不想按转义键并使用箭头键转到该行的末尾并按分号（`;`）只是为了结束线。*在vimrc*文件中写入以下行：

```
imap <C-l> <Esc>$a 
```

这条线说什么？它将 Ctrl+l 映射到一系列命令。这相当于你一次按`Esc`（命令模式），`$`（行尾），`a`（追加）。

* * *

## 回答 #11

> 赞同：13
> 
> 时间：2010-12-17T18:31:41.140

*还要注意line*（或者可能是物理线）和*screen line*之间的区别。行由行尾字符 ("\n") 终止。屏幕行是在终端或屏幕中显示为一行字符的任何内容。如果你的物理线长于屏幕宽度，这两者就会分开，这在写电子邮件等时很常见。

区别也显示在行尾命令中。

*   `$`并`0`分别移动到物理行或段落的末尾或开头：
*   `g``$`并`g``0`分别移动到屏幕行或段落的末尾或开头。

如果你总是喜欢后一种行为，你可以像这样重新映射键：

```
:noremap 0 g0
:noremap $ g$ 
```

* * *

## 回答 #12

> 赞同：9
> 
> 时间：2008-09-19T21:35:06.083

或者有一个明显的答案：使用`End`键走到行尾。

* * *

## 回答 #13

> 赞同：6
> 
> 时间：2008-10-01T18:47:03.240

可能不相关，但如果你想在当前行之后开始新的一行，你可以在该行的任何地方使用 o。

* * *

## 回答 #14

> 赞同：3
> 
> 时间：2014-07-29T13:53:58.723

最简单的选择是键入`$`. 如果您正在处理文本块，您可能会喜欢该命令`{`，`}`以便分别前后移动段落。

* * *

## 回答 #15

> 赞同：2
> 
> 时间：2014-08-02T22:00:03.377

我习惯于 Home/End 让我在插入模式下（从在 Windows 中使用，我认为是 Linux）进入行的开头和结尾，这是 Mac 不支持的。这特别烦人，因为当我在远程系统上使用 vim 时，我也不能轻易做到。经过一些痛苦的尝试和错误，我想出了这些`.vimrc`行，它们做同样的事情，但绑定到 Ctrl-A 用于行的开头和 Ctrl-D 用于行的结尾。（出于某种原因，我猜 Ctrl-E 是保留的，或者至少我想不出一种绑定它的方法。）享受吧。

```
:imap <Char-1> <Char-15>:normal 0<Char-13>
:imap <Char-4> <Char-15>:normal $<Char-13> 
```

这里有一个很好的 ASCII 控制字符代码图表供其他人使用：

[http://www.physics.udel.edu/~watson/scen103/ascii.html](http://www.physics.udel.edu/~watson/scen103/ascii.html)

您也可以执行 Ctrl-V + Ctrl- ，但这并不能很好地粘贴到这样的地方。

# c# - 无法弄清楚这个 SubString.PadLeft 在做什么

> ID：105724
> 
> 赞同：0
> 
> 时间：2008-09-19T21:19:53.483
> 
> 标签：c#, substring, padleft

在我正在调试的这段代码中，我有这个代码片段：

```
ddlExpYear.SelectedItem.Value.Substring(2).PadLeft(2, '0'); 
```

这会返回什么？我真的不能运行太多，因为它是实时信用卡应用程序的一部分。您可以从名称中想象的 DropDownList 包含 4 位数的年份。

更新：谢谢大家。我没有做很多 .NET 开发，所以设置一个快速测试对我来说不是那么快。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T21:24:08.027

它采用年份的最后两位数字并用零填充左侧，最多为 2 个字符。看起来像是以 08、07 等结尾的到期年份的“以防万一”，确保出现前导零。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T21:26:02.907

这会将“98”打印到控制台。

```
class Program
{
    static void Main(string[] args)
    {
        Console.Write("1998".Substring(2).PadLeft(2, '0'));
        Console.Read();
    }
} 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T21:26:44.183

当然你可以运行这个。您只是无法在您正在调试的应用程序中运行它。要找出它在做什么，而不仅仅是它看起来在做什么，请创建一个新的 Web 应用程序，放入一个 DropDownList，在其中放入一些静态年份，然后放入您提到的代码，看看它是什么做。那你就肯定知道了。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T21:31:50.100

一些愚蠢的事情。它获取所选项目的值并获取前两个字符之后的所有内容。如果只有一个字符，则在其开头添加一个“0”，如果是零个字符，则返回“00”。我说这很愚蠢的原因是因为如果您需要将值设置为两个字符长，为什么不在创建下拉列表时将其设置为开头呢？

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T21:24:00.430

看起来它正在从第 3 个字符（如果基于 0）到末尾抓取子字符串，然后如果子字符串的长度小于 2，它会通过在左侧添加 0 来使长度等于 2。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-19T21:26:05.730

PadLeft 确保您从输入中接收到至少两个字符，用适当的字符填充输入（在左侧）。所以输入，在这种情况下，可能是 12。你得到“12”。或者输入可能是 9，在这种情况下，您会得到“09”。

这是一个复杂链接的示例（请参阅[“链接中是否有任何好处”](https://stackoverflow.com/questions/105504/is-there-any-performance-benefit-with-chaining-statements-in-net)帖子）出错，并使代码显得过于复杂。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T21:28:37.657

子字符串返回跳过前两个字符的值，padleft 用前导零填充结果：

```
 string s = "2014";
    MessageBox.Show(s.Substring(2).PadLeft(2, 'x')); //14
    string s2 = "14";
    MessageBox.Show(s2.Substring(2).PadLeft(2, 'x')); //xx 
```

我的猜测是代码试图将年份转换为 2 位值。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-09-19T21:37:51.117

PadLeft 仅在用户输入的年份为 2 或 3 位数时才起作用。

对于 1 位数的年份，您会得到一个例外（Subsring errs）。

使用两位数的年份（07、08 等），它将返回 00。我会说这是一个错误。

对于作者可能认为是拼写错误的 3 位数年份 (207, 208)，它将返回用零填充的最后一位数字 - 207 -> 07；208 -> 08。

只要用户必须选择年份并且不允许输入年份，就不需要 PadLeft —— Substring(2) 完全可以满足您对 4 位数年份的需求。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2012-07-09T23:05:17.770

此代码似乎试图从四位数年份中获取 2 位数年份（ddlexpyear 是提示）

它接受字符串并返回字符串，所以我将避开字符串分隔符：

*   1998 -> 98
*   2000 -> 00
*   2001 -> 01
*   2012 -> 12

问题是它做得不好。在这些情况下，填充实际上并没有帮助。删除 pad 代码不会影响它正确的情况。

所以代码工作（有或没有衬垫）4 位数年份，它对其他长度的字符串有什么作用？

*   空：异常
*   0：异常
*   1：异常
*   2：总是返回“00”。例如，49 年（当犹太人被驱逐出罗马时）变为“00”。这是不好的。
*   3：保存最后一位，前面加一个“0”。在 10% 的情况下是正确的（当第二个数字实际上是零时，例如 304 或 908），但在其余情况下则完全错误（例如 915、423 和 110）
*   5：只保存第 3 位和第 4 位，这也是错误的，“10549”应该是“49”而不是“54”。
*   正如您所料，问题继续以更高的数字出现。

* * *

## 回答 #10

> 赞同：-1
> 
> 时间：2008-09-19T21:25:04.047

好的，所以它从下拉列表中获取值，ABCD

然后它从位置 2 获取子字符串，CD

然后它会出错，如果它也需要，用 2 个零填充它，CD

或者，如果你刚刚结束了 X，那么它将成为 X 的子字符串并填充到 OX

* * *

## 回答 #11

> 赞同：-1
> 
> 时间：2008-09-19T21:25:08.040

它采用年份的最后两位数字，然后用“0”向左填充。

所以 2010 年是 10 年，2009 年是 09 年。

不知道为什么开发人员不只是将下拉列表中的值设置为最后两位数，或者为什么您需要保留它（除非您处理的是公元 0-9 年）。

# programming-languages - 如何编写自我复制代码（在 exec 上打印源代码）？

> ID：105725
> 
> 赞同：34
> 
> 时间：2008-09-19T21:20:03.857
> 
> 标签：programming-languages, quine

我已经看到很多基于 C/C++ 的解决方案来解决这个问题，我们必须编写一个程序，在执行时打印它自己的源代码。

一些解决方案——

[http://www.cprogramming.com/challenges/solutions/self_print.html](http://www.cprogramming.com/challenges/solutions/self_print.html)

**[多种语言的 Quine Page 解决方案](http://www.nyx.net/~gthompso/quine.htm)**

网络上有更多的解决方案，每个解决方案都各不相同。我想知道我们如何处理这样一个问题，解决这个问题的人的内心是什么。借给我一些关于这个问题的见解......虽然解释语言（如 perl、php、ruby 等）的解决方案可能很容易......我想知道如何用编译语言设计它......

* * *

## 回答 #1

> 赞同：56
> 
> 时间：2008-09-20T01:01:52.530

除了作弊¹之外，编译语言和解释语言之间没有区别。

quines 的通用方法非常简单。首先，无论程序是什么样的，在某些时候它必须打印一些东西：

```
打印 ...

```

但是，它应该打印什么？本身。所以它需要打印“打印”命令：

```
打印“打印...”

```

接下来应该打印什么？好吧，与此同时程序也在增长，所以它也需要打印以“print”开头的字符串：

```
打印“打印\”打印...\“”

```

现在程序再次增长，所以还有更多要打印的内容：

```
打印"打印\"打印\\\"...\\\"\""

```

等等。每添加一个代码，就会有更多代码要打印。这种方法无济于事，但它揭示了一个有趣的模式：字符串“print \”“一遍又一遍地重复。将重复部分放入变量中会很好：

```
a = "打印\""
打印一个

```

但是，程序刚刚改了，所以我们需要调整一个：

```
a = "a = ...\n打印一个"
打印一个

```

当我们现在尝试填写“...”时，我们遇到了和以前一样的问题。最终，我们想写这样的东西：

```
a = "a = " + (a 的引用内容) + "\nprint a"
打印一个

```

但这是不可能的，因为即使我们有这样的`quoted()`引用功能，仍然存在我们`a`根据自身定义的问题：

```
a = "a = " + 引用(a) + "\nprint a"
打印一个

```

所以我们唯一能做的就是将占位符放入`a`：

```
a = "a = @\n打印一个"
打印一个

```

这就是全部技巧！现在其他任何事情都清楚了。只需将占位符替换为以下引用的内容`a`：

```
a = "a = @\n打印一个"
打印 a.replace("@", 引用(a))

```

由于我们更改了代码，我们需要调整字符串：

```
a = "a = @\nprint a.replace(\"@\", 引用(a))"
打印 a.replace("@", 引用(a))

```

就是这样！所有语言的所有 quines 都以这种方式工作（作弊的除外）。

那么，您应该确保只替换第一次出现的占位符。如果你使用第二个占位符，你可以避免需要引用字符串。

但这些都是小问题，很容易解决。事实上，实现`quoted()`和`replace()` 是各种 quines 真正不同的唯一细节。

* * *

¹ 通​​过让程序读取其源文件

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2008-09-19T21:24:41.660

编写quines有几种不同的策略。显而易见的一种是只编写打开代码并将其打印出来的代码。但更有趣的是涉及允许自嵌入的语言功能，例如许多语言中的 %s 样式的 printf 功能。您必须弄清楚如何嵌入某些内容，以便最终解决要嵌入的请求。我怀疑，就像回文一样，涉及到大量的反复试验。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T21:25:42.767

通常的方法（当你不能作弊时*）是编写一些将其源编码为字符串常量的东西，然后将该常量打印出两次：一次作为字符串文字，一次作为代码。这绕过了“每次我写一行代码，我都必须再写一个来打印出来！” 问题。

“作弊”包括： - 使用解释语言并简单地加载源并打印它 - 0 字节长的文件，在某些语言中有效，例如 C。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-12T03:07:20.850

为了好玩，我在 Scheme 中想出了一个，我为此骄傲了大约 5 分钟，直到我发现之前已经被发现。无论如何，为了更好地计算 Lisp 中数据和代码的对偶性，对游戏的“规则”进行了轻微修改：它不是打印出程序的源代码，而是一个返回自身的 S 表达式：

```
((lambda (x) (list x `',x)) '(lambda (x) (list x `',x))) 
```

维基[百科](http://en.wikipedia.org/wiki/Quines#Scheme_.28also_valid_Common_Lisp.29)上的那个具有相同的概念，但引用机制略有不同（更冗长）。不过我更喜欢我的。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T21:27:08.253

一个想法是考虑编码以及如何赋予某些东西双重含义，以便它可以用于以几种形式输出某些东西。还有一个警告，这种类型的问题带有限制，使其更难，因为除了程序输出本身之外没有任何规则，空程序是一个解决方案。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2013-01-01T17:45:07.383

实际阅读和打印您的源代码怎么样？一点都不难！！这是php中的一个：

```
<?php
{
header("Content-Type: text/plain");
    $f=fopen("5.php","r");
    while(!feof($f))
    {
        echo fgetc($f);
    } 
    fclose($f);
}
?> 
```

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2013-08-02T11:56:17.403

在python中，您可以编写：

```
s='c=chr(39);print"s="+c+s+c+";"+s';c=chr(39);print"s="+c+s+c+";"+s 
```

受此自打印伪代码的启发：

```
Print the following line twice, the second time with quotes.
"Print the following line twice, the second time with quotes." 
```

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2013-12-11T17:11:15.363

我为那些对此感兴趣的人做了一个 AS3 示例

```
var program = "var program = @; function main(){trace(program.replace('@', 

String.fromCharCode(34) + program + String.fromCharCode(34)))} main()"; 
function main(){
   trace(program.replace('@', String.fromCharCode(34) + program + String.fromCharCode(34)))
}
main() 
```

* * *

## 回答 #9

> 赞同：-1
> 
> 时间：2020-10-30T13:05:33.243

在 bash 中，这真的很容易

触摸测试；chmod oug+x 测试；。/测试

空文件，空输出

* * *

## 回答 #10

> 赞同：-2
> 
> 时间：2008-09-19T21:22:48.763

在红宝石中：

将 File.read(_ _ FILE _ _)

# windows-mobile - 如何通过 MFC 在 windows mobile 6 中将软键与基于 CDialog 的应用程序一起使用？

> ID：105731
> 
> 赞同：1
> 
> 时间：2008-09-19T21:20:26.633
> 
> 标签：windows-mobile, mfc

如何通过 MFC 在 windows mobile 6 中将软键与基于 CDialog 的应用程序一起使用？

我有一个基于 CDialog 的 Windows Mobile 6（触摸屏）专业应用程序，我正在使用它。

WM6 Professional 中基于 CDialog 的应用程序的默认行为是默认不使用任何软键...我想将软键映射到“取消”和“确定”功能，将 IDOK 和 IDCANCEL 发送到我的主对话框类。

我一直在尝试与 CCommandBar 一起工作，但没有成功，而且 SHCreateMenuBar 也不适合我。

有没有人有如何让它工作的样本？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T23:39:18.827

CCommandBar 对您来说什么“不起作用”？您应该能够将 CCommandBar 成员添加到对话框类中，然后在 DIAlog 的 InitDialog 中，您在命令栏上调用 Create 和 InsertMenuBar - 如下所示：

```
m_cmdBar.Create(this);
m_cmdBar.InsertMenuBar(IDR_MENU_RESRC_ID); 
```

您的菜单资源可能如下所示：

```
IDR_MENU_RESRC_ID MENU DISCARDABLE
BEGIN
MENUITEM "OK", IDOK
MENUITEM "Cancel", IDCANCEL
END 
```

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-20T04:23:49.953

太感谢了……我快疯了……

您的代码完全按预期工作......

起初我使用它并得到相同的结果，除了 SIP 输入按钮之外​​，软键区域将是空白的。

经过一个小时左右的调试后，我尝试将这两行代码放在 OnInitDIalog() 的末尾，它起作用了:)

我的问题是在我的 OnIitDialog() 中我正在创建一些子对话框。当我在创建子对话框之前放置 CCommandBar.InsertMenuBar() 时，我没有得到“确定”或“取消”软键，当我在创建子对话框之后放置该行时，软键按预期显示并且效果很好。

再次感谢

# java - 配置 Apache / Tomcat 的最佳实践

> ID：105754
> 
> 赞同：18
> 
> 时间：2008-09-19T21:24:30.587
> 
> 标签：java, apache, tomcat, jboss, mod-proxy

我们目前使用 Apache 2.2.3 和 Tomcat 5（嵌入在 JBoss 4.2.2 中）`mod_proxy_jk`作为连接器。

有人可以阐明计算/配置以下值的正确方法（以及其他可能相关的值）。Apache 和 Tomcat 都在不同的机器上运行，并且有大量的 ram（每个 4gb）。

相关 server.xml 部分：

```
<Connector port="8009"
    address="${jboss.bind.address}"
    protocol="AJP/1.3"
    emptySessionPath="true"
    enableLookups="false"
    redirectPort="8443"
    maxThreads="320"
    connectionTimeout="45000"
/> 
```

相关的 httpd.conf 部分：

```
<IfModule prefork.c>
  StartServers       8
  MinSpareServers    5
  MaxSpareServers   20
  ServerLimit      256
  MaxClients       256
  MaxRequestsPerChild  0
</IfModule> 
```

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-21T02:44:18.063

您应该考虑服务器可能获得的工作负载。

最重要的因素可能是高峰时间同时连接的客户端数量。尝试确定它并以以下方式调整您的设置：

*   Apache 和 Tomcat 中都有足够的处理线程，当服务器负载过重时它们不需要生成新线程
*   服务器中的处理线程不会比需要的多，因为它们会浪费资源。

通过这种设置，您可以最大限度地减少服务器的内部维护开销，这会很有帮助，尤其是当您的负载是零星的时。

例如，考虑一个应用程序，您每秒有大约 300 个新请求。每个请求平均需要 2.5 秒的服务时间。这意味着在任何给定时间，您都有大约 750 个需要同时处理的请求。在这种情况下，您可能希望调整您的服务器，使它们在启动时具有约 750 个处理线程，并且您可能希望最多添加约 1000 个处理线程以处理极高的负载。

还要考虑您需要线程的确切内容。在前面的示例中，每个请求都独立于其他请求，没有使用会话跟踪。在更“web-ish”的场景中，您可能让用户登录到您的网站，并且根据您使用的软件，Apache 和/或 Tomcat 可能需要使用相同的线程来处理一个会话中的请求。在这种情况下，您可能需要更多线程。但是，至少我知道 Tomcat，您实际上不需要考虑这一点，因为它无论如何都可以在内部使用线程池。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-09-19T21:49:20.043

### 最大客户数

这是您的 apache 应立即处理的并行客户端连接的基本上限。

使用 prefork，每个进程只能处理一个请求。*因此，在处理单个*请求所需的时间内，整个 apache 最多可以处理*$* MaxClients 个请求。当然，只有当应用程序每个请​​求需要少于 1/$MaxClients 资源时，才能达到这个理想的最大值。

 *例如，如果应用程序需要一秒钟的 cpu 时间来响应单个请求，将 MaxClients 设置为 4 会将您的吞吐量限制为每秒四个请求：每个请求都会占用一个 apache 连接，而 apache 一次只能处理四个. 但是如果服务器只有两个 CPU，就连这个都达不到，因为每个挂钟秒只有两个 cpu 秒，但是请求需要 4 个 cpu 秒。

### MinSpareServers

这告诉 apache 应该有多少空闲进程。这个数字越大，apache 在需要生成额外进程之前可以吞下的突发负载就越多，这很昂贵，因此会减慢当前请求的速度。

正确设置取决于您的工作量。如果您的页面包含许多子请求（图片、iframe、javascript、css），那么点击单个页面可能会在短时间内占用更多进程。

### 最大备用服务器

有太多未使用的 apache 进程挂起只会浪费内存，因此 apache 使用 MaxSpareServers 数字来限制它为突发请求保留的备用进程的数量。

### MaxRequestsPerChild

这限制了单个进程在其整个生命周期中将处理的请求数量。如果你非常关心稳定性，你应该在此处设置一个实际的限制，以不断回收 apache 进程，以防止资源泄漏影响系统。

### 启动服务器

这只是 apache 默认启动的进程数量。将此设置为通常运行的 apache 进程的数量，以减少系统的预热时间。即使您忽略此设置，apache 也会根据需要使用 Min-/MaxSpareServers 值来生成新进程。

### 更多信息

另请参阅[apache 的多处理模块的文档](http://httpd.apache.org/docs/2.0/mod/mpm_common.html)。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-20T01:03:59.090

默认设置通常是很好的起点，可以查看您的应用程序真正需要什么。我不知道您期望多少流量，因此猜测 MaxThreads、MaxClients 和 MaxServers 有点困难。我可以告诉您，与我打交道的大多数客户（为 linux 网络主机工作，主要与在 Tomcat 中运行 Java 应用程序的客户打交道）在相当长的一段时间内都使用默认设置，而无需进行太多调整。

如果您不期望有太多流量，那么这些“太高”的设置也不会对您产生太大影响。除非有必要，否则 Apache 不会为全部 256 个潜在客户分配资源。Tomcat 也是如此。

# c# - .NET String.Format() 为数字添加千位逗号

> ID：105770
> 
> 赞同：949
> 
> 时间：2008-09-19T21:26:21.643
> 
> 标签：c#, .net, string, format

我想在数字的千位中添加一个逗号。

`String.Format()`将是正确的路径吗？我会使用什么格式？

* * *

## 回答 #1

> 赞同：1392
> 
> 时间：2008-09-19T21:29:06.970

```
String.Format("{0:n}", 1234);  // Output: 1,234.00
String.Format("{0:n0}", 9876); // No digits after the decimal point. Output: 9,876 
```

* * *

## 回答 #2

> 赞同：427
> 
> 时间：2010-10-19T05:04:38.857

我发现这是最简单的方法：

```
myInteger.ToString("N0") 
```

* * *

## 回答 #3

> 赞同：158
> 
> 时间：2008-11-17T15:15:07.727

```
int number = 1000000000;
string whatYouWant = number.ToString("#,##0");
//You get: 1,000,000,000 
```

* * *

## 回答 #4

> 赞同：111
> 
> 时间：2010-10-26T09:22:58.720

如果你想要特定的文化，你可能想试试这个：

`(19950000.0).ToString("N",new CultureInfo("en-US"))`= 19,950,000.00

`(19950000.0).ToString("N",new CultureInfo("is-IS"))`= 19.950.000,00

注意：有些文化习惯于`,`表示小数，而不是`.`小心。

* * *

## 回答 #5

> 赞同：89
> 
> 时间：2013-03-01T23:44:34.140

标准格式及其相关输出，

```
Console.WriteLine("Standard Numeric Format Specifiers");
String s = String.Format("(C) Currency: . . . . . . . . {0:C}\n" +
                    "(D) Decimal:. . . . . . . . . {0:D}\n" +
                    "(E) Scientific: . . . . . . . {1:E}\n" +
                    "(F) Fixed point:. . . . . . . {1:F}\n" +
                    "(G) General:. . . . . . . . . {0:G}\n" +
                    "    (default):. . . . . . . . {0} (default = 'G')\n" +
                    "(N) Number: . . . . . . . . . {0:N}\n" +
                    "(P) Percent:. . . . . . . . . {1:P}\n" +
                    "(R) Round-trip: . . . . . . . {1:R}\n" +
                    "(X) Hexadecimal:. . . . . . . {0:X}\n",
                    - 1234, -1234.565F);
Console.WriteLine(s); 
```

示例输出（en-us 文化）：

```
(C) Currency: . . . . . . . . ($1,234.00)
(D) Decimal:. . . . . . . . . -1234
(E) Scientific: . . . . . . . -1.234565E+003
(F) Fixed point:. . . . . . . -1234.57
(G) General:. . . . . . . . . -1234
    (default):. . . . . . . . -1234 (default = 'G')
(N) Number: . . . . . . . . . -1,234.00
(P) Percent:. . . . . . . . . -123,456.50 %
(R) Round-trip: . . . . . . . -1234.565
(X) Hexadecimal:. . . . . . . FFFFFB2E 
```

* * *

## 回答 #6

> 赞同：52
> 
> 时间：2015-07-09T23:43:49.617

这是最好的格式。适用于所有这些情况：

```
String.Format( "{0:#,##0.##}", 0 ); // 0
String.Format( "{0:#,##0.##}", 0.5 ); // 0.5 - some of the formats above fail here. 
String.Format( "{0:#,##0.##}", 12314 ); // 12,314
String.Format( "{0:#,##0.##}", 12314.23123 ); // 12,314.23
String.Format( "{0:#,##0.##}", 12314.2 ); // 12,314.2
String.Format( "{0:#,##0.##}", 1231412314.2 ); // 1,231,412,314.2 
```

* * *

## 回答 #7

> 赞同：44
> 
> 时间：2015-08-12T02:51:49.590

投票最多的答案非常好，并且已经帮助了大约 7 年。随着 C# 6.0 的引入，特别是字符串插值的引入，有一种更简洁且 IMO 更安全的方法来执行所要求的操作`to add commas in thousands place for a number`：

```
var i = 5222000;
var s = $"{i:n} is the number"; // results to > 5,222,000.00 is the number
s = $"{i:n0} has no decimal"; // results to > 5,222,000 has no decimal 
```

变量`i` 放置在占位符的位置（即`{0}`）。所以没有必要记住哪个物体去哪个位置。格式（即`:n`）没有改变。有关新功能的完整功能，您可以[访问此页面](https://msdn.microsoft.com/en-us/magazine/dn879355.aspx)。

* * *

## 回答 #8

> 赞同：38
> 
> 时间：2017-08-24T05:08:32.490

就这么简单：

```
float num = 23658; // for example 
num = num.ToString("N0"); // Returns 23,658 
```

更多信息在[这里](https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings)

* * *

## 回答 #9

> 赞同：33
> 
> 时间：2008-09-19T21:29:07.907

```
String.Format("{0:#,###,###.##}", MyNumber) 
```

这将在相关点给你逗号。

* * *

## 回答 #10

> 赞同：24
> 
> 时间：2017-02-23T15:00:25.797

以下示例显示了使用包含零占位符的自定义格式字符串格式化的几个值。

```
String.Format("{0:N1}", 29255.0); 
```

或者

```
29255.0.ToString("N1") 
```

结果“29,255.0”

```
String.Format("{0:N2}", 29255.0); 
```

或者

```
29255.0.ToString("N2") 
```

结果“29,255.00”

* * *

## 回答 #11

> 赞同：21
> 
> 时间：2013-03-27T19:55:29.937

如果您希望强制使用“，”分隔符而不管文化（例如在跟踪或日志消息中），以下代码将起作用，并且具有告诉下一个偶然发现它的人您正在做什么的额外好处。

```
int integerValue = 19400320; 
string formatted = string.Format(CultureInfo.InvariantCulture, "{0:N0}", integerValue); 
```

设置为“19,400,320”

* * *

## 回答 #12

> 赞同：20
> 
> 时间：2019-02-09T13:21:27.963

C# 7.1（可能更早？）通过字符串插值使这变得简单而美观：

```
var jackpot = 1_000_000; // underscore separators in numeric literals also available since C# 7.0
var niceNumberString = $"Jackpot is {jackpot:n}";
var niceMoneyString = $"Jackpot is {jackpot:C}"; 
```

* * *

## 回答 #13

> 赞同：13
> 
> 时间：2016-11-02T20:22:05.510

更简单，使用字符串插值而不是 String.Format

```
 $"{12456:n0}"; // 12,456
 $"{12456:n2}"; // 12,456.00 
```

或使用你的变量

```
 double yourVariable = 12456.0;
 $"{yourVariable:n0}"; 
 $"{yourVariable:n2}"; 
```

* * *

## 回答 #14

> 赞同：11
> 
> 时间：2010-05-20T15:36:29.930

```
int num = 98765432;
Console.WriteLine(string.Format("{0:#,#}", num)); 
```

* * *

## 回答 #15

> 赞同：11
> 
> 时间：2012-10-23T21:19:57.040

例如`String.Format("{0:0,0}", 1);`返回 01，对我来说无效

这对我有用

```
19950000.ToString("#,#", CultureInfo.InvariantCulture)); 
```

输出 19,950,000

* * *

## 回答 #16

> 赞同：9
> 
> 时间：2008-10-12T00:35:09.300

请注意，您要格式化的值应该是数字。看起来它不会采用数字的字符串表示形式，格式是逗号。

* * *

## 回答 #17

> 赞同：6
> 
> 时间：2018-02-13T12:20:52.410

```
String.Format("0,###.###"); also works with decimal places 
```

* * *

## 回答 #18

> 赞同：3
> 
> 时间：2014-12-23T11:13:38.250

您可以使用这样的函数来格式化数字并可选择传入所需的小数位。如果未指定小数位，它将使用两位小数。

```
 public static string formatNumber(decimal valueIn=0, int decimalPlaces=2)
    {
        return string.Format("{0:n" + decimalPlaces.ToString() + "}", valueIn);
    } 
```

我使用十进制，但您可以将类型更改为任何其他类型或使用匿名对象。您还可以添加对负小数位值的错误检查。

* * *

## 回答 #19

> 赞同：0
> 
> 时间：2021-05-07T11:57:08.743

您想要相同的格式值和特定的文化。

```
 Double value= 1234567;
 value.ToString("#,#.##", CultureInfo.CreateSpecificCulture("hi-IN")); 
```

输出：12,34,567

* * *

## 回答 #20

> 赞同：0
> 
> 时间：2021-12-10T19:06:59.860

我尝试了上面的许多建议，但以下对我来说效果更好：

```
string.Format("{0:##,###.00}", myValue) 
```

但是当你有像 0.2014 这样的值时它会失败，它给出 .21 为此我使用

```
string.Format("{0:#,##0.00}", myValue) 
```

* * *

## 回答 #21

> 赞同：-3
> 
> 时间：2013-11-28T03:36:47.573

如果你想在 DataGridview 中显示它，你应该改变它的类型，因为默认是 String 并且因为你把它改成小数，所以它认为是带浮点数的数字

```
Dim dt As DataTable = New DataTable
dt.Columns.Add("col1", GetType(Decimal))
dt.Rows.Add(1)
dt.Rows.Add(10)
dt.Rows.Add(2)

DataGridView1.DataSource = dt 
```

* * *

## 回答 #22

> 赞同：-4
> 
> 时间：2012-06-13T09:55:01.233

我过去不再担心文化和潜在格式问题的方法是，我将其格式化为货币，然后取出货币符号。

`if (decimal.TryParse(tblCell, out result))`

```
{
  formattedValue = result.ToString("C").Substring(1);
} 
```

# chuck - 检测 ChuckK 子碎片何时完成

> ID：105771
> 
> 赞同：2
> 
> 时间：2008-09-19T21:26:25.323
> 
> 标签：chuck

如果您有对子碎片的引用，是否可以确定 ChuckK 子碎片何时完成执行？例如，在这段代码中：

```
// define function go()
fun void go()
{
    // insert code
}

// spork another, store reference to new shred in offspring
spork ~ go() => Shred @ offspring; 
```

是否可以确定何时`offspring`完成执行？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-19T23:03:03.453

我会这么说，让我引用最新版本的“VERSIONS”文件；

```
 - (added) int Shred.done()  // is the shred done?
            int Shred.running()  // is the shred running? 
```

我不是 100% 确定“正在运行”应该指的是什么（也许我误解了它？）但“完成”似乎适合您的需求；

================== 8<================

```
fun void foo()
    {
    second => now;
    }

spork ~ foo() @=> Shred bar;

<<<bar.done()>>>;
<<<bar.running()>>>; // why is this 0? Bug?
2::second => now;
<<<bar.done()>>>;
<<<bar.running()>>>; 
```

==========8<=======================

请注意，在没有附加粉碎进程的 Shred 对象上调用这些将返回或多或少的随机数，这可能是一个错误。

---卡森在[chuck-users邮件列表](https://lists.cs.princeton.edu/mailman/listinfo/chuck-users)上的回答。

# mysql - 如何从 mysqldump 恢复转储文件？

> ID：105776
> 
> 赞同：613
> 
> 时间：2008-09-19T21:27:00.673
> 
> 标签：mysql, sql, database

我得到了一个 MySQL 数据库文件，我需要将其还原为我的 Windows Server 2008 机器上的数据库。

我尝试使用 MySQL Administrator，但出现以下错误：

> 选择的文件是由 mysqldump 生成的，不能被这个应用程序恢复。

我如何让这个工作？

* * *

## 回答 #1

> 赞同：781
> 
> 时间：2009-06-09T18:58:05.550

如果要恢复的数据库尚不存在，则需要先创建它。

在命令行上，如果您位于包含转储文件的同一目录中，请使用以下命令（带有适当的替换）：

```
C:\> mysql -u root -p

mysql> create database mydb;
mysql> use mydb;
mysql> source db_backup.dump; 
```

* * *

## 回答 #2

> 赞同：648
> 
> 时间：2008-09-19T21:29:38.840

它应该像运行这个一样简单：

```
mysql -u <user> -p < db_backup.dump 
```

如果转储是单个数据库，您可能必须在文件顶部添加一行：

```
USE <database-name-here>; 
```

如果它是许多数据库的转储，则 use 语句已经存在。

要运行这些命令，请打开命令提示符（在 Windows 中）并打开可执行文件`cd`所在的目录`mysql.exe`（您可能需要四处寻找它，这取决于您安装 mysql 的方式，即独立或作为像 WAMP 这样的包）。进入该目录后，您应该可以像上面那样键入命令。

* * *

## 回答 #3

> 赞同：282
> 
> 时间：2008-09-19T21:45:05.480

你只需要运行这个：

```
mysql -p -u[user] [database] < db_backup.dump 
```

如果转储包含多个数据库，则应省略数据库名称：

```
mysql -p -u[user] < db_backup.dump 
```

要运行这些命令，请打开命令提示符（在 Windows 中）并打开可执行文件`cd`所在的目录`mysql.exe`（您可能需要四处寻找它，这取决于您安装 mysql 的方式，即独立或作为像 WAMP 这样的包）。进入该目录后，您应该只需键入命令即可。

* * *

## 回答 #4

> 赞同：62
> 
> 时间：2013-06-03T17:11:57.753

```
mysql -u username -p -h localhost DATA-BASE-NAME < data.sql 
```

看[这里 - 第 3 步](http://www.cyberciti.biz/faq/import-mysql-dumpfile-sql-datafile-into-my-database/)：这样你就不需要 USE 语句

* * *

## 回答 #5

> 赞同：37
> 
> 时间：2008-09-19T21:34:18.377

当我们使用 制作转储文件时`mysqldump`，它包含一个用于重新创建数据库内容的大型 SQL 脚本。所以我们通过启动 MySQL 的命令行客户端来恢复它：

```
mysql -uroot -p 
```

（`root`我们的 MySQL 管理员用户名在哪里），一旦连接到数据库，我们需要命令来创建数据库并将文件读入其中：

```
create database new_db;
use new_db;
\. dumpfile.sql 
```

详细信息将根据创建转储文件时使用的选项而有所不同。

* * *

## 回答 #6

> 赞同：23
> 
> 时间：2018-03-30T06:00:31.470

运行命令进入数据库

```
 # mysql -u root -p 
```

输入用户的密码然后创建一个新数据库

```
mysql> create database MynewDB;
mysql> exit 
```

并使 exit.Afetr that.Run 这个命令

```
# mysql -u root -p  MynewDB < MynewDB.sql 
```

然后进入数据库并输入

```
mysql> show databases;
mysql> use MynewDB;
mysql> show tables;
mysql> exit 
```

就是这样............您的转储将从一个数据库恢复到另一个数据库

**否则有转储恢复的替代方法**

```
# mysql -u root -p 
```

然后进入数据库并输入

```
mysql> create database MynewDB;
mysql> show databases;
mysql> use MynewDB;
mysql> source MynewDB.sql;
mysql> show tables;
mysql> exit 
```

* * *

## 回答 #7

> 赞同：18
> 
> 时间：2012-02-06T08:20:19.473

如果您想查看转储的进度，请尝试以下操作：

`pv -i 1 -p -t -e /path/to/sql/dump | mysql -u USERNAME -p DATABASE_NAME`

您当然需要安装“pv”。此命令仅适用于 *nix。

* * *

## 回答 #8

> 赞同：14
> 
> 时间：2008-10-01T13:52:38.313

我按照这些步骤让它工作......

1.  打开 MySQL Administrator 并连接到服务器

2.  选择左侧的“目录”

3.  右键单击左下角的框并选择“创建新架构”

    [MySQL 管理员 http://img204.imageshack.us/img204/7528/adminsx9.th.gif](http://img204.imageshack.us/img204/7528/adminsx9.th.gif) [放大图片](http://img204.imageshack.us/img204/7528/adminsx9.gif)

4.  命名新模式（例如：“dbn”）

    [MySQL 新架构 http://img262.imageshack.us/img262/4374/newwa4.th.gif](http://img262.imageshack.us/img262/4374/newwa4.th.gif) [放大图片](http://img262.imageshack.us/img262/4374/newwa4.gif)

5.  打开 Windows 命令提示符 (cmd)

    [Windows 命令提示符 http://img206.imageshack.us/img206/941/startef7.th.gif](http://img206.imageshack.us/img206/941/startef7.th.gif) [放大图片](http://img206.imageshack.us/img206/941/startef7.gif)

6.  将目录更改为 MySQL 安装文件夹

7.  执行命令：

    ```
    mysql -u root -p dbn < C:\dbn_20080912.dump 
    ```

    …其中“root”是用户名，“dbn”是数据库名称，“C:\dbn_20080912.dump”是 mysqldump .dump 文件的路径/文件名

    [MySQL 转储恢复命令行 http://img388.imageshack.us/img388/2489/cmdjx0.th.gif](http://img388.imageshack.us/img388/2489/cmdjx0.th.gif) [放大图片](http://img388.imageshack.us/img388/2489/cmdjx0.gif)

8.  享受！

* * *

## 回答 #9

> 赞同：13
> 
> 时间：2017-01-13T22:16:20.767

作为先前答案的具体示例：

我需要恢复备份，以便将其导入/迁移到 SQL Server。我只安装了 MySql，但没有将其注册为服务或将其添加到我的路径中，因为我不需要让它保持运行。

我使用 Windows 资源管理器将转储文件放在 C:\code\dump.sql 中。然后从开始菜单项打开 MySql。创建了数据库，然后使用完整路径运行源命令，如下所示：

```
mysql> create database temp
mysql> use temp
mysql> source c:\code\dump.sql 
```

* * *

## 回答 #10

> 赞同：12
> 
> 时间：2012-08-21T10:19:37.647

您可以尝试使用[SQLyog](http://www.webyog.com)的“执行 SQL 脚本”工具来导入 sql/dump 文件。

![在此处输入图像描述](https://i.stack.imgur.com/i2zon.png)

* * *

## 回答 #11

> 赞同：10
> 
> 时间：2013-01-03T16:59:38.027

使用在 Linux 上创建的 200MB 转储文件在带有 mysql 5.5 的 Windows 上恢复，我在

```
source file.sql 
```

从 mysql 提示符的方法比使用

```
mysql  < file.sql 
```

命令行上的方法，这导致了一些错误 2006“服务器已消失”（在 Windows 上）

奇怪的是，在（mysql）安装期间创建的服务引用了一个不存在的 my.ini 文件。我将“大”示例文件复制到 my.ini 中，我已经根据建议的增加对其进行了修改。

我的价值观是

```
[mysqld]
max_allowed_packet = 64M
interactive_timeout = 250
wait_timeout = 250 
```

* * *

## 回答 #12

> 赞同：10
> 
> 时间：2016-03-30T11:37:27.887

```
./mysql -u <username> -p <password> -h <host-name like localhost> <database-name> < db_dump-file 
```

* * *

## 回答 #13

> 赞同：4
> 
> 时间：2009-06-15T21:11:57.250

如果备份/转储不是从那里创建的，则不能使用 MySQL Admin 中的恢复菜单。不过值得一试。如果您选择使用复选框“忽略错误”，它会说它已成功完成，尽管它显然退出时只导入了一小部分行......请注意，这是一个转储。

* * *

## 回答 #14

> 赞同：3
> 
> 时间：2017-12-27T16:10:10.503

用于恢复生成的 SQL 的单行命令`mysqldump`

```
mysql -u <username> -p<password> -e "source <path to sql file>;" 
```

* * *

## 回答 #15

> 赞同：3
> 
> 时间：2019-06-13T22:40:49.490

假设您已经创建了空白数据库，您还可以从命令行恢复数据库，如下所示：

```
mysql databasename < backup.sql 
```

* * *

## 回答 #16

> 赞同：1
> 
> 时间：2008-11-09T03:53:03.497

您还可以使用 MySQL Administrator 中的还原菜单。您只需打开备份文件，然后单击恢复按钮。

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2019-02-06T01:08:46.220

# 如何使用 MySQLWorkbench 恢复 MySQL 数据库

您可以在查询选项卡中运行 drop 和 create 命令。

## 如果架构当前存在，则删除它

```
DROP DATABASE `your_db_name`; 
```

## 创建新架构

```
CREATE SCHEMA `your_db_name`; 
```

## 打开您的转储文件

[![MySQLWorkbench 打开 sql 文件](https://i.stack.imgur.com/eUYHJ.png)](https://i.stack.imgur.com/eUYHJ.png)

1.  单击**在新查询选项卡中打开 SQL 脚本**图标并选择您的数据库转储文件。
2.  然后单击**运行 SQL 脚本...**
3.  然后它将让您预览 SQL 转储脚本的第一行。
4.  然后，您将选择**默认模式名称**
5.  接下来选择**默认字符集**utf8 通常是一个安全的选择，但您可以通过查看诸如**character_set**之类的预览行来辨别它。
6.  单击**运行**
7.  耐心等待大型数据库恢复脚本，并观察您的驱动器空间消失！

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2021-10-07T00:40:18.317

如果您已经在`mysql`提示符内并假设您的转储文件`dump.sql`，那么我们也可以使用如下命令来恢复转储

```
mysql> \. dump.sql 
```

如果您的转储大小较大，则将`max_allowed_packet`值设置为更高。设置此值将帮助您更快地恢复转储。

# javascript - 为什么 Ajax 脚本不能在本地工作？

> ID：105777
> 
> 赞同：0
> 
> 时间：2008-09-19T21:27:04.697
> 
> 标签：javascript, ajax, webserver

我有一个问题，同一段代码在我的实时网站上运行良好，但在我的本地开发服务器上却没有。

我有一个更新 div 的 Ajax 函数。以下代码适用于实时站点：

```
self.xmlHttpReq.open("POST", PageURL, true);
self.xmlHttpReq.setRequestHeader("内容类型", "application/x-www-form-urlencoded");
self.xmlHttpReq.setRequestHeader("内容长度", QueryString.length);
//..更新 div 的东西...
self.xmlHttpReq.send(QueryString);
```

当我尝试在本地机器上运行它时，没有任何东西传递给 QueryString。

但是，为了混淆问题，以下代码**在**本地工作：

```
self.xmlHttpReq.open("POST", PageURL+"?"+QueryString, true);
self.xmlHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
//..div 更新内容..
self.xmlHttpReq.send(QueryString);
```

但是，我不能使用在我的本地机器上运行的代码，因为它在实时服务器上不起作用（出于安全原因，他们已经更改了查询字符串的策略）！

我可以提醒查询字符串，所以我知道它已传递到我本地机器上的函数中。我唯一能想到的是这是一个硬件/更新问题。

Live Site 正在运行 IIS 6（我认为是在 WIN 2003 机器上）

本地站点正在运行 IIS 5.1（在 XP Pro 上）

是否有一些更新或我缺少的东西或什么？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T21:35:06.207

您是否有理由`Content-Length`在第一个示例中明确设置标题？你......*不应该*这样做，我不会惊讶地发现它会导致问题。

哦，检查你的编码程序。查询字符串和 POST 表单数据的规则并不*完全相同*。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T21:38:13.593

我猜 Shog9 是对的，并且 IIS 6 我足够聪明，可以忽略您的请求并发送正确的标头，而 5.2 会引发错误。

# drawing - 绘制数据库模型的最终程序是什么？

> ID：105778
> 
> 赞同：15
> 
> 时间：2008-09-19T21:27:04.730
> 
> 标签：drawing, data-modeling

当我在一个新项目上时，我做的第一件事就是设计一个数据库模型。为了可视化模型，我使用了 7 年的 Smartdraw 版本。也许是时候来点新东西了。绘制数据库模型的最终程序是什么。Smartdraw 仅适用于 Windows。有什么东西也可以在unix上使用吗？

* * *

## 回答 #1

> 赞同：21
> 
> 时间：2008-09-19T21:33:58.223

最好的工具是铅笔和纸。

也许不是您正在寻找的答案，但有时最简单的解决方案是最好的。:-)

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2008-09-19T21:35:45.240

白板（和之后拍照的相机）

* * *

## 回答 #3

> 赞同：8
> 
> 时间：2008-09-19T22:24:47.290

你的**大脑**是最好的绘图工具。

我更喜欢在简单的文本文件中开发数据库模式。起初它只包含表名、属性和外键：

```
公司：
    公司名称
    ...

员工：
    姓名
    年龄
    公司名称 -> 公司
    ...

...：

```

语法并不重要。它只需要排列清晰且易于更改。后来我添加了类型和 CHECK() 约束，因此文本文件逐渐转换为有效的 SQL 代码。

在早期阶段使用绘图工具只会分散注意力，因为它会鼓励您在移动反应角上浪费时间。取而代之的是，让您的大脑以与阅读书籍时创建幻想图片相同的方式**构建图式图片。**

随着图式的增长，有必要通过创建**概览**来支持大脑。然而，在这里，铅笔和纸比任何绘图软件都快。另请注意，没有必要用不重要的细节来混乱概述。只需勾画表名和最重要的关系（外键）。任何进一步的细节都会*降低*此概述的价值。

但是，如果您真的觉得使用极其详细的图形比使用文本文件和概览图形更舒服，您可能想尝试 [DBDesigner4](http://fabforce.net/dbdesigner4/) 或 [WWW SQL Designer](http://ondras.zarovi.cz/sql/)。

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2008-09-19T22:02:30.977

我很高兴多年来一直使用[Sybase PowerDesigner 。](http://www.sybase.com/products/modelingmetadata/powerdesigner)

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-09-19T21:52:17.897

您看过 Visio 2007 SQL Server 加载项吗？

你可以在这里找到它：http: [//dbalink.wordpress.com/2008/04/24/microsoft-office-visio-2007-professional-sql-server-add-in/](http://dbalink.wordpress.com/2008/04/24/microsoft-office-visio-2007-professional-sql-server-add-in/)

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2013-08-13T20:58:04.000

我喜欢使用开源思维导图程序[Freemind](http://freemind.sourceforge.net/)。它类似于用铅笔和纸进行设计，因为没有太多的表面复杂性来中断设计过程。

但它比纸/铅笔有两个巨大的优势：

1.  节点折叠
2.  轻松拖放重新排列

在大约五分钟内无需使用鼠标即可轻松导航界面。您可以根据需要添加尽可能多或尽可能少的细节，并且可以随时折叠细节以整理您的视图。这是一个示例屏幕截图：

![FreeMind 截图](https://i.stack.imgur.com/lE3YZ.png)

Departments、Employees 和 Hours 表末端的圆圈表示折叠的节点更多。您可以疯狂地使用不同的字体、背景颜色，甚至 HTML 格式。我只是做了一个 [Ctrl]-[B] 来使我的表名加粗。

FreeMind——以及一般的思维导图软件——通过远离创作过程提供了最大的好处。这是我从头开始一个新项目时使用的第一个工具。

注意：我只在 Windows 上使用过该程序，但它[在 Linux 上可用](http://freemind.sourceforge.net/wiki/index.php/FreeMind_on_Linux)。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-20T09:52:40.553

I like ERWin. Not Cheap, but it can reverse engineer or do initial design + generate CRUD and manipulate db structure. Viso is pretty good for this too, but its not as complete and of course as strong MS SQL leanings is capabilities.

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-26T15:39:42.217

我曾经使用 Visio，但如果您的数据库服务器是 MySQL，请尝试[MySQL Workbench](http://dev.mysql.com/workbench/)。它有一个linux版本和一个win32版本。像他们的其他 GUI 产品一样，它有相当多的怪癖，但它工作得很好，并且能够创建模式图和从图中创建模式。

我也同意铅笔和纸，或白板和相机是勾勒事物的好方法，但我确实喜欢 GUI 工具，用于记录形式更完善或更复杂的想法。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-09-19T21:35:32.650

我不知道它是否是绘制数据库模型的“终极”程序，但我使用[Visio](http://office.microsoft.com/en-us/visio/default.aspx)。不幸的是，它只能在 Windows 中运行。

从好的方面来说，我可以创建自己的形状，或修改现有的形状，并将它们保存在称为模板的集合中。当我双击它们时，我还可以通过对它们进行编程来执行各种操作，从而使我的形状“智能”。

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-09-19T21:53:42.373

我也使用白板和相机。我第二次使用铅笔和纸。我几乎总是随身携带一支笔（铅笔）和一张纸，因为我总是在脑海中设计一些东西，需要把它记下来。我也喜欢 Visio，但我最喜欢使用的软件程序一直是 ERWin。那东西的价格刚刚好，但它很棒。

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2008-09-19T22:05:09.833

[WWW SQL Designer](http://ondras.zarovi.cz/sql/)是我见过的最好的之一，因为它全是 javascript，所以非常棒。它还可以导入和导出您绘制的所有内容的 xml 和 sql 代码。自从我上次使用以来，他们已经添加了漂亮的贝塞尔曲线。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2008-09-19T21:37:14.750

DIA 还不错，并且有一些工具可以从某些类型的模型中实际生成一些代码。如果您使用的是 PostgreSQL，甚至还有一个工具可以反其道而行之，即 pg-autodoc。

DIA 可用于 Unix，我相信 Windows 也是如此。

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2008-09-19T21:37:56.090

我曾经使用 Viso，但现在，由于我更基于 Mac，我使用 Omnigraffle。

不过，我必须承认，就像 andyUK 所做的那样，我在纸上画了一个粗略的草图。

它还取决于您使用的数据库。如果是 MySQL，那么有相当多的可视化开发工具可用，只要[有一个谷歌](http://www.google.co.uk/search?q=mysql+database+designer&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:en-GB:official&client=firefox-a)

* * *

## 回答 #14

> 赞同：1
> 
> 时间：2008-09-19T21:39:30.813

可能有更多的技术程序，但我使用[SmartDraw](http://www.smartdraw.com/)。我还想指出，“最终”取决于您的情况。找到最适合您或您和您的公司的方法。对你有用的是“终极”。

* * *

## 回答 #15

> 赞同：1
> 
> 时间：2008-09-19T21:51:44.233

首先在纸/白板上集思广益/草绘数据库，然后使用图表工具。

哪个工具取决于您的目标数据库。我们使用 SQL Server，因此 SQL Server Management Studio 中的设计器非常适合我们，因为我们同时创建了数据库本身。

* * *

## 回答 #16

> 赞同：1
> 
> 时间：2008-09-19T22:19:16.850

对于 linux，我使用 umbrello

* * *

## 回答 #17

> 赞同：1
> 
> 时间：2009-10-21T17:06:08.507

如果您正在寻找没有任何逆向/正向工程功能的廉价解决方案/工具，MS Visio 可能是您的最佳选择。但是，如果您打算在 ERD 工具上投资一些钱，请将其花在 ER/Studio 上。

我曾经使用并成为ERWIN的冠军。我一开始使用 ER/Studio，就成为它的粉丝。我是财富 100 强公司之一的企业数据架构师，没有它我不知道如何完成我的工作。

PS：我与这些产品和公司没有任何关系。

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2008-09-19T21:43:10.230

OpenOffice 有一个矢量绘图工具，Inkscape 是另一个不错的工具。
否则，您可以使用 Graphviz（点语言）从文本描述中生成此类图表。
还有一些工具可以从现有数据库中生成这样的图表（我首先认为这是你要问的）。

* * *

## 回答 #19

> 赞同：0
> 
> 时间：2008-09-19T21:49:52.910

如果您不需要太多，请选择[Dia](http://www.gnome.org/projects/dia/)。

* * *

## 回答 #20

> 赞同：0
> 
> 时间：2008-09-19T22:09:03.583

我使用[了电源设计器](http://www.sybase.com/products/modelingmetadata/powerdesigner)。它功能强大但相当复杂。

# windows - Windows 的好 postgresql 客户端？

> ID：105788
> 
> 赞同：83
> 
> 时间：2008-09-19T21:28:40.857
> 
> 标签：windows, postgresql, frontend, postgis

经过几年的 oracle 回到 postgresql ......

Windows 上最先进的 postgresql 管理/ddl 生成/数据插入前端是什么？如果它也集成了 postgis 那就太好了。它应该是独立的，或者是 intellij idea 的插件

回想起来，我使用的所有针对 postgresql 的 Windows 程序都是垃圾，尤其是 PGAdmin。它变得更好了吗？

* * *

## 回答 #1

> 赞同：21
> 
> 时间：2008-09-19T21:32:19.037

你的意思是像[pgAdmin](http://www.pgadmin.org/)这样的管理吗？

* * *

## 回答 #2

> 赞同：16
> 
> 时间：2008-09-19T21:47:54.303

我喜欢[Postgresql 大师](http://www.sqlmaestro.com/products/postgresql/maestro/)。我也将他们的版本用于 MySql。我对他们的产品很满意。或者您可以使用免费工具 PgAdmin。

* * *

## 回答 #3

> 赞同：10
> 
> 时间：2010-10-05T19:17:40.870

我衷心推荐[dbVis](http://www.dbvis.com/)。该客户端在 Mac、Windows 和 Linux 上运行，并支持各种数据库服务器，包括 PostgreSQL。

* * *

## 回答 #4

> 赞同：9
> 
> 时间：2008-10-31T08:48:13.347

实际上有一个非常强大的EMS [SQL Manager的免费软件版本](http://sqlmanager.net/en/products/postgresql/manager/download)

* * *

## 回答 #5

> 赞同：6
> 
> 时间：2010-05-12T13:35:43.777

我强烈推荐 Navicat。我发现特别出色的是它的导入功能——你可以导入几乎任何数据格式（Access、Excel、DBF、Lotus ...），定义源和目标之间的映射，可以保存并且可以重复（我什至保留了我的版本控制下的映射）。

我试过 SQLMaestro 并发现它有问题（特别是对于数据导入）；PGAdmin 是有限的。

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2011-01-13T09:36:38.850

对于正在寻找支持 Web 的 Postgres 客户端的任何人，我将把链接放在这里到 TeamPostgreSQL，这是一个用于 pg 的非常精致的 AJAX Web 客户端：

[http://www.teampostgresql.com](http://www.teampostgresql.com)

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-19T23:08:10.430

EMS 的[SQL 管理器](http://sqlmanager.net/products/postgresql/manager/)比 phpPgAdmin 或 PG Admin III 更易于使用并且具有更多的功能。但是，它只是 Windows，您必须为此付费。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-09-19T21:31:49.087

SQLExplorer 是一个很棒的 Eclipse 插件或独立界面，可与许多不同的数据库系统一起使用，无论是使用专用驱动程序还是使用 ODBC。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-09-19T22:55:13.270

[phpPgAdmin](http://phppgadmin.sourceforge.net/)是相当不错的 PostgreSQL web 前端。

# c# - 如何获取表示上 ascii 值字符的十六进制值的字符串类型

> ID：105810
> 
> 赞同：0
> 
> 时间：2008-09-19T21:32:27.087
> 
> 标签：c#, rtf

我们的应用程序的一部分解析了 RTF 文档，我们遇到了一个翻译不好的特殊字符。在 Word 中查看时，该字符是省略号 (...)，它在 RTF 中编码为 ('85)。

在我们的 vb 代码中，我们将十六进制 (85) 转换为 int(133)，然后将 Chr(133) 返回 (...)

这是 C# 中的代码 - 问题是这不适用于 127 以上的值。有什么想法吗？

调用代码：

```
// S is Hex number!!!
return Convert.ToChar(HexStringToInt(s)).ToString(); 
```

辅助方法：

```
private static int HexStringToInt(string hexString)
{
    int i;

    try
    {
        i = Int32.Parse(hexString, NumberStyles.HexNumber);
    }
    catch (Exception ex)
    {
        throw new ApplicationException("Error trying to convert hex value: " + hexString, ex);
    }

    return i;
} 
```

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T22:03:41.490

这对我来说似乎是一个字符编码问题。Unicode 不包含任何数字在 ASCII 128-255 范围内的字符，因此尝试转换字符 133 将失败。

需要首先使用正确的解码将其转换为字符，Convert.toChar 似乎使用的是 UTF-16。

有时有一个手动位操作黑客将字符从大写 ASCII 转换为适当的 unicode 字符，但由于省略号不在大多数广泛使用的扩展 ASCII 代码页中，所以这不太可能在这里工作。

您真正想要做的是使用[Encoding.GetString(Byte[])](http://msdn.microsoft.com/en-us/library/744y86tc.aspx)方法，并使用正确的编码。将您的值放入一个字节数组，然后 GetString 以获取该字符的 C# 本机字符串。

[您可以在RTF Wikipedia 页面](http://en.wikipedia.org/wiki/Rich_Text_Format#Character_encoding)上了解有关 RTF 字符编码的更多信息。

仅供参考：水平省略号是[字符 U+2026 (pdf)](http://unicode.org/charts/PDF/U2000.pdf)。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T22:00:17.397

您的原始代码对我来说非常好。它能够将任何从 00 到 FF 的十六进制转换为适当的字符。使用vs2008。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T21:34:34.773

```
private static int HexStringToInt(string hexString)
{
    try
    {
        return Convert.ToChar(hexString);
    }
    catch (FormatException ex)
    {
        throw new ArgumentException("Is not a valid hex character.", "hexString", ex);
    }
    // Convert.ToChar() will throw an ArgumentException also
    // if hexString is bad
} 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2009-01-17T00:10:33.117

只需使用我从 Chris 的网站修改（非常轻微）的这个函数：

```
 private static string charScrubber(string content)
    {
        StringBuilder sbTemp = new StringBuilder(content.Length);
        foreach (char currentChar in content)
        {
            if ((currentChar != 127 && currentChar > 1))
            {
                sbTemp.Append(currentChar);
            }
        }

        content = sbTemp.ToString();
        return content;
    } 
```

您可以修改“当前字符”条件以删除任何需要消除的字符（如此处所示，您不会得到任何 0x00 字符、(char)127 或 0x57 字符）。

ASCII/十六进制表： [http ://www.cs.mun.ca/~michael/c/ascii-table.html](http://www.cs.mun.ca/~michael/c/ascii-table.html)

克里斯的网站： [http ://seattlesoftware.wordpress.com/2008/09/11/hexadecimal-value-0-is-an-invalid-character/](http://seattlesoftware.wordpress.com/2008/09/11/hexadecimal-value-0-is-an-invalid-character/)

-汤姆

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-20T06:09:23.397

以下是一些适合您的粗略代码：

```
// Convert hex number, which represents an RTF code-page escaped character, 
// to the desired character (uses '85' from your example as a literal):
var number = int.Parse("85", System.Globalization.NumberStyles.HexNumber);
Debug.Assert(number <= byte.MaxValue);  

byte[] bytes = new byte[1] { (byte)number };
char[] chars = Encoding.GetEncoding(1252).GetString(bytes).ToCharArray();
// or, use:
// char[] chars = Encoding.Default.GetString(bytes).ToCharArray();  

string result = new string(chars); 
```

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-19T21:46:38.100

我的猜测是 .NET 中的 Char 实际上是两个字节（16 位），因为它们是 UTF-16 编码的。也许您只是在捕获/写入值的第一个字节？

基本上，您之后是否对 char 值进行了一些操作，假设它是 8 位而不是 16 位，因此要截断它？

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T21:57:10.787

您可能在读取 RTF 文件时使用默认字符编码，即 UTF-8，而实际使用“windows-1252”扩展 ASCII 拉丁编码存储 RTF 文件。

C# 字符串使用 16 位 unicode 位宽的字符格式。将 windows-1252 字符 0x85 转换为其 unicode 等效项涉及复杂的映射，因为代码点（字符编号）非常不同。幸运的是，Windows 可以为您完成这项工作。

您可以通过在打开流时显式指定源编码来更改在读取文本时转换字符的方式。

```
using System.IO;
using System.Text.Encoding;

using (TextReader tr = new StreamReader(path_to_RTF_file, Encoding.GetEncoding(1252)))
{
    // Read from the file as usual.
} 
```

# mysql - 如何在 plt-scheme 中通过 ffi 访问 char **？

> ID：105816
> 
> 赞同：2
> 
> 时间：2008-09-19T21:33:32.263
> 
> 标签：mysql, c, lisp, scheme

我在嘲笑 plt-scheme 的 ffi，我有一个返回 char **（字符串数组）的 C 函数。如果我将函数声明为`(_fun _pointer -> _pointer)`，如何将结果转换为方案中的字符串列表？

以下是相关的 C 声明：

```
typedef char **MYSQL_ROW;   /* return data as array of strings */
// ...
MYSQL_ROW STDCALL mysql_fetch_row(MYSQL_RES *result); 
```

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T21:57:44.483

我*认为*你想要的是cvector：

[http://docs.plt-scheme.org/foreign/Derived_Utilities.html#(part._foreign~3acvector)](http://docs.plt-scheme.org/foreign/Derived_Utilities.html#(part._foreign~3acvector))

_string/utf-8 的 cvector 或您需要的任何编码似乎都是合理的。

但这是对文档的快速调查——我自己没有尝试过。请让我知道它是否有效！

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T21:50:58.477

我知道这不是您正在寻找的东西，但它可能会有所帮助。我在 MySQL 的基本 Gambit Scheme FFI 上做了一些工作。我不知道 PLT Scheme 和 Gambit 在 FFI 实现方面有何不同（我敢说“相当”），但也许你可以从中得到一些东西：

[http://bunny.jonnay.net/zengarden/trunk/lib/mysql/mysql-ffi.scm](http://bunny.jonnay.net/zengarden/trunk/lib/mysql/mysql-ffi.scm)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T22:26:55.380

啊哈，我自己想通了。

我必须使用`_cpointer`麦克链接到的页面中描述的程序：

```
(_fun _pointer -> (_cpointer/null 'mysql-row (make-ctype _pointer #f #f))) 
```

似乎[有人已经打败了我](http://software.pupeno.com/mr-mysql/libmysqlclient.scm)为 mysqlclient 创建 ffi。不用担心; 我的主要目标是了解 ffi api，并且它正在向前发展。

# seo - SEO 和带有动态 URL 的硬链接

> ID：105830
> 
> 赞同：3
> 
> 时间：2008-09-19T21:35:25.647
> 
> 标签：seo, httphandler, httpmodule, dynamic-url, dynamic-links

使用 ASP.NET MVC（或使用 HttpHandlers），您可以动态生成 URL，就像这个问题中的一样，其中包括标题。

如果标题更改（例如，编辑它）并且有一个链接指向另一个站点的页面，或者 Google 的 Pagerank 是针对该 URL 计算的，会发生什么情况？

估计全丢了吧？（链接指向无处，计算的pagerank丢失）

如果是这样，有没有办法避免它？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-19T21:58:32.923

我使用与此处相同的系统，在 db 查询中不使用 URL 中数字之后的所有内容，然后我 301 将其他任何内容重定向为标题。

换句话说，如果标题更改，那么它将重定向到正确的位置。我用 PHP 而不是 htaccess 来做，因为它更容易管理更复杂的想法。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T21:39:14.637

如果可能的话，我认为您通常最好让服务器将永久重定向发送到新位置。

这样，从第三方链接获得的任何排名理论上都应该转移到新位置。我不相信这是否在实践中发生，但它应该发生。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-19T21:40:10.830

是的，所有的 SEO 在 url 更改时都会丢失——它会产生一个全新的记录。处理这个问题的方法是在旧标题上留下一个 301 重定向到新标题，并且一些搜索引擎（阅读：谷歌）足够聪明，可以选择它。

编辑：固定为 301 重定向！

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-09-19T21:40:30.733

就链接到问题而言，问题编号之后的一切似乎都实现了 Stackoverflow 的方式。例如：

[SEO 和带有动态 URL 的硬链接](https://stackoverflow.com/questions/105830/this-is-a-good-question)

链接到这个问题，尽管我只是凭空编造了“问题标题”部分。因此，链接不会指向任何地方，并且 PageRank 也不会丢失（尽管它可能会在两个 URL 之间拆分，具体取决于 Google 是否可以将它们规范化为单个 URL）。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-09-19T21:41:17.253

让您的应用通过[301 Redirect 重定向](http://en.wikipedia.org/wiki/URL_redirection#HTTP_status_codes_3xx)旧 URL 。这将告诉 Google 将 pagerank 转移到新 URL。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-09-19T21:42:10.107

如果将文档移动到不同的 URL，则应将服务器配置为返回旧 URL 的 HTTP 状态代码 301（永久移动），以告知客户端文档已移动到何处。对于 Apache，这是使用 mod_rewrite 和 RewriteRule 完成的。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-09-19T21:42:57.187

在这种情况下，帮助 Google 的最好方法是将旧 URL 上的永久重定向返回到新 URL。

我不是 ASP.NET 黑客——所以我不能推荐最好的实现方法——但是[谷歌搜索这个主题](http://www.google.co.uk/search?q=ASP.NET%20MVC%20permanent%20redirect)看起来相当有成效:-)

# java - JVM 会阻止尾调用优化吗？

> ID：105834
> 
> 赞同：99
> 
> 时间：2008-09-19T21:35:35.130
> 
> 标签：java, jvm, scala, tail-recursion

我在这个问题上看到了这句话：[什么是构建 Web 服务的好的函数式语言？](https://stackoverflow.com/questions/105710)

> Scala 尤其不支持尾调用消除，除非在自递归函数中，这限制了您可以执行的组合类型（这是 JVM 的基本限制）。

这是真的？如果是这样，那么造成这种基本限制的 JVM 是什么？

* * *

## 回答 #1

> 赞同：75
> 
> 时间：2008-09-19T21:44:48.400

这篇文章：[递归还是迭代？](https://stackoverflow.com/questions/72209/recursion-or-loop#72522)可能有帮助。

简而言之，由于安全模型和需要始终有可用的堆栈跟踪，尾调用优化很难在 JVM 中进行。这些要求理论上可以得到支持，但可能需要一个新的字节码（参见[John Rose 的非正式提案](https://blogs.oracle.com/jrose/entry/tail_calls_in_the_vm)）。

[Sun bug #4726340](http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4726340)中也有更多讨论，评估（从 2002 年开始）在此结束：

> 我相信这仍然可以完成，但这不是一项小任务。

[目前，达芬奇机器](http://openjdk.java.net/projects/mlvm/subprojects.html)项目正在进行一些工作。尾调用子项目的状态列为“proto 80%”；它不太可能进入 Java 7，但我认为它很有可能进入 Java 8。

* * *

## 回答 #2

> 赞同：27
> 
> 时间：2008-11-06T02:38:57.170

根本的限制只是 JVM 在其字节码中不提供尾调用，因此，构建在 JVM 上的语言没有直接的方法来提供尾调用本身。有一些变通方法可以实现类似的效果（例如蹦床），但它们的代价是糟糕的性能和混淆生成的中间代码，这使得调试器无用。

因此，在 Sun 在 JVM 本身中实现尾调用之前，JVM 无法支持任何生产质量的函数式编程语言。他们已经讨论了多年，但我怀疑他们是否会实现尾调用：这将非常困难，因为他们在实现这些基本功能之前已经过早地优化了他们的 VM，而且 Sun 的工作重点是动态语言而不是函数式语言。

因此，有一个非常强烈的论点认为 Scala 不是一种真正的函数式编程语言：自从 30 多年前首次引入 Scheme 以来，这些语言一直将尾调用视为基本特性。

* * *

## 回答 #3

> 赞同：22
> 
> 时间：2009-06-19T02:12:32.923

Scala 2.7.x 支持对 final 方法和本地函数的自递归（一个函数调用自身）进行尾调用优化。

Scala 2.8 也可能带有对 trampoline 的库支持，这是一种优化相互递归函数的技术。

可以在[Rich Dougherty 的博客](http://blog.richdougherty.com/2009/04/tail-calls-tailrec-and-trampolines.html)中找到有关 Scala 递归状态的大量信息。

* * *

## 回答 #4

> 赞同：8
> 
> 时间：2008-09-19T22:23:48.523

除了 Lambda The Ultimate 中链接的论文（来自上面发布的链接 mmyers），来自 Sun 的 John Rose 对尾调用优化还有更多话要说。

[http://blogs.oracle.com/jrose/entry/tail_calls_in_the_vm](http://blogs.oracle.com/jrose/entry/tail_calls_in_the_vm)

我听说有一天它可能会在 JVM 上实现。在达芬奇机器上正在研究尾呼叫支持等。

[http://openjdk.java.net/projects/mlvm/](http://openjdk.java.net/projects/mlvm/)

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2010-12-01T14:55:53.650

所有消息来源都指向 JVM 在尾递归的情况下无法优化，但在阅读[Java 性能调优](http://books.google.ca/books?id=iPHtCfZQyqQC&printsec=frontcover&dq=java%20performance%20tuning&hl=en&ei=gGH2TOrfM4SKlwfT0ozVBQ&sa=X&oi=book_result&ct=result&resnum=1&ved=0CDAQ6AEwAA#v=onepage&q&f=false)（2003，O'reilly）后，我发现作者声称他可以通过实现尾递归来实现更高的递归性能。

您可以在第 212 页找到他的声明（搜索“尾递归”，它应该是第二个结果）。是什么赋予了？

# oracle - Oracle 中的类似 Perl JOIN 的行为？

> ID：105836
> 
> 赞同：3
> 
> 时间：2008-09-19T21:36:05.673
> 
> 标签：oracle, join

我有两张桌子，我们称它们为 PERSON 和 NAME。

```
 PERSON
  person_id
  dob

 NAME
  name_id
  person_id
  name 
```

假设 NAME 表的数据如下：

```
name_id  person_id  name
1        1          Joe
2        1          Fred
3        1          Sam
4        2          Jane
5        2          Kim 
```

我需要一个将返回的查询（Oracle 10g）

```
name_id   names
1         Joe, Fred, Sam
2         Jane, Kim 
```

有没有一种简单的方法可以做到这一点？

* * *

更新：

根据 figs 提供的文章，从 9i 开始，您可以执行以下操作：

```
SELECT wmsys.wm_concat(dname) departments FROM dept; 
```

对于此示例，答案变为：

```
SELECT name_id,  wmsys.wm_concat(name) from names group by name_id 
```

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2008-09-21T01:53:33.223

简短的回答是使用 PL/SQL 函数。有关更多详细信息，请查看[此](https://stackoverflow.com/questions/102317/how-to-get-multiple-records-against-one-record-based-on-relation)帖子。

# recursion - 递归的真实示例

> ID：105838
> 
> 赞同：110
> 
> 时间：2008-09-19T21:36:12.477
> 
> 标签：recursion

除了深度优先搜索（DFS）之外，递归方法是自然解决方案的**实际**问题是什么？

（我不考虑[河内塔](http://en.wikipedia.org/wiki/Tower_of_Hanoi)、[斐波那契数](http://en.wikipedia.org/wiki/Fibonacci_number)或阶乘现实问题。在我看来，它们有点做作。）

* * *

## 回答 #1

> 赞同：114
> 
> 时间：2008-09-19T21:51:15.047

## 递归的真实示例

![向日葵](https://upload.wikimedia.org/wikipedia/commons/4/44/Helianthus_whorl.jpg)

* * *

## 回答 #2

> 赞同：65
> 
> 时间：2008-09-19T21:37:12.397

涉及文件系统中目录结构的任何事情怎么样。递归查找文件、删除文件、创建目录等。

这是一个 Java 实现，它递归地打印出目录及其子目录的内容。

```
import java.io.File;

public class DirectoryContentAnalyserOne implements DirectoryContentAnalyser {

    private static StringBuilder indentation = new StringBuilder();

    public static void main (String args [] ){
        // Here you pass the path to the directory to be scanned
        getDirectoryContent("C:\\DirOne\\DirTwo\\AndSoOn");
    }

    private static void getDirectoryContent(String filePath) {

        File currentDirOrFile = new File(filePath);

        if ( !currentDirOrFile.exists() ){
            return;
        }
        else if ( currentDirOrFile.isFile() ){
            System.out.println(indentation + currentDirOrFile.getName());
            return;
        }
        else{
            System.out.println("\n" + indentation + "|_" +currentDirOrFile.getName());
            indentation.append("   ");

            for ( String currentFileOrDirName : currentDirOrFile.list()){
                getPrivateDirectoryContent(currentDirOrFile + "\\" + currentFileOrDirName);
            }

            if (indentation.length() - 3 > 3 ){
                indentation.delete(indentation.length() - 3, indentation.length());
            }
        }       
    }

} 
```

* * *

## 回答 #3

> 赞同：62
> 
> 时间：2008-09-19T22:25:42.717

这里有很多数学例子，但你想要一个**真实世界**的例子，所以稍微思考一下，这可能是我能提供的最好的：

你会发现一个人感染了某种非致命性的传染性感染，并且很快就会自我修复（A 型），除了五分之一的人（我们将称之为 B 型）永久感染它并且没有表现出症状，只是充当传播者。

当 B 型感染大量 A 型时，这会造成相当烦人的破坏浪潮。

你的任务是追踪所有 B 型病毒并对其进行免疫以阻止疾病的主干。不幸的是，你不能对所有人进行全国性的治疗，因为 A 型的人对 B 型的治疗也有致命的过敏。

这样做的方式是社交发现，给定一个感染者（A 型），选择他们上周的所有联系人，将每个联系人标记在一个堆上。当您测试一个人被感染时，将他们添加到“跟进”队列中。当一个人是B型时，将他们添加到头部的“跟进”中（因为您想快速停止）。

处理给定人员后，从队列前面选择人员并在需要时进行免疫接种。获取他们之前未访问过的所有联系人，然后测试他们是否被感染。

重复直到感染者的队列变为0，然后等待再次爆发。

（好吧，这有点迭代，但它是解决递归问题的迭代方式，在这种情况下，广度优先遍历人口基数试图发现问题的可能路径，此外，迭代解决方案通常更快更有效，并且我强迫性地在所有地方都删除递归，以至于它变得本能......该死！）

* * *

## 回答 #4

> 赞同：44
> 
> 时间：2008-09-19T21:37:35.267

[快速排序](http://en.wikipedia.org/wiki/Quicksort)、[归并排序](http://en.wikipedia.org/wiki/Merge_sort)和大多数其他 N-log N 排序。

* * *

## 回答 #5

> 赞同：16
> 
> 时间：2008-09-19T21:38:26.357

马特迪拉德的例子很好。更一般地，树的任何行走通常都可以很容易地通过递归来处理。例如，编译解析树、遍历 XML 或 HTML 等。

* * *

## 回答 #6

> 赞同：16
> 
> 时间：2008-09-19T21:43:47.840

递归通常用于[回溯算法](http://en.wikipedia.org/wiki/Backtracking)的实现。对于这个的“现实世界”应用，[数独求解器](https://en.wikipedia.org/wiki/Sudoku_solving_algorithms)怎么样？

* * *

## 回答 #7

> 赞同：14
> 
> 时间：2008-09-19T21:51:21.223

只要可以通过将问题划分为子问题来解决问题，就可以使用递归，这些子问题可以使用相同的算法来解决它们。树和排序列表上的算法很自然。[计算几何（和 3D 游戏）中的许多问题都可以使用二进制空间分区](http://en.wikipedia.org/wiki/Binary_space_partitioning)(BSP) 树、[胖细分](http://www.google.com/search?hl=en&q=point+location+in+fat+subdivisions&btnG=Search)或其他将世界划分为子部分的方法递归地解决。

当您试图保证算法的正确性时，递归也是合适的。给定一个函数，它接受不可变的输入并返回一个结果，该结果是对输入的递归和非递归调用的组合，使用数学归纳法通常很容易证明该函数是正确的（或不正确的）。使用迭代函数或可能发生变异的输入通常很难做到这一点。这在处理财务计算和其他正确性非常重要的应用程序时很有用。

* * *

## 回答 #8

> 赞同：11
> 
> 时间：2008-09-19T21:40:10.453

肯定有很多编译器大量使用递归。计算机语言本身就是递归的（即，您可以将“if”语句嵌入到其他“if”语句中，等等）。

* * *

## 回答 #9

> 赞同：9
> 
> 时间：2008-09-19T21:56:46.017

对容器控件中的所有子控件禁用/设置只读。我需要这样做，因为一些子控件本身就是容器。

```
public static void SetReadOnly(Control ctrl, bool readOnly)
{
    //set the control read only
    SetControlReadOnly(ctrl, readOnly);

    if (ctrl.Controls != null && ctrl.Controls.Count > 0)
    {
        //recursively loop through all child controls
        foreach (Control c in ctrl.Controls)
            SetReadOnly(c, readOnly);
    }
} 
```

* * *

## 回答 #10

> 赞同：8
> 
> 时间：2008-09-19T21:56:43.380

人们经常使用递归方法对成堆的文档进行排序。例如，假设您正在对 100 个带有名称的文档进行排序。首先将文件按第一个字母成堆，然后对每一堆进行排序。

在字典中查找单词通常是通过类似于二分搜索的技术来执行的，该技术是递归的。

在组织中，老板经常向部门负责人下达命令，部门负责人又向经理下达命令，依此类推。

* * *

## 回答 #11

> 赞同：8
> 
> 时间：2008-09-20T12:04:05.057

# [来自SICP](http://mitpress.mit.edu/sicp/full-text/sicp/book/node77.html "评估/应用")的著名评估/应用周期

[![替代文字](https://i.stack.imgur.com/KUGF6.gif)](https://i.stack.imgur.com/KUGF6.gif)
[（来源：[mit.edu](https://mitpress.mit.edu/sicp/full-text/sicp/book/chapter-4/figs/eval-apply.gif)）]

这是eval的定义：

```
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type - EVAL" exp)))) 
```

这是应用的定义：

```
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type - APPLY" procedure)))) 
```

下面是 eval-sequence 的定义：

```
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env)))) 
```

`eval`-> `apply`-> `eval-sequence`->`eval`

* * *

## 回答 #12

> 赞同：7
> 
> 时间：2008-09-19T21:38:06.683

递归用于诸如 BSP 树之类的游戏开发（和其他类似领域）中的碰撞检测。

* * *

## 回答 #13

> 赞同：7
> 
> 时间：2008-09-19T22:14:03.697

我最近得到的现实世界要求：

需求 A：在彻底理解需求 A 后实现此功能。

* * *

## 回答 #14

> 赞同：4
> 
> 时间：2008-09-19T21:46:40.050

解析器和编译器可以用递归下降法编写。这不是最好的方法，因为像 lex/yacc 这样的工具可以生成更快、更高效的解析器，但在概念上简单且易于实现，因此它们仍然很常见。

* * *

## 回答 #15

> 赞同：4
> 
> 时间：2008-09-19T21:51:11.457

我有一个系统在几个地方使用纯[尾递归来模拟状态机。](https://en.wikipedia.org/wiki/Tail_call)

* * *

## 回答 #16

> 赞同：4
> 
> 时间：2008-09-20T04:07:32.427

[在函数式编程](http://en.wikipedia.org/wiki/Functional_programming)语言中可以找到一些很好的递归示例。在函数式编程语言（[Erlang](http://en.wikipedia.org/wiki/Erlang_%28programming_language%29)、[Haskell](http://en.wikipedia.org/wiki/Haskell_%28programming_language%29)、[ML](http://en.wikipedia.org/wiki/ML_%28programming_language%29) / [OCaml](http://en.wikipedia.org/wiki/Objective_Caml) / [F#](http://en.wikipedia.org/wiki/F_Sharp_%28programming_language%29)等）中，任何列表处理都使用递归是很常见的。

在处理典型的命令式 OOP 风格语言中的列表时，很常见的是将列表实现为链表 ([item1 -> item2 -> item3 -> item4])。但是，在某些函数式编程语言中，您会发现列表本身是递归实现的，其中列表的“头”指向列表中的第一项，“尾”指向包含其余项目的列表（ [item1 -> [item2 -> [item3 -> [item4 -> []]]]]）。在我看来这很有创意。

当与模式匹配结合使用时，这种对列表的处理非常强大。假设我想总结一个数字列表：

```
let rec Sum numbers =
    match numbers with
    | [] -> 0
    | head::tail -> head + Sum tail 
```

这实质上是说“如果我们被一个空列表调用，则返回 0”（允许我们中断递归），否则返回 head 的值 + 使用剩余项调用的 Sum 的值（因此，我们的递归）。

例如，我可能有一个[URL](http://en.wikipedia.org/wiki/Uniform_Resource_Locator)列表，我认为拆分每个 URL 链接到的所有 URL，然后我减少所有 URL 的链接总数以生成页面的“值”（谷歌的一种方法与[PageRank](http://en.wikipedia.org/wiki/PageRank)一起使用，您可以在原始[MapReduce](http://labs.google.com/papers/mapreduce.html)论文中找到定义）。您也可以这样做以在文档中生成字数统计。还有很多很多其他的事情。

您可以将此功能模式扩展到任何类型的[MapReduce](http://en.wikipedia.org/wiki/MapReduce)代码，您可以在其中获取某些内容的列表，对其进行转换并返回其他内容（无论是另一个列表，还是列表中的某个 zip 命令）。

* * *

## 回答 #17

> 赞同：4
> 
> 时间：2011-03-10T11:57:00.877

递归应用于问题（情况），您可以将其分解（减少）为更小的部分，并且每个部分看起来都与原始问题相似。

包含与其自身相似的较小部分的事物的好例子是：

*   树形结构（一个分支就像一棵树）
*   列表（列表的一部分仍然是列表）
*   容器（俄罗斯娃娃）
*   序列（序列的一部分看起来像下一个）
*   对象组（子组仍然是一组对象）

递归是一种不断将问题分解成越来越小的部分的技术，直到其中一个变得小到可以小菜一碟。当然，在你分解它们之后，你必须以正确的顺序将结果“缝合”在一起，以形成原始问题的整体解决方案。

一些递归排序算法、tree-walking 算法、map/reduce 算法、分治法都是这种技术的例子。

在计算机编程中，大多数基于堆栈的调用返回类型语言已经具有内置的递归功能：即

*   将问题分解成更小的部分 ==> 在原始数据的较小子集上调用自身），
*   跟踪碎片是如何划分的 ==> 调用堆栈，
*   将结果缝合回去 ==> 基于堆栈的返回

* * *

## 回答 #18

> 赞同：4
> 
> 时间：2013-08-09T04:37:25.857

分层组织中的反馈循环。

高层老板告诉高层管理人员收集公司每个人的反馈。

每个高管都会收集他/她的直接下属，并告诉他们从直接下属那里收集反馈。

并在下线。

没有直接下属的人——树中的叶子节点——给出他们的反馈。

反馈返回树上，每个经理都添加他/她自己的反馈。

最终，所有的反馈都会反馈给最高老板。

这是自然的解决方案，因为递归方法允许在每个级别进行过滤 - 整理重复项和删除令人反感的反馈。最高老板*可以*发送一封全球电子邮件，让每个员工直接向他/她报告反馈，但存在“你无法处理真相”和“你被解雇”的问题，所以递归在这里效果最好。

* * *

## 回答 #19

> 赞同：3
> 
> 时间：2008-09-19T21:39:32.360

XML，或遍历任何树。虽然，老实说，我几乎从不在我的工作中使用递归。

* * *

## 回答 #20

> 赞同：3
> 
> 时间：2008-09-19T21:43:30.680

通过递归解决的“现实世界”问题将是嵌套娃娃。你的函数是 OpenDoll()。

给定一堆它们，你会递归地打开娃娃，如果你愿意的话，调用 OpenDoll()，直到你到达最里面的娃娃。

* * *

## 回答 #21

> 赞同：2
> 
> 时间：2008-09-19T21:44:14.500

*   解析[XML](http://en.wikipedia.org/wiki/XML)文件。
*   在多维空间中进行高效搜索。例如。2D 中的四叉树、3D 中的八叉树、kd 树等。
*   层次聚类。
*   想一想，遍历任何层次结构自然会导致递归。
*   C++ 中的模板元编程，没有循环，递归是唯一的方法。

* * *

## 回答 #22

> 赞同：2
> 
> 时间：2008-09-19T21:44:20.973

假设你正在为一个网站构建一个 CMS，你的页面是树形结构，比如根是主页。

假设您的 {user|client|customer|boss} 请求您在每个页面上放置一个面包屑路径以显示您在树中的位置。

对于任何给定的页面 n，您可能希望遍历 n 的父级及其父级，依此类推，以递归方式构建一个节点列表，返回到页面树的根节点。

当然，在该示例中，您在每页中多次访问 db，因此您可能希望使用一些 SQL 别名，将页表查找为 a，再次将页表查找为 b，然后将 a.id 与b.parent 所以你让数据库做递归连接。已经有一段时间了，所以我的语法可能没有帮助。

再说一次，您可能只想计算一次并将其与页面记录一起存储，仅在移动页面时才更新它。那可能会更有效率。

无论如何，这是我的 $.02

* * *

## 回答 #23

> 赞同：2
> 
> 时间：2008-09-19T21:44:31.957

您有一个深度为 N 级的组织树。检查了几个节点，并且您希望仅扩展到已检查的那些节点。

这是我实际编码的东西。递归很好很容易。

* * *

## 回答 #24

> 赞同：2
> 
> 时间：2008-09-19T21:54:12.137

在我的工作中，我们有一个具有通用数据结构的系统，可以描述为树。这意味着递归是一种非常有效的数据处理技术。

在没有递归的情况下解决它需要大量不必要的代码。递归的问题在于，要跟踪所发生的事情并不容易。在遵循执行流程时，您确实必须集中精力。但是当它工作时，代码是优雅而有效的。

* * *

## 回答 #25

> 赞同：2
> 
> 时间：2008-09-19T22:14:47.423

金融/物理计算，例如复合平均值。

* * *

## 回答 #26

> 赞同：2
> 
> 时间：2008-09-19T22:22:54.360

我知道的最好的例子是[quicksort](http://en.wikipedia.org/wiki/Quicksort)，递归要简单得多。看一眼：

[shop.oreilly.com/product/9780596510046.do](http://shop.oreilly.com/product/9780596510046.do)

[www.amazon.com/Beautiful-Code-Leading-Programmers-Practice/dp/0596510047](https://rads.stackoverflow.com/amzn/click/com/0596510047)

（点击第3章下的第一个副标题：“我写过的最漂亮的代码”）。

* * *

## 回答 #27

> 赞同：2
> 
> 时间：2008-09-20T09:28:06.977

解析[Windows 窗体](http://en.wikipedia.org/wiki/Windows_Forms)或 WebForms (.NET Windows Forms / [ASP.NET](http://en.wikipedia.org/wiki/ASP.NET) ) 中的控件树。

* * *

## 回答 #28

> 赞同：1
> 
> 时间：2008-09-19T21:38:52.797

电话和有线电视公司维护其布线拓扑模型，这实际上是一个大型网络或图形。当您想要查找所有父元素或所有子元素时，递归是遍历此模型的一种方法。

由于从处理和内存的角度来看，递归是昂贵的，因此此步骤通常仅在拓扑发生更改并且结果以修改后的预排序列表格式存储时才执行。

* * *

## 回答 #29

> 赞同：1
> 
> 时间：2008-09-19T21:44:09.633

归纳推理是概念形成的过程，本质上是递归的。在现实世界中，你的大脑一直在做这件事。

* * *

## 回答 #30

> 赞同：1
> 
> 时间：2008-09-19T21:45:47.103

大多数情况下，递归对于处理递归数据结构是非常自然的。这基本上意味着列表结构和树结构。但是递归也是以某种方式动态/创建/树结构的一种很好的自然方式，通过分而治之，例如[快速排序](http://en.wikipedia.org/wiki/Quicksort)或二分搜索。

我认为你的问题在某种意义上有点误导。深度优先搜索与现实世界有何不同？深度优先搜索可以做很多事情。

例如，我想到的另一个例子是递归下降编译。在许多现实世界的编译器中使用它就足够了一个现实世界的问题。但你可以说它是 DFS，它基本上是对有效解析树的深度优先搜索。

* * *

## 回答 #31

> 赞同：1
> 
> 时间：2008-09-19T21:52:18.943

同上关于编译器的评论。抽象语法树节点自然适合递归。所有递归数据结构（链表、树、图等）也更容易使用递归处理。我确实认为，由于现实世界问题的类型，一旦我们离开学校，我们大多数人就不会经常使用递归，但最好意识到它是一种选择。

* * *

## 回答 #32

> 赞同：1
> 
> 时间：2008-09-19T22:03:28.230

自然数的乘法是递归的真实示例：

```
To multiply x by y
  if x is 0
    the answer is 0
  if x is 1
    the answer is y
  otherwise
    multiply x - 1 by y, and add x 
```

* * *

## 回答 #33

> 赞同：1
> 
> 时间：2008-09-19T22:39:37.847

任何具有树或图数据结构的程序都可能有一些递归。

* * *

## 回答 #34

> 赞同：1
> 
> 时间：2008-09-20T00:03:52.637

编写一个函数，将像 12345.67 这样的数字转换为“12345 美元和 67 美分”。

* * *

## 回答 #35

> 赞同：1
> 
> 时间：2008-09-20T03:21:25.220

我曾经写过一个 XML 解析器，如果没有递归，它会更难写。

我想你总是可以使用堆栈+迭代，但有时递归是如此优雅。

* * *

## 回答 #36

> 赞同：1
> 
> 时间：2008-11-15T21:24:33.990

在平均情况 O(n) 中找到中位数。相当于在 n 个事物的列表中找到第 k 个最大的项目，其中 k=n/2：

int kthLargest(list, k, first, last) { j = partition(list, first, last) if (k == j) return list[j] else if (k

在这里，`partition`选择一个枢轴元素，并在一次遍历数据中重新排列列表，使小于枢轴的项目首先出现，然后是枢轴，然后是大于枢轴的项目。“kthLargest”算法与快速排序非常相似，但只在列表的一侧递归。

对我来说，这是最简单的递归算法，比迭代算法运行得更快。它平均使用 2*n 次比较，与 k 无关。这比运行 k 遍历数据、每次找到最小值并丢弃它的幼稚方法要好得多。

阿莱霍

* * *

## 回答 #37

> 赞同：1
> 
> 时间：2009-01-24T12:06:50.087

如果不是因为导致堆栈溢出的实际限制，那么使用迭代的所有事情都可以通过递归更自然地完成；-)

但是严重的是递归和迭代是非常可互换的，您可以使用递归重写所有算法以使用迭代，反之亦然。数学家喜欢递归，程序员喜欢迭代。这可能也是你看到你提到的所有这些人为例子的原因。我认为称为数学归纳的数学证明方法与数学家为什么喜欢递归有关。 [http://en.wikipedia.org/wiki/Mathematical_induction](http://en.wikipedia.org/wiki/Mathematical_induction)

* * *

## 回答 #38

> 赞同：0
> 
> 时间：2008-09-19T21:45:05.577

我刚刚编写了一个递归函数来确定一个类是否需要使用 DataContractSerializer 进行序列化。最大的问题来自模板/泛型，其中一个类可能包含需要数据合同序列化的其他类型......所以它会遍历每种类型，如果它不是 datacontractserializable 检查它的类型。

* * *

## 回答 #39

> 赞同：0
> 
> 时间：2008-09-19T21:46:23.170

我们使用它们来进行 SQL 寻路。

我还要说调试很费劲，可怜的程序员很容易搞砸。

* * *

## 回答 #40

> 赞同：0
> 
> 时间：2008-09-19T21:54:56.207

我认为这真的取决于语言。在某些语言中，例如[Lisp](http://en.wikipedia.org/wiki/Lisp_%28programming_language%29)，递归通常是对问题的自然反应（通常在这种情况下，编译器会针对递归进行优化）。

Lisp 中的常见模式是对列表的第一个元素执行操作，然后在列表的其余部分上调用函数以累积一个值或一个新列表，这是一种非常优雅和最自然的方式来做很多事情那种语言的东西。在[Java](http://en.wikipedia.org/wiki/Java_%28programming_language%29)中，没有那么多。

* * *

## 回答 #41

> 赞同：0
> 
> 时间：2008-09-19T22:00:20.873

我在 C# 中编写了一个树来处理对具有默认情况的 6 段键的表的查找（如果键 [0] 不存在，则使用默认情况并继续）。查找是递归完成的。我尝试了字典（等）的字典，它很快就变得太复杂了。

我还在 C# 中编写了一个公式评估器，它评估存储在树中的方程以使评估顺序正确。当然，这很可能是为问题选择了不正确的语言，但这是一个有趣的练习。

我没有看到很多关于人们所做的事情的例子，而是他们使用过的库。希望这能给你一些思考。

* * *

## 回答 #42

> 赞同：0
> 
> 时间：2008-09-19T22:15:05.707

GIS 或制图的几何计算，例如寻找圆的边缘。

* * *

## 回答 #43

> 赞同：0
> 
> 时间：2008-09-19T22:15:45.690

求平方根的方法是递归的。用于计算现实世界中的距离。

* * *

## 回答 #44

> 赞同：0
> 
> 时间：2008-09-19T22:19:00.627

寻找素数的方法是递归的。用于生成散列密钥，适用于使用大数因子的各种加密方案。

* * *

## 回答 #45

> 赞同：0
> 
> 时间：2008-09-19T22:22:01.540

你有一栋楼。该建筑有20间客房。从法律上讲，每个房间只能容纳一定数量的人。您的工作是自动将人员分配到一个房间。如果我的房间满了，你需要找到一个可用的房间。鉴于只有某些房间可以容纳某些人，您还需要注意哪个房间。

例如：

房间 1、2、3 可以互相滚动。这个房间是为不能自己走路的孩子准备的，所以你希望他们远离其他一切，以避免分心和其他疾病（这对老年人来说不是一件事情，但对于一个 6 个月的孩子来说，这可能会变得非常糟糕。应该三个人都满了，这个人必须被拒绝进入。

房间 4、5、6 可以互相滚动。这个房间是为对花生过敏的人准备的，因此他们不能进入其他房间（可能有花生的东西）。如果这三个人都吃饱了，提供一个警告，询问他们的过敏水平，并且他们可以被授予访问权限。

在任何给定时间，房间都可能发生变化。所以你可以允许房间 7-14 是没有花生的房间。你不知道要检查多少个房间。

或者，也许您想根据年龄分开。年级、性别等。这些只是我遇到的几个例子。

* * *

## 回答 #46

> 赞同：0
> 
> 时间：2008-09-19T23:57:54.913

检查创建的图像是否可以在尺寸受限的框中工作。

```
function check_size($font_size, $font, $text, $width, $height) {
        if (!is_string($text)) {
            throw new Exception('Invalid type for $text');
        }   
        $box = imagettfbbox($font_size, 0, $font, $text);
        $box['width'] = abs($box[2] - $box[0]);
        if ($box[0] < -1) {
            $box['width'] = abs($box[2]) + abs($box[0]) - 1;
        }   
        $box['height'] = abs($box[7]) - abs($box[1]);
        if ($box[3] > 0) {
            $box['height'] = abs($box[7] - abs($box[1])) - 1;
        }   
        return ($box['height'] < $height && $box['width'] < $width) ? array($font_size, $box['width'], $height) : $this->check_size($font_size - 1, $font, $text, $width, $height);
    } 
```

* * *

## 回答 #47

> 赞同：0
> 
> 时间：2008-09-20T02:20:20.407

一种使用亚音速从数据库表生成树状结构菜单的方法。

```
public MenuElement(BHSSiteMap node, string role)
    {
        if (CheckRole(node, role))
        {
            ParentNode = node;

            // get site map collection order by sequence
            BHSSiteMapCollection children = new BHSSiteMapCollection();

            Query q = BHSSiteMap.CreateQuery()
                    .WHERE(BHSSiteMap.Columns.Parent, Comparison.Equals, ParentNode.Id)
                    .ORDER_BY(BHSSiteMap.Columns.Sequence, "ASC");

            children.LoadAndCloseReader(q.ExecuteReader());

            if (children.Count > 0)
            {
                ChildNodes = new List<MenuElement>();

                foreach (BHSSiteMap child in children)
                {
                    MenuElement childME = new MenuElement(child, role);
                    ChildNodes.Add(childME);
                }
            }
        }
    } 
```

* * *

## 回答 #48

> 赞同：0
> 
> 时间：2008-09-20T04:29:29.503

我有的最后一个真实世界的例子是一个非常无聊的例子，但它展示了递归有时是如何“恰到好处”的。

我使用的是责任链模式，因此 Handler 对象要么自己处理请求，要么将其委托给链。记录链的构造很有用：

```
public String getChainString() {
    cs = this.getClass().toString();
    if(this.delegate != null) {
        cs += "->" + delegate.getChainString();
    }
    return cs;
} 
```

您可能会争辩说这不是最纯粹的递归，因为尽管该方法调用“自身”，但每次调用它时它都在不同的实例中。

* * *

## 回答 #49

> 赞同：0
> 
> 时间：2008-11-16T00:51:28.207

递归是一种非常基本的编程技术，它适用于许多问题，列出它们就像列出所有可以通过使用某种加法来解决的问题。只是通过我的 Project Euler 的 Lisp 解决方案，我发现：一个交叉总计函数、一个数字匹配函数、几个用于搜索空格的函数、一个最小的文本解析器、一个将数字拆分为其十进制数字列表的函数、一个函数构造一个图，以及一个遍历输入文件的函数。

问题是当今许多（如果不是大多数）主流编程语言都没有尾调用优化，因此深度递归对它们来说是不可行的。这种不足意味着大多数程序员被迫放弃这种自然的思维方式，转而依赖其他可能不太优雅的循环结构。

* * *

## 回答 #50

> 赞同：0
> 
> 时间：2010-07-27T04:15:24.917

如果您有两个不同但相似的序列，并且想要匹配每个序列的组件，以便首先优先考虑大的连续块，然后是相同的序列顺序，那么您可以递归分析这些序列以形成一棵树，然后递归处理该树以展平它。

**参考：** [递归和记忆示例代码](https://stackoverflow.com/questions/3242597/what-is-memoization-good-for-and-is-it-really-all-that-helpful/3276775#3276775)

* * *

## 回答 #51

> 赞同：0
> 
> 时间：2011-09-13T20:03:00.640

插头： http: [//picogen.deviantart.com/gallery/](http://picogen.deviantart.com/gallery/)

![在此处输入图像描述](https://i.stack.imgur.com/hfKUR.jpg) ![在此处输入图像描述](https://i.stack.imgur.com/ELak2.png)

* * *

## 回答 #52

> 赞同：0
> 
> 时间：2012-01-31T04:36:26.730

1.  大学储蓄计划：让 A(n) = n 个月后为大学节省的金额 A(0) = $500 每个月，$50 存入一个年利率为 5% 的账户。

然后`A(n) = A(n-1) + 50 + 0.05*(1/12)* A(N-1)`

* * *

## 回答 #53

> 赞同：0
> 
> 时间：2013-06-11T11:07:27.670

由于您似乎不喜欢计算机科学或数学示例，因此这里有一个不同的示例：连线谜题。

许多金属丝谜题涉及通过在金属丝环内外加工来去除长长的闭合回路。这些谜题是递归的。其中之一被称为“箭头动力学”。如果你用谷歌搜索“箭头动力学线谜”，我想你可以找到它

这些谜题很像河内的塔。

* * *

## 回答 #54

> 赞同：-3
> 
> 时间：2008-09-19T21:46:36.540

间接递归的一个真实例子是问你的父母你是否可以在圣诞节玩那个电子游戏。爸爸：“问妈妈。”……妈妈：“问爸爸。” [简而言之，“不，但我们不想告诉你，以免你发脾气。”]

* * *

## 回答 #55

> 赞同：-3
> 
> 时间：2008-09-19T21:48:44.083

河内塔

这是您可以与之互动的一个：http: [//www.mazeworks.com/hanoi/](http://www.mazeworks.com/hanoi/)

> 使用递归关系，该解决方案所需的确切移动次数可以计算为：2h - 1。这个结果是通过注意到步骤 1 和 3 采取 Th - 1 移动，而步骤 2 采取 1 移动，得到 Th = 2Th − 1 + 1。见：[http ://en.wikipedia.org/wiki/Towers_of_hanoi#Recursive_solution](http://en.wikipedia.org/wiki/Towers_of_hanoi#Recursive_solution)

# language-agnostic - 具有最小圈复杂度的条件日志记录

> ID：105852
> 
> 赞同：71
> 
> 时间：2008-09-19T21:38:36.793
> 
> 标签：language-agnostic, logging, coding-style, cyclomatic-complexity

阅读“[你的/一个好的圈复杂度限制是多少？](http://web.archive.org/web/20090117062700/http://stackoverflow.com:80/questions/20702/whats-youra-good-limit-for-cyclomatic-complexity) ”后，我意识到我的许多同事对我们项目的这个新的[QA](http://en.wikipedia.org/wiki/Quality_assurance)政策感到非常恼火：每个函数不再有 10 个[圈复杂度。](http://en.wikipedia.org/wiki/Cyclomatic_complexity)

含义：不超过10个'if'、'else'、'try'、'catch'等代码工作流分支语句。对。正如我在'[你测试私有方法吗？](https://stackoverflow.com/questions/105007/do-you-test-private-method#105114)'，这样的政策有很多好的副作用。

但是：在我们（200 人 - 7 年之久）项目开始时，我们很高兴记录日志（不，我们不能轻易将其委托给某种“[面向方面编程](http://en.wikipedia.org/wiki/Aspect-oriented_programming)”的日志方法）。

```
myLogger.info("A String");
myLogger.fine("A more complicated String");
... 
```

当我们的系统的第一个版本上线时，我们遇到了巨大的内存问题，不是因为日志记录（曾经关闭过），而是因为*日志参数*（字符串），它们总是被计算出来，然后传递给'info()' 或 'fine()' 函数，却发现日志记录的级别是 'OFF'，并且没有发生日志记录！

所以 QA 回来并敦促我们的程序员进行条件日志记录。总是。

```
if(myLogger.isLoggable(Level.INFO) { myLogger.info("A String");
if(myLogger.isLoggable(Level.FINE) { myLogger.fine("A more complicated String");
... 
```

但是现在，由于每个函数限制的“不能移动”10 个圈复杂度级别，他们认为他们放入函数中的各种日志被认为是一种负担，因为每个“if(isLoggable())”都是算作+1圈复杂度！

因此，如果一个函数具有 8 个“if”、“else”等，在一个紧密耦合的不易共享算法中，以及 3 个关键日志操作......即使条件日志可能不是*真的*，它们也会超出限制该功能的所述复杂性的一部分......

您将如何解决这种情况？
我在我的项目中看到了一些有趣的编码演变（由于那个“冲突”），但我只想先得到你的想法。

* * *

谢谢你的所有答案。
我必须坚持认为问题与“格式”无关，而是与“参数评估”相关（在调用一个什么都不做的方法之前进行评估可能非常昂贵）
所以当一个在“A String”上面写的时候，我实际上意味着 aFunction()，aFunction() 返回一个字符串，并调用一个复杂的方法来收集和计算要由记录器显示的所有类型的日志*数据*......使用条件日志，因此人为增加“圈复杂度”的实际问题......）

我现在得到了你们中的一些人提出的“[可变参数](http://en.wikipedia.org/wiki/Variadic_function)函数”点（谢谢约翰）。
注意：java6 中的快速测试表明，我的[varargs 函数](http://java.sun.com/j2se/1.5.0/docs/guide/language/varargs.html)在被调用之前确实评估了它的参数，因此它不能应用于函数调用，而是用于“日志检索器对象”（或“函数包装器”），其中 toString( ) 只会在需要时调用。知道了。

我现在已经发布了我在这个主题上的经验。
我会把它留在那里直到下周二投票，然后我会选择你的答案之一。
再次感谢您的所有建议：）

* * *

## 回答 #1

> 赞同：64
> 
> 时间：2008-09-19T21:46:24.293

### 对于当前的日志框架，这个问题没有实际意义

当前的日志框架，如 slf4j 或 log4j 2 在大多数情况下不需要保护语句。他们使用参数化的日志语句，以便可以无条件地记录事件，但只有在启用事件时才会发生消息格式化。消息构造由记录器根据需要执行，而不是由应用程序先发制人。

如果您必须使用古董日志库，您可以继续阅读以获取更多背景信息以及使用参数化消息改造旧库的方法。

### 守卫语句真的增加了复杂性吗？

考虑从圈复杂度计算中排除日志保护语句。

可以说，由于其可预测的形式，条件日志检查确实不会增加代码的复杂性。

不灵活的指标会使原本优秀的程序员变坏。当心！

假设您的计算复杂性的工具无法针对该程度进行定制，以下方法可能会提供一种解决方法。

### 需要条件记录

我假设你的保护语句被引入是因为你有这样的代码：

```
private static final Logger log = Logger.getLogger(MyClass.class);

Connection connect(Widget w, Dongle d, Dongle alt) 
  throws ConnectionException
{
  log.debug("Attempting connection of dongle " + d + " to widget " + w);
  Connection c;
  try {
    c = w.connect(d);
  } catch(ConnectionException ex) {
    log.warn("Connection failed; attempting alternate dongle " + d, ex);
    c = w.connect(alt);
  }
  log.debug("Connection succeeded: " + c);
  return c;
} 
```

在 Java 中，每个 log 语句都会创建一个 new ，并在连接到字符串的每个对象上`StringBuilder`调用该方法。反过来，`toString()`这些方法可能会创建自己的实例，并调用其成员的方法，等等，跨越一个潜在的大型对象图。（在 Java 5 之前，它更加昂贵，因为使用过，并且它的所有操作都是同步的。）`toString()``StringBuilder``toString()``StringBuffer`

这可能相对昂贵，特别是如果日志语句位于某些执行量很大的代码路径中。而且，如上所述，即使记录器由于日志级别太高而必然丢弃结果，也会发生昂贵的消息格式化。

这导致了以下形式的保护语句的引入：

```
 if (log.isDebugEnabled())
    log.debug("Attempting connection of dongle " + d + " to widget " + w); 
```

`d`使用此保护，仅在必要时执行参数和`w`字符串连接的评估。

### 简单、高效的日志记录解决方案

但是，如果记录器（或您围绕所选日志记录包编写的包装器）采用格式化程序和格式化程序的参数，则可以延迟消息构造，直到确定将使用它，同时消除保护语句及其圈复杂度。

```
public final class FormatLogger
{

  private final Logger log;

  public FormatLogger(Logger log)
  {
    this.log = log;
  }

  public void debug(String formatter, Object... args)
  {
    log(Level.DEBUG, formatter, args);
  }

  … &c. for info, warn; also add overloads to log an exception …

  public void log(Level level, String formatter, Object... args)
  {
    if (log.isEnabled(level)) {
      /* 
       * Only now is the message constructed, and each "arg"
       * evaluated by having its toString() method invoked.
       */
      log.log(level, String.format(formatter, args));
    }
  }

}

class MyClass 
{

  private static final FormatLogger log = 
     new FormatLogger(Logger.getLogger(MyClass.class));

  Connection connect(Widget w, Dongle d, Dongle alt) 
    throws ConnectionException
  {
    log.debug("Attempting connection of dongle %s to widget %s.", d, w);
    Connection c;
    try {
      c = w.connect(d);
    } catch(ConnectionException ex) {
      log.warn("Connection failed; attempting alternate dongle %s.", d);
      c = w.connect(alt);
    }
    log.debug("Connection succeeded: %s", c);
    return c;
  }

} 
```

现在，除非必要，否则**不会发生带有缓冲区分配****的级联调用！`toString()`**这有效地消除了导致防护语句的性能损失。在 Java 中，一个小的惩罚是对您传递给记录器的任何原始类型参数进行自动装箱。

可以说，进行日志记录的代码比以往任何时候都更干净，因为不整洁的字符串连接已经消失了。如果格式字符串被外部化（使用 a `ResourceBundle`），它会更干净，这也有助于软件的维护或本地化。

### 进一步的增强

另请注意，在 Java 中，`MessageFormat`可以使用对象来代替“格式” `String`，这为您提供了额外的功能，例如可以更巧妙地处理基数的选择格式。另一种选择是实现您自己的格式化功能，该功能调用您为“评估”定义的某些接口，而不是基本`toString()`方法。

* * *

## 回答 #2

> 赞同：33
> 
> 时间：2008-09-19T22:06:12.153

在 Python 中，您将格式化的值作为参数传递给日志记录函数。仅当启用日志记录时才应用字符串格式。函数调用的开销仍然存在，但与格式化相比，这是微不足道的。

```
log.info ("a = %s, b = %s", a, b) 
```

您可以对任何具有可变参数的语言（C/C++、C#/Java 等）执行类似的操作。

* * *

这并不是真正适用于难以检索参数的情况，而是适用于将它们格式化为字符串的成本很高的情况。例如，如果您的代码中已经有一个数字列表，您可能希望记录该列表以进行调试。执行`mylist.toString()`将需要一段时间而没有任何好处，因为结果将被丢弃。因此，您将`mylist`作为参数传递给日志记录函数，并让它处理字符串格式。这样，只有在需要时才会执行格式化。

* * *

由于 OP 的问题特别提到了 Java，以下是如何使用上述内容：

> 我必须坚持认为问题与“格式化”无关，而是与“参数评估”相关（在调用一个什么都不做的方法之前进行评估可能非常昂贵）

诀窍是让对象在绝对需要之前不会执行昂贵的计算。这在支持 lambdas 和闭包的 Smalltalk 或 Python 等语言中很容易，但在 Java 中仍然可以实现，只要有一点想象力。

假设你有一个函数`get_everything()`。它会将数据库中的每个对象检索到一个列表中。显然，如果结果将被丢弃，您不想调用它。因此，您无需直接调用该函数，而是定义了一个名为 的内部类`LazyGetEverything`：

```
public class MainClass {
    private class LazyGetEverything { 
        @Override
        public String toString() { 
            return getEverything().toString(); 
        }
    }

    private Object getEverything() {
        /* returns what you want to .toString() in the inner class */
    }

    public void logEverything() {
        log.info(new LazyGetEverything());
    }
} 
```

在此代码中，对 的调用`getEverything()`被包装，因此在需要之前不会实际执行它。仅当启用调试时，日志记录功能才会`toString()`对其参数执行。这样，您的代码将只承受函数调用而不是完整`getEverything()`调用的开销。

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-09-19T21:50:02.863

在支持 lambda 表达式或代码块作为参数的语言中，一种解决方案是将其提供给日志记录方法。可以评估配置，并且仅在需要时实际调用/执行提供的 lambda/代码块。不过还没试过。

**理论上**这是可能的。我不想在生产中使用它，因为我期望大量使用 lamdas/代码块进行日志记录时会出现性能问题。

但一如既往：如果有疑问，请对其进行测试并测量对 CPU 负载和内存的影响。

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2008-09-20T07:30:20.910

感谢您的所有回答！你们真棒 ：）

现在我的反馈不像你的那么直截了当：

是的，对于*一个项目*（如“在单个生产平台上单独部署和运行的一个程序”），我想您可以对我进行所有技术操作：

*   专用的“Log Retriever”对象，可以传递给 Logger 包装器，只需要调用 toString()
*   与记录[可变参数函数](http://en.wikipedia.org/wiki/Variadic_function)（或普通 Object[] 数组！）结合使用

正如@John Millikin 和@erickson 所解释的那样，你已经有了它。

然而，这个问题迫使我们思考“为什么我们首先要登录？”
我们的项目实际上是部署在各种生产平台上的 30 个不同的项目（每个 5 到 10 人），具有异步通信需求和中央总线架构。*问题中描述的简单日志记录在开始时*（5 年前）
对每个项目都很好，但从那时起，我们必须加强。输入[关键绩效指标](http://en.wikipedia.org/wiki/Key_performance_indicator)。

 *我们不要求记录器记录任何内容，而是要求自动创建的对象（称为 KPI）注册事件。这是一个简单的调用（myKPI.I_am_signaling_myself_to_you()），不需要有条件（解决了“人为增加圈复杂度”的问题）。

该 KPI 对象知道谁调用了它，并且由于他从应用程序开始运行，因此他能够检索我们之前在记录时当场计算的大量数据。
此外，可以独立监控 KPI 对象，并在单个单独的发布总线上按需计算/发布其信息。
这样，每个客户都可以询问他真正想要的信息（例如，'我的流程是否开始了，如果是，从什么时候开始？'），而不是寻找正确的日志文件并寻找一个神秘的字符串......

事实上，“为什么我们首先要登录？”这个问题确实存在。让我们意识到我们不仅仅是为程序员和他的单元或集成测试而记录，而是为一个更广泛的社区，包括一些最终客户本身。我们的“报告”机制必须是集中的、异步的、24/7 的。

该 KPI 机制的具体内容超出了此问题的范围。可以说它的正确校准是迄今为止我们面临的最复杂的非功能性问题。它仍然不时使系统屈服！但是，经过适当校准，它可以挽救生命。

再次感谢您的所有建议。当简单的日志记录仍然存在时，我们将在系统的某些部分考虑它们。
但是这个问题的另一点是在一个更大、更复杂的背景下向你说明一个特定的问题。
希望你喜欢它。下周晚些时候，我可能会问一个关于 KPI 的问题（信不信由你，到目前为止，这在 SOF 上没有任何问题！）。

我将把这个答案留到下周二投票，然后我会选择一个答案（显然不是这个；））

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2008-09-28T01:07:10.427

也许这太简单了，但是围绕保护子句使用“提取方法”重构呢？您的示例代码：

```
public void Example()
{
  if(myLogger.isLoggable(Level.INFO))
      myLogger.info("A String");
  if(myLogger.isLoggable(Level.FINE))
      myLogger.fine("A more complicated String");
  // +1 for each test and log message
} 
```

变成这样：

```
public void Example()
{
   _LogInfo();
   _LogFine();
   // +0 for each test and log message
}

private void _LogInfo()
{
   if(!myLogger.isLoggable(Level.INFO))
      return;

   // Do your complex argument calculations/evaluations only when needed.
}

private void _LogFine(){ /* Ditto ... */ } 
```

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-09-19T21:42:18.157

在 C 或 C++ 中，我会使用预处理器而不是 if 语句来进行条件日志记录。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-09-19T21:45:56.650

将日志级别传递给记录器，让它决定是否写日志语句：

```
//if(myLogger.isLoggable(Level.INFO) {myLogger.info("A String");
myLogger.info(Level.INFO,"A String"); 
```

更新：啊，我看到你想有条件地创建没有条件语句的日志字符串。大概是在运行时而不是编译时。

我只想说我们解决这个问题的方法是将格式化代码放在记录器类中，这样只有在关卡通过时才会进行格式化。非常类似于内置的 sprintf。例如：

```
myLogger.info(Level.INFO,"A String %d",some_number); 
```

那应该符合你的标准。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2010-07-20T17:22:33.927

[![替代文字](https://i.stack.imgur.com/BpHoC.png)](https://i.stack.imgur.com/BpHoC.png)
[（来源：[scala-lang.org](http://www.scala-lang.org/sites/default/files/newsflash_logo.png)）]

[Scala](https://www.scala-lang.org/)有一个注解[@elidable()](https://daily-scala.blogspot.com/2010/04/elidable-remove-method-calls-at-compile.html)，它允许你删除带有编译器标志的方法。

使用 scala REPL：

> C:>斯卡拉
> 
> 欢迎使用 Scala 版本 2.8.0.final（Java HotSpot(TM) 64 位服务器 VM，Java 1\. 6.0_16）。输入表达式以对其进行评估。键入 :help 以获取更多信息。
> 
> scala> 导入 scala.annotation.elidable 导入 scala.annotation.elidable
> 
> scala> 导入 scala.annotation.elidable._ 导入 scala.annotation.elidable._
> 
> scala> @elidable(FINE) def logDebug(arg :String) = println(arg)
> 
> 日志调试：（arg：字符串）单位
> 
> scala> logDebug（“测试”）
> 
> 斯卡拉>

与 elide-beloset

> C:>scala -Xelide-below 0
> 
> 欢迎使用 Scala 版本 2.8.0.final（Java HotSpot(TM) 64 位服务器 VM，Java 1\. 6.0_16）。输入表达式以对其进行评估。键入 :help 以获取更多信息。
> 
> scala> 导入 scala.annotation.elidable 导入 scala.annotation.elidable
> 
> scala> 导入 scala.annotation.elidable._ 导入 scala.annotation.elidable._
> 
> scala> @elidable(FINE) def logDebug(arg :String) = println(arg)
> 
> 日志调试：（arg：字符串）单位
> 
> scala> logDebug（“测试”）
> 
> 测试
> 
> 斯卡拉>

另见[Scala 断言定义](https://stackoverflow.com/questions/2425091/slow-scala-assert/2437515#2437515)

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2011-07-02T22:15:39.393

条件日志是邪恶的。它给你的代码增加了不必要的混乱。

您应该始终将您拥有的对象发送到记录器：

```
Logger logger = ...
logger.log(Level.DEBUG,"The foo is {0} and the bar is {1}",new Object[]{foo, bar}); 
```

然后有一个 java.util.logging.Formatter 使用 MessageFormat 将 foo 和 bar 展平为要输出的字符串。仅当记录器和处理程序将在该级别记录时才会调用它。

为了增加乐趣，您可以使用某种表达语言来更好地控制如何格式化记录的对象（toString 可能并不总是有用）。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-09-19T21:47:03.777

尽管我讨厌 C/C++ 中的宏，但在工作中，我们为 if 部分设置了#defines，如果为假，则忽略（不评估）以下表达式，但如果为真，则返回一个流，可以使用 ' 将内容传送到该流中<<' 运算符。像这样：

```
LOGGER(LEVEL_INFO) << "A String"; 
```

我认为这将消除您的工具看到的额外“复杂性”，并且还消除了对字符串的任何计算，或者在未达到级别时要记录的任何表达式。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2009-09-16T05:38:59.683

这是一个使用三元表达式的优雅解决方案

logger.info(logger.isInfoEnabled() ? "日志语句在这里..." : null);

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2011-11-22T13:48:50.837

考虑一个日志记录工具函数......

```
void debugUtil(String s, Object… args) {
   if (LOG.isDebugEnabled())
       LOG.debug(s, args);
   }
); 
```

然后在您想要避免的昂贵评估周围使用“关闭”进行调用。

```
debugUtil(“We got a %s”, new Object() {
       @Override String toString() { 
       // only evaluated if the debug statement is executed
           return expensiveCallToGetSomeValue().toString;
       }
    }
); 
```

# asp.net-mvc - 通过 IIS 运行 MVC 应用程序导致“目录列表被拒绝”

> ID：105884
> 
> 赞同：2
> 
> 时间：2008-09-19T21:43:26.907
> 
> 标签：asp.net-mvc, visual-studio, iis, webproject

如果我使用 Visual Studio Webserver 中的构建，我有一个运行良好的 .Net MVC 应用程序。如果我使用项目属性页切换到 IIS 作为网络服务器并为我的项目创建一个虚拟目录，我发送到服务器的任何请求都会导致“目录列表被拒绝”失败。

有谁知道这个的解决方案？

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2008-09-19T21:46:44.870

可能是 IIS 没有将 default.aspx 设置为起始页。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T22:31:19.240

这是 IIS7 之前的“无扩展”网址的问题。

它需要一个 ISAPI 过滤器或路由表中带有 .mvc 扩展名的重复路由。试试 ScottGu 在 weblogs.asp.net 上的博客。

# types - 在特定于域的语言的自定义编辑器中实现类似 IntelliSense 的行为

> ID：105901
> 
> 赞同：7
> 
> 时间：2008-09-19T21:45:32.780
> 
> 标签：types, intellisense, dsl

我正在使用类似模板的编辑器创建 DSL，就像[Alice](http://www.allice.org)中的规则系统一样。用户将能够从列表中选择关系以及应用关系的对象。这两个列表应该根据可接受的类型进行过滤——例如，如果关系“大于”，那么可用对象必须是实现“大于”的类型。

类似地，如果选择的对象与大于*不可*比较，则该关系不应出现在潜在关系列表中。我认为这个问题的核心是类型检查器，但我不确定将这种类型的逻辑合并到我的应用程序中的最佳方式。有人知道现有的 DSL 类型检查库吗？

我对开源和跨平台技术特别感兴趣。Java 可能是我们最终会使用的语言，但这不是固定的。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T21:52:35.120

您可能会研究[Scintilla](http://www.scintilla.org/)。它是 Notepad++ 使用的编辑组件，以及其他工具。它对自动完成有一些支持，虽然我自己没有尝试过使用它，所以我不确定它的效果如何。它是开源的，所以如果它不能满足你的需求，我认为你可以毫不费力地扩展它。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T21:53:16.757

这可能在智能感知方面有所帮助 - [CodeTextBox](http://www.codeproject.com/KB/edit/codetextbox.aspx)

# c# - 如何在 Windows 窗体应用程序设置中记录窗口位置

> ID：105932
> 
> 赞同：24
> 
> 时间：2008-09-19T21:49:40.820
> 
> 标签：c#, .net, winforms, settings

这似乎是一个标准要求：下次用户启动应用程序时，以与之前相同的位置和状态打开窗口。这是我的愿望清单：

*   窗口位置和原来一样
    *   除非屏幕已调整大小并且旧位置现在不在屏幕上。
*   分离器应保留其位置
*   标签容器应保留其选择
*   一些下拉菜单应该保留他们的选择
*   窗口状态（最大化、最小化、正常）与以前相同。
    *   也许你永远不应该开始最小化，我还没有决定。

我将添加我当前的解决方案作为答案以及限制。

* * *

## 回答 #1

> 赞同：18
> 
> 时间：2008-09-19T22:01:33.867

我的另一个选择是围绕应用程序设置编写更多自定义代码并在 formLoad 和 formClosed 上执行它。这不使用数据绑定。

缺点：

*   更多的代码要写。
*   非常繁琐。您在 formLoad 上设置属性的顺序令人困惑。例如，您必须确保在设置分割器距离之前设置了窗口大小。

现在，这是我首选的解决方案，但似乎工作量太大。为了减少工作量，我创建了一个 WindowSettings 类，它将窗口位置、大小、状态和任何拆分器位置序列化为单个应用程序设置。然后我可以为我的应用程序中的每个表单创建一个该类型的设置，在关闭时保存并在加载时恢复。

我发布[了源代码](https://github.com/donkirkby/donkirkby/blob/master/WindowSettings/WindowSettings.cs)，包括 WindowSettings 类和一些使用它的表单。WindowSettings.cs 文件中包含有关将其添加到项目的说明。最棘手的部分是弄清楚如何添加具有自定义类型的应用程序设置。您从类型下拉列表中选择 Browse...，然后手动输入命名空间和类名。您项目中的类型不会显示在列表中。

**更新：**我添加了一些静态方法来简化您添加到每个表单的样板代码。按照说明将 WindowSettings 类添加到项目并创建应用程序设置后，下面是必须添加到要记录和恢复其位置的每个表单的代码示例。

```
 private void MyForm_FormClosing(object sender, FormClosingEventArgs e)
    {
        Settings.Default.CustomWindowSettings = WindowSettings.Record(
            Settings.Default.CustomWindowSettings,
            this, 
            splitContainer1);
    }

    private void MyForm_Load(object sender, EventArgs e)
    {
        WindowSettings.Restore(
            Settings.Default.CustomWindowSettings, 
            this, 
            splitContainer1);
    } 
```

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-09-20T13:58:36.483

下面的示例显示了我是如何做到的

*   关闭表单时调用 SavePreferences 并保存表单的大小，以及一个指示它是否已最大化的标志（在此版本中，如果已最小化，我不会保存它 - 下次它会恢复或最大化）。

*   LoadPreferences 是从 OnLoad 中调用的。

*   首先保存设计时的 WindowState 并将其设置为 Normal。只有当 WindowState 为 Normal 时，您才能成功设置表单大小。

*   接下来从您的持久设置中恢复大小。

*   现在确保表单适合您的屏幕（调用 FitToScreen）。自您上次运行该应用程序以来，屏幕分辨率可能已更改。

*   最后将 WindowState 设置回 Maximized（如果这样持久化），或者设置为之前保存的设计时值。

这显然可以适应保持起始位置以及关闭时表单是否最小化 - 我不需要这样做。表单上控件的其他设置（例如拆分器位置和选项卡容器）很简单。

```
private void FitToScreen()
{
    if (this.Width > Screen.PrimaryScreen.WorkingArea.Width)
    {
        this.Width = Screen.PrimaryScreen.WorkingArea.Width;
    }
    if (this.Height > Screen.PrimaryScreen.WorkingArea.Height)
    {
        this.Height = Screen.PrimaryScreen.WorkingArea.Height;
    }
}   
private void LoadPreferences()
{
    // Called from Form.OnLoad

    // Remember the initial window state and set it to Normal before sizing the form
    FormWindowState initialWindowState = this.WindowState;
    this.WindowState = FormWindowState.Normal;
    this.Size = UserPreferencesManager.LoadSetting("_Size", this.Size);
    _currentFormSize = Size;
    // Fit to the current screen size in case the screen resolution
    // has changed since the size was last persisted.
    FitToScreen();
    bool isMaximized = UserPreferencesManager.LoadSetting("_Max", initialWindowState == FormWindowState.Maximized);
    WindowState = isMaximized ? FormWindowState.Maximized : FormWindowState.Normal;
}
private void SavePreferences()
{
    // Called from Form.OnClosed
    UserPreferencesManager.SaveSetting("_Size", _currentFormSize);
    UserPreferencesManager.SaveSetting("_Max", this.WindowState == FormWindowState.Maximized);
    ... save other settings
} 
```

X

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-09-19T21:54:27.067

我发现的最简单的解决方案是将数据绑定与应用程序设置一起使用。我将窗口上的 location 和 clientSize 属性与拆分器上的 splitterDistance 绑定在一起。

缺点：

*   如果您在最小化时关闭窗口，它会在下次隐藏时打开。把窗户拿回来真的很难。
*   如果您在最大化时关闭窗口，它会打开填充整个屏幕，但不会最大化（小问题）。
*   使用右上角或左下角调整窗口大小只是丑陋的。我猜这两个数据绑定属性正在相互争斗。

如果您想尝试这种奇怪的行为，我发布了一个使用这种技术的[示例解决方案。](http://dl.getdropbox.com/u/194081/WindowSettings.zip)

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2008-09-20T00:44:18.467

我为要保存的每个值进行设置，并使用如下代码：

```
private void MainForm_Load(object sender, EventArgs e) {
  RestoreState();
}

private void MainForm_FormClosing(object sender, FormClosingEventArgs e) {
  SaveState();
}

private void SaveState() {
  if (WindowState == FormWindowState.Normal) {
    Properties.Settings.Default.MainFormLocation = Location;
    Properties.Settings.Default.MainFormSize = Size;
  } else {
    Properties.Settings.Default.MainFormLocation = RestoreBounds.Location;
    Properties.Settings.Default.MainFormSize = RestoreBounds.Size;
  }
  Properties.Settings.Default.MainFormState = WindowState;
  Properties.Settings.Default.SplitterDistance = splitContainer1.SplitterDistance;
  Properties.Settings.Default.Save();
}

private void RestoreState() {
  if (Properties.Settings.Default.MainFormSize == new Size(0, 0)) {
    return; // state has never been saved
  }
  StartPosition = FormStartPosition.Manual;
  Location = Properties.Settings.Default.MainFormLocation;
  Size = Properties.Settings.Default.MainFormSize;
  // I don't like an app to be restored minimized, even if I closed it that way
  WindowState = Properties.Settings.Default.MainFormState == 
    FormWindowState.Minimized ? FormWindowState.Normal : Properties.Settings.Default.MainFormState;
  splitContainer1.SplitterDistance = Properties.Settings.Default.SplitterDistance;
} 
```

请记住，重新编译会擦除存储设置的配置文件，因此在保存和恢复之间不要更改代码进行测试。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2011-04-07T07:37:08.340

根据 Don Kirkby 接受的答案和他编写的 WindowSettings 类，您可以从标准中派生一个 CustomForm 以减少为每个表单编写的相同代码的数量，可能是这样的：

```
using System;
using System.Configuration;
using System.Reflection;
using System.Windows.Forms;

namespace CustomForm
{
  public class MyCustomForm : Form
  {
    private ApplicationSettingsBase _appSettings = null;
    private string _settingName = "";

    public Form() : base() { }

    public Form(ApplicationSettingsBase settings, string settingName)
      : base()
    {
      _appSettings = settings;
      _settingName = settingName;

      this.Load += new EventHandler(Form_Load);
      this.FormClosing += new FormClosingEventHandler(Form_FormClosing);
    }

    private void Form_Load(object sender, EventArgs e)
    {
      if (_appSettings == null) return;

      PropertyInfo settingProperty = _appSettings.GetType().GetProperty(_settingName);
      if (settingProperty == null) return;

      WindowSettings previousSettings = settingProperty.GetValue(_appSettings, null) as WindowSettings;
      if (previousSettings == null) return;

      previousSettings.Restore(this);
    }

    private void Form_FormClosing(object sender, FormClosingEventArgs e)
    {
      if (_appSettings == null) return;

      PropertyInfo settingProperty = _appSettings.GetType().GetProperty(_settingName);
      if (settingProperty == null) return;

      WindowSettings previousSettings = settingProperty.GetValue(_appSettings, null) as WindowSettings;
      if (previousSettings == null)
        previousSettings = new WindowSettings();

      previousSettings.Record(this);

      settingProperty.SetValue(_appSettings, previousSettings, null);

      _appSettings.Save();
    }
  }
} 
```

要使用它，请在构造函数中传递您的应用程序设置类和设置名称：

```
CustomForm.MyCustomForm f = new CustomForm.MyCustomForm(Properties.Settings.Default, "formSettings"); 
```

这使用反射从/到设置类获取/设置先前的设置。将 Save 调用放入 Form_Closing 例程中可能不是最佳选择，可以在主应用程序退出时删除它并保存设置文件。

要将其用作常规形式，只需使用无参数构造函数即可。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-09-19T21:57:23.563

您可以使用设置来存储该信息的黑客。您所要做的就是将所需的属性（例如 form.Size 和 form.Location）绑定到特定设置，然后它会自动保存和更新。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-09-19T22:02:40.900

您可以使用应用程序设置来设置将保留哪些控件属性，在 Form_close 事件中，您必须使用应用程序设置上的保存方法将这些属性写入磁盘：

```
Properties.Settings.Default.Save(); 
```

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-09-19T22:04:05.280

这是我自己使用的几个示例。它只考虑主监视器，因此如果在多个监视器上使用它可能会更好地处理它。

```
Size size;
int x;
int y;
if (WindowState.Equals(FormWindowState.Normal))
{
    size = Size;
    if (Location.X + size.Width > Screen.PrimaryScreen.Bounds.Width)
        x = Screen.PrimaryScreen.Bounds.Width - size.Width;
    else
        x = Location.X;
    if (Location.Y + Size.Height > Screen.PrimaryScreen.Bounds.Height)
        y = Screen.PrimaryScreen.Bounds.Height - size.Height;
    else
        y = Location.Y;
}
else
{
size = RestoreBounds.Size;
x = (Screen.PrimaryScreen.Bounds.Width - size.Width)/2;
y = (Screen.PrimaryScreen.Bounds.Height - size.Height)/2;
}
Properties.Settings.Position.AsPoint = new Point(x, y); // Property setting is type of Point
Properties.Settings.Size.AsSize = size;                 // Property setting is type of Size
Properties.Settings.SplitterDistance.Value = splitContainer1.SplitterDistance; // Property setting is type of int
Properties.Settings.IsMaximized = WindowState == FormWindowState.Maximized;    // Property setting is type of bool
Properties.Settings.DropDownSelection = DropDown1.SelectedValue;
Properties.Settings.Save(); 
```

# vba - 查看项目是否在列表框控件中的最有效方法

> ID：105935
> 
> 赞同：0
> 
> 时间：2008-09-19T21:50:35.953
> 
> 标签：vba, ms-access, listbox, controls

此请求基于 MS Access VBA。我想知道最有效的方法是什么，看看一个项目是否存在于列表框控件中。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T23:14:06.453

这是一个可以适应的示例函数。

```
Function CheckForItem(strItem, ListB As ListBox) As Boolean
Dim rs As DAO.Recordset
Dim db As Database
Dim tdf As TableDef

    Set db = CurrentDb

    CheckForItem = False

    Select Case ListB.RowSourceType
        Case "Value List"
            CheckForItem = InStr(ListB.RowSource, strItem) > 0

        Case "Table/Query"
            Set rs = db.OpenRecordset(ListB.RowSource)

            For i = 0 To rs.Fields.Count - 1
                strList = strList & " & "","" & " & rs.Fields(i).Name
            Next

            rs.FindFirst "Instr(" & Mid(strList, 10) & ",'" & strItem & "')>0"

            If Not rs.EOF Then CheckForItem = True

        Case "Field List"

            Set tdf = db.TableDefs(ListB.RowSource)

            For Each itm In tdf.Fields
                If itm.Name = strItem Then CheckForItem = True
            Next

    End Select

End Function 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-09-19T22:24:48.833

不幸的是，没有比线性搜索更有效的方法了，除非你知道你的列表框是以某种特定的方式排序或索引的。

```
For i = 1 To TheComboBoxControl.ListCount
  if TheComboBoxControl.ItemData(i) = "Item to search for" Then do_something()
Next i 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T22:33:41.480

如果您不介意使用 Windows API，您可以搜索如下字符串：

```
Private Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long   
Private Const LB_FINDSTRINGEXACT = &H1A2

Dim index as Integer
Dim searchString as String
searchString = "Target" & Chr(0)

index = SendMessage(ListBox1.hWnd, LB_FINDSTRINGEXACT , -1, searchString) 
```

哪个应该返回包含目标字符串的行的索引。

# vb.net - 使用 Google 搜索 API 的简单 VB.NET？

> ID：105942
> 
> 赞同：1
> 
> 时间：2008-09-19T21:51:17.527
> 
> 标签：vb.net, visual-studio-2008, search, google-api

谁能指出一个可以在 VB.net (2008) 中实现的 Google API（我想是 AJAX 搜索 API？）的好、简单的示例？我曾尝试注册一个 Google API 密钥，但它需要一个 URL，从该 URL 执行搜索。我没有此示例的 URL。我尝试了[http://localhost](http://localhost)，但后来一位同事告诉她，她收到了“无效密钥”错误。一个简单的工作示例会很棒。谢谢你。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T22:55:53.533

如果您出于开发或测试目的在本地运行 Google API，则可以使用内部 IP 地址 - 它不必是公开给 Internet 的 URL。例如，我的开发机器使用 192.168.0.xxx 范围内的地址运行 Google Maps API。这允许从内部网络上的任何其他机器访问它们。显然，您需要一个固定的 IP。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-05T03:01:59.723

我认为 Google API TOS 不允许进行 .net 开发。我最近在新闻组文章中读到了这一点。

# sql-server - 如何从代码中设置 Sql Server 中的默认数据库？

> ID：105950
> 
> 赞同：13
> 
> 时间：2008-09-19T21:51:52.033
> 
> 标签：sql-server, database, sql-server-2000

我似乎无法弄清楚如何从代码中设置 Sql Server 中的默认数据库。这可以是 .Net 代码或 T-Sql（T-Sql 会很好，因为它很容易在任何语言中使用）。我搜索了谷歌，只能在 Sql Server Management Studio 中找到如何做到这一点。

* * *

## 回答 #1

> 赞同：30
> 
> 时间：2008-09-19T22:03:22.207

`ALTER LOGIN`应该用于 SQL Server 2005 或更高版本：

[http://technet.microsoft.com/en-us/library/ms189828.aspx](http://technet.microsoft.com/en-us/library/ms189828.aspx)

```
ALTER LOGIN <login_name> WITH DEFAULT_DATABASE = <default_database> 
```

`sp_defaultdb`最终将从 SQL Server 中删除：

[http://technet.microsoft.com/en-us/library/ms181738.aspx](http://technet.microsoft.com/en-us/library/ms181738.aspx)

* * *

## 回答 #2

> 赞同：14
> 
> 时间：2008-09-19T21:54:04.150

来自：[http ://doc.ddart.net/mssql/sql70/sp_da-di_6.htm](http://doc.ddart.net/mssql/sql70/sp_da-di_6.htm)

```
sp_defaultdb [@loginame =] 'login' , [@defdb =] 'database' 
```

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-09-19T22:03:40.117

谢谢斯蒂芬。

请注意，如果您使用的是 Windows 身份验证，则`@loginname`它是`YourDomain\YourLogin`（对其他人来说可能很明显，但我试了几次。

```
sp_defaultdb @loginame='YourDomain\YourLogin', @defdb='YourDatabase' 
```

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-09-19T21:56:49.773

如果您在登录后尝试更改您正在使用的数据库，您可以使用 USE 命令。例如使用罗斯文。

[https://www.tutorialspoint.com/sql/sql-select-database.htm](https://www.tutorialspoint.com/sql/sql-select-database.htm)

# xna - 什么是学习 XNA 的好资源？

> ID：105959
> 
> 赞同：4
> 
> 时间：2008-09-19T21:53:29.220
> 
> 标签：xna

我一直在考虑尝试游戏开发和 XNA。我已经是一名专业的 C/C++ 程序员。我阅读了一些 C# 书籍，但还没有在 C# 中进行任何开发。

从已经是专家级程序员的角度来看，什么是学习 XNA 的好资源？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-09-19T22:04:57.633

我将第二次 reimers 和 creators.xna.com 示例作为掌握如何快速完成任务的好方法。

另一方面，我强烈推荐[Nick Gravelyn 的 Tile Engine 教程](http://nick.gravelyn.com/tile-engine-series/)。这是一种不同的方法，因为整个系列都以视频形式呈现。对于初学者来说，这似乎是一个很好的起点，尽管新的编码员可能对他的速度有点麻烦。话虽如此，关于内容管道（它是管道概念的 XNA 特定实现）的部分是一个很好的介绍。

[Ziggyware](http://www.ziggyware.com/news.php)也有很好的教程选择，其中一些更高级。

[Shawn Hargreaves](http://blogs.msdn.com/shawnhar/)是 XNA 的开发人员之一，他有一个很棒的博客，可以让您更多地了解 XNA 的内部结构。如果有您特别感兴趣的主题，请查看存档。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-09-19T21:57:50.147

这很好：[http](http://www.riemers.net/) ://www.riemers.net/ ，请记住导航是通过右侧的栏。我一定很累，因为我花了一段时间才弄清楚:-O

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-09-19T21:55:59.730

查看[XNA 主页](http://creators.xna.com)和那里的教程，在 Community -> Resources 下。作为一个有经验的程序员，你应该能够从那里得到它。

如需更深入的信息，请浏览 XNA 团队的博客，也可从 XNA Creators 页面链接。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2010-09-11T23:41:16.017

我想说一个名为 XNA Debug Terminal 的库应该对您有所帮助。它是开源的，可以在几秒钟内完成设置。它允许您查看任何变量的值、调用任何方法、实时观察值变化等等，只需将 c# 代码输入到游戏窗口顶部的类似终端的显示器中即可。与普通的 Visual Studio 调试器不同，您可以在游戏运行时调用任意代码。[您可以在http://www.protohacks.net/xna_debug_terminal](http://www.protohacks.net/xna_debug_terminal)找到更多相关信息。这将极大地帮助您在学习 XNA 时避免很多挫折。

# bash - 我可以将任意命令块传递给 bash 函数吗？

> ID：105971
> 
> 赞同：7
> 
> 时间：2008-09-19T21:54:35.317
> 
> 标签：bash

我正在研究一个 bash 脚本，如果存在特定文件，我需要有条件地执行一些事情。这种情况多次发生，所以我抽象了以下函数：

```
function conditional-do {
    if [ -f $1 ]
    then
        echo "Doing stuff"
        $2
    else
        echo "File doesn't exist!"
    end
} 
```

现在，当我想执行此操作时，我会执行以下操作：

```
function exec-stuff {
    echo "do some command"
    echo "do another command"
}
conditional-do /path/to/file exec-stuff 
```

问题是，我很烦我定义了两件事：一组要执行的命令的函数，然后调用我的第一个函数。

我想以干净的方式将这组命令（通常是 2 个或更多）直接传递给“conditional-do”，但我不知道这是如何实现的（或者是否可能）......有人有吗有任何想法吗？

请注意，我需要它是一个可读的解决方案......否则我宁愿坚持我所拥有的。

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-09-19T21:59:13.700

这对大多数 C 程序员来说应该是可读的：

```
function file_exists {
  if ( [ -e $1 ] ) then 
    echo "Doing stuff"
  else
    echo "File $1 doesn't exist" 
    false
  fi
}

file_exists filename && (
  echo "Do your stuff..."
) 
```

或单线

```
file_exists filename && echo "Do your stuff..." 
```

现在，如果您真的希望从函数中运行代码，您可以这样做：

```
function file_exists {
  if ( [ -e $1 ] ) then 
    echo "Doing stuff"
    shift
    $*
  else
    echo "File $1 doesn't exist" 
    false
  fi
}

file_exists filename echo "Do your stuff..." 
```

不过我不喜欢那个解决方案，因为你最终会转义命令字符串。

编辑：将“eval $*”更改为 $ *。实际上，不需要 Eval。与 bash 脚本一样，它是在我喝了几杯啤酒时编写的；-)

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T21:56:27.263

一种（可能是破解）解决方案是将单独的函数完全存储为单独的脚本。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-09-21T12:37:53.407

正经的回答：

```
[ -f $filename ] && echo "it has worked!" 
```

或者，如果您真的想要，您可以将其包装起来：

```
function file-exists {
    [ "$1" ] && [ -f $1 ]
}

file-exists $filename && echo "It has worked" 
```

# oop - 在 OOP 中，在什么情况下您对对象采取行动而不是让对象采取行动？

> ID：105988
> 
> 赞同：4
> 
> 时间：2008-09-19T21:57:30.087
> 
> 标签：oop

在什么情况下，或者对于什么样的算法，您是否开始使用您的对象作为具有对象之外的方法的数据结构（即：TreeWalking 等......）。

你用什么方案？（访客？模式匹配？）

还是您认为对象应该始终是唯一允许对其自身数据进行操作的对象？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-09-19T22:18:58.940

对象应该有一个单一的职责。如果您正在执行的操作是作用于一个对象，但与该对象的责任无关。最好把它放在那个对象之外。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-09-19T22:00:37.567

> 还是您认为对象应该始终是唯一允许对其自身数据进行操作的对象？

这是我的哲学（除了只是实体的对象；即：它们映射其他东西，比如 xml 文件或其他东西，并且只包含属性）

# algorithm - 如何从非实验数据中获得科学结果（数据挖掘？）

> ID：105996
> 
> 赞同：4
> 
> 时间：2008-09-19T21:58:41.423
> 
> 标签：algorithm, data-mining

*   我想从具有许多变量的过程中获得最大性能，其中许多变量是无法控制的。
*   我不能运行数千个实验，所以如果我能运行数百个实验和
    *   改变许多可控参数
    *   收集有关表明性能的许多参数的数据
    *   对于那些我无法控制的参数，尽可能“正确”
    *   为那些我可以控制的事情梳理出“最佳”值，然后重新开始

感觉这将被称为数据挖掘，您正在处理大量数据，这些数据似乎并没有立即相关，但经过一些努力后确实显示出相关性。

所以...我从哪里开始研究这类事情的算法、概念和理论？甚至出于搜索目的的相关术语也会很有用。

背景：我喜欢做超级马拉松骑行，并记录每次骑行。我想保留更多数据，并且在数百次骑行之后能够提取有关我的表现的信息。

然而，一切都各不相同——路线、环境（温度、压力、嗡嗡声、太阳负荷、风、降水等）、燃料、姿态、重量、水负荷等等等。我可以控制一些事情，但是在同一条路线上跑 20 次来测试一种新的燃料状态只会令人沮丧，并且需要数年时间才能完成我想做的所有实验。但是，我可以记录所有这些以及更多内容（自行车 FTW 上的遥测）。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-09-19T22:03:01.820

听起来你想做一些[回归分析](http://en.wikipedia.org/wiki/Regression_analysis)。你当然有大量的数据！

* * *

回归分析是统计学和科学中极为常见的建模技术。（可以说统计是回归分析的艺术和科学。）有许多统计软件包可以进行您需要的计算。（我会推荐一个，但我已经过时了。）

数据挖掘的名声不好，因为人们常常认为相关性等于因果关系。我发现一个好的技术是从你知道有影响的变量开始，然后围绕它们建立一个统计模型。所以你知道风、重量和爬升会影响你的旅行速度，统计软件可以获取你的数据集并计算这些因素之间的相关性。这会给你一个统计模型或线性方程：

```
speed = x*weight + y*wind + z*climb + constant 
```

当您探索新变量时，您将能够通过比较拟合优度（如 R 平方）来查看模型是否得到改进。因此，您可以检查温度或一天中的时间是否对模型添加了任何内容。

您可能希望对数据应用转换。例如，您可能会发现自己在寒冷的日子里表现更好。但真正寒冷的日子和真正炎热的日子可能会影响性能。在这种情况下，您可以将温度分配给箱或[段](http://en.wikipedia.org/wiki/Segmented_regression)：< 0°C；0°C 至 40°C；> 40°C，或一些这样的。关键是以一种与现实世界中正在发生的事情的合理模型相匹配的方式转换数据，而不仅仅是数据本身。

* * *

如果有人认为这不是与编程相关的主题，请注意您可以使用这些相同的技术来分析系统性能。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-09-19T22:52:43.620

With that many variables you have too many dimensions and you may want to look at [Principal Component Analysis](http://en.wikipedia.org/wiki/Principal_components_analysis). It takes some of the "art" out of regression analysis and lets the data speak for itself. Some software to do that sort of analysis is shown at the bottom of the link.

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-09-19T22:47:46.703

I have used the Perl module [Statistics::Regression](http://search.cpan.org/~iawelch/Statistics-Regression-0.53/Regression.pm) for somewhat similar problems in the past. Be warned, however, that regression analysis is definitely an art. As the warning in the Perl module says, it won't make sense to you if you haven't learned the appropriate math.

# java - 如何在运行时为使用 Spring MVC 和 Hibernate 的 Web 应用程序获取 jdbc.batch_size 属性的值？

> ID：105998
> 
> 赞同：4
> 
> 时间：2008-09-19T21:59:11.750
> 
> 标签：java, hibernate, spring

根据我目前所发现的，我可以使用以下代码：

```
    LocalSessionFactoryBean sessionFactory = (LocalSessionFactoryBean)super.getApplicationContext().getBean("&sessionFactory");
    System.out.println(sessionFactory.getConfiguration().buildSettings().getJdbcBatchSize());

```

但后来我得到一个休眠异常：

> org.hibernate.HibernateException：找不到用于配置的本地数据源 - 必须在 LocalSessionFactoryBean 上设置数据源属性

有人可以解释一下吗？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-09-20T06:15:37.127

在我检查过的 Hibernate 版本中，getConfiguration 不是 SessionFactory 的公共方法。在一些绝望的情况下，我将 Session 或 SessionFactory 强制转换为它的底层实现，以获取一些不公开的值。在这种情况下，这将是：

```
((SessionFactoryImplementor)sessionFactory).getSettings().getJdbcBatchSize() 
```

当然，这很危险，因为如果他们更改实现，它可能会中断。我通常只为我可以不用的优化而这样做，然后将整个东西包装在一个 try/catch Throwable 块中，以确保它在失败时不会伤害任何东西。一个更好的主意可能是在初始化 Hibernate 时自己设置该值，以便从一开始就知道它是什么。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-09-19T22:34:55.550

尝试以下（我无法测试它，因为我不使用 Spring）：

```
System.out.println(sessionFactory.getConfiguration().getProperty("hibernate.jdbc.batch_size")) 
```******************