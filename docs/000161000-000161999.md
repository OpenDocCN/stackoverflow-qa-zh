# StackOverflow 问答 000161000-000161999

# java - 动态面包屑生成 - 怎么做？

> ID：161003
> 
> 赞同：1
> 
> 时间：2008-10-02T05:29:06.520
> 
> 标签：java, spring, tiles, breadcrumbs

我正处于使用 Spring + Tiles 开发品牌新网站的早期阶段。该站点需要动态生成的面包屑。

我所说的动态是指用户可以从多个起点到达某个站点。如果我有客户、订单和产品的视图，用户可以直接访问产品：

```
Products -> Product xyz 
```

或者用户可以通过客户的订单获得产品：

```
Customers -> John Doe -> Orders -> Order 123 -> Product xyz 
```

在 Java 环境中实现此类面包屑的最佳方法是什么？我之前使用请求属性（Url 对象的向量）来完成此操作，该属性填充了我的 web 应用程序的每个操作/servlet 中的 Urls（如在操作产品列表中）。我对这个解决方案不满意，因为它需要向每个控制器/操作添加代码以生成面包屑轨迹。在查看给定客户给定订单的产品等情况下，确定线索所需的 if-then-else 逻辑非常糟糕。

有没有我可以使用的库？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T05:51:33.813

为什么不直接使用存储轨迹的会话变量？在“根”视图的情况下，每个视图只需将自身附加到变量或重置变量。附加它的代码和显示它的代码总是相同的，并且可以放在通用库中，您只需使用标志调用它以在存储轨迹的情况下附加或重置值。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2011-02-25T17:32:22.820

[google code 上托管](http://code.google.com/p/struts2-arianna-plugin/)了一个更新的 struts ²面包屑插件，它非常可配置，应该可以满足您的需求。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-04T05:27:50.957

Struts2 有一个[面包屑](http://cwiki.apache.org/S2PLUGINS/breadcrumbs-plugin.html)插件。

# sitecore - 从代码启动内容编辑器

> ID：161007
> 
> 赞同：2
> 
> 时间：2008-10-02T05:30:46.140
> 
> 标签：sitecore, content-editor

我有一个应用程序正在 Sitecore 中创建一个新项目，然后打开该项目的内容编辑器，它加载正常，但是每当我尝试打开 html 编辑器时，我都会收到“NullReferenceException”。这仅在我以这种方法启动应用程序时发生。

源代码：

```
[Serializable]
public class PushToCMS : Command
{
    public override void Execute(CommandContext context)
    {
        //Context.ClientPage.Start(this, "Action_PushToCMS");

        Database dbCore = Sitecore.Configuration.Factory.GetDatabase("core");
        Item contentEditor = dbCore.GetItem(new ID("{7EADA46B-11E2-4EC1-8C44-BE75784FF105}"));

        Database dbMaster = Sitecore.Configuration.Factory.GetDatabase("master");
        DatabaseEngines engine = new DatabaseEngines(dbMaster);

        Item parentItem = dbMaster.GetItem("/sitecore/content/Home/Events/Parent/");

        // Load existing related item if it exists
        Event evt = new Event(new Guid(HttpContext.Current.Items["id"].ToString()));
        Item item = dbMaster.SelectSingleItem("/sitecore/content/Home/Events/Parent/Item");

        if (item == null)
            item = CreateNewEvent(engine.DataEngine, parentItem, evt);

        Sitecore.Text.UrlString parameters = new Sitecore.Text.UrlString();
        parameters.Add("id", item.ID.ToString());
        parameters.Add("fo", item.ID.ToString());
        Sitecore.Shell.Framework.Windows.RunApplication(contentEditor, contentEditor.Appearance.Icon, contentEditor.DisplayName, parameters.ToString());
    } 
```

在加载这两种方法时，我能说的唯一区别是 html 编辑器的 url，但是我不知道这是在哪里定义的或者我如何控制它。

通过正常方法启动： `http://xxxx/sitecore/shell/default.aspx?xmlcontrol=RichTextEditor&da=core&id=%7bDD4372AC-5D37-4C9E-BBFA-C4E3E2A27722%7d&ed=F27055570&vs&la=en&fld=%7b60D10DBB-7CD5-4341-A960-C7AB10347A2C%7d&so&di=0&hdl=H27055699&us=%7b83D34C8A-4CC4-4CD9-A209-600D51B26AAE%7d&mo`

通过 RunApplication 启动： `http://xxxx/layouts/xmlcontrol.aspx?xmlcontrol=RichTextEditor&da=core&id=%7bDD4372AC-5D37-4C9E-BBFA-C4E3E2A27722%7d&ed=F27055196&vs&la=en&fld=%7b60D10DBB-7CD5-4341-A960-C7AB10347A2C%7d&so&di=0&hdl=H27055325&us=%7b83D34C8A-4CC4-4CD9-A209-600D51B26AAE%7d&mo`

对此的任何帮助将不胜感激。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2010-02-16T17:16:10.450

菲尔，

如果答案还为时不晚... :) 可能是您在没有读取核心数据库的权限的情况下运行此代码。在这种情况下，当您尝试调用 contentEditor. 你会得到 NullReference。我建议您使用另一种运行应用程序的格式 - 使用另一种方法：

```
Sitecore.Shell.Framework.Windows.RunApplication("Content Editor", parameters.ToString()); 
```

如果这没有帮助，请附上您得到的异常的堆栈跟踪。

希望这可以帮助。

# perl - 如何创建一个显示 Sawtooth 调查汇总数据的网页？

> ID：161018
> 
> 赞同：2
> 
> 时间：2008-10-02T05:39:03.127
> 
> 标签：perl, survey

我猜这不适用于 99.99% 的人看到这个。我在工作中一直在做一些 Sawtooth 调查编程，我一直需要创建一个网页来显示来自已完成调查的一些汇总数据。我只是想知道是否有人使用 Sawtooth 生成的平面文件完成了这项工作，以及你是如何做到的。我只知道非常基本的 Perl，而且我使用的服务器没有 PHP，所以我有点不知所措。你所拥有的任何东西都会有所帮助。

编辑：提供示例文件的问题在于它更复杂。它不是单个文件，有时会移动到具有不同格式的不同文件中。那里增加的复杂性是我问这个问题的原因。

* * *

## 回答 #1

> 赞同：0
> 
> 时间：2009-01-20T07:58:25.190

Sawtooth 不导出为 CSV 格式吗？CSV 文件有许多 Perl 解析器。几乎每种语言都有一个或两个（或十二个）CSV 解析器，MS Excel 可以直接打开它们，它们仍然是纯文本的，因此您可以在任何文本编辑器中查看它们。

我知道我们工作中的 Sawtooth 版本（诚然非常旧）将 Sawtooth 数据导出为 SPSS 格式，然后可以将其导出为各种电子表格格式，包括 CSV，如果一切都失败了。

如果您有一个平面（固定宽度字段）文件，您可以在 Perl 中使用正则表达式轻松解析它，或者一次只获取每一行的子字符串，假设您知道字段的宽度。抱歉，您的问题太笼统，无法提供更好的建议。

将纯文本文件中的值与元数据（变量名称和标签、值标签等）匹配会更加复杂，除非您已经拥有某种脚本可读格式的元数据。在网页上提供所有这些内容仍然更加复杂。我已经完成了，要推出自己的项目可能有点冗长。您可以购买一些软件包，例如[SDA](http://sda.berkeley.edu/)，它将帮助您建立一个网站，人们可以在其中浏览和下载您的调查数据并查看您的密码本。

老实说，如果您在网站上发布统计数据，最简单的做法是将数据转换为 SPSS 或 SAS 或其他统计数据包格式，然后直接发布这些文件以供下载。那么你就不必担心了。

# asp.net - 为什么在 asp.net 中使用表单身份验证时会忽略本地样式？

> ID：161022
> 
> 赞同：1
> 
> 时间：2008-10-02T05:42:30.417
> 
> 标签：asp.net, css, webforms

例如，我将一些样式应用于 html

```
<body style="background: #C3DAF9;"> 
```

当我使用表单身份验证时，它会被忽略。如果我将样式放入外部 .css 文件中，那么它可以工作。

这对我来说似乎不是正常行为。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T09:56:40.230

你试过用 Firebug 检查你的 HTML 元素吗？这应该会告诉你什么（如果有的话）覆盖了你的 CSS。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-03T02:03:08.127

解决了这个问题。我不确定我是否理解它发生的原因，但这是有问题的代码；

```
if (User.Identity.IsAuthenticated) {
    if (User.Identity is BookingIdentity) {
        BookingIdentity id = (BookingIdentity) User.Identity;

        Response.Write("<p/>UserName: " + id.Name);
    }
} 
```

删除 Response.Write 会使一切重新工作。Response.Write（我添加它以检查用户是否在表单身份验证的同时登录）似乎正在对页面渲染做些什么？有任何想法吗？

原来 Response.Write 是问题所在，它从那时起基本上中止了页面其余部分的呈现。（或类似的词）

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T06:09:10.043

这很奇怪。我遇到过这个问题，但反过来：当我使用外部样式表时，外部样式表是被忽略的，只有我的内联 CSS 有效。

该问题的解决方案是为外部 CSS 文件所在的文件夹添加权限。

一个建议：查看渲染页面的源代码，并在那里检查 body 标签。样式可能在某处被外部 CSS 文件的值覆盖。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T10:03:03.130

了解如何使用 Firebug 并使用它来确定将哪些样式应用于您的页面。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T10:05:13.423

背景样式不采用“颜色”值。

您正在寻找背景颜色。

* * *

## 回答 #6

> 赞同：-2
> 
> 时间：2008-10-02T09:28:06.197

是的，您应该检查输出 html 和您的浏览器。

如果您的 html 输出中没有样式标签，您可以使用并尝试：

```
<body bgcolor="#C3DAF9"> 
```

# requirements - 关于将涉及多个参与者的流程拆分为用例的建议

> ID：161027
> 
> 赞同：1
> 
> 时间：2008-10-02T05:45:31.707
> 
> 标签：requirements, use-case

假设我正在模拟一个涉及两个演员之间对话或交流的过程。对于这个例子，我将使用一些容易理解的东西：-

1.  供应商创建价目表，
2.  买方选择一些要购买的物品并发送采购订单，
3.  供应商收到采购订单并发送货物。
4.  供应商发送发票
5.  买方收到发票并付款

当然，这些步骤中的每一个本身都可能很快变得复杂。您将如何在需求文档中将其拆分为用例？

如果这个过程被视为一个单一的用例，它可以写满一本书。

或者，从上述每个步骤中创建一个用例将隐藏一些应该捕获的基本交互和流程。是否有一个用例从“收到采购订单”开始，到“发送发票”结束，然后另一个用例从“接收发票”开始，到“付款”结束？

有什么建议吗？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T06:09:28.387

是的，这里有很多可能性。在您上面的示例中，买方进行多次部分付款以支付账单可能会更加复杂。

您可能需要创建完整的工作流用例。将上述每个步骤拆分为自己的用例可能没有用，因为某些步骤将具有前置和后置条件。

我在 QuickBooks 源代码上工作，交易可以通过系统流动的方式数量令人生畏。我们的 QA 人员几乎不可能测试每个组合。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T06:34:25.550

我通常处理此类任务的方式是刚开始为流程创建 UML 用例和高级活动图。不要在意细节，只要尽力而为。

当您有草稿时，您几乎会立即从中看到如何改进它。然后你可以继续重构它——让用例更小，构建大型活动等等。或者，如果它们太小，您可以将几个用例放在一起。

在不知道您项目的细节的情况下，我会继续将每个步骤作为一个单独的用例——它们似乎都是独立的，可以在没有任何交叉引用的情况下进行描述。如果这样做时您会发现任何依赖项，您总是可以重新考虑该方法。

还可以考虑对常见元素（如日志记录、安全性等）使用“扩展”和“包含”块。

# .net - 在 .NET 中有没有办法启用 Assembly.Load 跟踪？

> ID：161030
> 
> 赞同：3
> 
> 时间：2008-10-02T05:50:14.813
> 
> 标签：.net, assemblies

在 .NET 中有没有办法启用 Assembly.Load 跟踪？我知道在调试器下运行时，它会给您一个很好的消息，例如“已加载'程序集 X'”，但我想在调试器之外获取我正在运行的应用程序的程序集负载的日志，最好与我的调试/跟踪日志消息混合。

我正在跟踪我的应用程序中的各种事情，我基本上想知道是什么动作触发了特定的程序集被加载。

* * *

## 回答 #1

> 赞同：13
> 
> 时间：2008-10-02T05:52:48.303

获取应用程序的 AppDomain 并附加到 AssemblyLoad 事件。

示例（C#）：

```
AppDomain.CurrentDomain.AssemblyLoad += new AssemblyLoadEventHandler(OnAssemblyLoad); 
```

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-02T05:52:55.930

Fusion Log Viewer 是您的朋友。

[编辑] 实际上这可能太过分了，AssemblyResolve 事件也很好[编辑]

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2009-10-16T15:30:27.027

MS Visual Studio 内置了这个功能。

从 MS Visual Studio 输出窗口的上下文菜单中选择“模块加载消息”，它将显示如下内容：

```
Loaded 'C:\Windows\assembly\GAC_64\mscorlib\2.0.0.0__b77a5c561934e089\mscorlib.dll'
Loaded 'C:\projects\trunk\bin\Tester.exe', Symbols loaded.
Loaded 'C:\projects\trunk\bin\log4net.dll' 
```

# php - 合规的电子邮件标头需要什么

> ID：161048
> 
> 赞同：10
> 
> 时间：2008-10-02T06:00:00.547
> 
> 标签：php, email, header

我正在尝试从我正在构建的站点发送电子邮件，但它最终出现在雅虎垃圾邮件文件夹中。它是发送凭据的电子邮件。我能做些什么来使其合法化？

```
$header = "From: site <sales@site.com>\r\n";
$header .= "To: $name <$email>\r\n";
$header .= "Subject: $subject\r\n";
$header .= "Reply-To: site <sales@site.com>" . "\r\n";
$header .= "MIME-VERSION: 1.0\r\n";
$header .= 'Content-type: text/html; charset=iso-8859-1' . "\r\n";
$phpversion = phpversion();
$header .= "X-Mailer: PHP v$phpversion\r\n";
mail($email,$subject,$body,$header); 
```

* * *

## 回答 #1

> 赞同：10
> 
> 时间：2008-10-02T06:05:42.920

*   不要在您的电子邮件中使用 HTML。
*   通过具有静态 IP 和反向 DNS (PTR) 的合法邮件服务器发送它，该服务器指向机器的真实主机名（并匹配正向查找）。
*   包括一个 Message-ID（或确保本地邮寄者为您添加一个）。
*   [通过SpamAssassin](http://spamassassin.apache.org/)运行您的电子邮件，并查看它匹配哪些不良评分规则。避免匹配它们。
*   使用[DomainKeys Identified Mail](http://en.wikipedia.org/wiki/DKIM)对您的邮件进行数字签名。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-02T06:19:31.203

我刚刚从我的 Yahoo! 成功尝试了以下操作！虚拟主机帐户：

```
$email = "我@site.com";
$subject = "简单测试";
$body = "简单测试";
$header = "来自：站点 \r\n";
$header .= "收件人：$name \r\n";
$header .= "主题：$subject\r\n";
$header .= "回复：网站" . "\r\n";
$header .= "MIME-VERSION: 1.0\r\n";
$header .= '内容类型：文本/html; 字符集=iso-8859-1' 。"\r\n";
$phpversion = phpversion();
$header .= "X-Mailer: PHP v$phpversion\r\n";
邮件($email,$subject,$body,$header);

```

但是，您的标题中有一些重复，您只需要执行以下操作：

```
$email = "我@site.com";
$subject = "简单测试";
$body = "简单测试";
$header = "来自：站点 \r\n";
$header .= "MIME-VERSION: 1.0\r\n";
$header .= '内容类型：文本/html; 字符集=iso-8859-1' 。"\r\n";
$phpversion = phpversion();
$header .= "X-Mailer: PHP v$phpversion\r\n";
邮件($email,$subject,$body,$header);

```

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-02T10:47:38.983

除了 Ted Percival 的建议之外，您可以尝试使用[PHPMailer](http://phpmailer.codeworxtech.com/index.php?pg=phpmailer)为您创建电子邮件，而不是手动构建标题。我已经广泛使用了这个类，并且没有遇到任何电子邮件被雅虎或其他任何人拒绝为垃圾邮件的问题。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2010-02-03T19:15:16.473

'sendmail'（位于 PHP mail() 函数下面）也有可能需要额外的参数。如果您的返回标头（例如 Return-Path）没有按照您设置的方式设置，您可能需要使用*第五个*mail() 参数。例子：

```
mail('recipient@domain.com', 'Subject', $mail_body, $headers, " -f sender@domain.com"); 
```

有一些进一步的证据表明，真正的普通 sendmail 可能对此有问题！希望您在目标服务器上拥有“后缀”作为 PHP 的底层 mail() 支持。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T06:14:20.297

除了[Ted Percival 的建议](https://stackoverflow.com/questions/161048/what-do-i-need-for-a-compliant-email-header#161052)之外，根据site.com的[SPF 记录](http://www.openspf.org/)，请确保电子邮件来自的 IP 地址是电子邮件的合法来源。如果 site.com 没有 SPF 记录，则添加一个（当然，它允许有问题的 IP 地址）可能有助于让电子邮件通过垃圾邮件过滤器。

如果确实需要在您的电子邮件中使用 HTML，请确保您还包含纯文本版本；您将使用“multipart/alternative”而不是“text/html”的内容类型。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T06:48:45.830

Ted 的建议和 Tim 的建议都很好，但我能够可靠地将电子邮件发送到 Yahoo/Hotmail/etc 的唯一方法是使用 PEAR 电子邮件类。试试那些 & （假设你的服务器没问题）我几乎可以保证它会工作。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-03T00:10:56.307

泰德和蒂姆有很好的建议。就像寒衣一样。我们使用 PHPMailer，垃圾邮件过滤器没有任何问题。

需要注意的一件事是，如果您使用 MIME 格式，许多垃圾邮件过滤器会认为没有针对您的文本版本。您可以自己添加所有标题和文本版本，或者让 PHPMailer 或 PEAR 邮件库为您处理。拥有文本版本可能有帮助，也可能没有帮助，但这是一种很好的做法并且对用户友好。

我意识到您的代码示例就是这样 - 一个示例，但值得一提的是：永远不要将用户提供的数据放入您的邮件标题中。确保您验证它是您期望的数据。将一个 php 邮件脚本变成一个开放的中继是微不足道的，没有人想要这样。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-02T07:34:26.047

检查 rfc 822 和 rfc 2045 的电子邮件格式。我发现 python 的 Email 类真的很容易使用。我假设 php 的 PEAR 也是如此（根据早期的邮件）。标题和正文也由“\r\n\r\n”分隔，不确定您的代码是否会自动插入，但您可以尝试将其附加到标题中。

我不认为 DK/SPF 可能是必要的（因为那里有很多没有 DK/SPF 支持的网络服务器）。可能有很多因素可能导致它被阻止（至少 10K 不同的标准和方法.. p0f、灰名单、灰名单、黑名单等）。确保您的电子邮件格式正确（这有很大的不同）。查看为您生成完整标题的库..这样您犯错误的机会最小。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2009-07-02T07:38:19.070

添加 SPF 记录非常简单。你应该试试。

这个是为dreamhost加上googlemail的 你还应该给你的网络服务器IP地址做广告（在我的例子中，在googlemail之前的那一行）最后一行告诉服务器做一个软拒绝（标记为垃圾邮件但不要删除）我正在使用它而不是“-”（删除），因为谷歌文档是这样说的:-)

这是一个TXT记录 v=spf1 ip4:64.111.100.0/24 ip4:66.33.201.0/24 ip4:66.33.216.0/24 ip4:208.97.132.0/24 ip4:208.97.187.0/24 ip4:208.113.200.0/24 ip :208.113.244.0/24 ip4:208.97.132.74 ip4:67.205.36.71 包括:aspmx.googlemail.com mx ~all

希望能帮助到你

# c++ - 哪个更快：堆栈分配或堆分配

> ID：161053
> 
> 赞同：534
> 
> 时间：2008-10-02T06:06:28.067
> 
> 标签：c++, performance, memory, stack, heap-memory

这个问题听起来可能相当初级，但这是我与另一位共事的开发人员进行的辩论。

我小心翼翼地在可能的地方堆栈分配东西，而不是堆分配它们。他正在和我说话，看着我的肩膀并评论说这没有必要，因为它们在性能方面是相同的。

我一直认为堆的增长是恒定的时间，堆分配的性能取决于堆的当前复杂性，用于分配（找到适当大小的孔）和取消分配（折叠孔以减少碎片，如如果我没记错的话，许多标准库实现在删除期间需要时间来执行此操作）。

这让我觉得可能非常依赖编译器。特别是对于这个项目，我将[Metrowerks](http://en.wikipedia.org/wiki/Metrowerks)编译器用于[PPC](http://en.wikipedia.org/wiki/PowerPC)架构。了解这种组合会很有帮助，但总的来说，对于 GCC 和 MSVC++，情况如何？堆分配的性能不如堆栈分配吗？没有区别吗？或者差异如此之小以至于变得毫无意义的微优化。

* * *

## 回答 #1

> 赞同：524
> 
> 时间：2008-10-02T06:09:03.710

堆栈分配要快得多，因为它真正所做的只是移动堆栈指针。使用内存池，您可以从堆分配中获得相当的性能，但这会稍微增加复杂性并带来一些麻烦。

此外，堆栈与堆不仅是性能考虑因素；它还告诉你很多关于对象的预期生命周期的信息。

* * *

## 回答 #2

> 赞同：170
> 
> 时间：2008-10-02T06:16:44.673

堆栈要快得多。它实际上只在大多数架构上使用一条指令，在大多数情况下，例如在 x86 上：

```
sub esp, 0x10 
```

（这会将堆栈指针向下移动 0x10 个字节，从而“分配”这些字节以供变量使用。）

当然，堆栈的大小非常非常有限，因为您会很快发现是否过度使用堆栈分配或尝试进行递归:-)

此外，几乎没有理由优化不需要验证的代码的性能，例如通过分析证明。“过早的优化”通常会导致比其价值更多的问题。

我的经验法则：如果我知道我将*在编译时*需要一些数据，并且它的大小不到几百字节，我会堆栈分配它。否则我堆分配它。

* * *

## 回答 #3

> 赞同：122
> 
> 时间：2008-10-02T18:11:57.543

老实说，编写一个程序来比较性能是微不足道的：

```
#include <ctime>
#include <iostream>

namespace {
    class empty { }; // even empty classes take up 1 byte of space, minimum
}

int main()
{
    std::clock_t start = std::clock();
    for (int i = 0; i < 100000; ++i)
        empty e;
    std::clock_t duration = std::clock() - start;
    std::cout << "stack allocation took " << duration << " clock ticks\n";
    start = std::clock();
    for (int i = 0; i < 100000; ++i) {
        empty* e = new empty;
        delete e;
    };
    duration = std::clock() - start;
    std::cout << "heap allocation took " << duration << " clock ticks\n";
} 
```

据说[愚蠢的一致性是小脑袋里的妖精](http://www.google.com/search?hl=en&q=)。显然，优化编译器是许多程序员心目中的妖精。这个讨论曾经在答案的底部，但人们显然懒得读那么远，所以我把它移到这里以避免得到我已经回答过的问题。

**一个优化编译器可能会注意到这段代码什么都不做，并可能把它全部优化掉。做这样的事情是优化器的工作，而与优化器抗争是愚蠢的差事。**

**我建议在关闭优化的情况下编译此代码，因为没有好的方法可以欺骗当前正在使用或将来使用的每个优化器。**

**任何打开优化器然后抱怨与它作斗争的人都应该受到公众的嘲笑。**

如果我关心纳秒精度，我不会使用`std::clock()`. 如果我想将结果作为博士论文发表，我会在这方面做更多的事情，我可能会比较 GCC、Tendra/Ten15、LLVM、Watcom、Borland、Visual C++、Digital Mars、ICC 和其他编译器。实际上，堆分配比堆栈分配花费的时间要长数百倍，而且我认为进一步研究这个问题没有任何用处。

优化器的任务是摆脱我正在测试的代码。我看不出有任何理由告诉优化器运行然后试图欺骗优化器使其不实际优化。但如果我看到这样做的价值，我会做以下一项或多项：

1.  向 中添加数据成员`empty`，并在循环中访问该数据成员；但是如果我只从数据成员中读取，优化器可以进行常量折叠并删除循环；如果我只写数据成员，优化器可能会跳过循环的最后一次迭代。此外，问题不是“堆栈分配和数据访问与堆分配和数据访问”。

2.  声明`e` `volatile`，[但`volatile`经常编译不正确](http://www.cs.utah.edu/~regehr/papers/emsoft08-preprint.pdf)（PDF）。

3.  获取循环内部的地址（并可能将其分配给在另一个文件`e`中声明和定义的变量）。`extern`但即使在这种情况下，编译器可能会注意到——至少在堆栈上——`e`将始终分配在相同的内存地址，然后像上面的 (1) 那样进行常量折叠。我得到了循环的所有迭代，但实际上从未分配过对象。

除了明显之外，这个测试的缺陷在于它同时测量了分配和释放，并且最初的问题没有询问释放。当然，分配在堆栈上的变量会在其作用域结束时自动释放，因此不调用`delete`会（1）扭曲数字（堆栈释放包含在有关堆栈分配的数字中，因此测量堆释放是公平的）和（ 2) 导致非常糟糕的内存泄漏，除非我们保留对新指针的引用并`delete`在我们得到时间测量后调用。

在我的机器上，在 Windows 上使用 g++ 3.4.4，对于少于 100000 个分配的堆栈和堆分配，我得到“0 时钟滴答”，即使这样，堆栈分配和“15 个时钟滴答”也得到“0 时钟滴答” " 用于堆分配。当我测量 10,000,000 个分配时，堆栈分配需要 31 个时钟滴答，而堆分配需要 1562 个时钟滴答。

* * *

是的，优化编译器可能会省略创建空对象。如果我理解正确，它甚至可能会忽略整个第一个循环。当我将迭代次数增加到 10,000,000 次时，堆栈分配需要 31 个时钟滴答，而堆分配需要 1562 个时钟滴答。我认为可以肯定地说，在没有告诉 g++ 优化可执行文件的情况下，g++ 没有省略构造函数。

* * *

自从我写这篇文章以来的几年里，Stack Overflow 的偏好一直是通过优化构建发布性能。总的来说，我认为这是正确的。但是，我仍然认为当您实际上不希望代码优化时要求编译器优化代码是愚蠢的。我觉得这与为代客泊车支付额外费用非常相似，但拒绝交出钥匙。在这种特殊情况下，我不希望优化器运行。

使用稍微修改过的基准测试版本（解决原始程序每次通过循环都没有在堆栈上分配东西的有效点）并在没有优化但链接到发布库的情况下进行编译（解决我们没有的有效点'不想包括因链接到调试库而导致的任何减速）：

```
#include <cstdio>
#include <chrono>

namespace {
    void on_stack()
    {
        int i;
    }

    void on_heap()
    {
        int* i = new int;
        delete i;
    }
}

int main()
{
    auto begin = std::chrono::system_clock::now();
    for (int i = 0; i < 1000000000; ++i)
        on_stack();
    auto end = std::chrono::system_clock::now();

    std::printf("on_stack took %f seconds\n", std::chrono::duration<double>(end - begin).count());

    begin = std::chrono::system_clock::now();
    for (int i = 0; i < 1000000000; ++i)
        on_heap();
    end = std::chrono::system_clock::now();

    std::printf("on_heap took %f seconds\n", std::chrono::duration<double>(end - begin).count());
    return 0;
} 
```

显示：

```
on_stack took 2.070003 seconds
on_heap took 57.980081 seconds 
```

使用命令行编译时在我的系统上`cl foo.cc /Od /MT /EHsc`。

您可能不同意我获得非优化构建的方法。没关系：随意修改基准测试。当我打开优化时，我得到：

```
on_stack took 0.000000 seconds
on_heap took 51.608723 seconds 
```

不是因为堆栈分配实际上是瞬时的，而是因为任何半体面的编译器都可以注意到它`on_stack`没有做任何有用的事情并且可以被优化掉。我的 Linux 笔记本电脑上的 GCC 也注意到它`on_heap`没有做任何有用的事情，并对其进行了优化：

```
on_stack took 0.000003 seconds
on_heap took 0.000002 seconds 
```

* * *

## 回答 #4

> 赞同：31
> 
> 时间：2009-03-02T01:55:50.693

我在 Xbox 360 Xenon 处理器上了解到堆栈与堆分配的一个有趣的事情，这也可能适用于其他多核系统，即在堆上分配会导致进入关键部分以停止所有其他核心，以便分配不会不冲突。因此，在一个紧密的循环中，堆栈分配是用于固定大小数组的方法，因为它可以防止停顿。

如果您正在为多核/多进程编码，这可能是另一个需要考虑的加速，因为您的堆栈分配只能由运行您的作用域函数的核心查看，并且不会影响任何其他核心/CPU。

* * *

## 回答 #5

> 赞同：19
> 
> 时间：2008-10-02T06:08:22.463

您可以为特定大小的对象编写一个非常高效的特殊堆分配器。然而，*一般*的堆分配器并不是特别高效。

我也同意 Torbjörn Gyllebring 关于对象预期寿命的观点。好点子！

* * *

## 回答 #6

> 赞同：10
> 
> 时间：2018-11-03T15:21:56.393

## 特定于 C++ 语言的问题

首先，**C++ 没有规定所谓的“堆栈”或“堆”分配**。如果您谈论的是块作用域中的自动对象，它们甚至没有“分配”。（顺便说一句，C 中的自动存储持续时间绝对不同于“已分配”；后者在 C++ 用语中是“动态”的。）动态分配的内存在*空闲存储*区，不一定在“堆”上，尽管后者通常是（默认）*实现*。

尽管根据[抽象机器](http://www.eel.is/c++draft/intro.abstract)语义规则，自动对象仍会占用内存，但允许符合 C++ 的实现在可以证明这无关紧要时忽略这一事实（当它不改变程序的可观察行为时）。此权限由ISO C++ 中[的 as-if 规则](http://www.eel.is/c++draft/intro.abstract#footnote-4)授予，这也是启用常规优化的一般条款（ISO C 中也有几乎相同的规则）。除了 as-if 规则，ISO C++ 还有[复制省略规则](http://www.eel.is/c++draft/class.copy.elision)允许省略对象的特定创建。因此省略了所涉及的构造函数和析构函数调用。结果，与源代码隐含的幼稚抽象语义相比，这些构造函数和析构函数中的自动对象（如果有的话）也被消除了。

另一方面，免费商店分配绝对是设计上的“分配”。在 ISO C++ 规则下，这样的分配可以通过调用*分配函数*来实现。然而，从 ISO C++14 开始，有[一个新的（non-as-if）规则](http://www.eel.is/c++draft/expr.new#12)允许`::operator new`在特定情况下合并全局分配函数（即）调用。所以动态分配操作的一部分也可以像自动对象的情况一样是无操作的。

分配函数分配内存资源。可以使用分配器基于分配进一步分配对象。对于自动对象，它们是直接呈现的——虽然底层内存可以被访问并用于为其他对象提供内存（通过放置`new`），但这作为自由存储没有多大意义，因为没有办法移动其他地方的资源。

所有其他问题都超出了 C++ 的范围。尽管如此，它们仍然很重要。

## 关于 C++ 的实现

C++ 不公开具体化的激活记录或某种一流的延续（例如著名的[`call/cc`](https://en.wikipedia.org/wiki/Call/cc)），没有办法直接操作激活记录帧——实现需要将自动对象放置到的地方。一旦与底层实现（“本机”不可移植代码，例如内联汇编代码）没有（不可移植的）互操作，则忽略底层的帧分配可能是非常微不足道的。例如，当被调用的函数被内联时，可以有效地将帧合并到其他帧中，因此无法显示什么是“分配”。

但是，一旦尊重互操作性，事情就会变得复杂。C++ 的典型实现将公开在 ISA（指令集架构）上的互操作能力，其中一些*调用约定*作为与本机（ISA 级机器）代码共享的二进制边界。这显然会很昂贵，特别是在维护*堆栈指针*时，堆栈指针通常直接由 ISA 级寄存器保存（可能需要访问特定的机器指令）。堆栈指针指示（当前活动的）函数调用的顶部帧的边界。当进入一个函数调用时，需要一个新的帧并且堆栈指针被添加或减去一个不小于所需帧大小的值（取决于 ISA 的约定）。然后说该帧已**分配**当堆栈指针经过操作后。函数的参数也可以传递到堆栈帧上，具体取决于调用所使用的调用约定。框架可以保存由 C++ 源代码指定的自动对象（可能包括参数）的内存。在这种实现的意义上，这些对象是“分配的”。当控件退出函数调用时，不再需要该帧，通常通过将堆栈指针恢复到调用前的状态来释放它（根据调用约定之前保存的）。这可以被视为“解除分配”。这些操作使激活记录有效地成为一个 LIFO 数据结构，因此它通常被称为“ [（调用）堆栈](https://en.wikipedia.org/wiki/Call_stack)”。

因为大多数 C++ 实现（尤其是针对 ISA 级别的本机代码并使用汇编语言作为其直接输出的那些）都使用类似的策略，所以这种令人困惑的“分配”方案很受欢迎。这样的分配（以及解除分配）确实会花费机器周期，并且当（未优化的）调用频繁发生时可能会很昂贵，即使现代 CPU 微架构可以通过硬件为通用代码模式实现复杂的优化（例如使用实现 /指令中的*堆栈引擎）。*`PUSH``POP`

但无论如何，总的来说，**堆栈帧分配的成本确实比调用一个操作自由存储区的分配函数的成本要低得多（除非它被完全优化掉）**，它本身可以有数百个（如果不是数百万个） :-) 维护堆栈指针和其他状态的操作。分配功能通常基于托管环境提供的 API（例如操作系统提供的运行时）。与为函数调用保存自动对象的目的不同，这种分配是通用的，因此它们不会像堆栈那样具有框架结构。[传统上，它们从称为堆](https://en.wikipedia.org/wiki/Memory_management#HEAP)（或多个堆）的池存储中分配空间。与“栈”不同，这里的“堆”概念并不表示所使用的数据结构；[它源自几十年前的早期语言实现](https://stackoverflow.com/questions/1699057/why-are-two-different-concepts-both-called-heap)。（顺便说一句，调用堆栈通常在程序或线程启动时由环境从堆中分配固定或用户指定的大小。）用例的性质使得从堆中分配和释放要复杂得多（比推送或弹出堆栈帧），并且几乎不可能通过硬件直接优化。

## 对内存访问的影响

通常的堆栈分配总是将新帧放在顶部，因此它具有相当好的局部性。这对缓存很友好。OTOH，在免费存储中随机分配的内存没有这样的属性。从 ISO C++17 开始，有`<memory>`. 这种接口的直接目的是允许连续分配的结果在内存中靠近在一起。这承认了这样一个事实，即这种策略通常有利于当代实现的性能，例如对现代架构中的缓存友好。不过，这是关于*访问*而不是*分配*的性能。

## 并发

对内存的并发访问的预期在堆栈和堆之间可能会产生不同的影响。调用堆栈通常由 C++ 实现中的一个执行线程独占。OTOH，堆通常在进程中的线程之间*共享。*对于这样的堆，分配和释放功能必须保护共享的内部管理数据结构免受数据竞争的影响。因此，由于内部同步操作，堆分配和释放可能会产生额外的开销。

## 空间效率

由于用例和内部数据结构的性质，堆可能会受到内部[内存碎片](https://en.wikipedia.org/wiki/Fragmentation_(computing))的影响，而堆栈则不会。这对内存分配的性能没有直接影响，但是在具有[虚拟内存](https://en.wikipedia.org/wiki/Virtual_memory)的系统中，低空间效率可能会降低内存访问的整体性能。当 HDD 用作物理内存的交换时，这尤其糟糕。它可能会导致相当长的延迟——有时是数十亿个周期。

## 堆栈分配的限制

尽管实际上堆栈分配在性能上通常优于堆分配，但这并不意味着堆栈分配总是可以代替堆分配。

首先，无法使用 ISO C++ 以可移植的方式在运行时指定大小的堆栈上分配空间。G++ 的 VLA（可变长度数组）等实现提供了扩展`alloca`，但有理由避免使用它们。（IIRC，Linux 源代码最近删除了 VLA 的使用。）（另请注意 ISO C99 确实有强制 VLA，但 ISO C11 将支持变为可选。）

其次，没有可靠且可移植的方法来检测堆栈空间耗尽。这通常称为堆栈溢出[（嗯，本网站的词源）]，但更准确地说，可能是*堆栈溢出*。实际上，这通常会导致无效的内存访问，然后程序的状态就会被破坏（......或者更糟糕的是，一个安全漏洞）。事实上，ISO C++ 没有“堆栈”的概念，并且[在资源耗尽时使其行为未定义](https://groups.google.com/a/isocpp.org/d/msg/std-discussion/xphK7zA65nU/y9_KM4fPAgAJ)。请注意应该为自动对象留出多少空间。

如果堆栈空间用完，则堆栈中分配的对象过多，这可能是由于函数的主动调用过多或自动对象使用不当造成的。这种情况可能表明存在错误，例如没有正确退出条件的递归函数调用。

然而，有时需要深度递归调用。在需要支持未绑定活动调用的语言实现中（其中调用深度仅受总内存限制），*不可能*像典型的 C++ 实现那样直接使用（当代）本机调用堆栈作为目标语言激活记录。为了解决这个问题，需要构建激活记录的替代方法。例如，[SML/NJ](https://en.wikipedia.org/wiki/Standard_ML_of_New_Jersey)在堆上显式分配帧并使用[仙人掌堆栈](https://en.wikipedia.org/wiki/Parent_pointer_tree)。这种激活记录帧的复杂分配通常不如调用堆栈帧快。[但是，如果在保证适当尾递归](https://en.wikipedia.org/wiki/Tail_call)的情况下进一步实现这些语言，对象语言中的直接堆栈分配（即语言中的“对象”不存储为引用，而是可以一对一映射到非共享 C++ 对象的原生原始值）更加复杂性能损失一般。在使用 C++ 实现此类语言时，很难估计性能影响。

* * *

## 回答 #7

> 赞同：9
> 
> 时间：2008-10-02T06:12:26.273

我不认为堆栈分配和堆分配通常是可以互换的。我也希望两者的性能足以满足一般用途。

我强烈建议小件物品，以更适合分配范围的为准。对于大型项目，堆可能是必需的。

在具有多个线程的 32 位操作系统上，堆栈通常相当有限（尽管通常至少为几 mb），因为需要分割地址空间，并且迟早一个线程堆栈会运行到另一个线程堆栈。在单线程系统（无论如何，Linux glibc 单线程）上，限制要少得多，因为堆栈可以不断增长。

在 64 位操作系统上，有足够的地址空间使线程堆栈变得非常大。

* * *

## 回答 #8

> 赞同：7
> 
> 时间：2008-10-02T06:18:26.713

通常堆栈分配只包括从堆栈指针寄存器中减去。这比搜索堆要快很多。

有时堆栈分配需要添加一页虚拟内存。添加零内存的新页面不需要从磁盘读取页面，因此通常这仍然比搜索堆快很多（特别是如果堆的一部分也被调出）。在极少数情况下，您可以构建这样的示例，恰好在 RAM 中的部分堆中可用空间，但是为堆栈分配新页面必须等待其他页面被写出到磁盘。在这种罕见的情况下，堆更快。

* * *

## 回答 #9

> 赞同：6
> 
> 时间：2009-10-26T17:36:00.373

除了与堆分配相比具有数量级的性能优势外，堆栈分配更适合长时间运行的服务器应用程序。即使是最好的托管堆最终也会变得如此碎片化，以至于应用程序性能下降。

* * *

## 回答 #10

> 赞同：4
> 
> 时间：2008-10-02T08:34:12.410

可能堆分配与堆栈分配的最大问题是，在一般情况下，堆分配是一个无界操作，因此您不能在时间有问题的情况下使用它。

对于其他时间不是问题的应用程序，它可能并不重要，但如果你堆分配很多，这将影响执行速度。始终尝试将堆栈用于短期且经常分配的内存（例如在循环中），并尽可能长时间 - 在应用程序启动期间进行堆分配。

* * *

## 回答 #11

> 赞同：4
> 
> 时间：2008-10-02T16:57:39.033

堆栈的容量有限，而堆则没有。进程或线程的典型堆栈约为 8K。一旦分配，您就无法更改大小。

堆栈变量遵循范围规则，而堆则不遵循。如果您的指令指针超出了函数，则与该函数关联的所有新变量都会消失。

最重要的是，您无法提前预测整个函数调用链。因此，您仅分配 200 字节可能会引发堆栈溢出。如果您正在编写库而不是应用程序，这一点尤其重要。

* * *

## 回答 #12

> 赞同：4
> 
> 时间：2008-10-03T15:35:41.137

更快的不是 jsut 堆栈分配。您还可以在使用堆栈变量方面获益良多。它们具有更好的参考位置。最后，释放也便宜很多。

* * *

## 回答 #13

> 赞同：3
> 
> 时间：2008-10-02T06:43:14.390

我认为生命周期至关重要，分配的东西是否必须以复杂的方式构建。例如，在事务驱动的建模中，通常需要填写并传入一个包含一堆字段的事务结构来操作函数。以 OSCI SystemC TLM-​​2.0 标准为例。

将这些分配在靠近操作调用的堆栈上往往会导致巨大的开销，因为构造成本很高。好的方法是在堆上分配并通过池或简单的策略（例如“此模块只需要一个事务对象”）重用事务对象。

这比在每个操作调用上分配对象快很多倍。

原因很简单，该对象具有昂贵的结构和相当长的使用寿命。

我会说：两者都试一下，看看哪种方法最适合你的情况，因为它真的取决于你的代码的行为。

* * *

## 回答 #14

> 赞同：3
> 
> 时间：2010-08-17T20:22:42.990

堆栈分配是几条指令，而我所知的最快的 rtos 堆分配器（TLSF）平均使用大约 150 条指令。堆栈分配也不需要锁，因为它们使用线程本地存储，这是另一个巨大的性能优势。因此，堆栈分配可以快 2-3 个数量级，具体取决于您的环境的多线程程度。

一般来说，如果你关心性能，堆分配是你最后的选择。一个可行的中间选项可以是一个固定池分配器，它也只有几条指令，每次分配开销很小，因此非常适合小型固定大小的对象。不利的一面是，它仅适用于固定大小的对象，本质上不是线程安全的，并且存在块碎片问题。

* * *

## 回答 #15

> 赞同：3
> 
> 时间：2011-06-05T15:46:32.107

正如其他人所说，堆栈分配通常要快得多。

但是，如果您的对象复制起来很昂贵，那么在您使用对象时如果不小心的话，在堆栈上分配可能会导致巨大的性能损失。

例如，如果您在堆栈上分配一些东西，然后将其放入容器中，那么最好在堆上分配并将指针存储在容器中（例如，使用 std::shared_ptr<>）。如果您按值传递或返回对象，以及其他类似情况，情况也是如此。

关键是，尽管在许多情况下堆栈分配通常比堆分配更好，但有时如果您在堆栈分配不适合计算模型时特意进行堆栈分配，它可能会导致比它解决的问题更多的问题。

* * *

## 回答 #16

> 赞同：2
> 
> 时间：2009-01-27T20:41:51.987

关于这种优化，有一个普遍的观点。

**您获得的优化与程序计数器实际在该代码中的时间量成正比。**

如果您对程序计数器进行采样，您会发现它在哪里花费时间，这通常是在代码的一小部分中，并且通常在您无法控制的库例程中。

只有当你发现它在你的对象的堆分配上花费了很多时间时，堆栈分配它们才会明显更快。

* * *

## 回答 #17

> 赞同：2
> 
> 时间：2010-08-10T16:27:39.993

堆栈分配几乎总是与堆分配一样快或更快，尽管堆分配器当然可以简单地使用基于堆栈的分配技术。

但是，在处理堆栈与基于堆的分配的整体性能（或稍微更好的术语，本地与外部分配）时，存在更大的问题。通常，堆（外部）分配很慢，因为它要处理许多不同类型的分配和分配模式。减少您正在使用的分配器的范围（使其成为算法/代码的本地）将倾向于提高性能而无需任何重大更改。为您的分配模式添加更好的结构，例如，强制对分配和释放对进行 LIFO 排序，也可以通过以更简单和更有条理的方式使用分配器来提高分配器的性能。或者，您可以使用或编写针对您的特定分配模式调整的分配器；大多数程序经常分配一些离散的大小，因此，基于几个固定（最好是已知）大小的后备缓冲区的堆将执行得非常好。出于这个原因，Windows 使用其低碎片堆。

另一方面，如果线程太多，在 32 位内存范围上基于堆栈的分配也充满危险。堆栈需要一个连续的内存范围，因此您拥有的线程越多，您需要的虚拟地址空间就越多，它们才能在没有堆栈溢出的情况下运行。对于 64 位，这不会是问题（目前），但它肯定会在具有大量线程的长时间运行的程序中造成严重破坏。由于碎片而耗尽虚拟地址空间始终是一个痛苦的处理。

* * *

## 回答 #18

> 赞同：2
> 
> 时间：2013-06-07T08:24:38.797

请注意，在选择堆栈分配与堆分配时，考虑因素通常与速度和性能无关。堆栈就像一个堆栈，这意味着它非常适合推动块并再次弹出它们，后进先出。程序的执行也是栈式的，最后进入的程序首先退出。在大多数编程语言中，过程中所需的所有变量仅在过程执行期间可见，因此它们在进入过程时被压入，并在退出或返回时从堆栈中弹出。

现在举一个不能使用堆栈的例子：

```
Proc P
{
  pointer x;
  Proc S
  {
    pointer y;
    y = allocate_some_data();
    x = y;
  }
} 
```

如果你在过程 S 中分配一些内存并将其放入堆栈然后退出 S，则分配的数据将从堆栈中弹出。但是 P 中的变量 x 也指向了该数据，因此 x 现在指向堆栈指针下方的某个位置（假设堆栈向下增长）具有未知内容。如果堆栈指针只是向上移动而不清除它下面的数据，则内容可能仍然存在，但是如果您开始在堆栈上分配新数据，则指针 x 可能实际上指向该新数据。

* * *

## 回答 #19

> 赞同：2
> 
> 时间：2015-05-05T02:42:03.017

```
class Foo {
public:
    Foo(int a) {

    }
}
int func() {
    int a1, a2;
    std::cin >> a1;
    std::cin >> a2;

    Foo f1(a1);
    __asm push a1;
    __asm lea ecx, [this];
    __asm call Foo::Foo(int);

    Foo* f2 = new Foo(a2);
    __asm push sizeof(Foo);
    __asm call operator new;//there's a lot instruction here(depends on system)
    __asm push a2;
    __asm call Foo::Foo(int);

    delete f2;
} 
```

在 asm 中会是这样。当您在 中时`func`，`f1`and 指针`f2`已在堆栈上分配（自动存储）。顺便说一句， Foo`f1(a1)`对堆栈指针 ( `esp`) 没有指令影响，它已被分配，如果`func`要获取成员`f1`，它的指令是这样的：`lea ecx [ebp+f1], call Foo::SomeFunc()`。堆栈分配的另一件事可能会让某人认为内存类似于`FIFO`，`FIFO`当您进入某个函数时刚刚发生，如果您在函数中并分配类似于 的内容`int i = 0`，则不会发生推送。

* * *

## 回答 #20

> 赞同：1
> 
> 时间：2009-03-02T00:46:06.900

之前已经提到，堆栈分配只是移动堆栈指针，即大多数体系结构上的一条指令。将其与堆分配情况下*通常*发生的情况进行比较。

操作系统以链表的形式维护部分空闲内存，其中有效负载数据由指向空闲部分起始地址的指针和空闲部分的大小组成。为了分配 X 字节的内存，遍历链表并按顺序访问每个音符，检查其大小是否至少为 X。当找到大小为 P >= X 的部分时，将 P 分成两部分尺寸 X 和 PX。更新链表并返回指向第一部分的指针。

如您所见，堆分配取决于您请求的内存量、内存的碎片程度等因素。

* * *

## 回答 #21

> 赞同：1
> 
> 时间：2009-03-02T01:36:43.877

一般来说，堆栈分配比堆分配快，正如上面几乎每个答案所提到的。堆栈推入或弹出是 O(1)，而从堆中分配或释放可能需要遍历先前的分配。但是，您通常不应该在紧凑的、性能密集型的循环中进行分配，因此选择通常会归结为其他因素。

做出这种区分可能会很好：您可以在堆上使用“堆栈分配器”。严格来说，我认为堆栈分配是指实际的分配方法，而不是分配的位置。如果您在实际的程序堆栈上分配了很多东西，那么由于各种原因，这可能会很糟糕。另一方面，尽可能使用堆栈方法在堆上分配是您可以为分配方法做出的最佳选择。

既然你提到了 Metrowerks 和 PPC，我猜你的意思是 Wii。在这种情况下，内存非常宝贵，尽可能使用堆栈分配方法可以保证您不会在碎片上浪费内存。当然，这样做比“正常”的堆分配方法需要更多的注意。评估每种情况的权衡是明智的。

* * *

## 回答 #22

> 赞同：0
> 
> 时间：2009-02-04T17:21:37.590

永远不要做过早的假设，因为其他应用程序代码和使用会影响您的功能。所以看功能是隔离是没有用的。

如果您对应用程序很认真，那么 VTune 它或使用任何类似的分析工具并查看热点。

克坦

* * *

## 回答 #23

> 赞同：-1
> 
> 时间：2013-07-24T07:04:22.440

我想说实际上由 GCC 生成的代码（我也记得 VS）**没有开销来进行堆栈分配**。

说以下功能：

```
 int f(int i)
  {
      if (i > 0)
      {   
          int array[1000];
      }   
  } 
```

以下是代码生成：

```
 __Z1fi:
  Leh_func_begin1:
      pushq   %rbp
  Ltmp0:
      movq    %rsp, %rbp
  Ltmp1:
      subq    $**3880**, %rsp <--- here we have the array allocated, even the if doesn't excited.
  Ltmp2:
      movl    %edi, -4(%rbp)
      movl    -8(%rbp), %eax
      addq    $3880, %rsp
      popq    %rbp
      ret 
  Leh_func_end1: 
```

因此，无论您有多少局部变量（即使在 if 或 switch 内部），只有 3880 会更改为另一个值。除非你没有局部变量，否则这条指令只需要执行。所以分配局部变量没有开销。

# css - CSS 编辑器，在编辑时扩展单行声明

> ID：161056
> 
> 赞同：4
> 
> 时间：2008-10-02T06:07:30.373
> 
> 标签：css, editor

是否有一个 CSS 编辑器可以自动将单行声明扩展为焦点上的多行声明？为了澄清我的想法，请参见下面的示例：

原始CSS：

```
div#main { color: orange; margin: 1em 0; border: 1px solid black; } 
```

但是当关注它时，编辑器会自动将其扩展为：

```
div#main { 
  color: orange; 
  margin: 1em 0; 
  border: 1px solid black; 
} 
```

当它失去焦点时，编辑器再次自动将其压缩为一行声明。

谢谢。

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-02T11:23:53.267

如果您使用的是 Visual Studio，您应该能够对此进行近似：

1.  您可以通过工具 -> 选项菜单更改 CSS 的格式。
2.  如果未选中，请选中“显示所有设置”。
3.  转到文本编辑器 -> CSS -> 格式并选择半扩展选项
4.  好的，你改变了。
5.  然后`ctrl+A`, `ctrl+K`,`ctrl+D`应该重新格式化您的文档
6.  完成编辑后，只需返回选项并选择紧凑的 CSS 格式，然后`ctrl+A`, `ctrl+K`,`ctrl+D`再次重新格式化。

希望这可以帮助。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T06:53:45.787

我一个都没听说过。如果您使用的是 Mac，我绝对可以推荐[CSSEdit](http://macrabbit.com/cssedit/)。它可以很好地自动格式化，除此之外。

编辑：我最初说“尽管评论说这是一个好主意”但是，想想看，那是你真正想要的吗？我可以看到在单击时进行扩展/收缩会很好（在这种情况下，[TextMate](http://macromates.com/) - 再次是 Mac - 尽管 CSS 支持不如 CSSEdit），但是 onFocus？

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T06:19:18.740

对不起。我不知道有任何明确这样做的 IDE。

但是，有很多外部选项：

*   [CSSTidy](http://csstidy.sourceforge.net/)（下载）
*   [干净的 CSS](http://www.cleancss.com/)（浏览器内）
*   [CSS 优化](http://floele.flyspray.org/csstidy//css_optimiser.php)器（浏览器内）
*   [其他...](http://www.google.com/search?q=css+(tidy+OR+beautify))（谷歌搜索）

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T07:23:03.297

da5id，我实际上并不关心实现细节（onclick 或 onhover，虽然当你说它时 onclick 似乎更好；），我只是好奇是否有任何编辑器以任何方式支持这种功能。

PS。我不是在 Mac 上，而是在 Windows 上。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T14:02:01.670

您可以使用您最喜欢的编辑器的脚本语言来做到这一点。

例如在 SciTE 中：

```
function ExpandContractCSS()
  local ext = string.lower(props["FileExt"])
  if ext ~= "css" then return end
  local line = GetCurrentLine()
  local newForm
  if string.find(line, "}") then
    -- On one line
    newForm = string.gsub(line, "; *", ";\r\n  ")
    newForm = string.gsub(newForm, "{ *", "{\r\n  ")
    newForm = string.gsub(newForm, " *}", "}")
  else
    -- To contract
    -- Well, just use Ctrl+Z!
    -- Maybe not, code to come if interest
  end
  if newForm ~= nil then
    ReplaceCurrentLine(newForm)
  end
end 
```

GetCurrentLine 和 ReplaceCurrentLine 只是我收藏的便利函数，如果您有兴趣，我可以给它们（并做收缩部分）。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-02T11:59:30.340

它不完全是您想要的，但请尝试使用 textmate [E 文本编辑器](http://www.e-texteditor.com/)的 windows 端口，用于单击折叠 css 规则、自动格式化和大多数其他 textmate 功能。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-03T06:50:10.450

这是个好问题。我很想在 CSS 编辑器中看到这一点。[TopStyle 会这样做](http://www.newsgator.com/Individuals/TopStyle/Default.aspx)，但它不是自动的；你有你使用热键。

# bash - autoconf 使用 sh，我需要 SHELL=BASH，如何强制 autoconf 使用 bash？

> ID：161064
> 
> 赞同：8
> 
> 时间：2008-10-02T06:10:29.307
> 
> 标签：bash, unix, autoconf, sh

我正在运行 autoconf 并将 SHELL 设置为“/bin/sh”。这会产生巨大的问题。如何强制 SHELL 成为 autoconf 的“/bin/bash”？

我试图让它在 osx 上运行，它在 linux 上运行。Linux 使用 SHELL=/bin/bash。osx 默认为 /bin/sh。

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-10-02T06:43:56.650

我在带有 GCC 的 Solaris 上遇到了类似的问题——我使用了“标准”技术：

```
CONFIG_SHELL=/bin/bash ./configure ... 
```

（或者，实际上，我使用 /bin/ksh，但设置 CONFIG_SHELL 环境变量允许您告诉 autoconf 脚本使用哪个 shell。）

我检查了 git 和 gd 的配置脚本（它们恰好被提取）以检查这不是 GCC 特有的 env var。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2009-07-18T20:28:19.327

什么是“大问题”？autoconf 非常努力地生成适用于很大比例 shell 的配置脚本。如果您有一个 autoconf 正在编写的不可移植的构造示例，请将其报告给 autoconf 邮件列表。另一方面，如果您遇到的问题是由于您自己在 configure.ac 中的 shell 代码不可移植（例如，您正在使用 bashisms），那么解决方案是停止使用不可移植代码或要求用户在配置时显式设置 SHELL 或 CONFIG_SHELL。

听起来您遇到的问题是在用户运行配置的环境中。在 Linux 上，您的用户将 SHELL 设置为 /bin/bash，但在 OS X 上，它设置为 /bin/sh。由 autoconf 生成的配置脚本会对其运行的 shell 进行一些初始测试，如果提供的 shell 缺少某些功能，它会尝试使用不同的 shell 重新执行自身。但是，如果您在 configure.ac 中引入不可移植的 shell 代码，那么您就违反了 autoconf 的主要理念之一——即配置脚本应该是可移植的。如果您真的想在您的 shell 代码中使用 bashism，那么您需要您的用户将 SHELL=/bin/bash 作为参数传递给配置脚本。这不是 autoconf 中的错误，但许多人会认为这是您项目构建中的错误。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2012-03-08T01:41:23.947

Autoconf 应该通过生成可以“在任何地方”运行的脚本来解决可移植性问题。这就是为什么它会生成奇怪的代码，例如：

```
if test X$foo = X ; then ...   # check if foo is empty 
```

而不是：

```
if [ "$x" = "" ] ; then ... 
```

那种笨拙的代码可能曾经允许这些脚本在一些古老的 Ultrix 系统或其他系统上运行。

由于外壳差异而无法运行的配置脚本就像带着 10 升汽油和三个备用轮胎参加一级方程式比赛。

如果您正在使用 Autoconf 开发配置脚本，并且它对 shell 是 Bash 还是 OSX shell 很敏感，那么您做错了什么，或者 Autoconf 的人破坏了某些东西。如果它来自您，请通过使它们可移植来修复您添加到脚本中的任何外壳片段。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T06:14:52.150

SHELL 是在哪里设置的？当您需要 /bin/bash 时，使用 /bin/sh 运行什么？

配置脚本可以在任何地方运行，即使是在野外存在的严重损坏的非 Bash shell 上也是如此。

**编辑**：究竟是什么问题？

**另一个编辑**：也许您希望脚本重新执行自身，就像这样。这可能是错误的：

```
if test "$SHELL" = "/bin/sh" && test -x /bin/bash; then
    exec /bin/bash -c "$0" "$@"
fi 
```

* * *

## 回答 #5

> 赞同：-5
> 
> 时间：2008-10-02T06:14:39.170

`ln -f /bin/bash /bin/sh`

:-P（不，这不是一个严肃的答案。请不要这样做！）

# windows-server-2008 - 我应该升级到 Windows Server 和 Exchange 2008 吗？

> ID：161074
> 
> 赞同：0
> 
> 时间：2008-10-02T06:17:12.957
> 
> 标签：windows-server-2008, windows-server-2003

目前正在运行 Server 2003，但由于域的方向发生变化，我正在考虑在不久的将来重新安装。我应该借此机会安装 Windows Server 2008 吗？我很想使用新技术，服务器仅适用于小型家庭企业，因此停机/性能问题并不是真正的问题。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T06:38:05.307

我不是 Windows 服务器修订方面的专家，但我能想到的 Server 2008 的唯一新功能是 Hyper-V。但我会为 Hyper-V 尝试 Server 2008，因为这个 VM 管理程序据说比 VMware 和 Virtual PC 快得多，并且与 Virtual PC 虚拟磁盘兼容。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T06:49:01.257

多年来对我很有帮助的一条规则是：不要仅仅为了升级而升级基础设施组件。如果它运作良好，请留下它。您提到一些停机时间不是什么大问题，但如果服务器实际使用，那么它有可能会意外地成为大问题。为什么不简单地获得（或建造）一台新机器并在那里使用新的操作系统？这样你就可以两全其美了。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T11:15:14.270

没有 Exchange Server 2008。Exchange 一直与 IIS 紧密集成，后者倾向于将其绑定到特定版本的 Windows。但是，Exchange Server 2007 SP1 可以安装在 Windows Server 2008 上。

但是，Exchange Server 2003 无法在 Windows Server 2008 上运行，我认为未来的服务包中不会有这样做的计划。

请注意，Exchange Server 2007*需要*在生产系统上运行 64 位操作系统的 x64 体系结构。引导的日子`/3GB`已经过去——它根本无法为当前的大型数据库提供足够的虚拟地址空间。Exchange 长期运行的虚拟内存碎片问题并没有得到修复，它只是被赋予了更多的虚拟地址空间来工作。

# vb.net - 解析此文件的最佳方法是什么？

> ID：161084
> 
> 赞同：2
> 
> 时间：2008-10-02T06:23:37.900
> 
> 标签：vb.net, parsing, fileparse

我只是想知道是否有人知道我可以解析帖子底部文件的好方法。

我有一个数据库设置，每个部分都有正确的表，例如参考表、调用者表、位置表。每个表都有相同的列，显示在下面的文件中

我真的很想要一些具有相当遗传性的东西，所以如果文件布局发生变化，它不会让我很困惑。目前，我只是一次读取一行文件，并使用 case 语句来检查我所在的部分。

有人能帮我解决这个问题吗？

PS。我正在使用 VB，但 C# 或其他任何东西都可以，文档中的 x 只是我已空白的个人信息

谢谢，内森

文件：--->

```
DIAL BEFORE YOU DIG
Call 1100, Fax 1300 652 077
PO Box 7710 MELBOURNE, VIC 8004

Utilities are requested to respond within 2 working days and reference the Sequence number.

[REFFERAL DETAILS]
FROM=                 Dial Before You Dig - Web
TO=                   Technical Services
UTILITY ID=           xxxxxx
COMPANY=              {Company Name}
ENQUIRY DATE=         02/10/2008 13:53
COMMENCEMENT DATE=    06/10/2008
SEQUENCE NO=          xxxxxxxxx
PLANNING=             No

[CALLER DETAILS]
CUSTOMER ID=          403552
CONTACT NAME=         {Name of Contact}
CONTACT HOURS=        0
COMPANY=              Underground Utility Locating
ADDRESS=              {Address}
SUBURB=               {Suburb}
STATE=                {State}
POSTCODE=             4350
TELEPHONE=            xxxxxxxxxx
MOBILE=               xxxxxxxxxx
FAX TYPE=             Private
FAX NUMBER=           xxxxxxxxxx
PUBLIC ADDRESS=       xxxxxxxxxx
PUBLIC TELEPHONE=
EMAIL ADDRESS=        {Email Address}

[LOCATION DETAILS]
ADDRESS=              {Location Address}
SUBURB=               {Location Suburb}
STATE=                xxx
POSTCODE=             xxx
DEPOSITED PLAN NO=    0
SECTION & HUNDRED NO= 0
PROPERTY PHONE NO=
SIDE OF STREET=       B
INTERSECTION=         xxxxxx
DISTANCE=             0-200m B
ACTIVITY CODE=        15
ACTIVITY DESCRIPTION= xxxxxxxxxxxxxxxxxx
MAP TYPE=             StateGrid
MAP REF=              Q851_63
MAP PAGE=
MAP GRID 1=
MAP GRID 2=
MAP GRID 3=
MAP GRID 4=
MAP GRID 5=
GPS X COORD=
GPS Y COORD=
PRIVATE/ROAD/BOTH=    B
TRAFFIC AFFECTED=     No
NOTIFICATION NO=      3082321
MESSAGE=              entire intersection of Allora-Clifton rd , Hillside
rd and merivale st

MOCSMESSAGE=          Digsafe generated referral

Notice: Please DO NOT REPLY TO THIS EMAIL as it has been automatically generated and replies are not monitored. Should you wish to advise Dial Before You Dig of any issues with this enquiry, please Call 1100

(See attached file: 3082321_LLGDA94.GML) 
```

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-02T06:29:02.740

[谷歌有答案](http://www.google.com/search?client=safari&rls=en-us&q=parse+.ini+vb+.net&ie=UTF-8&oe=UTF-8)，一旦你知道文件格式被称为“.ini”

**编辑：**也就是说，它是一个 .ini 加上一些额外的前导/尾随粘液。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-02T06:31:34.387

您可以按顺序读取文件的每一行。每一行本质上是一个名称值对。将每个值放在以名称为键的映射（哈希表）中。为每个部分使用地图。完成文件解析后，您将拥有包含所有名称值对的映射。遍历每个地图并填充您的数据库表。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-02T06:56:24.530

我会去 Python 进行任何类型的字符串解析。我不确定你想要保留多少这些信息，但我可能会使用 Python 的`split()`函数来拆分`=`以去除等号，然后从第二块饼图中去掉空格。

首先，我会屏蔽掉我知道不需要的页眉/页脚信息，然后执行类似于以下的操作：

让我们取一块并将其保存在`test1.txt`：

```
地址= {位置地址}
SUBURB= {位置郊区}
状态 = xxx
邮政编码= xxx
存款计划编号= 0
部分 & 百号 = 0
物业电话号码=

```

这是一个小的python片段：

```
>>> f = open("test1.txt", "r")
>>> l = f.readlines()
>>> l = [line.split('=') for line in l]
>>> 对于 l 中的行：
    打印线

['地址', '{位置地址}']
['郊区'，'{地点郊区}']
['状态'，'xxx']
['邮政编码'，'xxx']
['存款计划号'，'0']
['部分和百无'，'0']
['物业电话号码', '']

```

这实际上会给您一个 [Column, Value] 元组，您可以使用它来将数据插入到数据库中（在转义所有字符串等之后，SQL 注入警告）。

这是假设电子邮件输入和您的数据库将具有相同的列名，但如果他们没有，那么使用字典设置列映射将相当简单。另一方面，如果电子邮件和列同步，则无需知道列的名称即可进行解析。

您可以遍历伪字典并在参数化 sql 字符串的正确位置打印出每个键值对。

希望这可以帮助！

编辑：虽然这是在 Python 中，但 C#/VB.net 应该具有相同/相似的能力。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-22T05:20:08.300

```
Using f As StreamReader = File.OpenText("sample.txt")
    Dim g As String = "undefined"
    Do
        Dim s As String = f.ReadLine
        If s Is Nothing Then Exit Do
        s = s.Replace(Chr(9), " ")
        If s.StartsWith("[") And s.EndsWith("]") Then
            g = s.Substring("[".Length, s.Length - "[]".Length)
        Else
            Dim ss() As String = s.Split(New Char() {"="c}, 2)
            If ss.Length = 2 Then
                Console.WriteLine("{0}.{1}={2}", g, Trim(ss(0)), Trim(ss(1)))
            End If
        End If
    Loop
End Using 
```

# vb6 - 即使在 vb6 中也防止 Enter 键触发按钮单击

> ID：161086
> 
> 赞同：0
> 
> 时间：2008-10-02T06:23:59.007
> 
> 标签：vb6

我有一个带有进度条和取消按钮的表单，该按钮在进程运行时显示。按钮“取消”属性设置为 true，因此按转义键会取消该过程。

但是，由于按钮是表单上唯一能够获得焦点的控件，如果用户在进程运行时不小心按了 Enter（或空格键），它将被取消。

我通过将 KeyPreview 设置为 true （在表单上）然后将 KeyAscii 设置为 0 来阻止空格键工作，但是这种方法似乎不适用于 enter 键，因为按钮单击事件首先触发。

我尝试将按钮的 TabStop 属性设置为“false” - 没有变化。

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-02T06:31:25.370

在我看来，Enter 键**应该激活**取消按钮。还是您要求用户伸出鼠标？为什么？

我建议在用户取消操作后只添加一个确认对话框，这样如果有人不小心按下了 Enter 键，就有机会继续说“不，我不想取消”。

但是作为用户**，如果取消按钮具有焦点并且我无法按**键盘上的 Enter 键激活它，我会很恼火。

我的 2 美分

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-02T06:35:32.333

添加一个大小为 1x1、无标题、无边框等的默认按钮。为其创建一个不执行任何操作的处理程序。Escape 键仍然会像现在一样取消。

# osgi - 如何将 SpringSource dm 服务器集成到另一个基于 OSGi 的应用程序服务器中？

> ID：161088
> 
> 赞同：3
> 
> 时间：2008-10-02T06:25:49.737
> 
> 标签：osgi, springsource, spring-dm

我真的很想使用 SpringSource dm Server，但我们的客户要求我们在他们的应用程序服务器（Websphere）上运行我们的应用程序。有没有办法将 SpringSource dm Server 与其他应用程序服务器集成？至少 dm Server 是基于 OSGi 构建的，许多其他应用服务器（包括 Websphere）也是基于 OSGi 的。是否可以将 SpringSource dm 服务器作为 websphere 组件运行？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-06T08:25:51.283

Spring DM 部署在 Knoplerfish OSGi 实现上。

Websphere 部署在 Equinox OSGi 实现上。

所以问题就变成了——这两者可以互换吗？他们都支持 R4，所以我会说，是的，他们是。

下一个问题是检查依赖关系，尤其是与 HttpServices 等相关的东西。

我会说这没问题，但我认为最终的证明是尝试部署它。最简单的方法是将捆绑包放入 Websphere 部署中。您将需要您的捆绑包以及您正在使用的任何弹簧捆绑包。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2009-01-19T21:24:43.643

SpringSource dm Server 基于 Eclipse Equinox OSGi 框架（不应与包含在 dm Server 中的 Spring DM 技术混淆，后者可以在 Equinox、Apache Felix 和 Knopflerfish 上运行）。

但是，将 dm Server 嵌入到基于 Equinox 的另一个应用程序服务器（例如 WebSphere Application Server）中将是一项不平凡的工作。有必要让这两个产品使用相同版本的 Equinox，他们目前没有，然后修改 dm Server 以支持嵌入到服务器中（例如，与主机服务器的应用程序调用机制、线程池和类加载集成）方案）。

如果您认为这种支持很重要，请向 dm Server[提出要求](https://issuetracker.springsource.com/browse/PLATFORM)（需要简单的注册）。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2009-01-15T10:35:43.437

我不认为这是真的……

请参阅以下链接：[http ://apsblog.burtongroup.com/2008/11/websphere-7-osgi.html](http://apsblog.burtongroup.com/2008/11/websphere-7-osgi.html)

但另一方面，趋势似乎很明显……基于 OSGI 的应用程序可以部署在 Java EE 应用程序服务器上。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2009-01-20T14:27:02.397

我也对这个话题很感兴趣。看待这个问题的另一种方法是，您希望在 Spring dm 服务器和传统应用服务器（Websphere、weblogic、JBoss，...）中都可以部署应用程序。

OSGi 容器可嵌入到非 OSGi 应用程序中，因此理论上可以将应用程序部署到 Spring dm 服务器，并将同一个应用程序 + OSGi 容器部署到传统应用程序服务器。

现在，像往常一样，魔鬼在细节中，包括 Web 开发和外部应用程序服务器和 OSGi 容器之间的桥接 servlet 等主题。

# sql - 使用单个 SQL 执行此操作

> ID：161093
> 
> 赞同：1
> 
> 时间：2008-10-02T06:29:39.167
> 
> 标签：sql, oracle

我有一个看起来像这样的表：

![替代文字](https://i.stack.imgur.com/R0TIr.jpg)

行按 CLNDR_DATE DESC 排序。

我需要找到与突出显示的行相对应的 CLNDR_DATE，换句话说：
找到最上面的行组 WHERE EFFECTIVE_DATE IS NOT NULL，并返回该组最后一行的 CLNR_DATE。

通常我会打开一个游标并从上到下循环，直到在 EFFECTIVE_DATE 中找到一个 NULL。然后我会知道我正在寻找的日期是 CLNDR_DATE，在上一步中获得。

但是，我想知道是否可以使用单个 SQL 来实现相同的效果？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-02T06:35:48.137

警告：无论如何都不是 DBA。;)

但是，一个快速的、未经测试的尝试：

```
SELECT min(CLNDR_DATE) FROM [TABLE]
WHERE (EFFECTIVE_DATE IS NOT NULL)
  AND (CLNDR_DATE > (
    SELECT max(CLNDR_DATE) FROM [TABLE] WHERE EFFECTIVE_DATE IS NULL
  )) 
```

假设您想要第**一个**CLNDR_DATE**和**EFFECTIVE_DATE 在**最后一个没有**.

如果您想在第**一个不****带**后第一个带，请将子查询更改为使用 min() 而不是 max()。

 *** * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T06:54:49.997

使用 Oracle 的分析功能（未经测试）

```
select *
from
(
  select 
    clndr_date, 
    effective_date, 
    lag(clndr_date, 1, null) over (order by clndr_date desc) prev_clndr_date
  from table
)
where effective_date is null 
```

`lag(clndr_date, 1, null) over (order by clndr_date desc)`返回前一个 clndr_date，如果这是第一行，则使用 null 。

（编辑：固定顺序）

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T06:38:04.263

此记录集的第一个结果就是您要查找的结果。根据您的数据库，您可能只能使用 LIMIT 或 TOP 返回此行

```
SELECT CLNDR_DATE 
FROM TABLE
WHERE CLNDR_DATE > (SELECT MAX(CLNDR_DATE)
                    FROM TABLE 
                    WHERE EFFECTIVE_DATE IS NOT NULL)
ORDER BY CLNDR_DATE 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T06:42:03.333

当您在 Oracle 环境中时，您可以使用分析功能 ( [http://www.orafaq.com/node/55](http://www.orafaq.com/node/55) )，这是非常强大的工具来执行您要求的查询。

使用标准 SQL 我认为这是不可能的，但也许一些 SQL 专家会提出一些不错的解决方案。

# algorithm - 以随机顺序访问三角形中的点

> ID：161101
> 
> 赞同：5
> 
> 时间：2008-10-02T06:35:17.513
> 
> 标签：algorithm, language-agnostic, math

对于由等式 aX + bY <= c 在整数上指定的直角三角形

我想以伪随机顺序绘制三角形中的每个像素（*）一次且仅一次，并且不存储先前命中点的列表。

我知道如何用 0 和 x 之间的线段来做到这一点

> 沿线选择一个随机点'o'，
> 选择与x相对质数的'p'
> 重复最多x次：O [next] = (O [cur] + P) MOD x

要对三角形执行此操作，我会
1\. 需要计算三角形中没有列表的像素数
2\. 将整数 0..points 映射到 ax,y 对中，该对是三角形内的有效像素

我希望任何解决方案都可以推广到金字塔和更高维度的形状。

(*) 我将 CG 术语像素用于整数点 X、Y 对，从而满足等式。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T06:42:52.690

由于您想保证访问每个像素一次且仅一次，因此考虑像素而不是真正的三角形可能会更好。您可以水平切割三角形并获得一堆水平[扫描线](http://en.wikipedia.org/wiki/Scan_line)。将扫描线连接在一起，您已将“三角形”转换为长线。将您的点访问算法应用于您的长链扫描线。

顺便说一句，这种映射只需要在纸上进行，您所需要的只是一个可以沿虚拟扫描线给定 (t) 的函数返回 (x, y)。

编辑：要将两个点转换为线段，您可以查找[Bresenham 的扫描转换](http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)。将 3 条线段转换为一系列点后，您可以将所有点放入一个桶中并按 y 对所有点进行分组。在相同的 y 值内，按 x 对点进行排序。y 值内的最小 x 是扫描线的起点，y 值内的最大 x 是扫描线的终点。这称为“扫描转换三角形”。如果你谷歌，你可以找到更多信息。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-02T06:48:16.627

这是[三角点拾取](http://mathworld.wolfram.com/TrianglePointPicking.html)的解决方案。

您需要做的是选择三角形的两个向量（边），将每个向量与 [0,1] 中的随机数相乘并将它们相加。这将在向量定义的四边形中提供均匀分布。您必须检查结果是否在原始三角形内；如果它没有将其重新转换或简单地丢弃它并重试。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T06:43:04.190

一种方法是将所有像素放入一个数组中，然后将数组打乱（这是O（n）），然后按打乱数组中的顺序访问像素。不过，这可能需要相当多的内存。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T06:45:05.400

这是一种浪费一些 CPU 时间的方法，但可能不会像更复杂的方法那样浪费。

计算一个外接三角形的矩形。很容易“线性化”那个矩形，每条扫描线都跟着下一条。使用您已经知道的算法来遍历矩形的像素。当你点击每个像素时，检查像素是否在三角形中，如果不是，则跳过它。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T08:10:32.730

我会将三角形的线视为单条线，将其切成段。这些段将存储在一个数组中，其中还存储了段的长度以及行总长度的偏移量。然后根据 O 的值，您可以根据此信息选择包含您当时要绘制的像素的数组元素，并根据元素中的值绘制像素。

# asp.net - 分布式缓存/会话我应该转向哪里？

> ID：161106
> 
> 赞同：3
> 
> 时间：2008-10-02T06:36:12.363
> 
> 标签：asp.net, session, caching, failover

我目前正在研究分布式缓存解决方案。

如果钱不是问题，你会推荐哪个？

*   [www.scaleoutsoftware.com](http://www.scaleoutsoftware.com/)
*   [缓存](http://www.alachisoft.com/ncache/)
*   [内存缓存点网](http://sourceforge.net/projects/memcacheddotnet/)
*   [质谱速度](http://www.microsoft.com/downloads/details.aspx?FamilyId=B24C3708-EEFF-4055-A867-19B5851E7CD2&displaylang=en)

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T07:04:23.887

在您的选择中，我只尝试过使用 memcached，即便如此，它也不是 C#/.NET 库。

然而，memcached 技术已经得到了很好的证明，只要[看看使用它的网站](http://en.wikipedia.org/wiki/Memcached)：

> ...该系统被几个非常大的知名网站使用，包括**YouTube**、**LiveJournal**、**Slashdot**、**Wikipedia**、**SourceForge**、ShowClix、GameFAQs、**Facebook**、**Digg**、**Twitter**、Fotolog、BoardGameGeek、NYTimes.com、deviantART、Jamendo、Kayak 、VxV、**ThePirateBay**和 Netlog。

我真的没有理由去看其他解决方案。

**祝你好运，布赖恩**G。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-03T07:21:31.000

人们在评估解决方案时通常会忘记的一件事是专门的支持。

如果您使用 memcached，那么您将一无所获，因为您使用的是不受任何供应商支持的完全开源软件。是的，核心平台经过了多年的良好测试，但 C# 客户端库可能要少得多。是的，您可能会在论坛等上获得一些帮助，但不能保证回复会很快，也不能保证您会得到任何回复。

我不知道对 NCache 或 ScaleOut 缓存的支持是什么样的，但在选择它们之前值得了解一下。在过去的几年里，我与许多公司打交道以获得支持，而支持通常外包给那些甚至不在公司工作的人（没有机会接触到在公司工作的人），这意味着没有机会得到及时支持的质量。另一方面，我还与那些将严重问题上报给合适的人、非常快速地解决重要问题并为您提供个人补丁的公司打过交道。

其中一家公司是微软，这也是我们使用他们的软件作为我们平台的原因之一。如果您有生产问题，那么您可以依靠他们的支持。所以我倾向于在此基础上选择 Velocity。

不过，可能最重要的事情是，无论您选择哪种缓存，都将其抽象到您自己的接口（例如 ICache）后面，这将允许您评估其中的一些，而不会阻碍其余的开发过程。这意味着即使您最初的决定对您不起作用，您也可以在不破坏大部分应用程序的情况下切换它。

（注意：我在这里假设所有缓存都具有足够的功能来支持您需要的功能，并且所有缓存都具有足够且大致相似的性能。这可能不是一个有效的假设，在这种情况下您需要提供在你的问题中更详细地说明为什么它不是）。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-03T01:32:04.740

您还可以将[Oracle Coherence](http://www.oracle.com/technology/products/coherence/index.html)添加到您的列表中。它同时具有 .NET 和 Java API。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2012-02-18T09:50:53.363

来自微软：App Fabric 商业：NCache 开源：RIAK

我们尝试了几次，最后我们使用了 asp.net/mvc 的 SQL 会话提供程序，是的，连接到数据库的开销很大，但我们的数据库服务器非常快，而且网络场有很多容量，所以不是问题。

对 RIAK 非常感兴趣，拥有 .net 客户端并被 Yahoo 使用 - 可以扩展到许多 manu 服务器

# mysql - 为什么使用 ActiveRecord 而不是 MySql API

> ID：161108
> 
> 赞同：2
> 
> 时间：2008-10-02T06:37:52.547
> 
> 标签：mysql, ruby-on-rails, activerecord

我开发 Web 应用程序已经有一段时间了，我对 mySql 很满意，事实上我几乎每天都使用某种形式的 SQL。我喜欢这种语法，并且在编写查询或优化我的表时遇到了零问题。我很喜欢这个 mysql [api](http://www.tmtm.org/en/mysql/ruby/)。

一直困扰我的是 Ruby on Rails 使用 ActiveRecord 并迁移所有内容，因此您可以使用函数来查询数据库。我想你的想法是“永远不必再看 SQL”。也许这不是 KISS（保持简单愚蠢），但 ActiveRecord 界面真的是最好的吗？如果是，为什么？

无需编写 SQL 语句的开发是否健康？如果您必须查找尚未定义为 rails 函数的东西怎么办？我知道他们有一个功能可以让我进行自定义查询。我想我真的想知道人们认为使用 ActiveRecord 而不是 mySQL 的优势是什么，如果有人像我一样觉得这对于 Rails 社区来说可能就像计算器对于数学社区一样，有些人可能会忘记如何长时间分配。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T13:30:02.447

没错，将 SQL 隐藏在 ActiveRecord 层之后意味着人们可能会忘记检查生成的 SQL。我自己也被这个咬过：缺少索引、低效的查询等。

ActiveRecord 允许让简单的事情变得简单：

```
Post.find(1) 
```

对比

```
SELECT * FROM posts WHERE posts.id = 1 
```

作为开发人员，您输入的内容更少，因此出错的机会也更少。

验证是 ActiveRecord 简化的另一件事。无论如何，您都必须这样做，那么为什么不提供一种简单的方法呢？将重复、无聊的部分抽象出来？

```
class Post < ActiveRecord::Base
  validates_presence_of :title
  validates_length_of :title, :maximum => 80
end 
```

对比

```
if params[:post][:title].blank? then
  # complain
elsif params[:post][:title].length > 80 then
  # complain again
end 
```

同样，易于指定，易于验证。想要更多验证？添加到 ActiveRecord 模型的单行。具有多个条件的复杂代码总是更难调试和测试。为什么不让你轻松一点？

我真正喜欢 ActiveRecord 而不是 SQL 的最后一件事是回调。回调可以用 SQL 触发器模拟（仅在 MySQL 5.0 或更高版本中可用），而 ActiveRecord 从那时起就有回调（我从 0.13 开始）。

总结一下：

*   ActiveRecord 让简单的事情变得简单；
*   ActiveRecord 去除了枯燥、重复的部分；
*   ActiveRecord 不会阻止您[编写自己的 SQL](http://api.rubyonrails.org/classes/ActiveRecord/Base.html#M001302)（通常出于性能原因），最后；
*   ActiveRecord 在大多数数据库引擎中是完全可移植的，而 SQL 本身不是（有时）。

我知道在您的情况下您是在专门谈论 MySQL，但仍然如此。有这个选项很好。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T06:47:32.180

这里的想法是，通过将数据库逻辑放在 Active Record 中，您可以在一个地方处理 SQL 代码，而不是遍布整个应用程序。这使得应用程序的各个层更容易遵循单一职责原则（即一个对象应该只有一个改变的理由）。

这[是一篇关于 Active Record 模式的文章](http://www.devshed.com/c/a/PHP/The-Active-Record-Pattern/)。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T07:47:30.540

当您决定更改数据库方案时，避免使用 SQL 会有所帮助。抽象对于各种事情也是必要的，比如验证。我并不是说你不会写 SQL：如果你觉得有必要，你总是可以这样做。但是您不必编写 5 行查询，您只需要 user.save。避免不必要的代码是 rails 的哲学。

# bookmarks - 您如何跟踪在线对话的临时线程

> ID：161114
> 
> 赞同：2
> 
> 时间：2008-10-02T06:39:10.907
> 
> 标签：bookmarks

通常，当我在网站上发表评论或回答时，我喜欢留意其他人的其他回复，如果合适的话，可能会再次回复。有时我会为一个页面添加书签一段时间，有时我会重新搜索关键字以再次找到该帖子。我一直认为应该有比我的记忆更好的东西来跟踪我关心的页面几天到一周。

有没有人对这种事情有任何聪明的想法？是否有一种带有书签的微型在线应用程序，用于非常短期的跟进？

* * *

**更新**我想我应该澄清一下。我并没有专门询问 Stack Overflow——一般来说，在“读/写网络”上，我会在博客文章中添加评论、回复谷歌群组线程等。这是我在随机网站上的单个页面的那种混搭会关心跟踪七到十天。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T06:41:53.053

对于 stackoverflow，我在[http://stackoverflow.hewgill.com](http://stackoverflow.hewgill.com)上整理了一个小书签。我用它来跟踪我以后可能想要回来的帖子，以供参考或在没有其他人这样做的情况下回答，或其他什么。后端自动从 SO 服务器检索更新并更新您的小书签列表。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T06:43:36.823

主要是在我的脑海里。我偶尔会忘记一些事情，但它工作得很好。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2011-01-24T07:56:48.407

这是你在这里问的一个非常有趣的问题。我执行以下操作：

1.  浏览器中的临时书签
2.  只是 Firefox 中的一个标签页打开了数周 :)
3.  尽可能订阅电子邮件\rss。收到电子邮件通知时，我经常将其放入电子邮件树中的特殊文件夹中。

不同的登录、通知类型等使网络中的以下信息变得复杂:(

其他有趣的问题：

1.  如何组织信息存储（笔记、保存的网页、论坛主题等）以供当前使用并作为只读库，在不同的 PC 和 USB 磁盘之间同步，如何标记（标记）和搜索
2.  如何存储旧邮件、对话、聊天......？
3.  为将来存储数码照片：制作硬拷贝打印输出或只是定期将其从 CD 重写为新的

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T06:49:37.153

单击您的用户名，然后单击响应。

# netbeans - 如何配置 Netbeans .netbeans 目录的位置？

> ID：161123
> 
> 赞同：0
> 
> 时间：2008-10-02T06:43:08.993
> 
> 标签：netbeans, netbeans6.1

我希望 Netbeans 6.1 将 .netbeans 目录存储在默认位置之外的另一个位置。我该怎么做呢？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T14:51:38.990

您还可以在通过命令行运行 Netbeans IDE 时指定此项。如果您想在 IDE 中拥有不同的配置文件/工作环境，或者在测试 Netbeans IDE 插件时，这很有用。这适用于 5.0 到当前版本 (6.5)。

只需在命令行上指定“--userdir”。例子：

netbeans --userdir /local/file/system/netbeans/userdir/6.1

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T06:50:04.733

有配置文件：

```
 <Netbeans>/etc/netbeans.conf

 netbeans_default_userdir=<dir> 
```

# wpf - WPF ListBox 可以“只读”吗？

> ID：161127
> 
> 赞同：15
> 
> 时间：2008-10-02T06:43:41.973
> 
> 标签：wpf, listbox, itemscontrol

我们有一个场景，我们想要显示一个项目列表并指示哪个是“当前”项目（带有一个小箭头标记或更改的背景颜色）。

ItemsControl 对我们没有好处，因为我们需要“SelectedItem”的上下文。但是，我们希望以编程方式移动选择，并且不允许用户更改它。

有没有一种简单的方法可以使 ListBox 非交互式？我们可以通过故意吞下鼠标和键盘事件来伪造它，但是我是否缺少一些基本属性（例如将“IsEnabled”设置为 false 而不会影响其视觉风格），这些属性可以提供我们想要的东西？

或者......是否有另一个 WPF 控件是两全其美的 - 具有 SelectedItem 属性的 ItemsControl？

* * *

## 回答 #1

> 赞同：19
> 
> 时间：2008-10-02T08:35:28.053

一种选择是设置`ListBoxItem.IsEnabled`为`false`：

```
<ListBox x:Name="_listBox">
    <ListBox.ItemContainerStyle>
        <Style TargetType="ListBoxItem">
            <Setter Property="IsEnabled" Value="False"/>
        </Style>
    </ListBox.ItemContainerStyle>
</ListBox> 
```

这可确保项目不可选择，但它们可能无法呈现您喜欢的方式。要解决此问题，您可以使用触发器和/或模板。例如：

```
<ListBox x:Name="_listBox">
    <ListBox.ItemContainerStyle>
        <Style TargetType="ListBoxItem">
            <Setter Property="IsEnabled" Value="False"/>
            <Style.Triggers>
                <Trigger Property="IsEnabled" Value="False">
                    <Setter Property="Foreground" Value="Red" />
                </Trigger>
            </Style.Triggers>
        </Style>
    </ListBox.ItemContainerStyle>
</ListBox> 
```

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2011-02-08T22:31:08.627

我遇到过同样的问题。我通过将 IsEnabled 设置为 true 并处理 ListBox 的 PreviewMouseDown 事件来解决它。在您不希望编辑它的情况下，在处理程序中将 e.Handled 设置为 true。

```
 private void lstSMTs_PreviewMouseDown(object sender, System.Windows.Input.MouseButtonEventArgs e)
    {
        e.Handled = !editRights;
    } 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T07:42:12.207

您的 ItemsControl/ListBox 是数据绑定的吗？

我只是想您可以将每个项目的背景画笔绑定到源数据中的属性，或者通过转换器传递属性。就像是：

```
 <ItemsControl DataContext="{Binding Source={StaticResource Things}}" ItemsSource="{Binding}" Margin="0">
    <ItemsControl.Resources>
      <local:SelectedConverter x:Key="conv"/>
    </ItemsControl.Resources>
    <ItemsControl.ItemsPanel>
      <ItemsPanelTemplate>
        <local:Control Background="{Binding Path=IsSelected, Converter={StaticResource conv}}"/>
      </ItemsPanelTemplate>
    </ItemsControl.ItemsPanel> 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2021-11-02T10:59:43.120

可以解决问题的神奇咒语是：

```
<ListBox IsHitTestVisible="False"> 
```

不幸的是，这也会阻止任何滚动条工作。

解决方法是将列表框放在滚动查看器中：

```
<ScrollViewer>
    <ListBox IsHitTestVisible="False">
    </ListBox>
</ScrollViewer> 
```

# import - 如何将用户从社区服务器导入 DNN？

> ID：161153
> 
> 赞同：0
> 
> 时间：2008-10-02T06:57:07.587
> 
> 标签：import, dotnetnuke

客户端正在从社区服务器切换到 DNN。我们只想导入所有用户，包括他们的密码。看起来这应该可以工作，因为这两种产品都使用 .NET SqlMembershipProvider。需要填充哪些表才能在 DNN 中正确设置用户？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2009-04-23T01:06:58.550

您最有可能需要的是 DNN 的成员资格提供程序，它允许您访问 CS 成员资格 - 我没有关于此路径的具体信息，但这将是我的猜测，并且很可能是最简单的路径

根据 Alex Chrome 在这篇文章[http://dev.communityserver.com/forums/t/488539.aspx](http://dev.communityserver.com/forums/t/488539.aspx)

可能有办法在 CS 2008 中使用 REST API

# java - 如何在更新后强制 tomcat Web 应用程序重新加载信任库

> ID：161160
> 
> 赞同：2
> 
> 时间：2008-10-02T07:01:54.237
> 
> 标签：java, tomcat, truststore

我有以下问题。我的基于 tomcat 5.5 的 Web 应用程序正在使用信任库来验证 SSL 连接。该应用程序允许用户添加或删除要在验证过程中使用的 CA 证书。但是，从信任库中添加或删除证书不会改变任何事情。应用程序仅“识别”tomcat 启动时信任存储区中的证书。为了让它识别新的证书集，我需要重新启动 tomcat。

然而，这不是一个有效的解决方案。我需要的是基于代码的解决方案。请指教。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T14:55:57.140

编写一个只为这个 web 应用程序加载到信任库中的自定义类加载器怎么样。当您需要刷新内容并重新加载它时，您可以卸载类加载器吗？

# c++ - 将迭代器用作参数时在内部增加迭代器是否安全？

> ID：161166
> 
> 赞同：1
> 
> 时间：2008-10-02T07:06:47.127
> 
> 标签：c++, iterator

目前我正在尝试从集合中删除一系列迭代器，但是 GCC 的标准库似乎被破坏了，因为 std::set::erase(iterator) 应该返回一个迭代器（下一个迭代器），但是在 GCC 它返回 void （哪个是标准的？）

无论如何我想写：

```
myIter = mySet.erase(myIter); 
```

但是 GCC 不喜欢它......所以写这个安全吗？

```
mySet.erase(myIter++); 
```

编辑：是的，我正在检查 mySet.end();

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-10-02T07:45:02.557

没有问题

```
mySet.erase(myIter++); 
```

操作顺序是明确定义的：将 myIter 复制到 myTempIter 中，将 myIter 递增，然后将 myTempIter 提供给擦除方法。

**对于 Greg 和 Mark**：不，operator++ 无法在调用擦除后执行操作。根据定义，在operator++ 返回后调用erase()。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-02T07:51:06.757

首先，重读标准，你会看到 set::erase 方法的原型是：

```
void erase(iterator position); 
```

但是，STL 中的关联容器是“稳定的”，因为擦除一个元素不会影响其他元素上的迭代器。这意味着以下行是有效的：

```
iterator to_erase = myIter++;
mySet.erase(to_erase);
// Now myIter is still on the next element 
```

# c# - 如何从符号 (.pdb) 文件中确定 C# 方法的文件和行号？

> ID：161170
> 
> 赞同：6
> 
> 时间：2008-10-02T07:08:53.517
> 
> 标签：c#, .net, pdb-files

pdb 文件包含 .NET 程序集的符号信息。我想读取一个 pdb 文件，以便将方法与它们的文件位置相关联。数据包含在其中，但我似乎无法找到如何将其取出的良好描述。

我知道[mdbg](http://blogs.msdn.com/jmstall/archive/2005/08/25/pdb2xml.aspx)，但这对于我想要的来说非常沉重（我认为/希望）。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T11:33:10.123

你应该看看：

*   [Mono.Cecil](http://www.mono-project.com/Cecil)，尤其是 Mono.Cecil.Pdb 模块。它应该做你想做的，甚至更多。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-02T07:46:30.073

在 DBGHELP.DLL 中，您可以使用 SymGetLineFromAddr64 函数。您需要使用 P/Invoke。DIA SDK中可能有对应的API，但我不像DBGHELP那样熟悉。

# sqlite - 将包含许多记录的大型表从 SQLite 导出到自定义分隔文本文件的最佳方法是什么？

> ID：161171
> 
> 赞同：0
> 
> 时间：2008-10-02T07:11:04.917
> 
> 标签：sqlite, export

我正在处理的表可能大于可用内存（比如说 10GB），并且某些字段最多可以有 100MB 的文本。所以一个简单的 SELECT 查询可能不会削减它。我见过一些命令行解决方案，但我需要能够通过 C# 程序来做到这一点。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T07:14:28.823

选择应该没问题。上次我检查时，当您查询数据库时，整个记录集（及其所有数据）并未加载到内存中。

如果情况并非如此，并且它占用了已知宇宙中的所有 RAM，请执行查询以获取 ID，然后通过获取单个记录的 ID 勾选。慢*得多*，但它应该限制RAM的使用。

# xml - 如何在 Linux 的 SUN One ASP 托管环境中加载 XML 文档

> ID：161176
> 
> 赞同：0
> 
> 时间：2008-10-02T07:13:23.773
> 
> 标签：xml, asp-classic

我正在使用 SUN One（以前称为 Chillisoft）服务器托管的 ASP 站点上工作。我在加载 XML 文件时遇到问题，我使用的代码如下

```
dim directory
set directory = Server.CreateObject("MSXML2.DOMDocument")

if(directory.load(Server.MapPath("directory.xml"))) then
     Response.Write("Loaded")
else
     Response.Write("NotLoaded")
    If directory.parseError.errorCode Then
        Response.Write( "Parse error" )
    end if
end if 
```

我的 asp 页面和 directory.xml 都在同一个文件夹“/public_html/”中。

我认为问题可能与 mappath 找不到文件有关，但没有返回错误，所以不知道该怎么做。

谢谢

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T07:47:15.407

我对 Sun One 了解不多，但我知道它有一个模拟 MSXML 的 Bean。

通常，您会使用：-

```
Set directory = Server.CreateObject("MSXML2.DOMDocument")
directory.async = false
directory.load(Server.MapPath("directory.xml") 
```

否则，当异步加载 xml 时，加载会立即返回。

它看不到您发布的代码如何不会返回没有错误的内容。

我的第一个诊断是：-

```
Response.Write(Server.MapPath("directory.xml")) 
```

接着

```
Dim direcotory
Set directory = Server.CreateObject("MSXML.DOMDocument")
Response.Write(Not (directory Is Nothing)) 
```

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-03T19:18:25.167

加载可能会返回 false，因为它尚未完全加载文档。您需要找到一种方法将 async 设置为 false。如果 Sun One 很好地模拟了 MSXML2.DOMDocument，那么 async 应该接受 false 但您可以尝试 -`1`或者`Response.Write(directory.async)`了解它最初设置的内容。

# c++ - C++ 是否支持“最终”块？（我一直听到的这个“RAII”是什么？）

> ID：161177
> 
> 赞同：310
> 
> 时间：2008-10-02T07:14:00.980
> 
> 标签：c++, exception, raii, finally, c++-faq

C++ 是否支持“ [**finally**](http://java.sun.com/docs/books/tutorial/essential/exceptions/finally.html) ”块？

什么是[**RAII 成语**](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)？

[**C++ 的 RAII 习语和C# 的“使用”语句**](http://www.c-sharpcorner.com/uploadfile/dipalchoksi/usingstatement11092005065819am/usingstatement.aspx)有什么区别？

* * *

## 回答 #1

> 赞同：297
> 
> 时间：2008-10-02T07:14:22.897

* * *

## 回答 #2

> 赞同：83
> 
> 时间：2008-10-02T07:47:35.033

在 C++ 中，由于 RAII ，finally**不是必需的。**

RAII 将异常安全的责任从对象的用户转移到对象的设计者（和实现者）。我认为这是正确的地方，因为您只需要正确地获得一次异常安全（在设计/实现中）。通过使用 finally，您需要在每次使用对象时正确地获得异常安全。

此外，IMO 代码看起来更整洁（见下文）。

例子：

一个数据库对象。为确保使用数据库连接，必须打开和关闭它。通过使用 RAII，这可以在构造函数/析构函数中完成。

### 像 RAII 一样的 C++

```
void someFunc()
{
    DB    db("DBDesciptionString");
    // Use the db object.

} // db goes out of scope and destructor closes the connection.
  // This happens even in the presence of exceptions. 
```

RAII 的使用使得正确使用数据库对象变得非常容易。无论我们如何尝试和滥用它，DB 对象都会通过使用析构函数正确地关闭它自己。

### Java 终于喜欢了

```
void someFunc()
{
    DB      db = new DB("DBDesciptionString");
    try
    {
        // Use the db object.
    }
    finally
    {
        // Can not rely on finaliser.
        // So we must explicitly close the connection.
        try
        {
            db.close();
        }
        catch(Throwable e)
        {
           /* Ignore */
           // Make sure not to throw exception if one is already propagating.
        }
    }
} 
```

当最终使用对象时，对象的正确使用被委托给对象的用户。**即**正确地明确关闭数据库连接是对象用户的责任。现在您可以争辩说这可以在终结器中完成，但是资源可能具有有限的可用性或其他约束，因此您通常确实希望控制对象的释放而不依赖于垃圾收集器的非确定性行为。

这也是一个简单的例子。
当您有多个需要释放的资源时，代码可能会变得复杂。

更详细的分析可以在这里找到：http: [//accu.org/index.php/journals/236](http://accu.org/index.php/journals/236)

* * *

## 回答 #3

> 赞同：74
> 
> 时间：2014-08-26T16:36:26.690

RAII 通常更好，但您可以轻松地在 C++ 中使用**finally语义。**使用少量代码。

此外，C++ [Core Guidelines 最后给出。](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-utilities)

这是[GSL Microsoft 实现](https://github.com/Microsoft/GSL)的链接和[Martin Moene 实现的链接](https://github.com/martinmoene/gsl-lite)

Bjarne Stroustrup 多次表示，GSL 中的所有内容最终都将纳入标准。所以它应该是一种面向未来的使用**finally**的方式。

如果您愿意，您可以轻松实现自己，请继续阅读。

在 C++11 RAII 和 lambdas 中，最终允许通用：

```
namespace detail { //adapt to your "private" namespace
template <typename F>
struct FinalAction {
    FinalAction(F f) : clean_{f} {}
   ~FinalAction() { if(enabled_) clean_(); }
    void disable() { enabled_ = false; };
  private:
    F clean_;
    bool enabled_{true}; }; }

template <typename F>
detail::FinalAction<F> finally(F f) {
    return detail::FinalAction<F>(f); } 
```

使用示例：

```
#include <iostream>
int main() {
    int* a = new int;
    auto delete_a = finally([a] { delete a; std::cout << "leaving the block, deleting a!\n"; });
    std::cout << "doing something ...\n"; } 
```

输出将是：

```
doing something...
leaving the block, deleting a! 
```

我个人使用这几次来确保在 C++ 程序中关闭 POSIX 文件描述符。

拥有一个真正的类来管理资源，从而避免任何类型的泄漏通常会更好，但这**最终**在创建一个类听起来像是矫枉过正的情况下很有用。

**此外，我最终**比其他语言更喜欢它，因为如果自然使用，您可以在开始代码附近编写结束代码（在我的示例中为**new**和**delete**），并且破坏遵循 C++ 中的 LIFO 顺序构造。唯一的缺点是你得到了一个你并没有真正使用的自动变量，并且 lambda 语法使它有点嘈杂（在我的第四行的例子中，只有**finally**这个词和右边的 {} 块是有意义的，休息本质上是噪音）。

另一个例子：

```
 [...]
 auto precision = std::cout.precision();
 auto set_precision_back = finally( [precision, &std::cout]() { std::cout << std::setprecision(precision); } );
 std::cout << std::setprecision(3); 
```

**如果finally**必须在失败的情况下才被调用，则**disable**成员很有用。例如，您必须在三个不同的容器中复制一个对象，您可以设置**finally**撤消每个复制并在所有复制成功后禁用。这样做，如果破坏不能扔，你保证了强有力的保证。

 ******禁用**示例：

```
//strong guarantee
void copy_to_all(BIGobj const& a) {
    first_.push_back(a);
    auto undo_first_push = finally([first_&] { first_.pop_back(); });

    second_.push_back(a);
    auto undo_second_push = finally([second_&] { second_.pop_back(); });

    third_.push_back(a);
    //no necessary, put just to make easier to add containers in the future
    auto undo_third_push = finally([third_&] { third_.pop_back(); });

    undo_first_push.disable();
    undo_second_push.disable();
    undo_third_push.disable(); } 
```

如果你不能使用 C++11，你仍然可以使用*finally*，但是代码会变得有点冗长。只需定义一个只有构造函数和析构函数的结构，构造函数引用所需的任何内容，析构函数执行您需要的操作。这基本上是 lambda 所做的，手动完成。

```
#include <iostream>
int main() {
    int* a = new int;

    struct Delete_a_t {
        Delete_a_t(int* p) : p_(p) {}
       ~Delete_a_t() { delete p_; std::cout << "leaving the block, deleting a!\n"; }
        int* p_;
    } delete_a(a);

    std::cout << "doing something ...\n"; } 
```

希望你可以使用 C++11，这段代码更多是为了说明“C++ 最终不支持”自 C++ 的最初几周以来一直是无稽之谈，甚至在 C++ 得名之前就可以编写这种代码.

* * *

## 回答 #4

> 赞同：34
> 
> 时间：2008-10-02T07:28:26.560

除了使用基于堆栈的对象使清理变得容易之外，RAII 也很有用，因为当对象是另一个类的成员时会发生相同的“自动”清理。当拥有的类被破坏时，由 RAII 类管理的资源被清理，因为该类的 dtor 被调用。

这意味着当您达到 RAII 必杀技并且类中的所有成员都使用 RAII（如智能指针）时，您可以为所有者类使用一个非常简单（甚至可能是默认）的 dtor，因为它不需要手动管理它成员资源生命周期。

* * *

## 回答 #5

> 赞同：31
> 
> 时间：2010-09-21T11:31:56.590

> 为什么即使是托管语言也提供了一个finally块，尽管垃圾收集器会自动释放资源？

实际上，基于垃圾收集器的语言需要“终于”更多。垃圾收集器不会及时销毁您的对象，因此不能依靠它来正确清理与内存无关的问题。

就动态分配的数据而言，许多人认为您应该使用智能指针。

然而...

> RAII 将异常安全的责任从对象的用户转移到设计者

可悲的是，这是它自己的垮台。旧的 C 编程习惯很难改掉。当您使用以 C 或非常 C 风格编写的库时，将不会使用 RAII。无需重新编写整个 API 前端，这正是您必须使用的。 **然后**缺乏“终于”真的很痛苦。

* * *

## 回答 #6

> 赞同：11
> 
> 时间：2017-11-30T13:14:14.417

另一个使用 C++11 lambda 函数的“finally”块模拟

```
template <typename TCode, typename TFinallyCode>
inline void with_finally(const TCode &code, const TFinallyCode &finally_code)
{
    try
    {
        code();
    }
    catch (...)
    {
        try
        {
            finally_code();
        }
        catch (...) // Maybe stupid check that finally_code mustn't throw.
        {
            std::terminate();
        }
        throw;
    }
    finally_code();
} 
```

希望编译器能优化上面的代码。

现在我们可以编写如下代码：

```
with_finally(
    [&]()
    {
        try
        {
            // Doing some stuff that may throw an exception
        }
        catch (const exception1 &)
        {
            // Handling first class of exceptions
        }
        catch (const exception2 &)
        {
            // Handling another class of exceptions
        }
        // Some classes of exceptions can be still unhandled
    },
    [&]() // finally
    {
        // This code will be executed in all three cases:
        //   1) exception was not thrown at all
        //   2) exception was handled by one of the "catch" blocks above
        //   3) exception was not handled by any of the "catch" block above
    }
); 
```

如果你希望你可以把这个成语包装成“try - finally”宏：

```
// Please never throw exception below. It is needed to avoid a compilation error
// in the case when we use "begin_try ... finally" without any "catch" block.
class never_thrown_exception {};

#define begin_try    with_finally([&](){ try
#define finally      catch(never_thrown_exception){throw;} },[&]()
#define end_try      ) // sorry for "pascalish" style :( 
```

现在“finally”块在 C++11 中可用：

```
begin_try
{
    // A code that may throw
}
catch (const some_exception &)
{
    // Handling some exceptions
}
finally
{
    // A code that is always executed
}
end_try; // Sorry again for this ugly thing 
```

就我个人而言，我不喜欢“finally”习语的“宏”版本，并且更喜欢使用纯“with_finally”函数，即使在这种情况下语法更庞大。

你可以在这里测试上面的代码：http: [//coliru.stacked-crooked.com/a/1d88f64cb27b3813](http://coliru.stacked-crooked.com/a/1d88f64cb27b3813)

**附言**

如果您的代码中需要*finally*块，那么[作用域守卫](https://stackoverflow.com/q/10270328/5447906)或[ON_FINALLY/ON_EXCEPTION](https://stackoverflow.com/a/48842771/5447906)宏可能会更好地满足您的需求。

这是使用 ON_FINALLY/ON_EXCEPTION 的简短示例：

```
void function(std::vector<const char*> &vector)
{
    int *arr1 = (int*)malloc(800*sizeof(int));
    if (!arr1) { throw "cannot malloc arr1"; }
    ON_FINALLY({ free(arr1); });

    int *arr2 = (int*)malloc(900*sizeof(int));
    if (!arr2) { throw "cannot malloc arr2"; }
    ON_FINALLY({ free(arr2); });

    vector.push_back("good");
    ON_EXCEPTION({ vector.pop_back(); });

    ... 
```

* * *

## 回答 #7

> 赞同：7
> 
> 时间：2010-06-02T14:25:48.177

很抱歉挖了这么老的帖子，但是下面的推理有一个重大错误：

> RAII 将异常安全的责任从对象的用户转移到对象的设计者（和实现者）。我认为这是正确的地方，因为您只需要正确地获得一次异常安全（在设计/实现中）。通过使用 finally，您需要在每次使用对象时正确地获得异常安全。

通常情况下，您必须处理动态分配的对象、对象的动态数量等。在 try 块中，一些代码可能会创建许多对象（有多少是在运行时确定的）并将指向它们的指针存储在列表中。现在，这不是一个奇特的场景，而是非常常见的。在这种情况下，你会想写类似的东西

```
void DoStuff(vector<string> input)
{
  list<Foo*> myList;

  try
  {    
    for (int i = 0; i < input.size(); ++i)
    {
      Foo* tmp = new Foo(input[i]);
      if (!tmp)
        throw;

      myList.push_back(tmp);
    }

    DoSomeStuff(myList);
  }
  finally
  {
    while (!myList.empty())
    {
      delete myList.back();
      myList.pop_back();
    }
  }
} 
```

当然，列表本身会在超出范围时被销毁，但这不会清理您创建的临时对象。

相反，你必须走丑陋的路线：

```
void DoStuff(vector<string> input)
{
  list<Foo*> myList;

  try
  {    
    for (int i = 0; i < input.size(); ++i)
    {
      Foo* tmp = new Foo(input[i]);
      if (!tmp)
        throw;

      myList.push_back(tmp);
    }

    DoSomeStuff(myList);
  }
  catch(...)
  {
  }

  while (!myList.empty())
  {
    delete myList.back();
    myList.pop_back();
  }
} 
```

另外：为什么即使是托管语言也提供了一个finally块，尽管垃圾收集器会自动释放资源？

提示：你可以用“finally”做更多的事情，而不仅仅是内存释放。

* * *

## 回答 #8

> 赞同：6
> 
> 时间：2008-10-02T07:25:09.657

FWIW，Microsoft Visual C++ 确实支持 try,finally，并且它在历史上一直在 MFC 应用程序中用作捕获严重异常的方法，否则会导致崩溃。例如;

```
int CMyApp::Run() 
{
    __try
    {
        int i = CWinApp::Run();
        m_Exitok = MAGIC_EXIT_NO;
        return i;
    }
    __finally
    {
        if (m_Exitok != MAGIC_EXIT_NO)
            FaultHandler();
    }
} 
```

我过去用它来做一些事情，比如在退出之前保存打开文件的备份。不过，某些 JIT 调试设置会破坏这种机制。

* * *

## 回答 #9

> 赞同：6
> 
> 时间：2018-08-08T04:45:55.823

正如其他答案中所指出的，C++ 可以支持`finally`类似的功能。这个功能的实现可能最接近标准语言的一部分，它是伴随着[C++ 核心指南](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)的实现，这是一组由 Bjarne Stoustrup 和 Herb Sutter 编辑的使用 C++ 的最佳实践。的[实现`finally`](https://github.com/Microsoft/GSL/blob/master/include/gsl/gsl_util#L75)是[指南支持库](https://github.com/Microsoft/GSL)(GSL) 的一部分。在整个指南中，`finally`建议在处理旧式接口时使用 ，并且它也有自己的指南，标题为[Use a final_action object to express cleanup if no appropriate resource handle is available](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e19-use-a-final_action-object-to-express-cleanup-if-no-suitable-resource-handle-is-available)。

因此，不仅 C++ 支持`finally`，实际上还建议在许多常见用例中使用它。

GSL 实现的示例使用如下所示：

```
#include <gsl/gsl_util.h>

void example()
{
    int handle = get_some_resource();
    auto handle_clean = gsl::finally([&handle] { clean_that_resource(handle); });

    // Do a lot of stuff, return early and throw exceptions.
    // clean_that_resource will always get called.
} 
```

[GSL 的实现和使用与Paolo.Bolzoni 的答案](https://stackoverflow.com/a/25510879/8680401)中的非常相似。一个区别是由创建的对象`gsl::finally()`缺少`disable()`调用。如果您需要该功能（例如，在组装后返回资源并且不会发生异常），您可能更喜欢 Paolo 的实现。否则，使用 GSL 与使用标准化功能一样接近。

* * *

## 回答 #10

> 赞同：4
> 
> 时间：2015-12-01T01:01:15.780

我有一个用例，我认为它`finally` *应该*是 C++11 语言的一个完全可以接受的部分，因为我认为从流程的角度来看它更容易阅读。我的用例是线程的消费者/生产者链，其中`nullptr`在运行结束时发送哨兵以关闭所有线程。

如果 C++ 支持它，你会希望你的代码看起来像这样：

```
 extern Queue downstream, upstream;

    int Example()
    {
        try
        {
           while(!ExitRequested())
           {
             X* x = upstream.pop();
             if (!x) break;
             x->doSomething();
             downstream.push(x);
           } 
        }
        finally { 
            downstream.push(nullptr);
        }
    } 
```

我认为将 finally 声明放在循环的开头更合乎逻辑，因为它发生在循环退出之后......但这是一厢情愿的想法，因为我们不能在 C++ 中做到这一点。请注意，队列`downstream`连接到另一个线程，因此您不能将哨兵`push(nullptr)`放入析构函数中，`downstream`因为此时无法销毁它......它需要保持活动状态，直到另一个线程接收到`nullptr`.

所以这里是如何使用带有 lambda 的 RAII 类来做同样的事情：

```
 class Finally
    {
    public:

        Finally(std::function<void(void)> callback) : callback_(callback)
        {
        }
        ~Finally()
        {
            callback_();
        }
        std::function<void(void)> callback_;
    }; 
```

下面是你如何使用它：

```
 extern Queue downstream, upstream;

    int Example()
    {
        Finally atEnd([](){ 
           downstream.push(nullptr);
        });
        while(!ExitRequested())
        {
           X* x = upstream.pop();
           if (!x) break;
           x->doSomething();
           downstream.push(x);
        }
    } 
```

* * *

## 回答 #11

> 赞同：3
> 
> 时间：2014-05-30T19:36:59.797

不是真的，但你可以在某种程度上模仿它们，例如：

```
int * array = new int[10000000];
try {
  // Some code that can throw exceptions
  // ...
  throw std::exception();
  // ...
} catch (...) {
  // The finally-block (if an exception is thrown)
  delete[] array;
  // re-throw the exception.
  throw; 
}
// The finally-block (if no exception was thrown)
delete[] array; 
```

请注意，finally 块本身可能会在重新抛出原始异常之前抛出异常，从而丢弃原始异常。这与 Java finally 块中的行为完全相同。此外，您不能`return`在 try&catch 块内使用。

* * *

## 回答 #12

> 赞同：3
> 
> 时间：2016-08-01T14:32:14.543

我想出了一个`finally`可以**像**¹ `finally`Java 中的关键字一样使用的宏；它利用了`std::exception_ptr`and Friends、lambda 函数和`std::promise`，所以它需要`C++11`或以上；它还利用了[复合语句表达式](https://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Statement-Exprs.html)GCC 扩展，clang 也支持。

**警告**：此答案的[早期版本](/revisions/38701485/2)使用了该概念的不同实现，但有更多限制。

首先，让我们定义一个辅助类。

```
#include <future>

template <typename Fun>
class FinallyHelper {
    template <typename T> struct TypeWrapper {};
    using Return = typename std::result_of<Fun()>::type;

public:    
    FinallyHelper(Fun body) {
        try {
            execute(TypeWrapper<Return>(), body);
        }
        catch(...) {
            m_promise.set_exception(std::current_exception());
        }
    }

    Return get() {
        return m_promise.get_future().get();
    }

private:
    template <typename T>
    void execute(T, Fun body) {
        m_promise.set_value(body());
    }

    void execute(TypeWrapper<void>, Fun body) {
        body();
    }

    std::promise<Return> m_promise;
};

template <typename Fun>
FinallyHelper<Fun> make_finally_helper(Fun body) {
    return FinallyHelper<Fun>(body);
} 
```

然后是实际的宏。

```
#define try_with_finally for(auto __finally_helper = make_finally_helper([&] { try 
#define finally });                         \
        true;                               \
        ({return __finally_helper.get();})) \
/***/ 
```

它可以这样使用：

```
void test() {
    try_with_finally {
        raise_exception();
    }    

    catch(const my_exception1&) {
        /*...*/
    }

    catch(const my_exception2&) {
        /*...*/
    }

    finally {
        clean_it_all_up();
    }    
} 
```

的使用`std::promise`使得它很容易实现，但它也可能引入了相当多的不必要的开销，这可以通过仅从`std::promise`.

* * *

¹ **CAVEAT：**有一些东西不像 java 版本的`finally`. 在我的头顶上：

1.  不可能使用and块中的`break`语句从外部循环中断，因为它们存在于 lambda 函数中；`try``catch()`
2.  后面必须至少有一个`catch()`块`try`：这是 C++ 要求；
3.  `try`如果函数具有除 void 以外的返回值，但在and块中没有返回`catch()'s`，则编译将失败，因为`finally`宏将扩展为要返回 a 的代码`void`。错误地，这可能是一个*void* ed，因为它有一个`finally_noreturn`宏。

总而言之，我不知道我自己是否会使用这些东西，但玩它很有趣。:)

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2014-07-09T21:07:57.137

正如许多人所说，解决方案是使用 C++11 特性来避免 finally 块。特点之一是[`unique_ptr`](http://en.cppreference.com/w/cpp/memory/unique_ptr)。

这是 Mephane 使用 RAII 模式编写的答案。

```
#include <vector>
#include <memory>
#include <list>
using namespace std;

class Foo
{
 ...
};

void DoStuff(vector<string> input)
{
    list<unique_ptr<Foo> > myList;

    for (int i = 0; i < input.size(); ++i)
    {
      myList.push_back(unique_ptr<Foo>(new Foo(input[i])));
    }

    DoSomeStuff(myList);
} 
```

更多关于在 C++ 标准库容器中使用 unique_ptr 的介绍在[这里](http://eli.thegreenplace.net/2012/06/20/c11-using-unique_ptr-with-standard-library-containers/)

* * *

## 回答 #14

> 赞同：1
> 
> 时间：2018-12-18T19:28:24.797

我还认为 RIIA 并不是异常处理和 finally 的完全有用的替代品。顺便说一句，我也认为 RIIA 是个坏名声。我称这些类型的类为“看门人”并经常使用它们。95% 的时间他们既没有初始化也没有获取资源，他们在范围内应用了一些更改，或者采用已经设置的东西并确保它被销毁。这是官方模式名称痴迷的互联网我被滥用，甚至暗示我的名字可能更好。

我只是认为要求某些特定事物列表的每个复杂设置都必须编写一个包含它的类以避免在面对需要捕获多个事物时清理所有备份时出现并发症是不合理的如果过程中出现问题，则异常类型。这将导致大量的临时课程，否则就没有必要了。

是的，对于旨在管理特定资源的类或旨在处理一组类似资源的通用类来说，这很好。但是，即使涉及的所有事物都有这样的包装器，清理的协调也可能不仅仅是简单的逆序调用析构函数。

我认为 C++ 有一个 finally 是非常有意义的。我的意思是，天哪，在过去的几十年里，有很多零碎的东西粘在它上面，以至于奇怪的人们会突然对像 finally 这样的东西变得保守，这可能非常有用，而且可能没有其他一些东西那么复杂添加（尽管这只是我的猜测。）

* * *

## 回答 #15

> 赞同：1
> 
> 时间：2015-09-02T09:23:09.227

**已编辑**

**如果您没有中断/继续/返回**等，您可以将捕获添加到任何未知异常并将始终代码放在它后面。这也是您**不需要**重新抛出异常的时候。

```
try{
   // something that might throw exception
} catch( ... ){
   // what to do with uknown exception
}

//final code to be called always,
//don't forget that it might throw some exception too
doSomeCleanUp(); 
```

### 所以有什么问题？

通常，finally 在其他编程语言中通常无论如何都会运行（通常意味着**不管**任何返回、中断、继续......）**除了**某种系统`exit()`- 每个编程语言有很大不同 - 例如 PHP 和 Java 只是退出时刻，但 Python 最终还是执行然后退出。

但是我上面描述的代码不能那样工作
=>**仅** `something wrong!`输出以下代码：

```
#include <stdio.h>
#include <iostream>
#include <string>

std::string test() {
    try{
       // something that might throw exception
       throw "exceptiooon!";

       return "fine";
    } catch( ... ){
       return "something wrong!";
    }

    return "finally";
}

int main(void) {

    std::cout << test();

    return 0;
} 
```

* * *

## 回答 #16

> 赞同：-2
> 
> 时间：2010-04-23T19:28:19.057

```
try
{
  ...
  goto finally;
}
catch(...)
{
  ...
  goto finally;
}
finally:
{
  ...
} 
```

# c# - 在 VS 08 和 C# 中获得生产力的最快方法

> ID：161184
> 
> 赞同：3
> 
> 时间：2008-10-02T07:16:28.837
> 
> 标签：c#, visual-studio, visual-studio-2008, development-environment

我最近一直在使用 Komodo Edit 和其他更简单的编辑器使用 Python，但现在我正在做一个项目，该项目将使用 VS 08 在 C# 中完成。我将不胜感激有关如何尽快在该平台上获得生产力的任何提示。

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-10-02T07:56:07.743

至于精通 C#，我强烈推荐[Programming C#](https://rads.stackoverflow.com/amzn/click/com/0596527438) and [C# in Depth](https://rads.stackoverflow.com/amzn/click/com/1933988363)。

对于 Visual Studio，开始在 IDE 中四处寻找、玩耍、熟悉它。从简单的项目开始，探索所有不同的方面。了解如何[优化 Visual Studio](https://stackoverflow.com/questions/8440/visual-studio-optimizations)并熟悉 IDE 的一些出色的[键盘快捷键/隐藏功能](https://stackoverflow.com/questions/98606/favorite-visual-studio-keyboard-shortcuts)。

绝对至少执行以下每一项：

**项目：**

*   创建一个简单的控制台应用程序（例如 hello world）
*   创建一个类库（托管 .dll）并从您创建的另一个应用程序中使用它
*   创建一个简单的 windows 应用程序
*   创建一个简单的 asp.net 网络应用程序

**调试：**

*   调试命令行应用程序
*   熟悉：断点、locals 和 watch 窗口、step over、step into、step out、continue、stop debug
*   创建一个使用类库中的函数的命令行应用程序。存储库的 dll 和符号文件 (.pdb) 但删除源代码，在进入库时通过应用程序进行调试
*   调试到 web 服务
*   了解如何使用 ILDasm 和 ILAsm

**命令行：**

*   熟悉 Visual Studio 命令行环境
*   仅使用命令行构建
*   使用 devenv.exe /debugexe 从命令行调试
*   从命令行使用 ILDasm / ILAsm 将一个简单的应用程序反汇编成 .IL，将其重新组合成一个不同名称的文件，测试它是否仍然有效

**测试：**

*   创建单元测试（右键单击方法，选择创建测试的选项）
*   了解如何：运行所有单元测试，在调试器下运行所有​​单元测试，重新运行失败的单元测试，查看测试失败的详细信息，运行单元测试的子集
*   了解如何为您的测试收集代码覆盖率统计信息

**源代码控制：**

*   了解如何在使用 VS 进行开发时与您选择的源代码控制系统进行交互

**重构等：**

*   熟悉所有内置重构（尤其是重命名和提取方法）
*   使用“转到定义”
*   使用“查找所有参考”
*   使用“在文件中查找”（ctrl-shift-F）

**IDE 和键盘快捷键：**

*   了解如何将设计器很好地用于 web 和 winforms
*   熟悉解决方案资源管理器窗口
*   尝试不同的窗口布局，直到找到适合自己的布局，稍后继续尝试，看看这是否仍然是最佳选择
*   了解智能感知的来龙去脉，尽可能地利用它
*   了解您所做的一切的键盘快捷键

* * *

## 回答 #2

> 赞同：8
> 
> 时间：2008-10-02T07:23:56.367

我个人会首先专注于学习 C# 和 .NET 的核心部分。对我来说，这意味着编写控制台应用程序（而不是 Windows 窗体）来试验语言和 IO 等重要方面。当您对基础感到满意时，请转向您的项目所需的任何“外围”技术（WinForms、WPF、ASP.NET、WCF 等）。

在书籍方面，我可以推荐[C# 3.0 in a Nutshell](http://msmvps.com/blogs/jon_skeet/archive/2008/03/31/book-review-c-3-0-in-a-nutshell.aspx)和[Accelerated C# 2008](http://msmvps.com/blogs/jon_skeet/archive/2008/08/01/book-review-accelerated-c-2008-by-trey-nash.aspx)。链接是我对这些书的评论。两者都涵盖语言 + 核心库。一开始我不会太担心 LINQ - 在处理 LINQ 之前，先熟悉语言的其余部分，尤其是委托和泛型。那时，我*强烈*建议您在开始使用 LINQ to SQL 或实体框架之前先使用 LINQ to Objects 一段时间。（另一方面，如果您需要使用 XML，我会直接使用 LINQ to XML - 它是一个完整的 XML API，而不仅仅是一个 LINQ 提供程序。它比普通的 DOM API 好得多。）

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-02T07:21:44.330

选择一个您过去完成的 Python 项目并将其手动转换为 C#。这就是我学习我目前知道的每一种语言的方式（x86 汇编除外）。

考虑使用 IronPython 来帮助弥合差距 - 您可以通过 IronPython 引用 .NET 程序集，以及创建 .NET 程序集以从 C# 引用。

另外，请**远离**那些*在 21 天内学习 C#！*书籍...它们几乎从不辜负炒作，而且通常弊大于利。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-10-02T07:22:35.420

> 我将不胜感激有关如何尽快在该平台上提高工作效率的任何提示。

实践经验我的朋友。*尽快**开始*使用它*以尽快*提高工作效率。

 *一些明显的建议是：

*   为频繁操作创建快捷方式\宏\模板。*强迫*自己使用快捷方式而不是点击菜单
*   安装 ReSharper - in 会给你 1000% 的生产力提升（如果你有几块钱买的话）

并且不要犹豫不时查看[手册:)](http://msdn.microsoft.com/en-us/vstudio/default.aspx)

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T07:21:23.643

获得一本好书并开始阅读。我有[Pro C# 2008 和 .NET 3.5 Platform](https://rads.stackoverflow.com/amzn/click/com/1590598849)。

既然你有一个项目要处理，那也应该有很大帮助。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T07:46:25.910

我认为从 Python 到 C# 的转变是进化阶梯的一步。期待更详细的体验（例如变量声明和类属性）。

密切关注[IronPython——](http://www.codeplex.com/IronPython)它将帮助您使用熟悉的语言感受 .NET。Python 的动态特性使得检查 .NET 行为比检查 C# 中的想法要快得多。您可以通过[IronPython](http://www.codeplex.com/IronPython) Studio 直接从 Visual Studio 中使用[IronPython](http://www.codeplex.com/IronPythonStudio)。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-02T09:04:09.030

**Python 到 C# 的转换**

您通常通过将其功能与您已经知道的语言进行比较来学习下一种语言。由于您熟悉 Python，因此请阅读一些 Python/C# 比较，例如[“A Python Programmmer's Perspective on C#”](http://jjinux.blogspot.com/2008/09/python-programmmers-perspective-on-c.html)和[“Does C# 3.0 Beat Dynamic Languages at their Own Game？”](http://www.25hoursaday.com/weblog/2008/01/02/DoesC30BeatDynamicLanguagesAtTheirOwnGame.aspx) . C# 3.5 和 Python 之间的差异并不大。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-02T07:20:55.440

做一些小项目。我头顶的一些。

1) Hello world
2) 控制台
3) GUI 设计
4) 玩具项目

与阅读教程相比，它们会让你更快上手。喝杯啤酒，玩得开心。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-02T07:20:59.870

微软为此提供了一个很好的学习平台：

[http://msdn.microsoft.com/en-us/vcsharp/aa336766.aspx](http://msdn.microsoft.com/en-us/vcsharp/aa336766.aspx)

我建议看一下“我如何”视频系列。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-10-02T07:21:20.743

我认为这取决于几件事。例如，您使用键盘多于鼠标吗？如果是这样，我会学习 VS 快捷方式。你了解 C# 吗？读一些书。我知道这很模糊，但这是一个有点模糊的问题。

实践，实践，实践，获得经验，变得富有成效。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-10-02T07:34:24.143

对于每一种工具、系统、语言或其他任何东西，获得生产力的最快方法是（至少对我而言）了解背景，而不是从 hello world 开始，然后从一个命令跌跌撞撞地跳到你认为需要的下一个命令。

所以买一本好书（比如微软出版社）或者去微软 MSDN 和 Technet 并尽可能多地阅读背景资料。详细的东西（在书本或互联网上）可以稍后参考。

此外 - 为了提高生产力 - 加入邮件列表、IRC、用户组等，使用相同的工具、系统、语言等来了解其他人的日常问题。

然后 - 一两周后 - 开始编程。

我知道，这不是一个人从一门新语言开始时想做的事情。但对我来说，这种方法在过去几年里效果最好。

# delphi - Delphi IDE 中的错误“无法在 OnShow 或 OnHide 中更改可见”

> ID：161187
> 
> 赞同：2
> 
> 时间：2008-10-02T07:19:17.893
> 
> 标签：delphi, ide

Delphi 2006 IDE 有一个非常奇怪的问题。

如果 IDE 被最小化，并且 PC 被锁定。我回到电脑，解锁它并最大化 IDE，我有时会收到错误“无法在 OnShow 或 OnHide 中更改 Visible”。

如果发生这种情况，我必须用任务管理器杀死 IDE。

有没有人有同样的问题？如果可能的话，一个解决方案？

我怀疑涉及某些第三方组件，但我的同事从未遇到此错误。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T10:46:23.793

是的，我在使用终端服务器时注意到了同样的问题。我使用 GExperts。如果您可以重现该问题，您应该在[http://qc.codegear.com/上报告它](http://qc.codegear.com/)

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T07:47:04.910

这是否与您目前打开的特定表格相关联？

如果不是，那么导致问题的可能不是第 3 方组件，而是您添加到 Delphi 的专家。尝试禁用所有专家。如果这样可以解决问题，请一一添加。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2009-01-27T08:34:16.917

无需在任务管理器中终止 IDE 的其他方法是显示任务栏设置并关闭“显示在其他窗口上方”。使用此设置，在 IDE err 上单击确定。味精，然后将其设置回来。通过一些练习，它可能会随着时间的推移而有用......

顺便说一句：同事的 IDE 布局设置是“经典未停靠”，他从来没有遇到过这个问题。

但是仍然缺少诸如错误修复之类的东西：/（WinXP，TurboDelphi 2006）

# c# - 使用 HTTP 代理上传 FTP 文件

> ID：161200
> 
> 赞同：20
> 
> 时间：2008-10-02T07:23:21.953
> 
> 标签：c#, proxy, ftp

有没有办法在 HTTP 代理后面将文件上传到 FTP 服务器？

似乎不支持在使​​用 .Net Webclient 的 HTTP 代理后面上传文件。（[http://msdn.microsoft.com/en-us/library/system.net.ftpwebrequest.proxy.aspx](http://msdn.microsoft.com/en-us/library/system.net.ftpwebrequest.proxy.aspx)）。

如果没有解决方法？如果没有，你知道我可以使用一个好的免费 FTP 库吗？

**编辑**：不幸的是，我没有任何 FTP 代理可以连接。

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-10-02T11:29:13.987

在主动 FTP 模式下，服务器向客户端发起数据连接。如果客户端在 HTTP 代理后面，这显然是行不通的。在被动 FTP 模式下，发起初始连接和数据连接的是客户端。由于 HTTP 代理可以通过隧道传输任意传出 TCP 连接（使用 CONNECT 方法），因此应该可以通过 HTTP 代理以被动模式访问 FTP 服务器。

`FtpWebRequest`似乎支持被动模式。但是，我不明白为什么支持文件下载和目录列表，而同样使用相同数据连接的文件上传却不支持。

您是否确认`FtpWebRequest`配置为被动模式不能通过 HTTP 代理工作，通过该代理目录列表/文件下载工作正常？

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2009-05-28T07:43:00.087

我们的[Rebex FTP/SSL](http://www.rebex.net/ftp-ssl.net/tutorial-ftp.aspx#proxy)可以使用 HTTP 代理。虽然不是免费的...

```
// initialize FTP client 
Ftp client = new Ftp();

// setup proxy details  
client.Proxy.ProxyType = FtpProxyType.HttpConnect;
client.Proxy.Host = proxyHostname;
client.Proxy.Port = proxyPort;

// add proxy username and password when needed 
client.Proxy.UserName = proxyUsername;
client.Proxy.Password = proxyPassword;

// connect, login 
client.Connect(hostname, port);
client.Login(username, password);

// do some work 
// ... 

// disconnect 
client.Disconnect(); 
```

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-10-02T11:31:57.207

大多数 FTP 代理在连接上做他们的事情，所以如果你没有代理，你这样做：

*   服务器：myftpserver.com
*   用户：我
*   密码：pwd

使用 FTP 代理，您可以：

*   服务器：ftpproxy.mydomain.com
*   用户：me@myftpserver.com
*   密码：pwd

它只是从那里解决问题。我正在通过 squid 代理使用这个 RIGHT THIS SECOND（试图调试某些东西）。

...但是由于您没有 FTP 代理....

你有 SOCKS 代理吗？这可能有效，但我不知道.NET 是否可以做到。否则，老实说，我认为你被卡住了！与 HTTP 相比，FTP 是一种“奇怪”的协议，因为它有一个控制通道（端口 21）和一个数据通道（或多个，在一个随机端口上），所以通过代理是……有趣至少说！

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2015-11-03T15:34:23.607

从 .NET 框架 4.8 开始，[`FtpWebRequest`](https://docs.microsoft.com/en-us/dotnet/api/system.net.ftpwebrequest)仍然[无法通过 HTTP 代理上传文件](https://docs.microsoft.com/en-us/dotnet/api/system.net.ftpwebrequest.proxy)。

> 如果指定的代理是 HTTP 代理，则仅支持 DownloadFile、ListDirectory 和 ListDirectoryDe​​tails 命令。

它可能永远不会像`FtpWebRequest`现在被弃用的那样。所以你需要使用第 3 方 FTP 库。

* * *

例如，使用[WinSCP .NET 程序集](https://winscp.net/eng/docs/library)，您可以使用：

```
// Setup session options
SessionOptions sessionOptions = new SessionOptions
{
    Protocol = Protocol.Ftp,
    HostName = "example.com",
    UserName = "user",
    Password = "mypassword",
};

// Configure proxy
sessionOptions.AddRawSettings("ProxyMethod", "3");
sessionOptions.AddRawSettings("ProxyHost", "proxy");

using (Session session = new Session())
{
    // Connect
    session.Open(sessionOptions);

    // Upload file
    string localFilePath = @"C:\path\file.txt";
    string pathUpload = "/file.txt";
    session.PutFiles(localFilePath, pathUpload).Check();
} 
```

有关 tje 的选项[`SessionOptions.AddRawSettings`](https://winscp.net/eng/docs/library_sessionoptions_addrawsettings)，请参阅[原始设置](https://winscp.net/eng/docs/rawsettings)。

更简单的是让 WinSCP GUI为您[生成 C# FTP 代码模板](https://winscp.net/eng/docs/ui_generateurl#code)。

请注意，WinSCP .NET 程序集不是本机 .NET 库。它是控制台应用程序上的一个瘦 .NET 包装器。

*（我是WinSCP的作者）*

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-10-02T13:40:26.777

一种解决方案是尝试 Mono 的 FtpWebRequest 实现。我查看了它的源代码，它似乎很容易修改，以便所有连接（控制和数据）都通过 HTTP 代理进行隧道传输。

您建立到 HTTP 代理的 TCP 连接，而不是实际的 FTP 服务器。然后你发送`CONNECT myserver:21 HTTP/1.0`后跟两个 CRLF (CRLF = \r\n)。如果代理需要身份验证，您需要使用 HTTP/1.1 并发送带有凭据的代理身份验证标头。然后你需要阅读响应的第一行。如果它以“ `HTTP/1.0 200` ”或“ `HTTP/1.1 200` ”开头，那么您（其余代码）可以继续使用该连接，就好像它直接连接到 FTP 服务器一样。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-10-02T12:09:37.570

正如 Alexander 所说，HTTP 代理可以代理任意流量。您需要的是支持使用 HTTP 代理的 FTP 客户端。亚历山大也是正确的，这只能在被动模式下工作。

我的雇主销售这样一个 FTP 客户端，但它是一个企业级工具，仅作为一个非常大的系统的一部分提供。

我敢肯定，还有其他更适合您的需求。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-10-02T11:42:05.483

*如果有一种方法可以让您在没有*C# 的情况下通过 FTP 上传文件，那么在 C# 中也应该可以。通过浏览器或 FTP 客户端上传是否有效？

我最喜欢的一个 FTP 库是[.NET FTP 客户端库](http://sourceforge.net/projects/dotnetftpclient)。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2011-06-27T22:20:24.517

通过 HTTP 代理将内容上传到 ftp:// URL 的标准方法是使用 HTTP PUT 请求。在处理 ftp:// URL 时，HTTP 代理充当 HTTP<->FTP 网关，向请求客户端发送 HTTP，向请求的 FTP 服务器发送 FTP。

至少 Squid HTTP 代理支持 PUT 到 ftp:// URL，不确定其他代理做什么。

更常见的方法是滥用 CONNECT 方法在代理上建立隧道。但这通常是不允许的，因为允许在代理上建立双向隧道的安全隐患。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2013-02-01T13:49:34.133

您好我有同样的问题 - 解决方案是创建代理对象并派生默认凭据 - 如果您的应用程序使用网络帐户运行，这应该没问题 -

```
FtpWebRequest reqFTP = (FtpWebRequest)FtpWebRequest.Create(new Uri(uri));

System.Net.WebProxy proxy = System.Net.WebProxy.GetDefaultProxy();
proxy.Credentials = System.Net.CredentialCache.DefaultCredentials;

// set the ftpWebRequest proxy
reqFTP.Proxy = proxy; 
```

这为我解决了这个问题。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2013-12-03T14:25:13.557

该死的这些不自由的应用程序和组件！！！这是我的开源 C# 代码，可以通过 HTTP 代理将文件上传到 FTP。

```
 public bool UploadFile(string localFilePath, string remoteDirectory)
    {
        var fileName = Path.GetFileName(localFilePath);
        string content;
        using (var reader = new StreamReader(localFilePath))
            content = reader.ReadToEnd();

        var proxyAuthB64Str = Convert.ToBase64String(Encoding.ASCII.GetBytes(_proxyUserName + ":" + _proxyPassword));
        var sendStr = "PUT ftp://" + _ftpLogin + ":" + _ftpPassword
            + "@" + _ftpHost + remoteDirectory + fileName + " HTTP/1.1\n"
            + "Host: " + _ftpHost + "\n"
            + "User-Agent: Mozilla/4.0 (compatible; Eradicator; dotNetClient)\n" + "Proxy-Authorization: Basic " + proxyAuthB64Str + "\n"
            + "Content-Type: application/octet-stream\n"
            + "Content-Length: " + content.Length + "\n"
            + "Connection: close\n\n" + content;

        var sendBytes = Encoding.ASCII.GetBytes(sendStr);

        using (var proxySocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))
        {
            proxySocket.Connect(_proxyHost, _proxyPort);
            if (!proxySocket.Connected)
                throw new SocketException();
            proxySocket.Send(sendBytes);

            const int recvSize = 65536;
            var recvBytes = new byte[recvSize];
            proxySocket.Receive(recvBytes, recvSize, SocketFlags.Partial);

            var responseFirstLine = new string(Encoding.ASCII.GetChars(recvBytes)).Split("\n".ToCharArray()).Take(1).ElementAt(0);
            var httpResponseCode = Regex.Replace(responseFirstLine, @"HTTP/1\.\d (\d+) (\w+)", "$1");
            var httpResponseDescription = Regex.Replace(responseFirstLine, @"HTTP/1\.\d (\d+) (\w+)", "$2");
            return httpResponseCode.StartsWith("2");
        }
        return false;
    } 
```

* * *

## 回答 #11

> 赞同：-1
> 
> 时间：2009-09-04T10:55:20.367

我刚刚遇到了同样的问题。

我的主要目标是将文件上传到 ftp。而且我不在乎我的流量是否会通过代理。

所以我刚刚在 FTPWebRequest.Create(uri) 之后将 FTPWebRequest.Proxy 属性设置为 null。

它奏效了。是的，我知道这个解决方案不是最好的。还有更多，我不明白为什么它会起作用。但无论如何，目标已经完成。

* * *

## 回答 #12

> 赞同：-1
> 
> 时间：2013-11-14T12:02:37.573

我不确定所有 HTTP 代理是否都以相同的方式工作，但我设法通过简单地创建一个 HTTP 请求来访问 URI [ftp://user:pass@your.server.com/path](ftp://user:pass@your.server.com/path)上的资源来欺骗我们的代理。

遗憾的是，要创建 HttpWebRequest 的实例，您应该使用 WebRequest.Create。如果这样做，您将无法为 ftp:// 模式创建 HTTP 请求。

所以我使用了一些反射来调用一个非公共构造函数，它这样做：

```
var ctor = typeof(HttpWebRequest).GetConstructor(
    BindingFlags.NonPublic | BindingFlags.Instance, 
    null, 
    new Type[] { typeof(Uri), typeof(ServicePoint) }, 
    null);
var req = (WebRequest)ctor.Invoke(new object[] { new Uri("ftp://user:pass@host/test.txt"), null });
req.Proxy = new WebProxy("myproxy", 8080);
req.Method = WebRequestMethods.Http.Put;

using (var inStream = req.GetRequestStream())
{
    var buffer = Encoding.ASCII.GetBytes("test upload");
    inStream.Write(buffer, 0, buffer.Length);
}

using (req.GetResponse())
{
} 
```

您还可以对其他任务使用其他方法，例如“DELETE”。

就我而言，它就像一个魅力。

* * *

## 回答 #13

> 赞同：-5
> 
> 时间：2008-10-02T08:04:54.943

我并没有真正看到 http 代理和上传到 ftp 服务器之间的连接。如果您使用 http 代理类，那就是通过 http 代理访问 http 资源。ftp 是另一种协议，而 ftp 代理使用不同的协议。

# email - 以编程方式发送大量电子邮件

> ID：161212
> 
> 赞同：2
> 
> 时间：2008-10-02T07:31:57.940
> 
> 标签：email, programming-languages

我需要能够定期向订阅用户发送电子邮件警报。PHP 似乎很难发送*一条*消息，所以我正在寻找好的替代方案。

如果实现速度足够快，任何语言都可以。发送的邮件数量最终将达到数千。

如果可以避免购买许可软件，那就更好了。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T12:55:40.940

[php 中的电子邮件队列](https://stackoverflow.com/questions/17609/email-queueing-in-php#17696)- 简短版本 - Pear 的 Mail_Queue。一年多来，我一直在使用它每天或更多（每周几天）发送 30-50,000 多封邮件，没有任何问题。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T07:33:54.737

我们有各种应用程序写入数据库表中的电子邮件队列，以及一个 .Net Windows 服务轮询该表以撰写电子邮件并通过我们的邮件服务器发送出去。

我们每分钟最多可以发送 1000 封电子邮件...

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T07:43:06.947

对于 Java，有[http://java.sun.com/products/javamail/](http://java.sun.com/products/javamail/) 我在应用程序中使用过它。很容易设置和使用。

在 Ruby 中它非常简单，但我没有使用过它，所以不能说任何关于性能的事情。 [http://snippets.dzone.com/posts/show/2362](http://snippets.dzone.com/posts/show/2362)

那就是说...我怀疑PHP本身发送邮件的速度太慢了。也许您的应用程序有一些瓶颈？

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-02T07:59:24.333

只想提一下，在我之前的工作中，我们用 PHP 创建了一个海量电子邮件解决方案，效果很好，所以我不明白为什么你会完全排除它：）

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T08:01:11.897

python 中的 smtplib 是一个轻而易举的设置和一个非常干净的 API。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T12:49:05.183

您可以做的一件事是将问题的焦点转移到底层邮件软件。例如，如果我想发送大量电子邮件，我会使用任何语言以 BSMTP 格式将它们写出来，这基本上看起来像简单的 SMTP 客户端命令。就像是：

```
MAIL FROM:<me@example.com>
RCPT TO:<you@example.com>
DATA
From: Me <me@example.com>
To: You <you@example.com>
Subject: test email

This is the body of the test email I'm sending
. 
```

然后我会通过 exim 提供 BSMTP 文件：

```
cat *.bsmtp | exim -bS 
```

这基本上消除了从您的程序发送电子邮件的延迟，并将负担放在 exim 上（作为 MTA，它更有能力处理它）。

一旦你掌握了基础知识，你就可以修改很多东西来提高效率。例如，如果您的电子邮件不是自定义的，您可以通过将同一域的所有收件人放入同一个 BSMTP 文件中来进行预优化：

```
MAIL FROM:<me@example.com>
RCPT TO:<you@example.com>
RCPT TO:<him@example.com>
RCPT TO:<her@example.com>
RCPT TO:<them@example.com>
DATA
From: Me <me@example.com>
To: Me <me@example.com>
Subject: test email

This is the body of the test email I'm sending
. 
```

然后，您还可以在如何优化 MTA 本身以发送邮件方面获得大量回旋余地（例如，它将自动处理并行传递、通过同一 TCP 连接将电子邮件传递到同一邮件服务器等）。

关于在代码中做这件事，我们曾经有一个 perl 库来帮助我们做这些事情。本质上，您将电子邮件和地址提供给它，它会根据需要分叉对邮件服务器的调用。它可以配置允许的并行会话数，它还监视服务器上的负载，如果负载超过用户可配置的阈值，它就会节流。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T12:58:15.723

我使用一个名为 e-Campaign 的程序读取 CSV 文件。如果您必须以编程方式执行此操作，那么您可能需要构建一种等待技术，这样您就不会尝试一次发送 10,000 封电子邮件。使用 e-Campaign，您可以选择一次发送多少封电子邮件，并在这些批次之间设置休息时间。它仍然非常快，但不会导致服务器过载问题。

* * *

## 回答 #8

> 赞同：-2
> 
> 时间：2008-10-02T07:48:40.850

有一个名为 blat 的基于 dos 的命令行工具，您可以非常轻松地下载和发送电子邮件

# asp.net - 在 WebForms 中使用 system.web.routing 时的状态服务

> ID：161221
> 
> 赞同：0
> 
> 时间：2008-10-02T07:37:08.177
> 
> 标签：asp.net, iis-7, routing

我在 WebForms 应用程序中使用 System.Web.Routing 程序集。运行部署在 win2008/IIS7 上的应用程序时，我收到以下消息。

> 会话状态只能在 enableSessionState 设置为 true 时使用，无论是在配置文件中还是在 Page 指令中。还请确保 System.Web.SessionStateModule 或自定义会话状态模块包含在应用程序配置的 \\ 部分中。

这只是使用我配置的路由时的问题。直接导航到 aspx 页面时，这不是问题。

在 web.config 和 Page 指令中都启用了 EnableSessionState。我已将 Session 条目添加到 web.config 的 httpmodule 中。

在我的工作站上使用 Visual Studio 进行开发时，这不是问题。只有在 Win 2008 上尝试在 IIS7 下运行应用程序时才会出现问题。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2009-06-04T13:44:35.287

我有同样的问题，我想我知道问题是什么。

我正在尝试在路由系统下实现 FileNotFound 页面（我还没有弄清楚如何同时提供 FileNotFound 页面并在标题中提供 404 响应）

我发现，出于某种原因，使用 BuildManager 注册的页面似乎在没有会话上下文的情况下被实例化（该页面实际上没有被请求，只是被实例化了！）。

至少它似乎是这样做的。

* * *

我现在不太确定我之前的断言。显然，当图像请求在物理上不存在时，它们也会通过路由系统。当图像路径匹配时，这会导致`IRouteHandler`调用。我很确定在请求图像时会话对象不存在，因此当路由到的页面尝试访问它时可能会导致问题。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2009-11-17T20:32:48.077

我认为您所描述的与我的一个[问题](https://stackoverflow.com/questions/1724393/why-wont-iis-6-redirect-my-request-when-it-works-with-vs2008-development-server/1751353#1751353)相似。

可能是您的 IIS7 以不同的模式运行，而且更像 II6 而不是 7：

几个问题： 1\. 您的映射是否正确重定向了您的请求？2\. 当你的请求被映射到哪里？3\. 如果你通过这个页面追踪是哪一行代码产生了错误（它甚至会影响你的代码）吗？

# eclipse - 如何在 Eclipse 项目中使用持续集成？

> ID：161222
> 
> 赞同：5
> 
> 时间：2008-10-02T07:37:10.423
> 
> 标签：eclipse, continuous-integration, build-automation, infinitest, javarebel

我一直在使用 maven2 和 hudson 进行持续集成，但我发现 Eclipse 和 Maven 不能很好地配合使用。当然有一个插件，但是将 maven 项目混搭成 eclipse 喜欢的东西，构建时间和单元测试太长了。我正在考虑切换回一个没有 ant 和 maven 的纯 Eclipse 项目。使用无限的插件和可能的 JavaRebel 代理，它会给我一个非常快速的构建-部署-测试周期。但是我仍然希望有自动和测试，所以：

如何在 Eclipse 项目中使用持续集成？

有命令行方法吗？

是否有本地已经支持它的构建服务器？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-02T09:18:25.953

是的，Eclipse Maven2 插件现在很垃圾。但我建议你坚持下去，使用 Maven2 有很多好处，所以它实际上是平衡的。

我们所做的是，我们使用 Eclipse 来开发，并且只使用 Maven 来管理依赖关系。其他一切都是通过在命令行上运行“mvn”来完成的。我们将测试保存在他们自己的集成测试项目（...-itest）中，并让持续集成服务器分两个阶段进行构建，首先构建实际代码，然后通过构建并运行 -itest 项目。（第一次通过（纯构建）通常非常快，而集成测试构建（运行测试）通常需要相当长的时间。）

这是使 mvn 运行测试的命令行： `mvn -o verify -Ditest`

当然，你需要在你的父 pom 中定义“itest”配置文件：说，像这样：

```
<profiles>
  <profile>
    <id>integration-test</id>
    <activation>
      <property>
        <name>itest</name>
      </property>
    </activation>
    <build>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-surefire-plugin</artifactId>
          <executions>
            <execution>
              <id>itest</id>
            </execution>
          </executions>
          <configuration>
            <testSourceDirectory>src/main</testSourceDirectory>
            <testClassesDirectory>target/classes</testClassesDirectory>
            <forkMode>once</forkMode>
          </configuration>
        </plugin>
      </plugins>
    </build>
  </profile>
</profiles> 
```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-23T13:32:53.907

我设法找到了一个好的解决方案。在使用 maven 和 eclipse 时，我只是得到了无限的（可以从 Eclipse 市场安装）工作

在 Eclipse->Project Properties->Java Build Path->Source 中取消选中名为“Allow output folder for source folder”的框

这将使您的项目具有多个输出路径，然后 Eclipse 将开始将测试类报告为类路径的一部分。Infinitest 现在找到它并开始运行测试！

我所做的只是使用官方的 Maven Eclipse 插件并将其添加到我的 POM

```
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.5</version>
        <!-- <scope>provided</scope> -->
    </dependency>

    <dependency>
        <groupId>org.infinitest</groupId>
        <artifactId>infinitest</artifactId>
        <scope>test</scope>
        <version>4.0</version>
    </dependency>

</dependencies> 
```

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-08T20:21:06.240

我在使用带有 CruiseControl 的 Eclipse + Ant 方面取得了相当大的成功。如果您想要自动化，您可能需要的不仅仅是纯 Eclipse。

CruiseControl 可以自动从源代码管理中检出您的项目副本、构建它、运行测试，然后使用结果更新 Web 应用程序。我上次使用它时非常光滑，但那是很久以前的事了。

# c# - ASP.NET MVC 中的站点范围过滤器

> ID：161223
> 
> 赞同：1
> 
> 时间：2008-10-02T07:37:20.393
> 
> 标签：c#, asp.net-mvc

在 ASP.NET MVC 应用程序中启用站点范围过滤器的最佳方法是什么？

为了澄清，我的母版页中有一个表单，它有一个下拉列表 =，它的值过滤了网站上的每个页面。每个单独的页面也有它自己的表单元素。我真的宁愿在整个页面上都没有表单元素（一个普通的 WebForms），但是当标题中的站点范围过滤器发生更改时，我很难知道要调用什么。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-03T09:00:41.333

我可能会在母版页上使用一个小表单，并在提交到其控制器时将值从下拉列表保存到会话。
然后每个其他控制器都可以检查会话中的值并对其进行处理，并且您还可以在视图上拥有更多表单。
但同样，也许我不明白你的问题:)

# java - Hibernate中不同的保存方式有什么区别？

> ID：161224
> 
> 赞同：208
> 
> 时间：2008-10-02T07:38:12.590
> 
> 标签：java, hibernate, persistence

Hibernate 有一些方法，它们以一种或另一种方式获取您的对象并将其放入数据库。它们之间有什么区别，什么时候使用哪个，为什么不只有一种智能方法知道什么时候使用什么？

到目前为止，我已经确定的方法是：

*   `save()`
*   `update()`
*   `saveOrUpdate()`
*   `saveOrUpdateCopy()`
*   `merge()`
*   `persist()`

* * *

## 回答 #1

> 赞同：120
> 
> 时间：2008-10-02T08:32:45.923

这是我对这些方法的理解。这些主要是基于[API](http://www.hibernate.org/hib_docs/v3/api/org/hibernate/Session.html)，但我在实践中并没有使用所有这些。

**saveOrUpdate** 根据某些检查调用保存或更新。例如，如果不存在标识符，则调用 save。否则调用更新。

**保存** 实体。如果不存在，将分配一个标识符。如果是这样，它本质上是在进行更新。返回生成的实体 ID。

**update** 尝试使用现有标识符来持久化实体。如果不存在标识符，我相信会引发异常。

**saveOrUpdateCopy** 这已被弃用，不应再使用。取而代之的是...

**合并** 现在这是我的知识开始动摇的地方。这里重要的是瞬态、分离和持久实体之间的区别。有关对象状态的更多信息，[请查看此处](http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/objectstate.html)。使用保存和更新，您正在处理持久对象。它们与 Session 相关联，因此 Hibernate 知道发生了什么变化。但是当你有一个瞬态对象时，就不会涉及会话。在这些情况下，您需要使用合并进行更新并持久保存。

**persist** 如上所述，这用于瞬态对象。它不返回生成的 ID。

* * *

## 回答 #2

> 赞同：117
> 
> 时间：2013-09-03T20:30:57.913

```
╔══════════════╦═══════════════════════════════╦════════════════════════════════╗
║    METHOD    ║            TRANSIENT          ║            DETACHED            ║
╠══════════════╬═══════════════════════════════╬════════════════════════════════╣
║              ║       sets id if doesn't      ║   sets new id even if object   ║
║    save()    ║     exist, persists to db,    ║    already has it, persists    ║
║              ║    returns attached object    ║ to DB, returns attached object ║
╠══════════════╬═══════════════════════════════╬════════════════════════════════╣
║              ║       sets id on object       ║             throws             ║
║   persist()  ║     persists object to DB     ║       PersistenceException     ║
║              ║                               ║                                ║
╠══════════════╬═══════════════════════════════╬════════════════════════════════╣
║              ║                               ║                                ║
║   update()   ║           Exception           ║     persists and reattaches    ║
║              ║                               ║                                ║
╠══════════════╬═══════════════════════════════╬════════════════════════════════╣
║              ║  copy the state of object in  ║    copy the state of obj in    ║
║    merge()   ║     DB, doesn't attach it,    ║      DB, doesn't attach it,    ║
║              ║    returns attached object    ║     returns attached object    ║
╠══════════════╬═══════════════════════════════╬════════════════════════════════╣
║              ║                               ║                                ║
║saveOrUpdate()║           as save()           ║            as update()         ║
║              ║                               ║                                ║
╚══════════════╩═══════════════════════════════╩════════════════════════════════╝ 
```

* * *

## 回答 #3

> 赞同：69
> 
> 时间：2008-10-02T09:05:00.290

*   请参阅[Hibernate 论坛](http://forum.hibernate.org/viewtopic.php?t=951275&highlight=difference+persist+save)以了解持久和保存之间的细微差别。看起来差异在于最终执行 INSERT 语句的时间。由于**save**确实返回了标识符，因此无论事务的状态如何，都必须立即执行 INSERT 语句（这通常是一件坏事）。**Persist**不会仅仅为了分配标识符而在当前运行的事务之外执行任何语句。Save/Persist 都适用于*瞬态实例*，即尚未分配标识符且因此未保存在数据库中的实例。

*   **更新**和**合并**都适用于*分离的实例*，即在数据库中有相应条目但当前未附加到会话（或由会话管理）的实例。它们之间的区别在于传递给函数的实例会发生什么。**update**尝试重新附加实例，这意味着现在不能有其他持久实体实例附加到 Session，否则将引发异常。**然而， merge**只是将所有值复制到 Session 中的持久实例（如果当前未加载，则会加载该实例）。输入对象没有改变。所以**合并**比**更新更通用**，但可能会使用更多资源。

* * *

## 回答 #4

> 赞同：17
> 
> 时间：2019-02-27T13:52:39.127

大多数时候，您应该更喜欢 JPA 方法，以及`update`批处理任务。

JPA 或 Hibernate 实体可以处于以下四种状态之一：

*   瞬态（新）
*   托管（持久）
*   分离式
*   已移除（已删除）

从一种状态到另一种状态的转换是通过 EntityManager 或 Session 方法完成的。

例如，JPA`EntityManager`提供了以下实体状态转换方法。

[![JPA 实体状态转换](https://i.stack.imgur.com/rJY2u.png)](https://vladmihalcea.com/a-beginners-guide-to-jpa-hibernate-entity-state-transitions/)

Hibernate`Session`实现了所有的 JPA`EntityManager`方法并提供了一些额外的实体状态转换方法，如[`save`](https://vladmihalcea.com/jpa-persist-merge-hibernate-save-update-saveorupdate/)、[`saveOrUpdate`](https://vladmihalcea.com/jpa-persist-merge-hibernate-save-update-saveorupdate/)和[`update`](https://vladmihalcea.com/jpa-persist-merge-hibernate-save-update-saveorupdate/).

[![Hibernate 实体状态转换](https://i.stack.imgur.com/NsKnR.png)](https://vladmihalcea.com/a-beginners-guide-to-jpa-hibernate-entity-state-transitions/)

## 坚持

要将实体的状态从 Transient (New) 更改为 Managed (Persisted)，我们可以使用[`persist`](https://vladmihalcea.com/jpa-persist-merge-hibernate-save-update-saveorupdate/)JPA 提供的方法，该方法`EntityManager`也由 Hibernate 继承`Session`。

> 该`persist`方法触发`PersistEvent`由`DefaultPersistEventListener`Hibernate 事件侦听器处理的 a。

因此，在执行以下测试用例时：

```
doInJPA(entityManager -> {
    Book book = new Book()
    .setIsbn("978-9730228236")
    .setTitle("High-Performance Java Persistence")
    .setAuthor("Vlad Mihalcea");

    entityManager.persist(book);

    LOGGER.info(
        "Persisting the Book entity with the id: {}", 
        book.getId()
    );
}); 
```

Hibernate 生成以下 SQL 语句：

```
CALL NEXT VALUE FOR hibernate_sequence

-- Persisting the Book entity with the id: 1

INSERT INTO book (
    author, 
    isbn, 
    title, 
    id
) 
VALUES (
    'Vlad Mihalcea', 
    '978-9730228236', 
    'High-Performance Java Persistence', 
    1
) 
```

请注意，在将实体附加到当前持久性上下文`id`之前分配了。`Book`这是必需的，因为托管实体存储在一个`Map`结构中，其中键由实体类型及其标识符组成，值是实体引用。这就是为什么 JPA`EntityManager`和 Hibernate`Session`被称为一级缓存的原因。

调用`persist`时，实体只附加到当前运行的持久化上下文中，INSERT 可以推迟到`flush`被调用。

唯一的例外是[`IDENTITY`](https://vladmihalcea.com/hibernate-identity-sequence-and-table-sequence-generator/)立即触发 INSERT，因为这是获取实体标识符的唯一方法。出于这个原因，Hibernate 不能使用`IDENTITY`生成器为实体批量插入。

## 节省

特定于 Hibernate 的`save`方法早于 JPA，并且自 Hibernate 项目开始时就可用。

> 该`save`方法触发`SaveOrUpdateEvent`由`DefaultSaveOrUpdateEventListener`Hibernate 事件侦听器处理的 a。因此，`save`方法等价于`update`and`saveOrUpdate`方法。

要查看该`save`方法的工作原理，请考虑以下测试用例：

```
doInJPA(entityManager -> {
    Book book = new Book()
    .setIsbn("978-9730228236")
    .setTitle("High-Performance Java Persistence")
    .setAuthor("Vlad Mihalcea");

    Session session = entityManager.unwrap(Session.class);

    Long id = (Long) session.save(book);

    LOGGER.info(
        "Saving the Book entity with the id: {}", 
        id
    );
}); 
```

在运行上面的测试用例时，Hibernate 会生成以下 SQL 语句：

```
CALL NEXT VALUE FOR hibernate_sequence

-- Saving the Book entity with the id: 1

INSERT INTO book (
    author, 
    isbn, 
    title, 
    id
) 
VALUES (
    'Vlad Mihalcea', 
    '978-9730228236', 
    'High-Performance Java Persistence', 
    1
) 
```

如您所见，结果与`persist`方法调用相同。但是，与 不同`persist`的是，该`save`方法返回实体标识符。

## 更新

特定于 Hibernate 的`update`方法旨在绕过[脏检查机制](https://vladmihalcea.com/the-anatomy-of-hibernate-dirty-checking/)并在刷新时强制更新实体。

> 该`update`方法触发`SaveOrUpdateEvent`由`DefaultSaveOrUpdateEventListener`Hibernate 事件侦听器处理的 a。因此，`update`方法等价于`save`and`saveOrUpdate`方法。

要了解该`update`方法的工作原理，请考虑以下示例，该示例将`Book`实体保留在一个事务中，然后在实体处于分离状态时对其进行修改，并使用`update`方法调用强制执行 SQL UPDATE。

```
Book _book = doInJPA(entityManager -> {
    Book book = new Book()
    .setIsbn("978-9730228236")
    .setTitle("High-Performance Java Persistence")
    .setAuthor("Vlad Mihalcea");

    entityManager.persist(book);

    return book;
});

LOGGER.info("Modifying the Book entity");

_book.setTitle(
    "High-Performance Java Persistence, 2nd edition"
);

doInJPA(entityManager -> {
    Session session = entityManager.unwrap(Session.class);

    session.update(_book);

    LOGGER.info("Updating the Book entity");
}); 
```

在执行上述测试用例时，Hibernate 会生成以下 SQL 语句：

```
CALL NEXT VALUE FOR hibernate_sequence

INSERT INTO book (
    author, 
    isbn, 
    title, 
    id
) 
VALUES (
    'Vlad Mihalcea', 
    '978-9730228236', 
    'High-Performance Java Persistence', 
    1
)

-- Modifying the Book entity
-- Updating the Book entity

UPDATE 
    book 
SET 
    author = 'Vlad Mihalcea', 
    isbn = '978-9730228236', 
    title = 'High-Performance Java Persistence, 2nd edition'
WHERE 
    id = 1 
```

请注意，`UPDATE`在持久性上下文刷新期间执行，就在提交之前，这就是`Updating the Book entity`首先记录消息的原因。

## 用于`@SelectBeforeUpdate`避免不必要的更新

现在，即使实体在分离状态下没有更改，也会始终执行更新。为了防止这种情况，您可以使用`@SelectBeforeUpdate`Hibernate 注释，该注释将触发`SELECT`获取的语句，`loaded state`然后由脏检查机制使用。

所以，如果我们`Book`用注解来注解实体`@SelectBeforeUpdate`：

```
@Entity(name = "Book")
@Table(name = "book")
@SelectBeforeUpdate
public class Book {

    //Code omitted for brevity
} 
```

并执行以下测试用例：

```
Book _book = doInJPA(entityManager -> {
    Book book = new Book()
    .setIsbn("978-9730228236")
    .setTitle("High-Performance Java Persistence")
    .setAuthor("Vlad Mihalcea");

    entityManager.persist(book);

    return book;
});

doInJPA(entityManager -> {
    Session session = entityManager.unwrap(Session.class);

    session.update(_book);
}); 
```

Hibernate 执行以下 SQL 语句：

```
INSERT INTO book (
    author, 
    isbn, 
    title, 
    id
) 
VALUES (
    'Vlad Mihalcea', 
    '978-9730228236', 
    'High-Performance Java Persistence', 
    1
)

SELECT 
    b.id,
    b.author AS author2_0_,
    b.isbn AS isbn3_0_,
    b.title AS title4_0_
FROM 
    book b
WHERE 
    b.id = 1 
```

`UPDATE`请注意，这一次，由于 Hibernate 脏检查机制检测到实体未被修改，因此没有执行任何操作。

## 保存或更新

特定于 Hibernate 的`saveOrUpdate`方法只是`save`and的别名`update`。

> 该`saveOrUpdate`方法触发`SaveOrUpdateEvent`由`DefaultSaveOrUpdateEventListener`Hibernate 事件侦听器处理的 a。因此，`update`方法等价于`save`and`saveOrUpdate`方法。

现在，您可以`saveOrUpdate`在想要持久化实体或强制使用时使用`UPDATE`，如下例所示。

```
Book _book = doInJPA(entityManager -> {
    Book book = new Book()
    .setIsbn("978-9730228236")
    .setTitle("High-Performance Java Persistence")
    .setAuthor("Vlad Mihalcea");

    Session session = entityManager.unwrap(Session.class);
    session.saveOrUpdate(book);

    return book;
});

_book.setTitle("High-Performance Java Persistence, 2nd edition");

doInJPA(entityManager -> {
    Session session = entityManager.unwrap(Session.class);
    session.saveOrUpdate(_book);
}); 
```

## 当心`NonUniqueObjectException`

`save`, `update`, 和可能发生的一个问题是，`saveOrUpdate`如果持久性上下文已经包含具有相同 id 和相同类型的实体引用，如下例所示：

```
Book _book = doInJPA(entityManager -> {
    Book book = new Book()
    .setIsbn("978-9730228236")
    .setTitle("High-Performance Java Persistence")
    .setAuthor("Vlad Mihalcea");

    Session session = entityManager.unwrap(Session.class);
    session.saveOrUpdate(book);

    return book;
});

_book.setTitle(
    "High-Performance Java Persistence, 2nd edition"
);

try {
    doInJPA(entityManager -> {
        Book book = entityManager.find(
            Book.class, 
            _book.getId()
        );

        Session session = entityManager.unwrap(Session.class);
        session.saveOrUpdate(_book);
    });
} catch (NonUniqueObjectException e) {
    LOGGER.error(
        "The Persistence Context cannot hold " +
        "two representations of the same entity", 
        e
    );
} 
```

现在，在执行上面的测试用例时，Hibernate 将抛出 a`NonUniqueObjectException`因为第二个`EntityManager`已经包含一个`Book`与我们传递给的具有相同标识符的实体`update`，并且持久性上下文不能包含同一实体的两个表示。

```
org.hibernate.NonUniqueObjectException: 
    A different object with the same identifier value was already associated with the session : [com.vladmihalcea.book.hpjp.hibernate.pc.Book#1]
    at org.hibernate.engine.internal.StatefulPersistenceContext.checkUniqueness(StatefulPersistenceContext.java:651)
    at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.performUpdate(DefaultSaveOrUpdateEventListener.java:284)
    at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.entityIsDetached(DefaultSaveOrUpdateEventListener.java:227)
    at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.performSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:92)
    at org.hibernate.event.internal.DefaultSaveOrUpdateEventListener.onSaveOrUpdate(DefaultSaveOrUpdateEventListener.java:73)
    at org.hibernate.internal.SessionImpl.fireSaveOrUpdate(SessionImpl.java:682)
    at org.hibernate.internal.SessionImpl.saveOrUpdate(SessionImpl.java:674) 
```

## 合并

为了避免`NonUniqueObjectException`，您需要使用`merge`JPA 提供并由`EntityManager`Hibernate 继承的方法`Session`。

如果在持久性上下文中没有找到实体引用，则从数据库中[`merge`](https://vladmihalcea.com/jpa-persist-and-merge/)获取新的实体快照，并将分离实体的状态复制到`merge`方法中。

> 该`merge`方法触发`MergeEvent`由`DefaultMergeEventListener`Hibernate 事件侦听器处理的 a。

要了解该`merge`方法的工作原理，请考虑以下示例，该示例将`Book`实体保留在一个事务中，然后在实体处于分离状态时对其进行修改，并将分离的实体传递到`merge`子序列持久性上下文中。

```
Book _book = doInJPA(entityManager -> {
    Book book = new Book()
    .setIsbn("978-9730228236")
    .setTitle("High-Performance Java Persistence")
    .setAuthor("Vlad Mihalcea");

    entityManager.persist(book);

    return book;
});

LOGGER.info("Modifying the Book entity");

_book.setTitle(
    "High-Performance Java Persistence, 2nd edition"
);

doInJPA(entityManager -> {
    Book book = entityManager.merge(_book);

    LOGGER.info("Merging the Book entity");

    assertFalse(book == _book);
}); 
```

在运行上面的测试用例时，Hibernate 执行了以下 SQL 语句：

```
INSERT INTO book (
    author, 
    isbn, 
    title, 
    id
) 
VALUES (
    'Vlad Mihalcea', 
    '978-9730228236', 
    'High-Performance Java Persistence', 
    1
)

-- Modifying the Book entity

SELECT 
    b.id,
    b.author AS author2_0_,
    b.isbn AS isbn3_0_,
    b.title AS title4_0_
FROM 
    book b
WHERE 
    b.id = 1

-- Merging the Book entity

UPDATE 
    book 
SET 
    author = 'Vlad Mihalcea', 
    isbn = '978-9730228236', 
    title = 'High-Performance Java Persistence, 2nd edition'
WHERE 
    id = 1 
```

请注意，返回的实体引用与我们传递给该方法`merge`的分离引用不同。`merge`

`merge`现在，虽然在复制分离的实体状态时您应该更喜欢使用 JPA，但`SELECT`在执行批处理任务时，额外的可能会出现问题。

出于这个原因，[`update`](https://vladmihalcea.com/how-to-optimize-the-merge-operation-using-update-while-batching-with-jpa-and-hibernate/)当您确定没有实体引用已经附加到当前运行的持久性上下文并且分离的实体已被修改时，您应该更喜欢使用。

## 结论

要持久化一个实体，您应该使用 JPA`persist`方法。要复制分离的实体状态，`merge`应该是首选。该`update`方法仅对批处理任务有用。`save`and`saveOrUpdate`只是别名，`update`你根本不应该使用它们。

一些开发人员`save`甚至在实体已经被托管时调用，但这是一个错误并触发冗余事件，因为对于托管实体，UPDATE 是在持久性上下文刷新时自动处理的。

* * *

## 回答 #5

> 赞同：12
> 
> 时间：2013-06-11T09:21:57.040

这个链接很好地解释了：

[http://www.stevideter.com/2008/12/07/saveorupdate-versus-merge-in-hibernate/](http://www.stevideter.com/2008/12/07/saveorupdate-versus-merge-in-hibernate/)

我们都有那些我们很少遇到的问题，以至于当我们再次看到它们时，我们知道我们已经解决了这个问题，但不记得是如何解决的。

在 Hibernate 中使用 Session.saveOrUpdate() 时抛出的 NonUniqueObjectException 是我的一个。我将为复杂的应用程序添加新功能。我所有的单元测试工作正常。然后在测试 UI 时，尝试保存对象时，我开始收到异常消息“具有相同标识符值的不同对象已与会话关联”。这是来自 Java Persistence with Hibernate 的一些示例代码。

```
 Session session = sessionFactory1.openSession();
            Transaction tx = session.beginTransaction();
            Item item = (Item) session.get(Item.class, new Long(1234));
            tx.commit();
            session.close(); // end of first session, item is detached

            item.getId(); // The database identity is "1234"
            item.setDescription("my new description");
            Session session2 = sessionFactory.openSession();
            Transaction tx2 = session2.beginTransaction();
            Item item2 = (Item) session2.get(Item.class, new Long(1234));
            session2.update(item); // Throws NonUniqueObjectException
            tx2.commit();
            session2.close(); 
```

要了解此异常的原因，了解分离对象以及在分离对象上调用 saveOrUpdate()（或仅 update()）时会发生什么很重要。

当我们关闭一个单独的 Hibernate Session 时，我们正在使用的持久对象被分离。这意味着数据仍在应用程序的内存中，但 Hibernate 不再负责跟踪对象的更改。

如果我们随后修改我们分离的对象并想要更新它，我们必须重新附加该对象。在重新附加过程中，Hibernate 将检查是否存在同一对象的任何其他副本。如果它找到任何东西，它必须告诉我们它不再知道“真实”副本是什么。也许对我们期望保存的其他副本进行了其他更改，但 Hibernate 不知道它们，因为当时它没有管理它们。

Hibernate 没有保存可能的坏数据，而是通过 NonUniqueObjectException 告诉我们问题。

那么我们该怎么办呢？在 Hibernate 3 中，我们有 merge()（在 Hibernate 2 中，使用 saveOrUpdateCopy()）。此方法将强制 Hibernate 将来自其他分离实例的任何更改复制到您要保存的实例上，从而在保存之前合并内存中的所有更改。

```
 Session session = sessionFactory1.openSession();
        Transaction tx = session.beginTransaction();
        Item item = (Item) session.get(Item.class, new Long(1234));
        tx.commit();
        session.close(); // end of first session, item is detached

        item.getId(); // The database identity is "1234"
        item.setDescription("my new description");
        Session session2 = sessionFactory.openSession();
        Transaction tx2 = session2.beginTransaction();
        Item item2 = (Item) session2.get(Item.class, new Long(1234));
        Item item3 = session2.merge(item); // Success!
        tx2.commit();
        session2.close(); 
```

请务必注意，合并返回对实例新更新版本的引用。它不会将项目重新附加到会话。如果您测试实例相等性（item == item3），您会发现它在这种情况下返回 false。从现在开始，您可能希望使用 item3。

还需要注意的是，Java Persistence API (JPA) 没有分离和重新附加对象的概念，而是使用 EntityManager.persist() 和 EntityManager.merge()。

一般来说，我发现在使用 Hibernate 时，saveOrUpdate() 通常足以满足我的需要。当我有可以引用相同类型对象的对象时，我通常只需要使用合并。最近，异常的原因是在验证引用不是递归的代码中。作为验证的一部分，我将相同的对象加载到我的会话中，导致错误。

你在哪里遇到过这个问题？合并对您有用还是需要其他解决方案？您更喜欢始终使用合并，还是更喜欢仅在特定情况下需要使用它

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2012-04-11T05:45:06.280

`save()`实际上，休眠和方法之间的区别`persist()`取决于我们使用的生成器类。

`save()`如果我们的生成器类被分配，那么和`persist(`) 方法之间没有区别。因为生成器'assigned'的意思是，作为一个程序员，我们需要给主键值以保存在数据库中[希望你知道这个生成器的概念]如果不是分配的生成器类，假设我们的生成器类名称是增量意味着hibernate 它自己会将主键 id 值分配到数据库中[除了分配的生成器，hibernate 仅用于处理主键 id 值记住]，所以在这种情况下，如果我们调用`save()`or`persist()`方法，那么它会将记录插入数据库正常但听到的是， `save()`方法可以返回由休眠生成的主键 id 值，我们可以通过

```
long s = session.save(k); 
```

在同样的情况下，`persist()`永远不会将任何价值回馈给客户。

* * *

## 回答 #7

> 赞同：5
> 
> 时间：2017-04-12T06:11:33.043

我找到了一个很好的例子，展示了所有休眠保存方法之间的差异：

[http://www.journaldev.com/3481/hibernate-session-merge-vs-update-save-saveorupdate-persist-example](http://www.journaldev.com/3481/hibernate-session-merge-vs-update-save-saveorupdate-persist-example)

简而言之，根据上面的链接：

**节省（）**

*   我们可以在事务之外调用这个方法。如果我们在没有事务的情况下使用它并且我们在实体之间有级联，那么除非我们刷新会话，否则只有主实体会被保存。
*   因此，如果从主对象映射了其他对象，它们会在提交事务或刷新会话时保存。

**坚持（）**

*   它类似于在事务中使用 save() ，因此它是安全的并且可以处理任何级联对象。

**保存或更新（）**

*   可以在有或没有事务的情况下使用，就像 save() 一样，如果它在没有事务的情况下使用，映射的实体将不会被保存，除非我们刷新会话。

*   根据提供的数据生成插入或更新查询。如果数据存在于数据库中，则执行更新查询。

**更新（）**

*   当我们知道我们只更新实体信息时，应该使用 Hibernate 更新。此操作将实体对象添加到持久上下文中，并在提交事务时跟踪和保存进一步的更改。
*   因此，即使在调用更新之后，如果我们在实体中设置任何值，它们也会在事务提交时更新。

**合并（）**

*   Hibernate 合并可用于更新现有值，但是此方法从传递的实体对象创建一个副本并返回它。返回的对象是持久上下文的一部分并跟踪任何更改，不跟踪传递的对象。这是 merge() 与所有其他方法的主要区别。

对于所有这些的实际示例，请参阅我上面提到的链接，它显示了所有这些不同方法的示例。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-10-03T12:13:20.797

请注意，如果您对分离的对象调用更新，无论您是否更改了对象，数据库中总会有更新完成。如果这不是您想要的，您应该使用 Session.lock() 和 LockMode.None。

仅当对象在当前会话范围之外（处于分离模式时）更改时，才应调用更新。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2012-10-26T10:38:45.893

以下答案均不正确。所有这些方法看起来都很相似，但实际上做的事情却完全不同。很难给出简短的评论。最好提供有关这些方法的完整文档的链接：http: [//docs.jboss.org/hibernate/core/3.6/reference/en-US/html/objectstate.html](http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/objectstate.html)

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2018-11-22T10:23:55.383

以上答案都不完整。尽管 Leo Theobald 的答案看起来最接近。

基本点是hibernate如何处理实体的状态以及当状态发生变化时它如何处理它们。还必须查看有关刷新和提交的所有内容，每个人似乎都完全忽略了它们。

永远不要使用休眠的保存方法。忘记它甚至存在于 HIBERNATE 中！

**坚持**

正如大家所解释的，Persist 基本上将实体从“瞬态”状态转换为“托管”状态。此时，一个 slush 或一个提交可以创建一个插入语句。但实体仍将保持“托管”状态。这不会随着冲洗而改变。

此时，如果再次“坚持”，则不会有任何变化。如果我们尝试持久化一个持久化实体，将不会有更多的保存。

当我们试图驱逐实体时，乐趣就开始了。

驱逐是 Hibernate 的一个特殊功能，它将实体从“托管”转换为“分离”。我们不能在分离的实体上调用持久化。如果我们这样做，那么 Hibernate 会引发异常，并且整个事务会在提交时回滚。

**合并与更新**

这是 2 个有趣的函数，它们在以不同的方式处理时会做不同的事情。他们俩都试图将实体从“分离”状态转换为“托管”状态。但是做的不一样。

了解一个事实，即分离意味着一种“离线”状态。和管理意味着“在线”状态。

观察下面的代码：

```
Session ses1 = sessionFactory.openSession();

    Transaction tx1 = ses1.beginTransaction();

    HibEntity entity = getHibEntity();

    ses1.persist(entity);
    ses1.evict(entity);

    ses1.merge(entity);

    ses1.delete(entity);

    tx1.commit(); 
```

你什么时候做这个？你认为会发生什么？如果您说这会引发异常，那么您是正确的。这将引发异常，因为合并已对处于分离状态的实体对象起作用。但它不会改变对象的状态。

在幕后，合并将引发一个选择查询，并基本上返回一个处于附加状态的实体副本。观察下面的代码：

```
Session ses1 = sessionFactory.openSession();

    Transaction tx1 = ses1.beginTransaction();
    HibEntity entity = getHibEntity();

    ses1.persist(entity);
    ses1.evict(entity);

    HibEntity copied = (HibEntity)ses1.merge(entity);
    ses1.delete(copied);

    tx1.commit(); 
```

上面的示例有效，因为合并将一个新实体带入了处于持久状态的上下文中。

当与更新一起应用时，同样可以正常工作，因为更新实际上并没有带来像合并这样的实体副本。

```
Session ses1 = sessionFactory.openSession();

    Transaction tx1 = ses1.beginTransaction();

    HibEntity entity = getHibEntity();

    ses1.persist(entity);
    ses1.evict(entity);

    ses1.update(entity);

    ses1.delete(entity);

    tx1.commit(); 
```

同时在调试跟踪中我们可以看到 Update 没有引发 select like merge 的 SQL 查询。

**删除**

在上面的例子中，我使用了 delete 而没有谈到 delete。删除基本上会将实体从托管状态转换为“已删除”状态。并且在刷新或提交时会发出删除命令来存储。

但是，可以使用 persist 方法将实体从“已删除”状态带回“托管”状态。

希望以上解释能澄清任何疑问。

# msmq - 访问远程计算机的 MSMQ 给出“远程计算机不可用”

> ID：161230
> 
> 赞同：1
> 
> 时间：2008-10-02T07:41:20.103
> 
> 标签：msmq

我们有一个在服务器上运行的 Windows 应用程序并访问其他 4 个服务器（它们都是域中的成员）以获取每个私有队列中的消息。我们刚刚安装了一个新服务器，由于某种原因，当应用程序尝试访问该计算机时，它会收到“远程计算机不可用”消息。
该应用程序以管理员域用户身份访问其他服务器。
有没有人遇到过这样的问题，或者有什么可能导致它的线索？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2009-08-24T13:32:12.047

这个线程可能为时已晚，但我在这里找到了答案：http: [//blogs.msdn.com/johnbreakwell/archive/2008/07/10/getting-msmq-messages-out-of-windows-server -2008.aspx](http://blogs.msdn.com/johnbreakwell/archive/2008/07/10/getting-msmq-messages-out-of-windows-server-2008.aspx)

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-06T13:50:55.433

您是否启动了诸如[Microsoft Network Monitor](http://blogs.technet.com/netmon/)或[Wireshark](http://www.wireshark.org/)之类的数据包捕获工具，并查看了进出出现错误的系统的流量？这通常是无需花费大量时间进行实验即可查看正在发生的事情的最可靠方法。

我会从收到错误的框中设置捕获，运行直到收到错误，然后立即停止捕获。设置过滤器以仅查看进出该系统的流量。如果您无法在盒子本身上安装捕获工具，请确保将其放置在网络上，使其仍然能够看到来自该盒子的所有流量。（即不要将它放在交换机上的相邻端口上，因为交换机的工作是将每个端口的流量相互隔离）。

如果您没有看到实际流量被发送到有问题的远程服务器，那么您可能遇到了命名/目录/DNS 类型问题。即本地服务器无法确定另一个在哪里。由于这是 Windows 域类型的情况，我将开始在 Active Directory 中寻找线索。

如果您看到流量传出到远程服务器，但在故障之前您从未看到从它返回的一个数据包，那么您可能在远程机器上或从这里到那里的路由上遇到了防火墙问题。

如果您看到流量往返于远程服务器但随后停止，您需要深入研究这些数据包并查看流量中可能存在哪些低级错误代码。NETMON 和 Wireshark 对 Microsoft 协议都有很好的解码，因此您应该能够准确地看到正在发生的事情。如果您不熟悉这些协议，您可能希望首先捕获与其他服务器之一的正常工作连接，以便进行比较。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T11:49:47.243

会不会是防火墙问题？

[http://support.microsoft.com/kb/183293](http://support.microsoft.com/kb/183293)

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2010-01-12T06:57:29.170

问题终于解决了，一不小心就解决了： 显然DNS服务器有些混乱，缓存服务器很难访问到正确的服务器。我们的网站管理员更正了所有服务器名称，这也解决了 MSMQ 问题。

# c# - 你如何强制构造函数签名和静态方法？

> ID：161231
> 
> 赞同：25
> 
> 时间：2008-10-02T07:42:04.203
> 
> 标签：c#, java, oop, language-features, language-design

**有没有办法强制（子）类在 C# 或 Java 中具有具有特定签名或特定静态方法的构造函数？**

您显然不能为此使用接口，而且我知道它的用途有限。我发现它很有用的一个例子是当你想强制执行一些设计指南时，例如：

**例外**
他们应该都有四个规范的构造函数，但是没有办法强制执行它。您必须依靠像 FxCop（C# 案例）这样的工具来捕捉这些。

**运算符**
没有约定可以对两个类求和（在 C# 中使用 operator+）

是否有任何设计模式可以解决此限制？*在未来的 C# 或 Java 版本中，可以向语言*添加什么结构来克服这个限制？

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-10-02T07:56:52.717

使用泛型，您可以强制类型参数具有无参数构造函数 - 但这就是它的限制。

除了在泛型中，即使它们存在，实际*使用这些限制也会很棘手，但它有时对类型参数/参数很有用。*在接口（或可能是静态接口）中允许静态成员同样有助于解决“通用数字运算符”问题。

不久前，我在遇到类似问题时[写了这篇文章。](http://codeblog.jonskeet.uk/2008/08/29/lessons-learned-from-protocol-buffers-part-4-static-interfaces)

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2008-10-02T12:31:08.033

在编译时没有强制执行，但我花了很多时间研究类似的问题；[MiscUtil](http://www.pobox.com/~skeet/csharp/miscutil/)中提供了一个[支持泛型的数学库](http://www.pobox.com/~skeet/csharp/miscutil/usage/genericoperators.html)和一个高效的（非默认）ctor API 。但是，这些仅在运行时首次使用时检查。实际上这不是什么大问题——你的单元测试应该很快找到任何缺失的操作符/ctor。但它有效，而且非常快......

* * *

## 回答 #3

> 赞同：7
> 
> 时间：2008-10-02T08:37:26.783

您可以使用工厂模式。

```
interface Fruit{}

interface FruitFactory<F extends Fruit>{
   F newFruit(String color,double weight);

   Cocktail mixFruits(F f1,F f2);
} 
```

然后，您可以为任何类型的 Fruit 创建类

```
class Apple implements Fruit{}
class AppleFactory implements FruitFactory<Apple>{
   public Apple newFruit(String color, double weight){
       // create an instance
   }
   public Cocktail mixFruits(Apple f1,Apple f2){
       // implementation
   }
} 
```

这并不强制您不能使用工厂以外的其他方式创建实例，但至少您可以指定您将从工厂请求的方法。

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2008-10-02T07:58:19.717

### 力构造函数

你不能。最接近的方法是将默认构造函数设为私有，然后提供具有参数的构造函数。但它仍然存在漏洞。

```
class Base
{
  private Base() { }
  public Base(int x) {}
}

class Derived : Base
{
  //public Derived() { } won't compile because Base() is private
  public Derived(int x) :base(x) {}
  public Derived() : base (0) {} // still works because you are giving a value to base
} 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T07:57:04.323

语言中的问题是静态方法实际上是二等公民（构造函数也是一种静态方法，因为您不需要实例开始）。

静态方法只是具有命名空间的全局方法，它们并不真正“属于”它们定义的类（好吧，它们可以访问类中的私有（静态）方法，仅此而已）。

编译器级别的问题是，如果没有类实例，您就没有虚函数表，这意味着您无法使用所有继承和多态性的东西。

我认为可以通过为每个类添加一个全局/静态虚拟表来使其工作，但如果还没有完成，那么可能有一个很好的理由。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T10:13:46.960

如果我是语言设计师，我会解决这个问题。

**允许接口包含静态方法、运算符和构造函数。**

```
interface IFoo  
{  
  IFoo(int gottaHaveThis);  
  static Bar();  
}

interface ISummable
{
      operator+(ISummable a, ISummable b);
} 
```

**不允许相应的`new IFoo(someInt)`或`IFoo.Bar()`**

**允许继承构造函数（就像静态方法一样）。**

```
class Foo: IFoo
{
  Foo(int gottaHaveThis) {};
  static Bar() {};
}

class SonOfFoo: Foo 
{
  // SonOfFoo(int gottaHaveThis): base(gottaHaveThis); is implicitly defined
}

class DaughterOfFoo: Foo
{
  DaughhterOfFoo (int gottaHaveThis) {};
} 
```

**允许程序员转换为接口**，并在运行时检查转换是否在*语义上*有效，即使类没有明确指定也是如此。

```
ISummable PassedFirstGrade = (ISummable) 10; 
```

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-02T12:15:38.477

不幸的是，你不能在 C# 中。不过，这是一个打击：

```
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine(Foo.Instance.GetHelloWorld());
        Console.ReadLine();
    }
}

public class Foo : FooStaticContract<FooFactory>
{
    public Foo() // Non-static ctor.
    {
    }

    internal Foo(bool st) // Overloaded, parameter not used.
    {
    }

    public override string GetHelloWorld()
    {
        return "Hello World";
    }
}

public class FooFactory : IStaticContractFactory<Foo>
{
    #region StaticContractFactory<Foo> Members

    public Foo CreateInstance()
    {
        return new Foo(true); // Call static ctor.
    }

    #endregion
}

public interface IStaticContractFactory<T>
{
    T CreateInstance();
}

public abstract class StaticContract<T, Factory>
    where Factory : IStaticContractFactory<T>, new() 
    where T : class
{
    private static Factory _factory = new Factory();

    private static T _instance;
    /// <summary>
    /// Gets an instance of this class. 
    /// </summary>
    public static T Instance
    {
        get
        {
            // Scary.
            if (Interlocked.CompareExchange(ref _instance, null, null) == null)
            {
                T instance = _factory.CreateInstance();
                Interlocked.CompareExchange(ref _instance, instance, null);
            }
            return _instance;
        }
    }
}

public abstract class FooStaticContract<Factory>
    : StaticContract<Foo, Factory>
    where Factory : IStaticContractFactory<Foo>, new() 
{
    public abstract string GetHelloWorld();
} 
```

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-02T08:02:38.303

好吧，我从您的问题的措辞中知道您正在寻找编译时强制执行。除非其他人有一个绝妙的建议/黑客可以让你按照你暗示编译器应该的方式这样做，否则我建议你可以编写一个自定义的 MSbuild 任务来做到这一点。像 PostSharp 这样的 AOP 框架可能会通过搭载它的构建任务模型来帮助您在编译时完成此任务。

但是代码分析或运行时执行有什么问题呢？也许这只是偏好，我尊重这一点，但我个人对让 CA/FXCop 检查这些事情没有任何问题......如果你真的想强制你的类的下游实现者拥有构造函数签名，你总是可以添加规则运行 -使用反射检查基类构造函数的时间。

理查德

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-02T12:15:51.470

我不确定你想要达到什么目的，你能详细说明一下吗？跨不同类强制使用特定构造函数或静态方法的唯一原因是尝试在运行时动态执行它们，这是正确的吗？

构造函数旨在特定于特定类，因为它旨在初始化该类的特定需求。据我了解，您希望在类层次结构或接口中强制执行某些内容的原因是它是与正在执行的流程相关的活动/操作，但在不同情况下可能会有所不同。我相信这是多态性的预期好处，这是使用静态方法无法实现的。

它还需要知道您要为其调用静态方法的类的特定类型，这将打破接口或抽象类试图实现的行为差异的所有多态隐藏。

如果构造函数表示的行为旨在成为这些类的客户端之间合同的一部分，那么我会将其显式添加到接口中。

如果类的层次结构具有相似的初始化要求，那么我将使用抽象基类，但是应该由继承类决定如何找到该构造函数的参数，这可能包括公开相似或相同的构造函数。

如果这是为了让您在运行时创建不同的实例，那么我建议在抽象基类上使用静态方法，该方法知道所有具体类的不同需求（您可以为此使用依赖注入）。

# windows - propset svn:ignore 的问题 - 可能与 Vista 相关

> ID：161238
> 
> 赞同：4
> 
> 时间：2008-10-02T07:44:38.363
> 
> 标签：windows, svn, version-control

据我了解，使用 SVN 忽略目录*内容的命令是这样的：*

```
svn propset svn:ignore "*" tmp/ 
```

这应该在`tmp`目录的内容上设置忽略属性，对吧？换句话说，通配符设置为 tmp 目录上的忽略值。麻烦的是，这是我的 Windows 机器上发生的事情：

```
> svn propset svn:ignore "*" ./tmp
property 'svn:ignore' set on 'app'
property 'svn:ignore' set on 'config'
property 'svn:ignore' set on 'db'
property 'svn:ignore' set on 'doc'
property 'svn:ignore' set on 'lib'
property 'svn:ignore' set on 'log'
property 'svn:ignore' set on 'nbproject'
property 'svn:ignore' set on 'public'
[etc...] 
```

那是不对的。我做错了什么（或者可能会发疯），还是我在 Windows 上的 svn 坏了？

**一些注意事项：**

*   机器正在运行 Windows Vista SP1
*   通过 Tortoise 设置此属性非常有效。
*   我正在使用[适用于 Windows 的 Collabnet 二进制文件](http://www.collab.net/downloads/subversion/)：

> `> svn --version
> svn, version 1.5.2 (r32768)
> compiled Aug 28 2008, 19:05:34`

* * *

***更新：***我刚刚在 Windows XP 机器上尝试过，它按预期工作。所以要么这是 Vista 特定的问题，要么是我的 Vista 配置有问题。是否有其他人能够在 Vista 上重现此问题？[我刚刚发现在CollabNet 下载页面](http://www.collab.net/downloads/subversion/)上没有将 Vista 列为支持的平台之一。

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-10-02T13:09:34.277

看起来微软以其无限的智慧[改变了 Windows Vista 中通配符扩展的行为](https://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=1917798&SiteID=1)：

因此，它不是传递一个转义的通配符，而是被扩展：

> 在 Win 95、98、2000、XP 下，应用程序按预期运行：当参数类似于 «*.txt» 时会进行通配符扩展，而当参数类似于 «"*.txt"» 时则不会。在 Windows Vista 下，通配符扩展总是发生，或者说，双引号不会抑制它。

**[Collabnet 论坛](http://subversion.open.collab.net/ds/viewMessage.do?dsForumId=4&viewType=browseAll&dsMessageId=115201#messagefocus)**上有关于这个问题的进一步讨论。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-02T08:26:25.640

该命令***应该***按您的预期工作。

正在变得全球化，`*`它不应该这样做。所以，你正在运行：（
`svn propset svn:ignore [value] app config db doc lib log nbproject public ... tmp`
因为 app 是第一个受影响的文件夹，我猜它之前还有另一个文件夹）。

您可以尝试 2 件事：

1.  指定一个列表文件：`svn propset svn:ignore tmp -F .svnignore`
2.  只需指定路径：`svn propset svn:ignore tmp`. 这应该会打开您的默认文本编辑器（如果已配置）以允许您编写和保存列表。

* * *

**回复评论**

由于您现在正在尝试更正设置，`propedit`并且`propdel`可以正常工作 - 特别是如果您在目录中有其他更改。

但是，如果您不需要担心任何其他更改（检查），使用and`svn st`会更快。`svn revert -R``svn propset`

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-02T08:32:35.220

这并不能回答您的 svn 问题，但是您为什么要尝试忽略目录的所有内容？在我看来，如果您想要在构建中的某个时间点有一个临时目录，您应该将该目录作为构建的一部分，而不是从 repo 那里。

您是否试图忽略它，因为它已经存在并且您无法删除它？

无论如何，从我的 unix 命令行，这对我来说可以忽略名为 tmp 的目录中的未跟踪文件

```
$ svn --版本
svn，版本 1.5.1 (r32289)
   编译于 2008 年 8 月 28 日，10:00:12

$ svn propset svn:ignore '*' tmp

```

Windows 是否在夸大你的报价？

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-10-02T08:41:52.140

在我看来，为 Windows 编译的 svn.exe 二进制文件正在执行内置的 globbing，这是它通常不会在 unix 构建中执行的操作，因为 unix shell 在构建命令行时应该执行 globbing。我会考虑这种意外行为，尤其是因为您似乎无法解决全局问题。

正如其他人指出的那样，您可以`*`使用该`-F`选项或在文本编辑器中以交互方式提供。

但是，我认为您可能不会以最简单的方式解决此问题。为了忽略整个子目录，我会做这样的事情：

```
svn propset svn:ignore tmp . 
```

这会将`svn:ignore`属性设置为`.`（当前目录， 的父目录`tmp/`），告诉它忽略`tmp`子目录及其下的所有内容。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-10-02T08:43:18.800

您使用的是哪个版本的颠覆？

我在 Windows 上尝试了 1.5.2，它只更改了 tmp 目录上的属性：

```
[C:\Temp\temp] :svn propset svn:ignore "*" tmp/
property 'svn:ignore' set on 'tmp' 
```

和：

```
[C:\Temp\temp] :svn proplist *
svn: Skipping argument: '.svn' ends in a reserved name
Properties on 'tmp':
  svn:ignore 
```

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2010-04-14T15:17:54.520

对于使用“-F”替代方案在 shell 脚本中使用的单行代码，只需尝试以下操作：

```
echo "*" > .svnignore && svn propset svn:ignore <path> -F .svnignore && rm .svnignore 
```

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T07:49:05.183

试试不带斜杠。此外，必须将 tmp 目录本身添加到存储库中。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2009-01-12T11:31:24.777

使用 GUI SVN 客户端是合理的（除非你是受虐狂！）。如果您使用的是 Windows TortoiseSVN，则应该是您的第一个停靠港。右键单击要忽略的文件，然后单击“TortoiseSVN -> 属性”。在属性对话框中，您可以通过单击“名称”的下拉箭头并选择“svn:ignore”来忽略整个目录。然后在值框中输入“*”。当然，这一切都没有引号。

# web-applications - 谷歌网络工具包

> ID：161248
> 
> 赞同：-1
> 
> 时间：2008-10-02T07:47:51.507
> 
> 标签：web-applications, gwt, struts

我应该将 GWT 用于 struts Web 应用程序吗？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T12:21:32.907

我想你会发现 GWT 对 Stripes 之类的补充比它对 struts 的补充要多得多。我不想引发某种火焰/开发平台之战，但在我看来，Stripes 是一个比 struts 更优越且更易于使用的框架，我们一年前从 struts 迁移并且从未回头。

也就是说，是的，您可以轻松地将 GWT 与 struts 集成，事实上，如果您在 GWT 中完成整个 UI，您甚至不需要 struts，您可以直接 RPC 到您的 java 后端。如果您只想制作小型组件，那么 GWT 也可以很好地解决这个问题，我想如果您愿意的话，您可能会*不寒而栗*地将您的 struts 表单传递给它。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T07:50:31.187

我不认为 GWT 会很好地集成到 Struts 中 - GWT 更像是一个框架，您可以使用它来代替 Struts。

您可以尝试类似[Ext JS](http://extjs.com/)的东西，我认为它（作为一个纯 JavaScript 库）更有可能集成到 Struts 中。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T12:24:31.763

Struts 是一个与 Web 相关的所有东西的可靠框架，GWT 是一个类似 Web 应用程序行为的框架......所以，让 GWT 模块成为需要大量 AJAX 功能的部分，并使用 Struts 处理整个站点结构业务，然后你会做就好了。

# .net - .NET 的已编译、强类型替代方案？

> ID：161251
> 
> 赞同：0
> 
> 时间：2008-10-02T07:49:32.953
> 
> 标签：.net, strong-typing, compiled

是否有一种适合构建 Web 应用程序的编程语言，即编译型、强类型，而不是 ASP.NET？

我想过使用 Mono ( [http://www.mono-project.com/](http://www.mono-project.com/) )，但我想知道是否还有其他选择。

（如果语言和框架是开源的，那是一大优势！）

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-10-02T07:53:23.240

不知道你说的“编译”是什么意思。Java 呢？

Java 有很多用于 Web 开发的框架。例如[挂毯](http://tapestry.apache.org)：

> Tapestry 是一个开源框架，用于在 Java 中创建动态、健壮、高度可扩展的 Web 应用程序。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-02T07:56:49.457

Java 满足所有标准

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-10-02T08:49:26.600

如果您的意思是编译为 win32 代码，而不是中间语言，请尝试[Delphi](http://www.codegear.com)。

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2008-10-02T08:04:03.387

spring框架和java语言。

[http://www.springframework.org/](http://www.springframework.org/)开源并在业界广泛使用。

特别是检查 spring-mvc 和 spring web-flow 模块，它们使创建 web 项目变得更加简单。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2010-03-17T21:12:56.883

> 是否有一种适合构建 Web 应用程序的编程语言，即编译型、强类型，而不是 ASP.NET？

只是为了完整起见：理论上，甚至可以使用[Ada](http://en.wikipedia.org/wiki/Ada_%28programming_language%29)来满足这些要求：

> [AdaCGI](http://www.dwheeler.com/adacgi/)是“通用网关接口”(CGI) 的 Ada 95 接口。AdaCGI 使创建可由万维网 (WWW) HTTP 服务器使用标准 CGI 接口调用的 Ada 程序变得更加容易。使用它，您可以创建 Ada 程序，根据 WWW 用户的请求执行查询或其他处理。AdaCGI 以前被命名为“Package CGI”。AdaCGI 是开源/自由软件，使用 LGPL（“一般公共许可证”）许可证发布。
> 
> [Ada for the Web](http://www.sigada.org/wg/Web_Ada/)：本网站致力于推广使用 Ada95 作为编程 Web 和 Internet 小程序和应用程序、服务器和浏览器的主要语言。

[在http://libre.adacore.com/libre/tools/aws/](http://libre.adacore.com/libre/tools/aws/)上还有 Ada“aws”包

> 首先，AWS 代表 Ada Web Server，但它不仅仅是另一个 Web 服务器……</p>
> 
> AWS 是一个用于开发基于 Web 的应用程序的完整框架。该框架的主要部分是嵌入式 Web 服务器。这个小而强大的 Web 服务器可以嵌入到您的应用程序中，因此您的应用程序将能够与标准的 Web 浏览器（例如 Microsoft Internet Explorer 或 Netscape Communicator）进行通信。围绕这个 Web 服务器已经开发了很多服务。

该框架包括：

```
* A Web parameters module. This module takes care of retrieving the forms or URL parameters and to build an associative table for easy access.
* A session server, this is a very important module to be able to keep client’s data from page to page.
* Support SOAP to develop Web Services.
* A tool (based on ASIS) to generate a WSDL document from an Ada spec.
* A tool to generate Web Services stubs/skeletons from a WSDL document.
* A template parser, this module makes it possible to completely separate the Web design from the code. No more scripting into your Web page. This template engine is amazingly fast due to its concurrent cached compiled templates support.
* An Ajax runtime based on templates hiding javascript.
* Support for Secure Sockets (HTTPS/SSL), this is based on OpenSSL library.
* Support for large servers using dispatchers based on URI, request methods, timers.
* Support for virtual hosting (dispatchers based on the host name).
* Support for server push.
* A directory browser ready to be used in any application.
* A status page to get many information about the current AWS server.
* A log module. Log files keep information about all resources requested to the server.
* Hotplug modules which can be loaded/unloaded dynamically to add specific features to a server.
* A light communication API to exchange data between applications using the HTTP protocol.
* A configuration API to tune/change the server parameters without recompilation.
* A client API to retrieve any Web page from a Web site.
* A Web Page service to build a simple static page server.
* Support for SMTP, LDAP and Jabber protocols.
* And more… 
```

> 使用 AWS 构建的服务器非常易于部署。您只需要复制并启动一个可执行文件。无需执行 Web 服务器安装和配置步骤。

有关aws 文档，请参阅[http://www.adacore.com/wp-content/files/auto_update/aws-docs/aws.html](http://www.adacore.com/wp-content/files/auto_update/aws-docs/aws.html)

[http://en.wikibooks.org/wiki/Ada_Programming/Libraries/Web](http://en.wikibooks.org/wiki/Ada_Programming/Libraries/Web)

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T08:01:32.517

你到底在问什么？

您是要编译的东西还是高性能的东西？
您是在要求强类型的东西，还是要求能够轻松帮助您调试错误的东西？（单元测试有时是编译器的更好替代品）
您的客户是否要求它不是用 ASP.Net 编写的？
是否存在无法运行 .Net 代码的技术要求？

您正在寻求一种技术来解决您尚未正确定义的问题。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-02T08:24:16.973

Mono 不是一种不同的编程语言，它只是 .NET 框架的开源实现，适用于 Unix 系统（以及 Mac）。它旨在与 .NET 完全兼容，因此您最终会以同样的方式使用 C# 和 ASP.NET。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-02T08:20:14.157

也许您的意思是“编译为机器代码”？

C# 和 Java 被编译成中间语言，然后在运行时进行解释。

大多数体面的解释器在运行时将其编译为实际的机器代码以加快速度（即时编译）。

当然它的效率不高，但许多语言功能否则将很难实现（例如垃圾收集）。

还有一种中间语言可以让你编译的代码在不同的平台上运行。

# bash - bash：在后台启动多个链式命令

> ID：161252
> 
> 赞同：47
> 
> 时间：2008-10-02T07:50:25.477
> 
> 标签：bash, background, command

我正在尝试使用 bash 在后台并行运行一些命令。这是我正在尝试做的事情：

```
forloop {
  //this part is actually written in perl
  //call command sequence
  print `touch .file1.lock; cp bigfile1 /destination; rm .file1.lock;`;
} 
```

反引号 (``) 之间的部分生成一个新的 shell 并连续执行命令。问题是，只有在执行完最后一个命令后，才会返回对原始程序的控制。我想在后台执行整个语句（我不期待任何输出/返回值）并且我希望循环继续运行。

调用程序（具有循环的程序）在所有生成的 shell 完成之前不会结束。

我可以在 perl 中使用线程来生成调用不同 shell 的不同线程，但这似乎有点矫枉过正......

我可以启动一个 shell，给它一组命令并告诉它进入后台吗？

* * *

## 回答 #1

> 赞同：32
> 
> 时间：2008-10-02T08:24:17.067

我还没有测试过这个但是怎么样

```
print `(touch .file1.lock; cp bigfile1 /destination; rm .file1.lock;) &`; 
```

括号意味着在子shell中执行，但这不应该受到伤害。

* * *

## 回答 #2

> 赞同：21
> 
> 时间：2008-10-02T08:42:23.560

谢谢休，做到了：

```
adrianp@frost:~$ (echo "started"; sleep 15; echo "stopped")
started
stopped
adrianp@frost:~$ (echo "started"; sleep 15; echo "stopped") &
started
[1] 7101
adrianp@frost:~$ stopped

[1]+  Done                    ( echo "started"; sleep 15; echo "stopped" )
adrianp@frost:~$ 
```

其他想法不起作用，因为它们在后台启动每个命令，而不是命令序列（这对我来说很重要！）。

再次感谢你！

* * *

## 回答 #3

> 赞同：21
> 
> 时间：2013-09-26T13:15:45.817

另一种方法是使用以下语法：

```
{ command1; command2; command3; } &
wait 
```

请注意，`&`在命令组的末尾，而不是在每个命令之后。最后一个命令之后的分号是必要的，第一个括号之后和最后一个括号之前的空格也是如此。at the `wait`end 确保在生成的子进程（命令组）结束之前父进程不会被杀死。

你也可以做一些花哨的事情，比如重定向`stderr`和`stdout`：

```
{ command1; command2; command3; } 2>&2 1>&1 & 
```

您的示例如下所示：

```
forloop() {
    { touch .file1.lock; cp bigfile1 /destination; rm .file1.lock; } &
}
# ... do some other concurrent stuff
wait # wait for childs to end 
```

* * *

## 回答 #4

> 赞同：14
> 
> 时间：2008-10-02T08:02:41.063

```
for command in $commands
do
    "$command" &
done
wait 
```

命令末尾的 & 符号在后台运行它，并`wait`等待后台任务完成。

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2009-11-05T20:11:52.683

[GavinCattell](https://stackoverflow.com/questions/161252/bash-start-multiple-chained-commands-in-background/161284#161284)最接近（对于 bash，IMO），但正如 Mad_Ady 指出的那样，它不会处理“锁定”文件。这应该：

如果还有其他待处理的作业，则**等待**也会等待这些作业。*如果您只*需要等待副本，则可以累积这些 PID 并仅等待那些。如果没有，您可以使用“pids”删除 3 行，但它更通用。

此外，我添加了检查以完全避免复制：

```
pids=
for file in bigfile*
do
    # Skip if file is not newer...
    targ=/destination/$(basename "${file}")
    [ "$targ" -nt "$file" ] && continue

    # Use a lock file:  ".fileN.lock" for each "bigfileN"
    lock=".${file##*/big}.lock"
    ( touch $lock; cp "$file" "$targ"; rm $lock ) &
    pids="$pids $!"
done
wait $pids 
```

顺便说一句，您似乎正在将新文件复制到 FTP 存储库（或类似存储库）。如果是这样，您*可以*考虑使用复制/重命名策略而不是锁定文件（但这是另一个主题）。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2013-01-26T12:05:49.843

您正在寻找的 bash 工具称为`Compound Commands`. 有关更多信息，请参见手册页：

> 复合命令 复合命令是以下之一：
> 
> ```
>  (list) list  is  executed  in a subshell environment (see COMMAND EXECUTION ENVIRONMENT below).  Variable assignments and
>           builtin commands that affect the shell's environment do not remain in effect after  the  command  completes.   The
>           return status is the exit status of list.
> 
>    { list; }
>           list  is  simply  executed in the current shell environment.  list must be terminated with a newline or semicolon.
>           This is known as a group command.  The return status is the exit status of list.  Note that unlike the metacharac‐
>           ters  (  and  ),  {  and  } are reserved words and must occur where a reserved word is permitted to be recognized.
>           Since they do not cause a word break, they must be separated from list by whitespace or another shell  metacharac‐
>           ter. 
> ```

还有其他的，但这些可能是最常见的两种类型。第一个，括号，将在子shell中运行一系列命令，而第二个，花括号，将在当前shell中连续运行命令列表。

### 括号

```
% ( date; sleep 5; date; )
Sat Jan 26 06:52:46 EST 2013
Sat Jan 26 06:52:51 EST 2013 
```

### 大括号

```
% { date; sleep 5; date; }
Sat Jan 26 06:52:13 EST 2013
Sat Jan 26 06:52:18 EST 2013 
```

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2012-09-13T10:52:40.503

使用 at 作业运行命令：

```
# date
# jue sep 13 12:43:21 CEST 2012
# at 12:45
warning: commands will be executed using /bin/sh
at> command1
at> command2
at> ...
at> CTRL-d
at> <EOT>
job 20 at Thu Sep 13 12:45:00 2012 
```

结果将通过邮件发送到您的帐户。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2014-04-08T21:48:18.920

我在这里偶然发现了这个线程，并决定整理一个代码片段来生成链式语句作为后台作业。我在 BASH for Linux、KSH for IBM AIX 和 Busybox 的 ASH for Android 上对此进行了测试，所以我认为可以肯定地说它适用于*任何*Bourne-like shell。

```
processes=0;
for X in `seq 0 10`; do
   let processes+=1;
   { { echo Job $processes; sleep 3; echo End of job $processes; } & };
   if [[ $processes -eq 5 ]]; then
      wait;
      processes=0;
   fi;
done; 
```

此代码运行多个后台作业，达到一定的并发作业限制。例如，您可以使用它来重新压缩大量 gzip 文件，`xz`而不会有大量`xz`进程占用您的整个内存并使您的计算机崩溃：在这种情况下，您可以使用`*`' `for`s list 和批处理作业是`gzip -cd "$X" | xz -9c > "${X%.gz}.xz"`。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2016-11-19T10:18:19.670

在子shell中运行命令：

```
(command1 ; command2 ; command3) & 
```

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2008-10-02T08:05:24.177

尝试用 &s 将命令放在大括号中，如下所示：

```
{command1 & ; command2 & ; command3 & ; } 
```

这不会创建子 shell，而是在后台执行该组命令。

高温高压

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-10-03T21:45:55.243

我不知道为什么没有人回答正确的解决方案：

```
my @children;
for (...) {
    ...
    my $child = fork;
    exec "touch .file1.lock; cp bigfile1 /destination; rm .file1.lock;" if $child == 0;
    push @children, $child;
}
# and if you want to wait for them to finish,
waitpid($_) for @children; 
```

这会导致 Perl 生成子进程来运行每个命令，并允许您等待所有子进程完成后再继续。

顺便一提，

```
print `some command` 
```

和

```
system "some command" 
```

将相同的内容输出到标准输出，但第一个具有更高的开销，因为 Perl 必须捕获所有“ `some command`”的输出

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2014-11-01T02:53:59.517

在 for 循环中分叉：

`for i in x; do ((a; b; c;)&); done`

例子：

`for i in 500 300 100; do ((printf "Start $i: "; date; dd if=/dev/zero of=testfile_$i bs=1m count=$i 2>/dev/null; printf "End $i: "; date;)&) && sleep 1; done`

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2014-10-27T13:44:43.623

万一有人仍然感兴趣，您可以在不调用这样的子shell的情况下执行此操作：

```
print `touch .file1.lock && cp bigfile1 /destination && rm .file1.lock &`; 
```

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2014-11-01T07:23:02.933

您可以使用 GNU`parallel`命令并行运行作业。它更安全更快。

我的猜测是您正在尝试将多个大文件从源复制到目标。为此，您可以与以下语句并行执行此操作。

```
$ ls *|parallel -kj0 --eta 'cp {} /tmp/destination' 
```

由于我们使用`-j0`了选项，所有文件将被并行复制。如果您需要减少并行进程的数量，那么您可以使用`-j<n>`where`<n>`是要执行的并行进程的数量。

Parallel 还会收集进程的输出，并以`-k`其他作业控制机制无法做到的顺序方式（带有选项）进行报告。

`--eta`选项将为您提供正在进行的过程的详细统计信息。所以我们可以知道这个过程有多少完成了，需要多长时间才能完成。

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2019-07-10T05:31:02.353

您可以将参数传递给命令组（具有顺序命令）并在后台运行它们。

```
for hrNum in {00..11};
do
    oneHour=$((10#$hrNum + 0))
    secondHour=$((10#$hrNum + 12))
    { echo "$oneHour"; echo "$secondHour"; } &
    wait
done 
```

# windows - 使用什么语言/方法来收听 Windows 中的可移动驱动器？

> ID：161257
> 
> 赞同：-1
> 
> 时间：2008-10-02T07:52:09.997
> 
> 标签：windows, events, drive, listen

当可移动驱动器插入 PC 时，我将使用什么语言或方法来收听事件？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-02T09:01:06.790

我想任何可以与 Windows API 一起使用的语言都应该这样做。基本上，您听的是 Windows 消息 WM_DEVICECHANGE。仅此一项就可以让您收听系统范围的消息。

有关更具体的场景，请查看 API 函数 RegisterDeviceNotification()。不用说，C/C++ 可以直接完成这项任务。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T07:56:04.153

您的程序是否将作为 Windows 服务运行并等待？还是在这种情况下将启动脚本放在可移动驱动器上？

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T08:01:32.550

[codeproject.com](http://www.codeproject.com/KB/shell/shchangenotifyregister.aspx)上的这篇文章是用 C++ 编写的，并且有一个使用 shell 更改通知注册功能的解决方案。

# windows - 如何为 Windows 平台的 USB 设备编写驱动程序？

> ID：161273
> 
> 赞同：12
> 
> 时间：2008-10-02T07:58:45.193
> 
> 标签：windows, usb, driver

我正在寻找一种通过 USB 接口读取接线电压并返回数据的设备。我将如何编写一些东西来解释这些数据以及我将使用什么语言？

编辑：如果有帮助，这个项目是为不支持综合 ODB2 数据端口的旧引擎开发一个数字转速表。因此，它将读取直流电路上的电压并具有准确的图形界面。我完全不知道从哪里开始，但我决心让它发挥作用！它适用于窗户。

* * *

## 回答 #1

> 赞同：8
> 
> 时间：2008-10-02T08:02:44.590

作弊并使用**[libusb](http://libusb.wiki.sourceforge.net/)**。我为一个我已经工作了一段时间的项目做了这个，并编写了一个**C++/ [wxWidgets](http://wxwidgets.org/)**应用程序来处理数据。

我最近一直在考虑用**[wxPython](http://wxpython.org/)**在 PC 上重新编写应用程序，因为它对于 GUI 开发来说要快得多。

你想如何显示/记录数据？有很多可用的选项。[您可以使用wxWidgets 的 OpenGL 功能](http://www.wxwidgets.org/docs/tutorials/opengl.htm)（轻松地）做一些非常酷的事情，无论是 2D 还是 3D 数据表示。

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-10-02T08:44:52.163

如果可以的话，我会建议使用像 kris 和 Jon Cage 所建议的 libusb 这样的库。

如果 libusb 不能满足您的需求并且您正在为 Windows 开发，您应该看看[Jungo](http://www.jungo.com/st/windriver_usb_pci_driver_development_software.html)提供的软件。同样，这将 USB 软件移动到用户空间，而不需要 Windows 内核开发。（编辑 3：Ilya 在评论中指出 Jungo 也可用于 Linux）

如果您必须进行一些内核开发（Windows 或 Linux），那么 C 是您唯一的选择。研究Rubini 为 linux 开发编写的[这](http://lwn.net/Kernel/LDD3/)本书。对于 Windows 驱动程序开发，我可以推荐Oney 的[这](https://rads.stackoverflow.com/amzn/click/com/0735618038)本书。但是在这两种情况下，我都会优先研究 libusb 选项而不是驱动程序开发。

* * *

顺便提一句。如果您感兴趣的只是能够测量 USB 设备上的电压（并且编写代码并不重要），那么有很多产品可以为您做到这一点。看看[National Instruments](http://sine.ni.com/nifn/cds/view/main/p/sn/n24:USB/lang/en/nid/1036/ap/daq)提供的一些产品。这些将处理 USB 的艰苦工作和数据采集，并为您提供一个很好的编程接口以在您的应用程序中使用。

* * *

（编辑 2）还有一些 USB 串行芯片（例如[这些](http://www.ftdichip.com/FTProduct.htm)）可以直接连接到仅使用 uart 的嵌入式处理器。通常这些都带有驱动程序。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-02T08:02:04.077

看看[libusb](http://libusb.wiki.sourceforge.net/)。它适用于 Linux 和 Windows。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-02T10:49:48.323

由于您仍在寻找将电压转换为信息的设备，因此我建议您查看实现 USB-HID（人机接口设备）接口的设备，例如[在此处找到的](http://www.toradex.com/Products/Oak_USB_Sensors)设备。

它们的好处是不需要进行任何设备驱动程序开发或安装驱动程序。它们就像鼠标、键盘或闪存驱动器一样即插即用。该接口非常通用，大多数制造商还提供了必要的库来从设备读取信息、插入/拔出设备时收到通知、发现设备等。

此外，请查看[这篇文章](http://www.vsj.co.uk/articles/display.asp?id=600)，它解释了如何在 C# 中使用 HID 设备，例如。

戴夫

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T10:00:12.500

Unless you're bit-banging your own USB driver on the firmware side, your chip will probably come with a driver for the PC. For example, PIC microcontrollers from Microchip come not only with firmware for the PIC, but with a Windows driver. I expect that other USB-enabled chips would also come with their own drivers.

Remember that while you interact with the USB port directly on the firmware side, on the PC side all you actually interact with is the driver for the host controller.

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T15:18:52.217

大多数微控制器都内置了 ADC，其中很多还内置了 USB 子系统。赛普拉斯、PIC、AVR 浮现在脑海中。每当我为自己的项目做 USB 工作时，我都会使用[pyusb](http://pyusb.berlios.de/)和[wxPython](http://wxpython.org/)。尽管初始学习曲线相当苛刻，但它们使完成工作变得非常容易。

抛开无耻的自我插件不谈，我用pyusb为USB-LCD设备编写了一个小的python驱动程序。[你可以在这里](http://www.penjuinlabs.com/blog/?p=30)查看我的源代码。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-02T15:23:02.877

我个人使用的是 Microchip PIC——它们有 AD/DA 转换器、USB 端口、免费驱动程序和引导加载程序——所有这些都低于 4 美元。插入这样的设备后，您将获得一个额外的 COM 端口 - 其余的都是微不足道的。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-10-02T15:30:57.320

你没有说你在看什么平台。如果您的目标是 Windows，[USB Revealed](https://rads.stackoverflow.com/amzn/click/com/1931448027)是一个很棒的参考。

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-10-02T08:40:55.327

在我看来，如果你想读取接线电压，那么你需要一个 A/D 转换器。您是否正在制作自己的 A/D 转换器？如果是这样，您需要在设备端进行一些不错的固件编程，而不是您在此处询问的主机端驱动程序。否则你要买一个 A/D 转换器，你应该只使用供应商提供的驱动程序。

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2009-12-17T05:02:16.563

对于硬件，请查看[FTDI](http://ftdichip.com "FTDI")产品。

如果您有硬件并想在 Windows 中访问它，我最近发现了[WinUSB](http://msdn.microsoft.com/en-us/library/aa476426.aspx "WinUSB")。如果这是您需要的，请查看[此白皮书](http://www.microsoft.com/whdc/connect/usb/winusb_howto.mspx "这份白皮书")。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-10-02T11:05:31.267

您最简单的选择可能是购买某种现成的数据采集设备。很多公司都在做这种事情，但有时它们的价格高得吓人：

1.  [国家仪器](http://www.ni.com/dataacquisition/usb/)
2.  [扩增子](http://www.amplicon.co.uk/MandC/product/PC-Analog-USB-3028.cfm "数据采集​​产品经销商")
3.  [实验室杰克](http://www.labjack.com/results.php?category=0)

您也可以使用工具包构建自己的工具包，尽管我现在找不到任何链接。

如果您想要更自定义的东西，您可以使用[EZ-USB](http://www.cypress.com/products/?fid=13&rpn=CY7C64713&ref=sch)或[PIC](http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2654 "微芯 USB 产品")。它们提供 USB 驱动程序（至少适用于 Windows），允许您在不编写驱动程序的情况下与设备交互。

对于其中的大多数，您可以选择相当广泛的编程语言，我过去曾编写过用于与 Visual Basic 6 中的 EZ-USB 设备通信的软件。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2010-01-19T09:20:53.367

除了 WinUSB、libusb 和 Jungo，还有另一个从用户模式编程 USB 设备的选项 -[用户模式驱动程序框架 (UMDF)](http://www.microsoft.com/whdc/driver/wdf/UMDF.mspx)。

编写 UMDF 驱动程序基本上是使用您喜欢的工具创建一个进程内 COM 组件。

# ruby-on-rails - ruby/ruby on rails 内存泄漏检测

> ID：161315
> 
> 赞同：45
> 
> 时间：2008-10-02T08:15:27.883
> 
> 标签：ruby-on-rails, ruby, memory, memory-leaks, coding-style

我使用 ruby​​ on rails 编写了一个小型 Web 应用程序，它的主要目的是上传、存储和显示来自 xml（文件最多几 MB）文件的结果。运行大约 2 个月后，我注意到 mongrel 进程使用了​​大约 4GB 的内存。我对调试 ruby​​ 内存泄漏进行了一些研究，但找不到太多。所以我有两个问题。

*   有没有什么好的工具可以用来查找 Ruby/rails 中的内存泄漏？
*   什么类型的编码模式会导致 ruby​​ 中的内存泄漏？

* * *

## 回答 #1

> 赞同：39
> 
> 时间：2008-10-02T11:53:53.007

在 Rails 中查找内存泄漏的一些技巧：

*   使用[荒凉之家](http://www.rubyinside.com/bleakhouse-tool-to-find-memory-leaks-in-your-rails-applications-470.html)插件
*   实施[Scout 监控](https://scoutapm.com/)，特别是内存使用分析器
*   尝试另一个[简单的内存使用记录器](https://github.com/binarylogic/memorylogic/tree/master)

第一个是对 ObjectSpace 中对象的内存使用情况的图形探索。

最后两个将帮助您识别导致内存使用量膨胀的特定使用模式，您可以从那里开始工作。

至于特定的编码模式，根据经验，您必须观察处理文件 io、图像处理、处理大量字符串等的任何内容。

我会检查您是否使用了最合适的 XML 库 - 众所周知，ReXML 很慢并且被认为是泄漏的（我没有证据！）。还要检查您是否可以[记住](https://web.archive.org/web/20160418141426/http://unintelligible.org/blog/2007/08/16/one-line-ruby-memoization/)昂贵的操作。

* * *

## 回答 #2

> 赞同：20
> 
> 时间：2008-10-02T19:46:52.057

在每个请求之后或之前记录内存使用情况的超级简单方法（仅适用于 Linux）。

```
#Put this in applictation_controller.rb
before_filter :log_ram # or use after_filter
def log_ram
  logger.warn 'RAM USAGE: ' + `pmap #{Process.pid} | tail -1`[10,40].strip
end 
```

您可能想要加载脚本/控制台并首先尝试该语句以确保它适用于您的机器。

```
puts 'RAM USAGE: ' + `pmap #{Process.pid} | tail -1`[10,40].strip 
```

然后就监控top，当一个请求让你的内存使用量跳跃时，去查看日志。当然，这只有在内存泄漏发生在大跳跃而不是微小增量时才会有所帮助。

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-10-02T10:35:02.197

内存泄漏是当前 ruby​​ 实现中的一个问题，这是一个很好的起点是 ~~[http://whytheluckystiff.net/articles/theFullyUpturnedBin.html](http://whytheluckystiff.net/articles/theFullyUpturnedBin.html)~~ Whytheluckystiff 网站不再存在，但您可以在此处找到原始文章：[https：/ /viewsourcecode.org/why/hacking/theFullyUpturnedBin.html](https://viewsourcecode.org/why/hacking/theFullyUpturnedBin.html)

有关长时间运行的 ruby​​ 进程问题的更具体答案，请参见 [https://just.do/2007/07/18/heap-fragmentation-in-a-long-running-ruby-process/](https://just.do/2007/07/18/heap-fragmentation-in-a-long-running-ruby-process/)

也许您可以尝试一下乘客（mod_rails）[https://web.archive.org/web/20130901072209/http://nubyonrails.com/articles/ask-your-doctor-about-mod_rails](https://web.archive.org/web/20130901072209/http://nubyonrails.com/articles/ask-your-doctor-about-mod_rails)

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2012-08-31T06:42:55.653

你应该看看[ruby​​-prof](https://github.com/ruby-prof/ruby-prof)。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-10-10T15:35:45.443

切换到 jruby 并使用[Eclipse Memory Analyzer](http://www.eclipse.org/mat)。目前没有可比的 Ruby 工具。

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2010-03-04T08:32:25.353

现在，您可以运行以下命令以 R 可以读取的格式获取内存。我假设您的日志行如下所示：

```
1234567890 RAM USAGE: 27456K 
```

运行这个（或修改为套件）：

```
$ grep 'RAM USAGE' fubar.log | awk '{print s " " $1 " " $4; s++}' | sed 's/K//g' > mem.log 
```

然后你可以运行这个：

```
#!/bin/sh
rm -f mem.png
R --vanilla --no-save --slave <<RSCRIPT
    lst <- read.table("mem.log")
    attach(lst)
    m = memory / 1024.0
    summary(m)
    png(filename="mem.png", width=1024)
    plot(date, m, type='l', main="Memory usage", xlab="time", ylab="memory")
RSCRIPT 
```

并得到一个漂亮的图表。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2014-03-17T21:03:00.617

这些宝石对我有用：

[记忆逻辑](https://github.com/binarylogic/memorylogic)

> 在 Rails 日志中添加进程 ID 和内存使用情况，非常适合跟踪内存泄漏

[恩克](https://github.com/noahd1/oink)

> 日志解析器可识别显着增加 VM 堆大小的操作

# php - 是否有用于电子邮件地址验证的 PHP 库？

> ID：161342
> 
> 赞同：8
> 
> 时间：2008-10-02T08:27:54.780
> 
> 标签：php, email, open-source, email-validation

我需要验证我的用户的电子邮件地址。[不幸的是，制作符合标准](https://www.rfc-editor.org/rfc/rfc2822#section-3.4.1)的验证器很难。

[这](http://www.ex-parrot.com/%7Epdw/Mail-RFC822-Address.html)是一个尝试符合标准的正则表达式示例。

是否有验证电子邮件地址的 PHP 库（最好是开源的）？

* * *

## 回答 #1

> 赞同：16
> 
> 时间：2008-10-02T08:34:26.340

你看过[PHP 的 filter_ 函数](http://us2.php.net/manual/en/function.filter-var.php)吗？它们并不完美，但根据我的经验，它们做得相当不错。

示例用法（返回布尔值）：

`filter_var($someEmail, FILTER_VALIDATE_EMAIL);`

* * *

## 回答 #2

> 赞同：12
> 
> 时间：2008-10-02T09:58:17.200

AFAIK，验证电子邮件的唯一好方法是发送电子邮件并查看用户是否使用此电子邮件中的链接返回站点。这就是很多网站所做的。

正如您通过指向众所周知的庞大正则表达式的链接所指出的那样，验证所有形式的电子邮件地址非常困难，几乎是不可能的。很容易做错，即使是琐碎的电子邮件（我发现太多网站拒绝电子邮件地址中的大写字母！而且大多数旧的正则表达式拒绝超过 4 个字母的 TLD！）。

AFAIK、“Jean-Luc B. O'Grady”@example.com 和 e=mc^2@[82.128.45.117] 都是有效地址……而 I-Made-It-Up@Absurd-Domain-Name。信息可能无效。

所以不知何故，我会检查我们是否有一些东西，一个唯一的@，别的东西，然后用它：它会捕获大多数用户错误（比如空字段或用户名而不是电子邮件地址）。
如果用户想提供一个假地址，它只会给出一些看起来正确的随机地址（参见@on.tv 或 bill.gates@microsoft.com）。并且没有验证器会发现拼写错误（jhon.b@example.com 而不是 john.b@example.com）。

如果真的想根据完整的 RFC 验证电子邮件，我建议使用正则表达式来拆分 @，然后分别检查本地名称和域名。以 " 开头的本地名称的大小写与其他情况等分开。以 [ 开头的域名的大小写与其他情况等分开。在较小的特定域中拆分问题，并仅在定义明确、更简单的情况下使用正则表达式。
此建议可以应用于许多正则表达式用途，当然......

* * *

## 回答 #3

> 赞同：10
> 
> 时间：2009-02-10T16:11:47.320

[更新] 我在这里整理了我所知道的关于电子邮件地址验证的所有信息：http: [//isemail.info](http://isemail.info)，它现在不仅可以验证，还可以诊断电子邮件地址的问题。我同意这里的许多评论，即验证只是答案的一部分；[在http://isemail.info/about](http://isemail.info)上查看我的文章。

我现在整理了来自 Cal Henderson、Dave Child、Phil Haack、Doug Lovell 和 RFC 3696 的测试用例。总共有 158 个测试地址。

我针对我能找到的所有验证器运行了所有这些测试。比较在这里： http: [//www.dominicsayers.com/isemail](http://www.dominicsayers.com/isemail)

随着人们增强他们的验证器，我将尝试使此页面保持最新。感谢 Cal、Dave 和 Phil 在编译这些测试时提供的帮助和合作，以及对[我自己的验证器](http://code.google.com/p/isemail/source/browse/trunk/is_email.php)的建设性批评。

人们应该特别注意[针对 RFC 3696 的勘误表](http://www.rfc-editor.org/errata_search.php?rfc=3696)。其中三个规范示例实际上是无效地址。地址的最大长度是 254 或 256 个字符，**而不是**320。

* * *

## 回答 #4

> 赞同：8
> 
> 时间：2008-10-03T16:26:32.347

[Cal Henderson](http://www.iamcal.com/)（来自 Flickr）编写了一个[符合 RFC822 的电子邮件地址匹配器](http://www.iamcal.com/publish/articles/php/parsing_email)，其中包含对 RFC 的解释以及利用 RFC 匹配电子邮件地址的代码。我已经使用它很长一段时间了，没有任何抱怨。

> RFC822（1982 年发布）定义了互联网文本消息（电子邮件）地址的格式等。您可以通过谷歌搜索找到 RFC - 网上有很多副本。它们有点简洁且格式怪异，但只要稍加努力，我们就可以看到它们在做什么。

... 更新 ...

正如[Porges](https://stackoverflow.com/users/10311/porges)在评论中指出的那样，链接上的库已经过时，但该页面有一个指向[更新版本](http://code.iamcal.com/php/rfc822/)的链接。

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2008-10-02T08:28:21.767

我在谷歌代码中找到了一个库：[http ://code.google.com/p/php-email-address-validation/](http://code.google.com/p/php-email-address-validation/)

还有其他人吗？

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T10:56:32.800

[Zend_Validate](http://framework.zend.com/manual/en/zend.validate.set.html#zend.validate.set.email_address)包括一个电子邮件验证器。

周围有很多用于验证的正则表达式 - 从非常基本到非常高级的所有内容。您确实应该选择与应用程序中有效电子邮件的重要性相匹配的内容。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T12:00:39.917

我建议查看 Zend_Validate_EmailAddress [ [source](http://framework.zend.com/svn/framework/standard/trunk/library/Zend/Validate/EmailAddress.php) ] 的源代码。

修复依赖项后，您只需执行以下操作：

```
$mail_validator = new Zend_Validate_EmailAddress();
$mail_validator->isValid($address);   // returns true or false 
```

最好的办法是将完整的 Zend 库通过`svn external`并指向它的包含路径...

但是您可以只下载必要的文件（[1](http://framework.zend.com/svn/framework/standard/trunk/library/Zend/Validate/EmailAddress.php)、[2](http://framework.zend.com/svn/framework/standard/trunk/library/Zend/Validate/Abstract.php)、[3](http://framework.zend.com/svn/framework/standard/trunk/library/Zend/Validate/Ip.php)、[4](http://framework.zend.com/svn/framework/standard/trunk/library/Zend/Validate/Interface.php)、[5](http://framework.zend.com/svn/framework/standard/trunk/library/Zend/Validate/Hostname.php)、[6](http://framework.zend.com/svn/framework/standard/trunk/library/Zend/Loader.php)），然后将它们全部包含在内（删除*require_once*调用）。

# http - 如何防止 ServerXMLHTTP 自动跟随重定向（HTTP 303 请参阅其他响应）？

> ID：161343
> 
> 赞同：6
> 
> 时间：2008-10-02T08:28:01.143
> 
> 标签：http, post, redirect, winhttp, serverxmlhttp

我正在使用 ServerXMLHTTP 来执行 HTTP POST。返回的响应是一个重定向（特别是 303 See Other）。ServerXMLHTTP 会自动遵循此重定向，但这会导致身份验证失败，因为未传播原始请求的 Authorization 标头。

有没有办法可以防止自动重定向（或者确保重新发送授权标头）？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-02T12:16:22.093

**ServerXMLHTTP 不支持拦截重定向**（请参阅[Microsoft 知识库文章 308607](http://support.microsoft.com/kb/308607)）。但是，可以使用**WinHTTP代替它，并且它****确实**包含一个可配置的“启用重定向”选项。

如何在 VBA 中禁用 WinHTTP 重定向：

```
webClient.Option(6) = False 
```

在上下文中：

```
Set webClient = CreateObject("WinHttp.WinHttpRequest.5.1")
webClient.Option(6) = False 
webClient.Open "POST", "http://example.com", False
webClient.send ("") 
```

# f# - F# - 给定元组条件时出现问题

> ID：161348
> 
> 赞同：-2
> 
> 时间：2008-10-02T08:29:48.020
> 
> 标签：f#

鉴于以下情况：

```
#light
//any function returning bool * 'a
let foo =
    let x = ref 10
    fun () ->
        x := !x - 1
        if !x <> 0 then
            (true, x)
        else
            (false, x)

while let (c,x) = foo() in c do print_any x;//can't access x, but would be convinent.

//this is how I want it to work, without all the typing
let rec loop f =
    match f() with
    | (true, x) ->
        print_any x
        loop f
    | (false, _) -> ()
loop foo 
```

我应该如何解决这个问题？还是我应该费力地将“foo”转换为序列表达式？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T09:32:46.760

这是一种解决方案，但我个人认为这是对 while 构造的滥用。

```
#light
while 
   (let (c,x) = foo()
    if c then print_any !x
    c)
   do () 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T09:41:16.850

我认为另一种解决方案稍微好一些。它将 x 移出 while 的条件子句范围，并将其放入更高范围内可用的引用 y 中。仍然不是最好的（功能性）解决方案，但它确实有效。

```
let y = ref 1
while (let (c,x) = foo()
       y := !x
       c)
       do printf "%i" !y 
```

我认为您的`rec loop`解决方案效果最好，因为它是功能最强大的解决方案（避免副作用，尽管 foo 使用状态）和最通用的解决方案（它与 foo 同时适用于所有功能）。它的输入时间更长，但是如果您将使用更多像 foo 这样的函数，则循环比仅针对 foo 的单个最短解决方案更有效率。

我什至会更多地概括循环，并抽象出你想在“真实”情况下对值执行的操作：

```
let loop f a = 
   let rec loop2() = 
      match f() with
      | (true, x) ->
         a x
         loop2()
      | (false, _) -> ()
   loop2()

loop foo print_any 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T15:20:44.880

我喜欢其他关于如何使用“foo”的建议，假设 foo 是固定的。

在我看来，“foo”的代码很臭。如果按照以下方式将“foo”转换为“bar”是合理的

```
let bar =    
    let x = ref 10    
    seq {
        x := !x - 1        
        while !x <> 0 do
            yield x
            x := !x - 1        
    }
bar |> Seq.iter print_any 
```

然后我会这样做，但是“酒吧”虽然好一些，但仍然看起来很可疑。（在“bar”中，我保留了它返回“int ref”而不仅仅是“int”的奇怪方面，就像“foo”所做的那样，但希望那个方面是无意的？）

我认为“foo”最时髦的地方在于数据类型中不明显的隐含信息（只要 bool 部分为真，您就可以继续调用它），这就是使 seq 版本有点更具吸引力。

# java - 不再使用 EJB 3.0 的主要原因是什么？

> ID：161349
> 
> 赞同：7
> 
> 时间：2008-10-02T08:30:00.937
> 
> 标签：java, jakarta-ee, ejb-3.0

场景

*   您已经使用 EJB 版本 3 开发了一个 webapp。
*   该系统由客户部署、交付和使用。

如果您必须从头开始重写系统，您会再次使用 EJB 吗？

**是**：不要回答这个问题，而是回答[这个](https://stackoverflow.com/questions/105544/most-important-problem-solved-by-ejb-3)问题。

**否**：根据您的个人经验，提供不再使用 EJB 的主要原因。

让答案只包含**一个**原因。这将让其他读者投票选出远离 EJB 3 的第一大理由。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T08:45:25.220

该项目没有任何 EJB 应该解决的问题。使用 EJB 只会使编码、调试、构建、部署以及记录和理解变得更加困难。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T09:19:27.480

不再使用 EJB 3.0 的主要原因是什么？也许您可以等待 EJB 3.1，它消除了一个主要的疯狂：强制本地接口。

[https://blogs.oracle.com/kensaks/entry/optional_local_business_interfaces](https://blogs.oracle.com/kensaks/entry/optional_local_business_interfaces)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T08:56:51.387

必须自己进行关系子管理：Hibernate 的 all-delete-orphan 没有进入 3.0 规范。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-03T20:35:46.383

在 EJB 中编写应用程序过于庞大，根据我的经验，您可以选择轻量级的替代方案

# ms-word - 使用 VSTO 创建新的 Word 文档

> ID：161356
> 
> 赞同：1
> 
> 时间：2008-10-02T08:32:31.460
> 
> 标签：ms-word, vsto, ms-office

如何使用 Visual Studio Tools for Office 以编程方式创建新的 Word 文档？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2011-05-22T23:52:23.343

您真正追求的是使用 PIA（主要互操作程序集）的办公自动化。

VSTO 实际上是一组托管的 .net 扩展，这使得为 Office 编写加载项变得更加容易。对于外部交互，根本不使用 VSTO（尽管您仍然可以参考 VSTO 库并根据需要使用一些帮助程序）。

请查看[http://support.microsoft.com/kb/316384](http://support.microsoft.com/kb/316384)以帮助您入门。和谷歌'word interop 创建文档'

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-11-18T12:30:37.933

对于 VSTO 应用级加载项，您可以执行以下操作：

```
Globals.ThisAddIn.Application.Documents.Add(ref objTemplate, ref missingType, ref missingType, ref missingType); 
```

哪里`objTemplate`可以是文档模板

请参阅[Documents.Add 方法](http://msdn.microsoft.com/en-us/library/microsoft.office.interop.word.documents.add%28v=office.14%29.aspx)

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2010-04-29T18:36:25.880

现在，我可能错了，但我不相信你真的可以使用 VSTO 制作一个新的 Word 文档。我对 VSTO 不是很熟悉，所以如果我在这一点上不正确，请原谅我。

不过，我知道您可以使用 Office 互操作库来执行此操作。

要下载这些库，只需搜索“office interop 程序集”，可能包括您想要的 Office 版本（例如：“office interop 程序集 2007”）。

将 Word Interop 程序集包含到应用程序中后（使用添加引用），您可以执行以下操作：

```
using Word = Microsoft.Office.Interop.Word;

object missing = System.Reflection.Missing.Value;
Word.Application app = new Word.ApplicationClass();
Word.Document doc = app.Documents.Add(ref missing, ref missing, ref missing, ref missing);
doc.Activate();
app.Selection.TypeText("This is some text in my new Word document.");
app.Selection.TypeParagraph(); 
```

希望有帮助！

# python - 用于将回溯转换为其异常的库？

> ID：161367
> 
> 赞同：0
> 
> 时间：2008-10-02T08:35:39.347
> 
> 标签：python

只是好奇：是否有一种已经编码的方法可以将打印的回溯转换回生成它的异常？:) 还是到类似 sys.exc_info 的结构？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T09:48:57.207

给定常见的异常类（解析异常类的最后一行以及在实例化时给它的参数），将回溯转换为异常对象不会太难。回溯对象（sys.exc_info返回的第三个参数（ )) 是完全不同的事情，不过。回溯对象实际上包含在异常发生时构成堆栈的帧对象链。包括局部变量、全局变量等。仅仅从显示的回溯中重新创建它是不可能的。

您可以做的最好的事情是解析每个“文件“X”，第 N 行，在 Y:' 行并创建几乎完全为空的假框架对象。它的价值很小，因为基本上你唯一能用它做的就是打印它。你想达到什么目的？

# .net - 将 .net 2.0 解决方案转换为 .net 3.5 的陷阱

> ID：161368
> 
> 赞同：6
> 
> 时间：2008-10-02T08:35:48.503
> 
> 标签：.net, visual-studio, migration, enterprise-library

我们正在将一个包含 20 多个项目的解决方案从 .net 2.0 迁移到 3.5，同时从 Visual Studio 2005 迁移到 2008。我们同时也从 MS Entlib 2.0 切换到 4.0。

*   是否有任何理由不让 Visual Studio 向导为我们转换解决方案？
*   3.5 是否完全向后兼容 2.0？
*   Entlib 4.0 是否完全向后兼容 2.0？

**编辑：**当我写这篇文章时，我可能有点困惑，向后兼容性应该意味着；2.0 项目中是否存在无法在 3.5 中工作/编译的内容

:)

//W

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-02T15:44:12.920

我们从 2005 年到 2008 年升级了一个相当大的解决方案（20 多个项目），但它真的很微不足道。项目升级基本而已。底层框架仍然相同，因为 3.0/3.5 和 2.0 共享相同的核心框架。

如上所述，即使您正在升级，也不需要更改项目的框架引用 - 事实上，它默认将框架保留为 2.0 而不是将其更改为 3.0/3.5。这意味着您将无法利用 3.0/3.5 功能，直到您更改参考（项目属性页面，应用程序表“目标框架”字段），但这也意味着您更加确信不会有额外的兼容性问题（因为在更改该引用之前，添加 3.0/3.5 代码会出错）。

TFS 2008 的新功能也不容忽视，尽管您无需升级应用程序即可使用 TFS 2008。

1.1 到 2.0 的转换要痛苦得多……

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-02T08:42:05.510

我使用向导将几个项目从 Visual Studio 2005 升级到 2008，并且它们都变得轻松（嗯......除了那个 C++ 野兽。但无论如何你都在谈论 .NET）。

请记住，您不需要升级 .NET 版本。Visual Studio 2008 支持 .NET 2.0、3.0 和 3.5。但是，无论如何，3.5 都是向后兼容的，因为它位于同一个 CLR 上，并且或多或少只是一些额外的库。“旧”库保持不变。

我不知道Entlib。

你为什么不试着运行你的单元测试呢？:)

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T08:44:12.323

*   是否有任何理由不让 Visual Studio 向导为我们转换解决方案？

不。

*   3.5 是否完全向后兼容 2.0？

不，3.5 中的新功能不会原生向后移植。并且（IIRC）从 2.0 到 3.5 有一些弃用。

*   Entlib 4.0 是否完全向后兼容 2.0？

我不这么认为。3.5 被列为要求。

进行备份，运行向导，看看会发生什么。这样一个庞大的项目可能需要一段时间，但您将处于可以判断它是否会按预期构建/运行的位置。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2009-06-26T11:42:24.287

当我从 EntLib 2.0 升级到 4.0 时，如果您使用缓存应用程序块，我观察到以下破坏性源代码更改：

*   在 2.0 中，您可以使用`CacheManager cache = CacheFactory.GetCacheManager()`.
*   在 4.0 中，您必须替换`CacheManager`为，`ICacheManager`否则将无法编译。

此外，如果您正在为异常处理块编写自己的异常格式化程序类：

*   在 2.0 中，您必须定义一个带有签名的构造函数`(TextWriter, Exception)`。
*   在 4.0 中，这已过时，您必须使用签名定义第二个构造函数`(TextWriter, Exception, Guid)`。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2009-07-09T04:07:20.463

从 EntLib 3.1 迁移到 4.0 时不应该有任何重大更改：

“公共 API 没有重大变化。这是 EL4 的设计目标之一。请记住 EL4 需要 .NET3.5。

——格里高利”

[http://blogs.msdn.com/agile/archive/2008/05/16/enterprise-library-4-0-for-visual-studio-2008-released.aspx](http://blogs.msdn.com/agile/archive/2008/05/16/enterprise-library-4-0-for-visual-studio-2008-released.aspx)

（Grigori 是 EntLib 的项目经理）

不过，我不确定 2.0 到 3.1。如果我明天能找到合适的人@p&p，我会更新这个。

阿德

# c++ - 在 Visual Studio 中关闭运行时检查

> ID：161369
> 
> 赞同：3
> 
> 时间：2008-10-02T08:35:49.300
> 
> 标签：c++, visual-studio-2008, runtime

我有一个问题，在 Visual C++ 2008 中运行时检查失败，因为将太大的数字转换为较小的类型。故障出在外部 dll 中，所以我无法在那里修复它。那么如何关闭外部项目的运行时检查。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T09:17:36.627

如果强制转换（和检查）发生在您无法重新编译的这个 DLL 中，那么您不能轻易关闭检查。

您唯一能做的就是更改传递给 DLL 的数据以避免该问题。或者修补二进制文件以禁用检查，这可能不会像这种事情那样非常困难 - 你对反汇编程序好吗？

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2021-04-28T07:34:00.787

运行时检查取决于选项 /RTC c 能够在项目的 Visual Studio 配置属性、C/C++ 代码生成、“较小的类型检查”中找到。您应该关闭它，然后重新编译。

* * *

## 回答 #3

> 赞同：-1
> 
> 时间：2008-10-02T09:12:06.343

您始终可以在项目设置中关闭强制转换为较小的类型检查。

如果在检查被编译到 dll 时这不起作用，那么您可以尝试链接到非调试版本的 dll，因为检查只能用于调试“优化”构建。当然，它可能会影响您的调试。

# c# - 隐藏 WinForms TreeView 加号

> ID：161378
> 
> 赞同：5
> 
> 时间：2008-10-02T08:40:53.547
> 
> 标签：c#, winforms, treeview

我有一个带有一个主节点和几个子节点的 WinForms TreeView。

如何隐藏主节点中的 +（加号）？

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2008-10-02T08:47:45.963

Treview 属性：**`.ShowRootLines = false`**

当`ShowRootLines`为 false 时，不会为根节点显示加号/减号，但在必要时仍会在子节点上显示。

隐藏加号/减号后，您可以考虑在`Expand()`填充树后执行根节点的方法。这将确保根节点显示所有第一级子节点。

注意：TreeView 上有一个`ShowPlusMinus`属性，但它适用于*所有*节点。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T08:51:14.693

请参阅 TreeView::ShowExpandCollapse 属性。将其设置为 false 以禁用展开/折叠节点指示器。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2013-01-18T16:14:40.727

将 SiteMapDataSource 属性 ShowStartingNode 设置为 false。例如：

# css - 使用带有媒体打印的 css 时隐藏下拉列表的三角形

> ID：161388
> 
> 赞同：2
> 
> 时间：2008-10-02T08:43:41.327
> 
> 标签：css, drop-down-menu, printing, media

我在我的外部 css 文件中使用 @media print 来隐藏菜单等。但是，在打印下拉列表的小三角形时仍然显示。是否有可用的 css 设置来隐藏它并只打印所选项目？

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2012-05-15T19:16:28.827

这适用于 Chrome 和 Firefox（其他可能也适用）

```
-moz-appearance: none;
-webkit-appearance: none;
appearance: none; 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-03T13:21:39.597

正如大多数人所说，表单小部件的呈现风格几乎取决于浏览器。您可以对它们进行一些样式化，但对它们进行根本性的更改充其量是不可靠的。

正如另一位评论者所提到的，您最好使用一些 javascript 来实现此效果。我已经给出了一些 jQuery 可以做到这一点。但它并不理想 - 它依赖于用户单击“打印此页面”链接，而不是使用浏览器自己的打印功能。

对于以下标记：

```
 <p><a class="print" href="#">print this</a></p>
    <form action="/my/action/" method="POST">
        <select id="mySelect">
            <option value="1">An Option</option>
            <option value="2" selected="selected">Another Option</option>
        </select>
    </form> 
```

这个 jQuery 将从下拉列表中附加一个包含当前所选项目内容的段落，并在打印页面之前隐藏表单元素。

```
 $(document).ready(function() {
        $('a.print').click(function() {
            var selected = $('#mySelect option:selected').text();
            $('#mySelect').after('<p class="replacement">' + selected + '</p>');
            $('#mySelect').hide();
            window.print();
        });
    }); 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T08:50:48.080

不，没有。此外，每个浏览器都以自己的方式显示其下拉菜单，有些使用系统小部件，有些有自己的。例如，在 Safari 中，无论您删除什么样式，它仍然有一个框（嗯，有点）围绕它。如果您不想更改您的 HTML 代码，也许一些 javascript 可能会做到 - 获取选定的值并将下拉列表交换为段落。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-02T09:13:20.817

我会暂时说你不能，因为它是一个整体组件：你不能改变它，就像你不能改变滚动条的外观一样。

我没有随机选择我的示例：当然，在某些浏览器中（至少是 IE），您可以更改后者。但是使用一些特定于浏览器的 CSS，这不是很实用，除非您的目标是强制内部网应用程序......

太糟糕了，隐藏这部分确实是个好主意。

[更新] 可能有一种方法，虽然在语义上它有点难看......无论如何。

```
<select name="Snakes" style="width: 200px;">
  <option value="A">Anaconda</option>
  <option value="B">Boa</option>
  <option value="C">Cobra</option>
  <option selected="" value="P">Python</option>
  <option value="V">Viper</option>
</select>
<!-- Put this style in a class, of course -->
<div style="background-color: white; 
    min-width: 20px; max-width: 20px; position: relative; 
    right: -180px; top: -19px;">&Nbsp;</div> 
```

当然，div 必须隐藏在屏幕媒体中，并在平面媒体中获得上述样式。
在 WinXP 上的 FF3、Opera 9.5 甚至 IE7（不是 IE6）中运行良好。唉，我担心上述黑客是系统相关的，可能会在其他浏览器中被破坏。

PS.：我写 Nbsp 是因为语法高亮隐藏了它... :-P

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-11-10T22:11:10.520

这在 IE6 中对我有用。其他浏览器没试过

[http://weblogs.asp.net/bleroy/archive/2005/08/09/how-to-put-a-div-over-a-select-in-ie.aspx](http://weblogs.asp.net/bleroy/archive/2005/08/09/how-to-put-a-div-over-a-select-in-ie.aspx)

# c# - 在 Active Directory 中使用登录名查找用户

> ID：161398
> 
> 赞同：7
> 
> 时间：2008-10-02T08:46:09.290
> 
> 标签：c#, active-directory

我可能只是愚蠢，但我正在尝试使用登录名（“域\用户”）从 C# 在 Active Directory 中查找用户。

我的“骨架”广告搜索功能通常如下所示：

```
de = new DirectoryEntry(string.Format("LDAP://{0}", ADSearchBase), null, null, AuthenticationTypes.Secure);
ds = new DirectorySearcher(de);
ds.SearchScope = SearchScope.Subtree;
ds.PropertiesToLoad.Add("directReports");
ds.PageSize = 10;
ds.ServerPageTimeLimit = TimeSpan.FromSeconds(2);
SearchResult sr = ds.FindOne(); 
```

现在，如果我拥有用户的完整 DN（ADSearchBase 通常指向 Active Directory 中的“我们的用户”OU），这将起作用，但我根本不知道如何根据“域\用户”语法查找用户.

任何指针？

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-10-02T10:44:17.043

您需要设置一个过滤器（DirectorySearcher.Filter），例如：

“(&(objectCategory=person)(objectClass=user)(sAMAccountName={0}))”

请注意，您只为属性 sAMAccountName 指定用户名（不包括域）。要搜索域\用户，首先找到所需域的命名上下文，然后在那里搜索 sAMAccountName。

顺便说一句，在使用 String.Format 构建 LDAP 查询字符串时，通常应该小心转义任何特殊字符。帐户名称可能不是必需的，但如果您正在搜索其他属性，例如用户的名字（givenName 属性）或姓氏（sn 属性），则可能是必需的。我有一个实用方法 EscapeFilterLiteral 来执行此操作：您可以像这样构建字符串：

```
String.Format("(&(objectCategory=person)(objectClass=user)(sn={0}))", 
              EscapeFilterLiteral(lastName, false)); 
```

其中 EscapeFilterLiteral 实现如下：

```
public static string EscapeFilterLiteral(string literal, bool escapeWildcards)
{
    if (literal == null) throw new ArgumentNullException("literal");

    literal = literal.Replace("\\", "\\5c");
    literal = literal.Replace("(", "\\28");
    literal = literal.Replace(")", "\\29");
    literal = literal.Replace("\0", "\\00");
    literal = literal.Replace("/", "\\2f");
    if (escapeWildcards) literal = literal.Replace("*", "\\2a");
    return literal;
} 
```

此实现允许您将 * 字符视为文字的一部分 (escapeWildcard = true) 或通配符 (escapeWildcard = false)。

更新：这与您的问题无关，但您发布的示例并未在其使用的一次性对象上调用 Dispose。与所有一次性对象一样，这些对象（DirectoryEntry、DirectorySearcher、SearchResultCollection）应始终被处置，通常使用 using 语句。有关更多信息，请参阅[此帖子](https://stackoverflow.com/questions/90652/can-i-get-more-than-1000-records-from-a-directorysearcher-in-aspnet#90668)。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T11:57:04.917

谢谢。我想我可以通过指定“LDAP://{0}.somedomain.com/DC={0},DC=somedomain,DC=com”来获取域（至少在我的 AD 中），将 {0} 替换为域，至少在我们的环境中有效。

但是有一个问题：sAMAccountName 似乎已被贬低：[用于支持运行旧版本操作系统的客户端和服务器的登录名，例如 Windows NT 4.0、Windows 95、Windows 98 和 LAN Manager。此属性必须少于 20 个字符才能支持旧客户端。](http://msdn.microsoft.com/en-us/library/ms679635%28VS.85%29.aspx)

这仍然是最好的方法吗？还是有更“现代”的领域可以查询？（Windows 2003 Active Directory、Windows XP 或 2003 客户端、.net 3.0）

**编辑：**再次感谢。我们的结构有点复杂：我们有一个很大的“domain.com”森林，有多个区域办事处的域。本质上：登录是“something\username”，完整的域是 some.domain.com，邮件是 user@domain.com（没有 something），但主体名称是 user@something.domain.com。我将手动“翻译”something\username 为 username@something.domain.com，因为这似乎是最可靠的方式。特别是因为我想保留自动发现功能。

* * *

## 回答 #3

> 赞同：-1
> 
> 时间：2013-08-13T18:03:49.887

登录名（Windows 2000 之前）

```
"(&(objectCategory=person)(objectClass=user)(!sAMAccountType=805306370)(sAMAccountName=John))" 
```

登录名（Windows 2000 及以上）

```
"(&(objectCategory=person)(objectClass=user)(!sAMAccountType=805306370)(userPrincipalName=John))" 
```

# c# - Page.Tostring() 在 .net 1.1 中的行为有点奇怪？

> ID：161399
> 
> 赞同：0
> 
> 时间：2008-10-02T08:46:43.877
> 
> 标签：c#, .net, .net-1.1

我有一个控件，我必须检查我在哪个页面，所以我可以相应地设置某个变量。

```
string pageName = this.Page.ToString();
switch (pageName)
{
case "ASP.foo_bar_aspx": doSomething(); break;
default: doSomethingElse(); break;
} 
```

这在本地和某些开发服务器上都可以正常工作，但是当我将其上线时，它停止工作，因为我没有得到`ASP.foo_bar_aspx`但是`_ASP.foo_bar_aspx` （请注意实时版本中的下划线）为什么它会这样，我可以以某种方式设置它吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T08:50:24.100

您不能依赖自动生成的名称。改用类型，例如：

```
if (Page is FooBar) { ... } 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T08:49:53.977

这似乎是获取当前请求的一种非常狡猾的方式。您是否尝试过使用`HttpContext.Current.Request.FilePath`或其他`HttpContext.Current.Request...`变量？

# sql - 在 SQL 中使用 DISTINCT 内连接

> ID：161404
> 
> 赞同：38
> 
> 时间：2008-10-02T08:48:45.323
> 
> 标签：sql, distinct, inner-join

我有三个表，A、B、C，其中 A 是多对一 B，B 是多对一 C。我想要 A 中所有 C 的列表。

我的表是这样的：A[id，valueA，lookupB]，B[id，valueB，lookupC]，C[id，valueC]。我已经用两个嵌套的 SELECT 编写了一个查询，但我想知道是否有可能以某种方式使用 DISTINCT 进行 INNER JOIN。

```
SELECT valueC
FROM C
INNER JOIN
(
    SELECT DISTINCT lookupC
    FROM B INNER JOIN
    (
        SELECT DISTINCT lookupB
        FROM A
    ) 
    A2 ON B.id = A2.lookupB
) 
B2 ON C.id = B2.lookupC 
```

编辑：表相当大，A 是 500k 行，B 是 10k 行，C 是 100 行，所以如果我做一个基本的内部连接并最后使用 DISTINCT，就会有很多不必要的信息，如下所示：

```
SELECT DISTINCT valueC
FROM 
C INNER JOIN B on C.id = B.lookupB
INNER JOIN A on B.id = A.lookupB 
```

这非常非常慢（比我上面做的嵌套 SELECT 慢几倍。

* * *

## 回答 #1

> 赞同：15
> 
> 时间：2008-10-02T13:38:33.113

I did a test on MS SQL 2005 using the following tables: A 400K rows, B 26K rows and C 450 rows.

The estimated query plan indicated that the basic inner join would be 3 times slower than the nested sub-queries, however when actually running the query, the basic inner join was twice as fast as the nested queries, The basic inner join took 297ms on very minimal server hardware.

What database are you using, and what times are you seeing? I'm thinking if you are seeing poor performance then it is probably an index problem.

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2008-10-02T08:55:44.727

我相信您的**1:m**关系应该已经隐式地创建了 DISTINCT JOIN。

But, if you're goal is just C's in each A, it might be easier to just use DISTINCT on the outer-most query.

```
SELECT DISTINCT a.valueA, c.valueC
FROM C
    INNER JOIN B ON B.lookupC = C.id
    INNER JOIN A ON A.lookupB = B.id
ORDER BY a.valueA, c.valueC 
```

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-02T08:55:56.880

```
SELECT DISTINCT C.valueC 
FROM C 
  LEFT JOIN B ON C.id = B.lookupC
  LEFT JOIN A ON B.id = A.lookupB
WHERE C.id IS NOT NULL 
```

I don't see a good reason why you want to limit the result sets of A and B because what you want to have is a list of all C's that are referenced by A. I did a distinct on C.valueC because i guessed you wanted a unique list of C's.

* * *

**EDIT**: I agree with your argument. Even if your solution looks a bit nested it seems to be the best and fastest way to use your knowledge of the data and reduce the result sets.

There is no distinct join construct you could use so just stay with what you already have :)

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-02T08:54:05.560

你是这个意思吗？

```
SELECT DISTINCT C.valueC
FROM 
C
INNER JOIN B ON C.id = B.lookupC
INNER JOIN A ON B.id = A.lookupB 
```

# sql - 哪些工具可用于提供 SQL Server 数据库使用的磁盘空间的细分

> ID：161422
> 
> 赞同：0
> 
> 时间：2008-10-02T08:54:04.403
> 
> 标签：sql, database, size, msde2000

我有一个似乎接近 2Gb 限制的 MSDE2000 数据库。

我可以使用哪些工具来确定所有空间的使用位置？

理想情况下考虑用于 SQL 数据库的 TreesizePro

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T09:12:20.960

虽然数据库大小可能是 1.5GB，但它可能只包含 500MB 的数据。这将取决于许多因素（即自动增长大小、索引填充因素等）。运行 sp_spaceused 以查明有多少未分配。然后，您应该能够使用 DBCC SHRINKDB 之类的东西来回收一些空间。

要查看文件的大小，您只需查看磁盘即可。将有一个数据文件 (.MDF) 和一个日志文件 (.LDF) - 除非您将数据库拆分为多个文件组，我不知道您是否可以在 MSDE 中执行此操作。

如果您想找出哪些表/索引使用最多的空间（并且假设您没有企业管理器来简单地查看任务板视图 - 这也会为您提供上面的信息），那么您可以使用表名执行 sp_spaceused作为参数。对所有表运行或编写一个脚本来循环遍历所有表不会花费很长时间。

# hibernate - 自动查询缓存失效

> ID：161427
> 
> 赞同：4
> 
> 时间：2008-10-02T08:55:40.237
> 
> 标签：hibernate, caching

我试图了解休眠查询缓存的真正工作原理。我现在看到的是，当我将新实体插入数据库时​​，Hibernate 不会自动更新其二级缓存（尽管我只使用 Hibernate 调用）。我发现让它工作的唯一方法是在插入新实体后手动清理缓存。

这是更具体的例子。我有一个名为 Container 的持久实体，它可以有许多项目。我想缓存所有项目：

```
@Cache（使用 = CacheConcurrencyStrategy.READ_WRITE）
类项目
{
  //剩下的代码...
}

类容器{
  @Cache（使用 = CacheConcurrencyStrategy.READ_WRITE）

  公共列表 getItems() { ... }

  //剩下的代码...
}

```

我注意到的问题是，当我：

1）从db中读取一些Containers到内存中（连同对应的item）

```
 String hql =
      "from Container c left join fetch c.items where c.type = 1";
   List<Item> list = hibernateTemplate.find(hql); 
```

2) 为选定的容器插入新项目

```
 hibernateTemplate.save(item) 
```

3）重复第一步
，然后在第三步中我看不到我在第二步中插入的项目。只有在插入新项目后手动清理缓存时，我才会看到它们：

```
 sessionFactory.evictCollection("Container.items", updatedContainerId) 
```

我的直觉告诉我，Hibernate 应该自动执行这样的缓存失效。有没有人看到它工作？我做错了什么还是不支持？

提前感谢您的回答。问候汤姆

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2009-07-10T07:19:18.713

您可能会发现我关于查询缓存工作的博客有助于理解查询缓存的作用以及为什么它可能无法按照您认为的方式工作：

*   [http://tech.puredanger.com/2009/07/10/hibernate-query-cache/](http://tech.puredanger.com/2009/07/10/hibernate-query-cache/)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-03T12:05:38.520

Hibernate 使用由查询（或查询名称）和指定参数的值组成的键来存储来自查询的数据。我想当您修改数据时，它不能轻易知道要使哪些缓存无效。

要解决此问题，您只需调用[SessionFactory.evictQueries 即可](http://www.hibernate.org/hib_docs/v3/api/org/hibernate/SessionFactory.html#evictQueries(java.lang.String))。

* * *

## 回答 #3

> 赞同：-1
> 
> 时间：2012-06-04T16:44:51.700

是的，本机 SQL 查询不存在查询缓存自动失效。对于 HQL 查询，如果参与查询的任何表对任何对象都有 INSERT/UPDATE/DELETE，则它只是清除所有缓存。

所以你可以试试[Hibernate Dynamic SQL Cache](https://github.com/mrniko/hibernate-dsc)项目，它旨在通过自动更新 SQL 查询缓存而不失效来解决这个问题。

PS“比尔蜥蜴”感谢您的理解:)

# eclipse - 单元测试：Maven 还是 Eclipse？

> ID：161430
> 
> 赞同：2
> 
> 时间：2008-10-02T08:56:01.560
> 
> 标签：eclipse, unit-testing

我对 Maven 程序不是很熟悉，但我已经使用 Eclipse 进行单元测试、代码覆盖、javadoc 生成、代码样式检查等很长一段时间了。可能是我不太喜欢 Eclipse 的唯一主要事情是同时运行 Eclipse 和 Ant 时它生成的“编译错误”。所以我想知道如果您正在运行 Ant 任务，Maven 2 是否会做同样的事情。

李23

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T09:06:28.540

我目前工作的公司有很多使用 Maven (1.x) 运行的 JUnit 测试。我们从来没有真正遇到过任何问题，任何在 Maven 中失败的测试都可以使用远程调试器或在 Eclipse 中自行调试。

最重要的是您花时间和精力正确设置环境，以便在您的测试运行时使用正确的目录、变量等。这样您就不会遇到“编译错误”运行 Eclipse 和 Ant 时获取。

Maven 能够在编译的测试周期中为您运行所有测试，这应该不再需要任何 Ant 任务来运行测试。但是，如果您仍然需要其他任务（生成代码等）的脚本，那么请厌倦 Maven 生成代码的能力，而不是将其包含在已编译的二进制文件（jar、war）中，尽管这可能会为新版本修复Maven 的版本。

最终，最好评估一下 Maven 2，看看它是否适合您。听起来您已经（讽刺）用 Ant 和 Eclipse 获得了很多乐趣（/讽刺）。:)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T09:11:23.177

使用 maven 的主要好处之一是您需要指定一次依赖项、构建设置和部署方法，然后您可以在多个环境中运行它们。

特别是，您只需使用 pom.xml 文件就可以让您的持续集成/夜间构建环境运行这些任务。

此外，您可以（并且可能应该）将 pom.xml 文件添加到您的版本控制存储库中。这有两个好处：a）您可以跟踪版本之间的构建过程如何变化，以及 b）其他开发人员不需要手动查找和安装您的项目所依赖的所有 JAR 文件，他们只需获取 POM 文件并maven 负责其余的工作。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T09:39:45.950

如果您已经准备好使用测试和代码覆盖工具，那么您应该研究一下 maven。特别是如果您开始与项目团队合作。

只要您是唯一的开发人员，在 eclipse 中运行测试就可以了。使用 maven 将使您能够使用连续集成工具，例如[continuum](http://continuum.apache.org/)

似乎您必须投入更多时间来正确设置 maven，但从长远来看，它肯定会带来回报。

我们在这里使用 continuum，只要系统设置正确，我们就从未见过任何编译错误问题。

# c# - 在 C# 2.0 中同步两个 IList 的最佳算法

> ID：161432
> 
> 赞同：11
> 
> 时间：2008-10-02T08:56:22.217
> 
> 标签：c#, .net, algorithm, optimization, list

想象一下以下类型：

```
public struct Account
{
    public int Id;
    public double Amount;
} 
```

`IList<Account>`在 C# 2.0中同步两个的最佳算法是什么？（没有 linq）？

第一个列表（L1）是参考列表，第二个（L2）是根据第一个同步的：

*   L2 中不再存在于 L1 中的所有帐户必须从 L2 中删除
*   必须更新 L2 中仍然存在于 L1 中的所有帐户（金额属性）
*   所有在 L1 中但尚未在 L2 中的帐户都必须添加到 L2

Id 标识帐户。找到一个幼稚且有效的算法并不难，但我想知道是否有一个聪明的解决方案来处理这种情况而不会破坏可读性和性能。

**编辑**：

*   帐户类型无关紧要，可以是一个类、具有属性、相等成员等。
*   L1 和 L2 未排序
*   L2 项目不能被 L1 项目替换，它们必须更新（逐个字段，逐个属性）

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-02T08:59:56.917

首先，我会摆脱可变结构。可变值类型从根本上来说是一件坏事。（与公共领域一样，IMO。）

可能值得构建一个字典，以便您可以轻松比较两个列表的内容。一旦你有了检查存在/不存在的简单方法，剩下的就应该很简单了。

老实说，听起来您基本上希望 L2 成为 L1 的完整副本...清除 L2 并调用 AddRange？还是说您在更改 L2 时还想采取其他行动？

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-02T09:43:55.017

如果您的两个列表已排序，那么您可以简单地串联浏览它们。这是一个 O(m+n) 操作。以下代码可能会有所帮助：

```
class Program
{
    static void Main()
    {
        List<string> left = new List<string> { "Alice", "Charles", "Derek" };
        List<string> right = new List<string> { "Bob", "Charles", "Ernie" };

        EnumerableExtensions.CompareSortedCollections(left, right, StringComparer.CurrentCultureIgnoreCase,
            s => Console.WriteLine("Left: " + s), s => Console.WriteLine("Right: " + s), (x,y) => Console.WriteLine("Both: " + x + y));
    }
}

static class EnumerableExtensions
{
    public static void CompareSortedCollections<T>(IEnumerable<T> source, IEnumerable<T> destination, IComparer<T> comparer, Action<T> onLeftOnly, Action<T> onRightOnly, Action<T, T> onBoth)
    {
        EnumerableIterator<T> sourceIterator = new EnumerableIterator<T>(source);
        EnumerableIterator<T> destinationIterator = new EnumerableIterator<T>(destination);

        while (sourceIterator.HasCurrent && destinationIterator.HasCurrent)
        {
            // While LHS < RHS, the items in LHS aren't in RHS
            while (sourceIterator.HasCurrent && (comparer.Compare(sourceIterator.Current, destinationIterator.Current) < 0))
            {
                onLeftOnly(sourceIterator.Current);
                sourceIterator.MoveNext();
            }

            // While RHS < LHS, the items in RHS aren't in LHS
            while (sourceIterator.HasCurrent && destinationIterator.HasCurrent && (comparer.Compare(sourceIterator.Current, destinationIterator.Current) > 0))
            {
                onRightOnly(destinationIterator.Current);
                destinationIterator.MoveNext();
            }

            // While LHS==RHS, the items are in both
            while (sourceIterator.HasCurrent && destinationIterator.HasCurrent && (comparer.Compare(sourceIterator.Current, destinationIterator.Current) == 0))
            {
                onBoth(sourceIterator.Current, destinationIterator.Current);
                sourceIterator.MoveNext();
                destinationIterator.MoveNext();
            }
        }

        // Mop up.
        while (sourceIterator.HasCurrent)
        {
            onLeftOnly(sourceIterator.Current);
            sourceIterator.MoveNext();
        }

        while (destinationIterator.HasCurrent)
        {
            onRightOnly(destinationIterator.Current);
            destinationIterator.MoveNext();
        }
    }
}

internal class EnumerableIterator<T>
{
    private readonly IEnumerator<T> _enumerator;

    public EnumerableIterator(IEnumerable<T> enumerable)
    {
        _enumerator = enumerable.GetEnumerator();
        MoveNext();
    }

    public bool HasCurrent { get; private set; }

    public T Current
    {
        get { return _enumerator.Current; }
    }

    public void MoveNext()
    {
        HasCurrent = _enumerator.MoveNext();
    }
} 
```

不过，在迭代它们时，您必须小心修改集合。

如果它们没有排序，那么将一个中的每个元素与另一个中的每个元素进行比较是 O(mn)，这很快就会变得很痛苦。

如果您可以忍受将每个集合中的键值复制到字典或类似内容中（即当被问及“X 存在吗？”时具有可接受性能的集合），那么您可以想出一些合理的东西。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2019-02-14T12:44:02.820

我遇到了同样的问题，我最好的解决方案是以下（适用于您的情况），同时加载了两个列表：

1.  对于 L1 中的每个*Account*，验证它是否存在于 L2：
    *   如果找到，请根据 L2更新 L1*帐户中的所有值。*然后，从 L2中删除该*帐户。*
    *   如果没有找到，将 L1 的*Account*标记为已删除，或者将其从列表中删除，这取决于您的数据库的结构。
2.  对于 L2 中剩余的每个*Account*，将其添加到 L1。

我建议在您的*Account*`IEquatable<>`类中实现该接口（或仅覆盖该方法），以便它始终比较需要在对象之间进行比较的方法上的 ID：*`Equals()`*

 *```
public struct Account : IEquatable<Account>
{
    public int Id;
    public double Amount;

    public bool Equals(Account other)
    {
        if (other == null) return false;
        return (this.Id.Equals(other.Id));
    }
} 
```

同步算法将是这样的（确保两个列表都已初始化，因此不会发生错误）：

```
L1.ForEach (L1Account =>
{
    var L2Account = L2.Find(a => a.Id == L1Account.id);
    // If found, update values
    if (L2Account != null)
    {
        L1Account.Amount = L2Account.Amount;
        L2.Remove(L2Account);
    }
    // If not found, remove it
    else
    {
        L1.Remove(L1Account);
    }
}
// Add any remaining L2 Account to L1
L1.AddRange(L2); 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T09:01:15.213

除了 Jon Skeet 的评论之外，让您的 Account 结构成为一个类并覆盖 Equals() 和 GetHashCode() 方法以获得良好的相等性检查。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T09:06:05.500

L2 = L1.clone()？

...但我猜你忘了提一些事情。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2010-06-04T20:45:37.567

我知道这是一篇旧帖子，但您应该查看 AutoMapper。它将以一种非常灵活和可配置的方式完全满足您的需求。

[自动映射器](http://automapper.codeplex.com/)

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2021-01-23T02:43:19.233

## 介绍

我已经实现了两种算法，一种用于排序，一种用于顺序收集。两者都支持空值和重复值，并且以相同的方式工作：

它们产生`CollectionModification<LeftItemType,RightItemType>`类似于`CollectionChangedEventArgs<T>`( [reference](https://docs.microsoft.com/en-us/dotnet/api/microsoft.rtc.signaling.collectionchangedeventargs-1?view=ucma-api) ) 的 return ，后者可用于**同步**集合。

关于收益率：

> 当使用一种或另一种算法将左侧项目（参考集合）与右侧项目进行比较时，您可以`CollectionModification`在它们返回后立即应用返回的每个收益，但这可能导致“集合已修改”-异常（例如在使用`List<T>.GetEnumerator`) 时。为了防止这种情况，两种算法都可以使用可索引集合作为即将发生变异的参考集合。您只需使用[YieldIteratorInfluencedReadOnlyListExtensions](https://github.com/teroneko/Teronis.DotNet/blob/76cd5f50576d99f6927f522eaf33ec651135e1a1/src/NetStandard/Collections/Algorithms/src/Modifications/YieldIteratorInfluencedReadOnlyListExtensions.cs)`YieldIteratorInfluencedReadOnlyList<ItemType>`中的扩展方法将引用集合与 (abstract) 一起包装。:)

### SortedCollectionModifications

第一个算法适用于升序或降序列表并使用`IComparer<T>`.

```
/// <summary>
/// The algorithm creates modifications that can transform one collection into another collection.
/// The collection modifications may be used to transform <paramref name="leftItems"/>.
/// Assumes <paramref name="leftItems"/> and <paramref name="rightItems"/> to be sorted by that order you specify by <paramref name="collectionOrder"/>.
/// Duplications are allowed but take into account that duplications are yielded as they are appearing.
/// </summary>
/// <typeparam name="LeftItemType">The type of left items.</typeparam>
/// <typeparam name="RightItemType">The type of right items.</typeparam>
/// <typeparam name="ComparablePartType">The type of the comparable part of left item and right item.</typeparam>
/// <param name="leftItems">The collection you want to have transformed.</param>
/// <param name="getComparablePartOfLeftItem">The part of left item that is comparable with part of right item.</param>
/// <param name="rightItems">The collection in which <paramref name="leftItems"/> could be transformed.</param>
/// <param name="getComparablePartOfRightItem">The part of right item that is comparable with part of left item.</param>
/// <param name="collectionOrder">the presumed order of items to be used to determine <see cref="IComparer{T}.Compare(T, T)"/> argument assignment.</param>
/// <param name="comparer">The comparer to be used to compare comparable parts of left and right item.</param>
/// <param name="yieldCapabilities">The yieldCapabilities that regulates how <paramref name="leftItems"/> and <paramref name="rightItems"/> are synchronized.</param>
/// <returns>The collection modifications.</returns>
/// <exception cref="ArgumentNullException">Thrown when non-nullable arguments are null.</exception>
public static IEnumerable<CollectionModification<LeftItemType, RightItemType>> YieldCollectionModifications<LeftItemType, RightItemType, ComparablePartType>(
    IEnumerable<LeftItemType> leftItems,
    Func<LeftItemType, ComparablePartType> getComparablePartOfLeftItem,
    IEnumerable<RightItemType> rightItems,
    Func<RightItemType, ComparablePartType> getComparablePartOfRightItem,
    SortedCollectionOrder collectionOrder,
    IComparer<ComparablePartType> comparer,
    CollectionModificationsYieldCapabilities yieldCapabilities) 
```

Python 算法灵感来自：[有序列表的两个实例的高效同步](https://cstheory.stackexchange.com/a/20121/61134)。

### EqualityTrailingCollectionModifications

第二种算法适用于任何顺序并使用`IEqualityComparer<T>`.

```
/// <summary>
/// The algorithm creates modifications that can transform one collection into another collection.
/// The collection modifications may be used to transform <paramref name="leftItems"/>.
/// The more the collection is synchronized in an orderly way, the more efficient the algorithm is.
/// Duplications are allowed but take into account that duplications are yielded as they are appearing.
/// </summary>
/// <typeparam name="LeftItemType">The type of left items.</typeparam>
/// <typeparam name="RightItemType">The type of right items.</typeparam>
/// <typeparam name="ComparablePartType">The type of the comparable part of left item and right item.</typeparam>
/// <param name="leftItems">The collection you want to have transformed.</param>
/// <param name="getComparablePartOfLeftItem">The part of left item that is comparable with part of right item.</param>
/// <param name="rightItems">The collection in which <paramref name="leftItems"/> could be transformed.</param>
/// <param name="getComparablePartOfRightItem">The part of right item that is comparable with part of left item.</param>
/// <param name="equalityComparer">The equality comparer to be used to compare comparable parts.</param>
/// <param name="yieldCapabilities">The yield capabilities, e.g. only insert or only remove.</param>
/// <returns>The collection modifications.</returns>
/// <exception cref="ArgumentNullException">Thrown when non-nullable arguments are null.</exception>
public static IEnumerable<CollectionModification<LeftItemType, RightItemType>> YieldCollectionModifications<LeftItemType, RightItemType, ComparablePartType>(
    IEnumerable<LeftItemType> leftItems,
    Func<LeftItemType, ComparablePartType> getComparablePartOfLeftItem,
    IEnumerable<RightItemType> rightItems,
    Func<RightItemType, ComparablePartType> getComparablePartOfRightItem,
    IEqualityComparer<ComparablePartType>? equalityComparer,
    CollectionModificationsYieldCapabilities yieldCapabilities)
    where ComparablePartType : notnull 
```

## 要求

需要以下框架之一

*   .NET 标准 2.0
*   .NET 核心 3.1
*   .NET 5.0

这两种算法都是使用自定义实现类型（`IndexDirectory`,`NullableKeyDictionary`等`LinkedBucketList`）创建的，所以我不能在这里简单地复制粘贴代码，所以我想参考我的以下包：

*   [Teronis.NetStandard.Core](https://www.nuget.org/packages/Teronis.NetStandard.Core/0.1.8-alpha.65)：由以下包传递使用
*   [Teronis.NetStandard.Collections](https://www.nuget.org/packages/Teronis.NetStandard.Collections/0.1.8-alpha.65)：包含一些自定义集合类型。由以下包传递使用
*   [Teronis.NetStandard.Collections.Algorithms](https://www.nuget.org/packages/Teronis.NetStandard.Collections.Synchronization/0.1.8-alpha.65)：包含算法
*   [Teronis.NetStandard.Collections.Synchronization](https://www.nuget.org/packages/Teronis.NetStandard.Collections.Algorithms/0.1.8-alpha.65)：包含集合同步类

## 执行

### 预期课程

**帐户**：

```
public class Account
{
    public Account(int id) =>
        Id = id;

    public int Id { get; }
    public double Amount { get; }
} 
```

以及以下集合项相等比较器类：

**AccountEqualityComparer**：

```
public class AccountEqualityComparer : EqualityComparer<Account>
{
    public new static AccountEqualityComparer Default = new AccountEqualityComparer();

    public override bool Equals([AllowNull] Account x, [AllowNull] Account y) =>
        ReferenceEquals(x, y) || (!(x is null && y is null) && x.Id.Equals(y.Id));

    public override int GetHashCode([DisallowNull] Account obj) =>
        obj.Id;
} 
```

### “我的课程

**AccountCollectionViewModel**：

```
using Teronis.Collections.Algorithms.Modifications;
using Teronis.Collections.Synchronization;
using Teronis.Collections.Synchronization.Extensions;
using Teronis.Reflection;

public class AccountCollectionViewModel : SyncingCollectionViewModel<Account, Account>
{
    public AccountCollectionViewModel()
        : base(CollectionSynchronizationMethod.Sequential(AccountEqualityComparer.Default))
    {
        // In case of SyncingCollectionViewModel, we have to pass a synchronization method.
        //
        //   Sequential means any order
        //
    }

    protected override Account CreateSubItem(Account superItem) =>
        superItem;

    protected override void ApplyCollectionItemReplace(in ApplyingCollectionModificationBundle modificationBundle)
    {
        foreach (var (oldItem, newItem) in modificationBundle.OldSuperItemsNewSuperItemsModification.YieldTuplesForOldItemNewItemReplace())
        {
            // Implementation detail: update left public property values by right public property values.
            TeronisReflectionUtils.UpdateEntityVariables(oldItem, newItem);
        }
    }
} 
```

**程序**：

```
using System.Diagnostics;
using System.Linq;

class Program
{
    static void Main()
    {
        // Arrange
        var collection = new AccountCollectionViewModel();

        var initialData = new Account[] {
            new Account(5) { Amount = 0 },
            new Account(7) { Amount = 0 },
            new Account(3) { Amount = 0 }
        };

        var newData = new Account[] {
            new Account(5) { Amount = 10 }, 
            /* Account by ID 7 got removed .. */ 
            /* but account by ID 8 is new. */ 
            new Account(8) { Amount = 10 },
            new Account(3) { Amount = 10 }
        };

        // Act
        collection.SynchronizeCollection(initialData);

        // Assert
        Debug.Assert(collection.SubItems.ElementAt(1).Id == 7, "The account at index 1 has not the ID 7.");
        Debug.Assert(collection.SubItems.All(x => x.Amount == 0), "Not all accounts have an amount of 0.");

        // Act
        collection.SynchronizeCollection(newData);

        // Assert
        Debug.Assert(collection.SubItems.ElementAt(1).Id == 8, "The account at index 1 has not the ID 8.");
        Debug.Assert(collection.SubItems.All(x => x.Amount == 10), "Not all accounts have an amount of 10.");

        ;
    }
} 
```

你可以看到我使用了[SyncingCollectionViewModel](https://github.com/teroneko/Teronis.DotNet/blob/76cd5f50576d99f6927f522eaf33ec651135e1a1/src/NetStandard/Collections/Synchronization/src/SyncingCollectionViewModel.cs)，一个非常“重”的类型。那是因为我还没有完成轻量级的[SynchronizableCollection](https://github.com/teroneko/Teronis.DotNet/blob/76cd5f50576d99f6927f522eaf33ec651135e1a1/src/NetStandard/Collections/Synchronization/src/SynchronizableCollection.cs)实现（添加、删除、替换等虚拟方法缺失）。

# php - 在 Zend Framework 中使用 URL 段作为操作方法参数

> ID：161443
> 
> 赞同：12
> 
> 时间：2008-10-02T09:00:44.030
> 
> 标签：php, zend-framework

在 Kohana/CodeIgniter 中，我可以使用这种形式的 URL：

```
http://www.name.tld/controller_name/method_name/parameter_1/parameter_2/parameter_3 ... 
```

然后读取我的控制器中的参数如下：

```
class MyController 
{
    public function method_name($param_A, $param_B, $param_C ...)
    {
        // ... code
    }
} 
```

您如何在 Zend 框架中实现这一点？

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-10-02T10:13:47.303

看一下 Zend_Controller_Router 类：

[http://framework.zend.com/manual/en/zend.controller.router.html](http://framework.zend.com/manual/en/zend.controller.router.html)

这些将允许您定义 Zend_Controller_Router_Route 以您需要的方式映射到您的 URL。

索引控制器的索引操作有 4 个静态参数的示例是：

```
$router = new Zend_Controller_Router_Rewrite();

$router->addRoute(
    'index',
    new Zend_Controller_Router_Route('index/index/:param1/:param2/:param3/:param4', array('controller' => 'index', 'action' => 'index'))
);

$frontController->setRouter($router); 
```

在您定义了前端控制器后，这将添加到您的引导程序中。

一旦开始行动，您就可以使用：

```
$this->_request->getParam('param1'); 
```

在您的操作方法中访问值。

安德鲁

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-10-08T20:54:59.383

**更新（2016 年 4 月 13 日）：** 我下面答案中的链接已移动并已修复。但是，以防万一它再次消失——这里有一些替代方法可以提供有关此技术的一些深入信息，并使用原始文章作为参考材料：

*   [Zend Framework 控制器动作与函数参数](http://codeutopia.net/blog/2009/03/16/zend_controller-actions-that-accept-parameters/)
*   [接受参数的 Zend_Controller 动作？](http://codeutopia.net/blog/2009/03/16/zend_controller-actions-that-accept-parameters/)

* * *

@Andrew [Taylor](https://stackoverflow.com/questions/161443/url-segment-to-action-method-parameter-in-zend-framework#161636)的回应是处理 URL 参数的正确 Zend Framework 方式。但是，如果您想在控制器的操作中包含 URL 参数（如您的示例中所示） - 请查看[Zend DevZone 上的本教程](http://devzone.zend.com/1138/actions-now-with-parameters/)。

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2011-07-21T13:13:32.053

我已经扩展`Zend_Controller_Action`了我的控制器类并进行了以下更改：

在`dispatch($action)`方法替换

`$this->$action();`

和

`call_user_func_array(array($this,$action), $this->getUrlParametersByPosition());`

并添加了以下方法

```
/**
 * Returns array of url parts after controller and action
 */
protected function getUrlParametersByPosition()
{
    $request = $this->getRequest();
    $path = $request->getPathInfo();
    $path = explode('/', trim($path, '/'));
    if(@$path[0]== $request->getControllerName())
    {
        unset($path[0]);
    }
    if(@$path[1] == $request->getActionName())
    {
        unset($path[1]);
    }
    return $path;
} 
```

现在对于像这样的网址`/mycontroller/myaction/123/321`

在我的操作中，我将获得控制器和操作之后的所有参数

```
public function editAction($param1 = null, $param2 = null)
{
    // $param1 = 123
    // $param2 = 321
} 
```

URL 中的额外参数不会导致任何错误，因为您可以将更多参数发送到然后定义的方法。您可以通过 获得所有这些`func_get_args()` 并且您仍然可以`getParam()`以通常的方式使用它们。您的 URL 可能不包含使用默认名称的操作名称。

实际上我的 URL 不包含参数名称。只有他们的价值观。（就像问题一样）并且您必须定义路由以指定 URL 中的参数位置，以遵循框架的概念并能够使用 Zend 方法构建 URL。但是如果你总是知道你的参数在 URL 中的位置，你可以很容易地得到它。

这不像使用反射方法那么复杂，但我想提供的开销更少。

Dispatch 方法现在看起来像这样：

```
/**
 * Dispatch the requested action
 *
 * @param string $action Method name of action
 * @return void
 */
public function dispatch($action)
{
    // Notify helpers of action preDispatch state
    $this->_helper->notifyPreDispatch();

    $this->preDispatch();
    if ($this->getRequest()->isDispatched()) {
        if (null === $this->_classMethods) {
            $this->_classMethods = get_class_methods($this);
        }

        // preDispatch() didn't change the action, so we can continue
        if ($this->getInvokeArg('useCaseSensitiveActions') || in_array($action, $this->_classMethods)) {
            if ($this->getInvokeArg('useCaseSensitiveActions')) {
                trigger_error('Using case sensitive actions without word separators is deprecated; please do not rely on this "feature"');
            }
            //$this->$action();
            call_user_func_array(array($this,$action), $this->getUrlParametersByPosition()); 
        } else {
            $this->__call($action, array());
        }
        $this->postDispatch();
    }

    // whats actually important here is that this action controller is
    // shutting down, regardless of dispatching; notify the helpers of this
    // state
    $this->_helper->notifyPostDispatch();
} 
```

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2009-12-30T18:04:49.940

对于允许更复杂配置的更简单方法，请尝试[这篇文章](http://sourcecodebean.com/archives/friendly-urls-and-the-zend-router/31)。总之：

创造`application/configs/routes.ini`

```
routes.popular.route = popular/:type/:page/:sortOrder
routes.popular.defaults.controller = popular
routes.popular.defaults.action = index
routes.popular.defaults.type = images
routes.popular.defaults.sortOrder = alltime
routes.popular.defaults.page = 1
routes.popular.reqs.type = \w+
routes.popular.reqs.page = \d+
routes.popular.reqs.sortOrder = \w+ 
```

添加`bootstrap.php`

```
// create $frontController if not already initialised
$frontController = Zend_Controller_Front::getInstance(); 

$config = new Zend_Config_Ini(APPLICATION_PATH . ‘/config/routes.ini’);
$router = $frontController->getRouter();
$router->addConfig($config,‘routes’); 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2009-06-25T02:17:25.823

最初发布在这里[http://cslai.coolsilon.com/2009/03/28/extending-zend-framework/](http://cslai.coolsilon.com/2009/03/28/extending-zend-framework/)

我目前的解决方案如下：

```
abstract class Coolsilon_Controller_Base 
    extends Zend_Controller_Action { 

    public function dispatch($actionName) { 
        $parameters = array(); 

        foreach($this->_parametersMeta($actionName) as $paramMeta) { 
            $parameters = array_merge( 
                $parameters, 
                $this->_parameter($paramMeta, $this->_getAllParams()) 
            ); 
        } 

        call_user_func_array(array(&$this, $actionName), $parameters); 
    } 

    private function _actionReference($className, $actionName) { 
        return new ReflectionMethod( 
            $className, $actionName 
        ); 
    } 

    private function _classReference() { 
        return new ReflectionObject($this); 
    } 

    private function _constructParameter($paramMeta, $parameters) { 
        return array_key_exists($paramMeta->getName(), $parameters) ? 
            array($paramMeta->getName() => $parameters[$paramMeta->getName()]) : 
            array($paramMeta->getName() => $paramMeta->getDefaultValue()); 
    } 

    private function _parameter($paramMeta, $parameters) { 
        return $this->_parameterIsValid($paramMeta, $parameters) ? 
            $this->_constructParameter($paramMeta, $parameters) : 
            $this->_throwParameterNotFoundException($paramMeta, $parameters); 
    } 

    private function _parameterIsValid($paramMeta, $parameters) { 
        return $paramMeta->isOptional() === FALSE 
            && empty($parameters[$paramMeta->getName()]) === FALSE; 
    } 

    private function _parametersMeta($actionName) { 
        return $this->_actionReference( 
                $this->_classReference()->getName(), 
                $actionName 
            ) 
            ->getParameters(); 
    } 

    private function _throwParameterNotFoundException($paramMeta, $parameters) { 
        throw new Exception(”Parameter: {$paramMeta->getName()} Cannot be empty”); 
    } 
} 
```

# java - Java：将 DOM 写入 XML 文件（格式问题）

> ID：161462
> 
> 赞同：27
> 
> 时间：2008-10-02T09:10:33.070
> 
> 标签：java, xml, formatting, pretty-print

我`org.w3c` `XML API`用来打开现有`XML`文件。我正在删除一些节点，而我正在添加其他节点。

问题是添加的新节点是一个接一个地写入的，没有换行符，也没有缩进。虽然`XML`文件确实有效，但人类很难检查它。

无论如何要添加 indentation ，或者在每个节点之后至少添加一个换行符？

* * *

## 回答 #1

> 赞同：54
> 
> 时间：2008-10-02T09:18:58.823

我假设您正在使用 a[`Transformer`](http://java.sun.com/javase/6/docs/api/javax/xml/transform/Transformer.html)来进行实际的写作（对 a [`StreamResult`](http://java.sun.com/javase/6/docs/api/javax/xml/transform/stream/StreamResult.html)）。在这种情况下，请在调用之前执行此操作`transform`：

```
transformer.setOutputProperty(OutputKeys.INDENT, "yes");
transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2"); 
```

* * *

## 回答 #2

> 赞同：17
> 
> 时间：2012-05-02T11:14:50.133

```
transformer.setOutputProperty(OutputKeys.INDENT, "yes");
transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2"); 
```

来源 [如何从 Java 漂亮地打印 XML？](https://stackoverflow.com/questions/139076/how-to-pretty-print-xml-from-java)

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-11-17T06:08:31.107

以下线程中有几个“漂亮打印”的好例子

[如何从 Java 漂亮地打印 xml](https://stackoverflow.com/questions/139076/how-to-pretty-print-xml-from-java)

[链接到我的解决方案](https://stackoverflow.com/questions/139076/how-to-pretty-print-xml-from-java#260314)

# c# - 如何在 C# .NET 中“克隆”WebControl？

> ID：161474
> 
> 赞同：3
> 
> 时间：2008-10-02T09:17:57.373
> 
> 标签：c#, .net, asp.net

我的基本问题是，在 .NET 中，如何克隆 WebControls？

我想构建一个自定义标签，它可以生成其子项的多个副本。最终我打算构建一个类似于 JSP/Struts 的标签。

但我遇到的第一个障碍是复制/克隆控件内容的能力。

考虑这个相当人为的例子；

```
<custom:duplicate count="2">
    <div>
        <p>Some html</p>
        <asp:TextBox id="tb1" runat="server" />
    </div>
</custom:duplicate> 
```

输出的 HTML 标记类似于，

```
<div>
    <p>Some html</p>
    <input type="text" id="tb1" />
</div>
<div>
    <p>Some html</p>
    <input type="text" id="tb1" />
</div> 
```

*注意：我知道我的 id 重复了，我以后可以想出一个解决方案！*

所以我们将拥有我的自定义控件和 3 个子控件（我认为）——一个文字控件、一个 TextBox 控件和另一个文字控件。

在这个例子中，我说过'count=2'，所以控件应该做的是输出/渲染它的孩子两次。

我希望做的是编写一些“OnInit”代码，它执行以下操作：

```
List<WebControl> clones;
for(int i=1; i<count; i++)
{
    foreach(WebControl c in Controls) 
    {
        WebControl clone = c.Clone();
        clones.Add(clone);
    }
}

Controls.AddRange(clones); 
```

但是，据我所知，WebControls 没有实现 ICloneable，因此不可能以这种方式克隆它们。

有什么想法可以克隆 WebControls 吗？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-02T11:00:46.923

使用中继器并绑定无用数据源有什么问题。它将复制模板化控件并处理 ID 创建和所有操作。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2009-09-03T08:02:52.950

只是作为真正想要克隆**自定义服务器控件**的其他人的参考。

```
public class MyCustomServerCtrl
{

   ...

   public MyCustomServerCtrl Clone()
   {
      return MemberwiseClone() as MyCustomServerCtrl;
   }

} 
```

但请注意：这很少需要，如果需要，很可能只是在您有一些非常具体的逻辑时。应尽可能避免。一般来说，使用现有的控件（如 Repeater、ListView 等）就足够了。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T09:40:08.320

在 ASP.NET 中执行此操作的方法是使用模板。MSDN 中有这方面的示例，只需查找模板化控件/ITemplate。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2010-05-06T01:12:56.057

WebControl.CopyBaseAttributes 方法将 AccessKey、Enabled、ToolTip、TabIndex 和 Attributes 属性从指定的 Web 服务器控件复制到调用此方法的 Web 服务器控件。

[MSDN 文档](http://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.webcontrol.copybaseattributes(VS.90).aspx)

# c# - C# 中 typedef 的等价物

> ID：161477
> 
> 赞同：364
> 
> 时间：2008-10-02T09:18:29.603
> 
> 标签：c#, typedef

C# 中是否有 typedef 等效项，或者以某种方式获得某种类似的行为？我做了一些谷歌搜索，但我所看到的所有地方似乎都是负面的。目前我的情况类似于以下：

```
class GenericClass<T> 
{
    public event EventHandler<EventData> MyEvent;
    public class EventData : EventArgs { /* snip */ }
    // ... snip
} 
```

现在，不需要火箭科学家就能发现，在尝试为该事件实现处理程序时，这会很快导致大量输入（为可怕的双关语道歉）。它最终会是这样的：

```
GenericClass<int> gcInt = new GenericClass<int>;
gcInt.MyEvent += new EventHandler<GenericClass<int>.EventData>(gcInt_MyEvent);
// ...

private void gcInt_MyEvent(object sender, GenericClass<int>.EventData e)
{
    throw new NotImplementedException();
} 
```

除了在我的情况下，我已经使用了一个复杂类型，而不仅仅是一个 int。如果可以稍微简化一下就好了...

编辑：即。也许对 EventHandler 进行类型定义，而不是需要重新定义它以获得类似的行为。

* * *

## 回答 #1

> 赞同：374
> 
> 时间：2008-10-02T09:21:15.183

不，没有真正的 typedef 等价物。您可以在一个文件中使用“使用”指令，例如

```
using CustomerList = System.Collections.Generic.List<Customer>; 
```

但这只会影响该源文件。在 C 和 C++ 中，我的经验是它`typedef`通常在广泛包含的 .h 文件中使用 - 因此单个`typedef`可以在整个项目中使用。C# 中不存在这种能力，因为`#include`C# 中没有允许您将一个文件中的`using`指令包含在另一个文件中的功能。

幸运的是，您给出的示例*确实*有一个修复 - 隐式方法组转换。您可以将您的活动订阅行更改为：

```
gcInt.MyEvent += gcInt_MyEvent; 
```

:)

* * *

## 回答 #2

> 赞同：42
> 
> 时间：2008-10-02T11:48:19.103

乔恩真的给出了一个很好的解决方案，我不知道你能做到！

有时我求助于从类继承并创建它的构造函数。例如

```
public class FooList : List<Foo> { ... } 
```

不是最好的解决方案（除非您的程序集被其他人使用），但它确实有效。

* * *

## 回答 #3

> 赞同：19
> 
> 时间：2012-02-22T18:50:36.173

如果您知道自己在做什么，则可以使用隐式运算符定义一个类，以在别名类和实际类之间进行转换。

```
class TypedefString // Example with a string "typedef"
{
    private string Value = "";
    public static implicit operator string(TypedefString ts)
    {
        return ((ts == null) ? null : ts.Value);
    }
    public static implicit operator TypedefString(string val)
    {
        return new TypedefString { Value = val };
    }
} 
```

我实际上并不认可这一点，也从未使用过这样的东西，但这可能适用于某些特定情况。

* * *

## 回答 #4

> 赞同：14
> 
> 时间：2018-07-12T00:49:07.513

C++ 和 C# 都缺少创建与现有类型在语义上相同的*新类型的简单方法。*我发现这样的'typedefs'对于类型安全的编程来说是完全必要的，而且真的很遗憾 c# 没有内置它们。`void f(string connectionID, string username)`to之间的区别`void f(ConID connectionID, UserName username)`很明显...

（您可以在 C++ 中通过 BOOST_STRONG_TYPEDEF 中的 boost 实现类似的功能）

使用继承可能很诱人，但这有一些主要限制：

*   它不适用于原始类型
*   派生类型仍然可以转换为原始类型，即我们可以将其发送到接收原始类型的函数，这违背了整个目的
*   我们不能从密封类派生（即许多 .NET 类是密封的）

在 C# 中实现类似事情的唯一方法是将我们的类型组合到一个新类中：

```
class SomeType { 
  public void Method() { .. }
}

sealed class SomeTypeTypeDef {
  public SomeTypeTypeDef(SomeType composed) { this.Composed = composed; }

  private SomeType Composed { get; }

  public override string ToString() => Composed.ToString();
  public override int GetHashCode() => HashCode.Combine(Composed);
  public override bool Equals(object obj) => obj is TDerived o && Composed.Equals(o.Composed); 
  public bool Equals(SomeTypeTypeDefo) => object.Equals(this, o);

  // proxy the methods we want
  public void Method() => Composed.Method();
} 
```

虽然这会起作用，但对于 typedef 来说是非常冗长的。此外，我们在序列化（即对 Json）方面存在问题，因为我们想通过其 Composed 属性对类进行序列化。

下面是一个帮助类，它使用“Curiously Recurring Template Pattern”来简化它：

```
namespace Typedef {

  [JsonConverter(typeof(JsonCompositionConverter))]
  public abstract class Composer<TDerived, T> : IEquatable<TDerived> where TDerived : Composer<TDerived, T> {
    protected Composer(T composed) { this.Composed = composed; }
    protected Composer(TDerived d) { this.Composed = d.Composed; }

    protected T Composed { get; }

    public override string ToString() => Composed.ToString();
    public override int GetHashCode() => HashCode.Combine(Composed);
    public override bool Equals(object obj) => obj is Composer<TDerived, T> o && Composed.Equals(o.Composed); 
    public bool Equals(TDerived o) => object.Equals(this, o);
  }

  class JsonCompositionConverter : JsonConverter {
    static FieldInfo GetCompositorField(Type t) {
      var fields = t.BaseType.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy);
      if (fields.Length!=1) throw new JsonSerializationException();
      return fields[0];
    }

    public override bool CanConvert(Type t) {
      var fields = t.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy);
      return fields.Length == 1;
    }

    // assumes Compositor<T> has either a constructor accepting T or an empty constructor
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) {
      while (reader.TokenType == JsonToken.Comment && reader.Read()) { };
      if (reader.TokenType == JsonToken.Null) return null; 
      var compositorField = GetCompositorField(objectType);
      var compositorType = compositorField.FieldType;
      var compositorValue = serializer.Deserialize(reader, compositorType);
      var ctorT = objectType.GetConstructor(new Type[] { compositorType });
      if (!(ctorT is null)) return Activator.CreateInstance(objectType, compositorValue);
      var ctorEmpty = objectType.GetConstructor(new Type[] { });
      if (ctorEmpty is null) throw new JsonSerializationException();
      var res = Activator.CreateInstance(objectType);
      compositorField.SetValue(res, compositorValue);
      return res;
    }

    public override void WriteJson(JsonWriter writer, object o, JsonSerializer serializer) {
      var compositorField = GetCompositorField(o.GetType());
      var value = compositorField.GetValue(o);
      serializer.Serialize(writer, value);
    }
  }

} 
```

使用 Composer，上面的类变得很简单：

```
sealed Class SomeTypeTypeDef : Composer<SomeTypeTypeDef, SomeType> {
   public SomeTypeTypeDef(SomeType composed) : base(composed) {}

   // proxy the methods we want
   public void Method() => Composed.Method();
} 
```

此外，`SomeTypeTypeDef`将以与此相同的方式序列化为 Json `SomeType`。

希望这可以帮助 ！

* * *

## 回答 #5

> 赞同：6
> 
> 时间：2008-10-02T09:23:29.687

我认为没有typedef。您只能在 GenericClass 中定义特定的委托类型而不是通用的委托类型，即

```
public delegate GenericHandler EventHandler<EventData> 
```

这将使它更短。但是下面的建议呢：

使用 Visual Studio。这样，当你输入

```
gcInt.MyEvent += 
```

它已经提供了来自 Intellisense 的完整事件处理程序签名。按TAB，它就在那里。接受生成的处理程序名称或更改它，然后再次按 TAB 以自动生成处理程序存根。

* * *

## 回答 #6

> 赞同：6
> 
> 时间：2008-10-02T12:05:32.667

C# 支持事件委托的一些继承协变，所以像这样的方法：

```
void LowestCommonHander( object sender, EventArgs e ) { ... } 
```

可用于订阅您的活动，无需显式转换

```
gcInt.MyEvent += LowestCommonHander; 
```

您甚至可以使用 lambda 语法，智能感知将为您完成所有工作：

```
gcInt.MyEvent += (sender, e) =>
{
    e. //you'll get correct intellisense here
}; 
```

* * *

## 回答 #7

> 赞同：5
> 
> 时间：2016-03-13T17:07:30.100

您可以使用我创建的一个名为[LikeType](https://github.com/mattklein999/LikeType)的开源库和 NuGet 包，它们将为您提供`GenericClass<int>`您正在寻找的行为。

代码如下所示：

```
public class SomeInt : LikeType<int>
{
    public SomeInt(int value) : base(value) { }
}

[TestClass]
public class HashSetExample
{
    [TestMethod]
    public void Contains_WhenInstanceAdded_ReturnsTrueWhenTestedWithDifferentInstanceHavingSameValue()
    {
        var myInt = new SomeInt(42);
        var myIntCopy = new SomeInt(42);
        var otherInt = new SomeInt(4111);

        Assert.IsTrue(myInt == myIntCopy);
        Assert.IsFalse(myInt.Equals(otherInt));

        var mySet = new HashSet<SomeInt>();
        mySet.Add(myInt);

        Assert.IsTrue(mySet.Contains(myIntCopy));
    }
} 
```

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2016-05-15T19:28:49.370

这是它的代码，享受吧！，我从 dotNetReference 类型的命名空间行 106 **[http://referencesource.microsoft.com/#mscorlib/microsoft/win32/win32native.cs中的“using”语句中选择了它](http://referencesource.microsoft.com/#mscorlib/microsoft/win32/win32native.cs)**

```
using System;
using System.Collections.Generic;
namespace UsingStatement
{
    using Typedeffed = System.Int32;
    using TypeDeffed2 = List<string>;
    class Program
    {
        static void Main(string[] args)
        {
        Typedeffed numericVal = 5;
        Console.WriteLine(numericVal++);

        TypeDeffed2 things = new TypeDeffed2 { "whatever"};
        }
    }
} 
```

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2019-11-07T21:07:12.457

对于非密封类，只需从它们继承：

```
public class Vector : List<int> { } 
```

但是对于密封类，可以使用这样的基类来模拟 typedef 行为：

```
public abstract class Typedef<T, TDerived> where TDerived : Typedef<T, TDerived>, new()
{
    private T _value;

    public static implicit operator T(Typedef<T, TDerived> t)
    {
        return t == null ? default : t._value;
    }

    public static implicit operator Typedef<T, TDerived>(T t)
    {
        return t == null ? default : new TDerived { _value = t };
    }
}

// Usage examples

class CountryCode : Typedef<string, CountryCode> { }
class CurrencyCode : Typedef<string, CurrencyCode> { }
class Quantity : Typedef<int, Quantity> { }

void Main()
{
    var canadaCode = (CountryCode)"CA";
    var canadaCurrency = (CurrencyCode)"CAD";
    CountryCode cc = canadaCurrency;        // Compilation error
    Concole.WriteLine(canadaCode == "CA");  // true
    Concole.WriteLine(canadaCurrency);      // CAD

    var qty = (Quantity)123;
    Concole.WriteLine(qty);                 // 123
} 
```

* * *

## 回答 #10

> 赞同：1
> 
> 时间：2018-03-30T06:25:03.587

`typedef`我在 C# 中找到的最佳替代方案是`using`. 例如，我可以使用以下代码通过编译器标志控制浮点精度：

```
#if REAL_T_IS_DOUBLE
using real_t = System.Double;
#else
using real_t = System.Single;
#endif 
```

不幸的是，它要求您将它放在您使用的**每个文件**`real_t`的顶部。目前无法在 C# 中声明全局命名空间类型。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2022-01-19T19:06:31.303

使用 C# 10，您现在可以做到

```
global using Bar = Foo 
```

其工作方式类似于项目中的 typedef。

我还没有深入测试它，所以可能会有怪癖。

我像这样使用它

```
global using DateTime = DontUseDateTime 
```

其中 DontUseDateTime 是标记为 Obsolete 的结构，以强制人们使用 NodaTime。

# java - Spring MVC：将 3 个下拉列表绑定到 SimpleFormController 中的日期属性

> ID：161485
> 
> 赞同：6
> 
> 时间：2008-10-02T09:21:37.677
> 
> 标签：java, spring-mvc, propertyeditor

我应该如何配置该类以将三个下拉列表（日期、月份、年份）绑定到单个 Date 属性，以便它按照“每个属性的单个请求参数”方案的工作方式工作？我想应该通过覆盖 initBinder 方法来添加一些自定义的 PropertyEditors。还有什么 ？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-06T10:10:19.077

Aleksey Kudryavtsev：你可以在你的控制器中重写 onBind 方法，我不能在命令对象中摆弄一些特殊的东西，比如

```
dateField = new SimpleFormat("YYYY-mm-dd").parse(this.year + "-" + this.month + "-" this.day); 
```

或者：

```
Calendar c = Calendar.getInstance();
c.set(year, month, day);
dateField = calendar.getTime(); 
```

但我宁愿在 javascript 中进行验证并使用一些可用的日期选择器组件，它们有很多......

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T09:34:44.790

您可以在表单中创建一个隐藏输入，并在用户选择日期时使用 JavaScript 填充它，然后在命令对象中绑定到此输入。

无论如何，您可能会使用 javascript 来检查日期的正确性，所以为什么不在一个参数中格式化准备使用的日期。

然后您需要注册一个属性编辑器，它将字符串“2008-05-20”转换为 Date 对象。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-03T06:58:16.030

然后我将在我的命令对象中有三个字段 - 年、月、日，并将使用标准弹簧验证进行日期检查

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2011-05-11T15:13:05.533

我没试过，但你可以尝试绑定到[Joda library 中的 MutableDateTime](http://www.jarvana.com/jarvana/view/joda-time/joda-time/1.6.1/joda-time-1.6.1.jar!/org/joda/time/MutableDateTime.class?classDetails=ok)。它对所有三个字段都有单独的 setter 和 getter。

# asp.net - 在 ASP.NET 中更改错误消息的语言

> ID：161486
> 
> 赞同：32
> 
> 时间：2008-10-02T09:21:40.360
> 
> 标签：asp.net

我使用瑞典版本的 Windows XP 和 Visual Studio Professional 开发 ASP.NET 应用程序。当我得到一个错误又名。“黄屏死机”错误消息是瑞典语，因此很难搜索有关它的信息。

如何更改 ASP.NET 中的错误消息使用的语言？

我没有为 .net 框架安装语言包。然而，我正在运行一个带有瑞典语界面包的英语 windows xp。

我的 web.config 中也有这个：

```
<system.web>
   <globalization uiCulture="en-US" />
</system.web> 
```

* * *

## 回答 #1

> 赞同：47
> 
> 时间：2008-10-02T09:28:50.123

在 web.config 中添加：

```
<system.web>
   <globalization uiCulture="en-US" />
</system.web> 
```

或您喜欢的任何语言（注意：uiCulture="en-US" 不是culture="en-US"）。

此外，您应该检查您的应用程序是否未更改 uiCulture，例如更改为 global.asax 中特定于用户的 uiCulture。

如果错误发生在处理 web.config 文件之前或期间，这当然没有区别。在这种情况下，您需要更改运行 ASP.NET 应用程序的帐户的区域设置。

如果您正在使用 VS2005 或更高版本进行开发，您可能正在 Cassini Web 服务器下以当前用户的身份运行 - 所以只需更改当前用户的设置即可。如果您使用 IIS，您可能想要更改 ASPNET 帐户的区域设置 - 您可以通过选中“应用于当前用户和默认用户配置文件”复选框从控制面板的区域设置中执行此操作。

* * *

## 回答 #2

> 赞同：16
> 
> 时间：2015-08-19T04:58:08.087

我最近在 IIS 版本 10 上遇到了同样的问题，这些步骤修复了它。

1.  打开 IIS 管理器
2.  从“连接”面板中选择服务器
3.  在“ASP.NET”下双击“.NET Globalization”
4.  编辑“ **UI Culture** ”属性
5.  可选择将“文件”属性设置为“utf-8”
6.  最后单击“应用”并重新启动服务器。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2011-07-05T12:56:10.940

[您可以在finderr.net](http://finderr.net/search)上找到您的错误翻译成英文

或者

此问题的第二种解决方案是移动、删除或重命名包含异常翻译的文件。这些翻译在文件中：

> %windir%\assembly\mscorlib.resources.dll { 版本：2.0.0.0 文化：sv 令牌：b77a5c561934e089}

更改后，您必须重新启动 .NET 框架。重要信息：风险自负，我不知道此解决方案的副作用是什么。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2018-05-03T13:14:57.470

我也有这个问题。我已经放弃了，直到今天我再次尝试，成功了；

> 以管理员身份打开**CMD**，然后键入“ **LPKSETUP** ”并回车，然后卸载导致问题的语言。

所有功劳**归于 spunk.funk** ([来源](https://www.techsupportforum.com/forums/f217/solved-cant-uninstall-language-packs-554970.html))

这对我有用。而且似乎时区和本地化键盘仍然有效，这是我想要的唯一本地化的东西。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T09:26:56.197

错误消息不是依赖于安装的 .NET Framework 吗？即，您可以只卸载 .NET 的瑞典语语言包。在生产服务器上，无论如何，您很可能拥有一个纯英文框架。

# c++ - 引用结构不“粘”

> ID：161490
> 
> 赞同：0
> 
> 时间：2008-10-02T09:24:13.707
> 
> 标签：c++, mfc

我目前正在将大量代码从基于 MFC 的应用程序移植到 DLL 以用于客户品牌推广。

我遇到了一个不寻常的问题。这段代码在两个系统中是相同的：

```
// ...
    CCommsProperties props;

    pController->GetProperties( props );
    if (props.handshake != HANDSHAKE_RTS_CTS) 
    {
        props.handshake = HANDSHAKE_RTS_CTS;
        pController->RefreshCommProperties( props );
    }

// ... in another file: 
void CControllerSI::RefreshCommProperties ( const CCommsProperties& props )
{
    // ... code ...
} 
```

CommProperties 是 comm 设置、序列化等的包装器，pController 是 ControllerSI 类型，它本身是实际 Comms 和应用程序之间的一个层。

在原始 MFC 版本上，与 RTS-CTS 握手的设置保持不变，但是当作为 DLL 版本运行时，它会在输入函数后立即将自身重置为 0。代码完全包含在代码的 DLL 部分中，因此没有界限。

原始模块和新模块之间的主要区别是调用各种对话框的变量已被删除，并且已删除 #includes

我已经为此失去了一个下午，我真的不想再失去了......

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T09:54:19.097

仅从给定的代码很难看出哪里出了问题。一些通用指针：

1.  对象在不同的​​二进制模块中初始化和处理，链接不兼容（例如 C 运行时）

2.  如果类/结构是共享的，则它不会正确导出/导入。

3.  类在多个地方定义，并且您没有包含正确的定义。

以上三个是最可能的原因，特别是如果所有字段都重置为其默认初始化值。

如果这只发生在一个或两个字段上，则结构可能对齐不佳，您可能需要重新排列字段以更正这些（在发布中也检查）。

一般来说，我很想假设您初始化的对象不是`RefreshCommProperties()`看到的对象，出于某种原因，可能是上述三个对象之一。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T10:51:26.043

要真正弄清楚发生了什么，您可能需要发布您的源代码——或者至少要尽可能多地复制问题。不幸的是，StackOverflow 似乎并不鼓励这样做。您可以在 FTP 站点上发布您的代码或访问允许发布源代码的站点（如 CodeGuru）。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T11:54:18.340

CCommsProperties 可能在两个不同的位置定义，并且每个文件都包含自己的版本。

要测试这个理论，你需要在调试器中查看 &props.handshake 。如果调试器告诉您该字段在函数内部和外部具有不同的地址，那么假设是正确的，您可以继续检查预处理器输出以找出它发生的原因。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T14:14:41.887

在 Saratv 发布之后，我决定放弃我所做的并再次从工作源重新启动它。

但是这次它起作用了......我想我永远不会知道为什么传递一个结构会导致它改变。

# .net - 请提供一些学习 F# 的好资源

> ID：161492
> 
> 赞同：10
> 
> 时间：2008-10-02T09:24:48.777
> 
> 标签：.net, f#

我是 .Net 程序员（C# 和 VB.net），我也想进入 F# 领域，但找不到一些好的在线文章/pdf 开始。请指导我完成这个。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-02T10:18:02.830

[hubFS：F#的地方](http://cs.hubfs.net/)

[hubFS：F# 的地方 » 建立 F# 技能 » 书籍、教程、链接和其他资源](http://cs.hubfs.net/forums/88/ShowForum.aspx)

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-02T09:28:07.990

查看 MSDN F# 开发中心，那里有一些文章：

[http://msdn.microsoft.com/en-us/fsharp/default.aspx](http://msdn.microsoft.com/en-us/fsharp/default.aspx)

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-10-02T09:37:22.163

编写[F# 基础的](https://rads.stackoverflow.com/amzn/click/com/1590597575)[Robert Pickering](http://www.strangelights.com/blog/)有一个博客，您可以查看。

[F# 语言的首席设计师Don Syme](http://blogs.msdn.com/dsyme/)也有一个。他还与人合着了[Expert F#](https://rads.stackoverflow.com/amzn/click/com/1590598504)一书。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-02T09:35:34.353

有一个很棒的系列文章叫做“ [F# 用于游戏开发](http://sharp-gamedev.blogspot.com/2008/09/introduction.html)”，它逐步解释了 F#。这些文章的好处是它们是由初学者编写的，并展示了他如何学习 F#。

另一个很好的资源是“[探索 F# 语言](http://www.gotnet.biz/Blog/post/Kevin-Hazzards-Exploring-the-FSharp-Language-Series-Part1-What-is-FSharp.aspx)”文章，它从开发人员的角度解释了 F#。

Hanselman 提到了一些资源[这里](http://www.hanselman.com/blog/TheWeeklySourceCode34TheRiseOfF.aspx)您应该看看名为“ [F# Eye for the C# Guy](http://www.slideshare.net/gueste3f83d/f-eye-for-the-c-guy-presentation?type=powerpoint) ”的精彩演示文稿，它确实帮助我理解了 F#。

# c - 有没有用 GNU readline 处理多行输入的好方法？

> ID：161495
> 
> 赞同：18
> 
> 时间：2008-10-02T09:25:21.117
> 
> 标签：c, command-line, gnu, readline

我的应用程序有一个命令行界面，我正在考虑使用[GNU Readline 库](http://tiswww.case.edu/php/chet/readline/rltop.html)来提供历史记录、可编辑的命令行等。

问题是我的命令可能很长而且很复杂（想想 SQL），我希望允许用户将命令分布在多行上，以使它们在历史记录中更具可读性。

是否可以在 readline 中执行此操作（可能通过指定换行符和命令结尾之间的差异）？

或者我会更好地实现自己的命令行（但也许使用[GNU 历史库](http://tiswww.case.edu/php/chet/readline/history.html)）？

* * *

## 回答 #1

> 赞同：18
> 
> 时间：2008-10-02T09:56:11.713

你当然可以。

您可以使用 '\r' 和 '\n' 值定义选项

```
rl_bind_key('\r', return_func); 
```

您的 return_func 现在可以决定如何处理这些键。

```
int return_func(int cnt, int key) { ... } 
```

如果您在 UNIX 终端中执行此操作，如果您想移动光标，则需要了解 ANSI 终端代码。维基百科上有一个[起始参考](http://en.wikipedia.org/wiki/ANSI_escape_code#Codes)。

这是一些使用 readline 读取多行的示例代码，当您输入分号时将停止编辑（我已将其设置为 EOQ 或 end-or-query）。Readline 非常强大，有很多东西要学。

```
#include <stdio.h>
#include <unistd.h>
#include <readline/readline.h>
#include <readline/history.h>

int my_startup(void);
int my_bind_cr(int, int);
int my_bind_eoq(int, int);
char *my_readline(void);

int my_eoq; 

int
main(int argc, char *argv[])
{

  if (isatty(STDIN_FILENO)) {
    rl_readline_name = "my";
    rl_startup_hook = my_startup;
    my_readline();
  }
}

int
my_startup(void) 
{
  my_eoq = 0;
  rl_bind_key('\n', my_bind_cr);
  rl_bind_key('\r', my_bind_cr);
  rl_bind_key(';', my_bind_eoq);
}

int
my_bind_cr(int count, int key) {
  if (my_eoq == 1) {
    rl_done = 1;
  }
  printf("\n");
}

int
my_bind_eoq(int count, int key) {
  my_eoq = 1;

  printf(";");
}

char * 
my_readline(void)
{
  char *line;

  if ((line = readline("")) == NULL) {
    return NULL;
  }

  printf("LINE : %s\n", line);
} 
```

# windows-xp - 连接特定类型的 USB 设备时如何在 XP 中执行应用程序

> ID：161497
> 
> 赞同：1
> 
> 时间：2008-10-02T09:27:07.897
> 
> 标签：windows-xp, usb, drivers

在 Windows XP 中，当连接了特定类型的 USB 设备（它当前作为存储设备连接 - 即它显示为驱动器）时，执行特定应用程序的最佳方式是什么。

我正在寻找的解决方案必须从第一次连接设备时执行应用程序或提供应用程序作为选择，无论哪个更容易实现，设备必须作为存储设备保持连接。

**编辑：**轮询所有连接的设备是不够的 - windows 在那个阶段已经完成了它的弹出窗口。问题是在没有额外弹出窗口的情况下启动应用程序，然后应用程序将需要将该设备用作普通存储驱动器。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T09:48:34.273

快速搜索发现[此站点](http://msdn.microsoft.com/en-us/library/bb758856.aspx)，请参阅“3.3 设备更改侦听器”部分

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-02T10:48:03.007

您可以让后台应用程序对该特定 USB 设备的连接事件做出反应，这将启动实际应用程序。

```
ManagementEventWatcher Watcher;
WqlEventQuery Query = new WqlEventQuery();
Query.EventClassName = "__InstanceCreationEvent";
Query.Condition = "TargetInstance ISA 'Win32_USBControllerDevice'";
Query.WithinInterval = new TimeSpan(0, 0, 2);

Watcher = new ManagementEventWatcher(Query);
Watcher.EventArrived += new EventArrivedEventHandler(OnUsbConnected); 
```

OnUsbConnected 处理程序随后将启动所需的应用程序。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-02T09:40:14.667

您还可以打开 USB 驱动器的自动播放，并在 USB 驱动器上设置一个 autorun.inf 文件，尽管我建议不要使用这种方法，因为有几种病毒可以利用它。它默认关闭是有原因的。

如果你确实想走这条路，[看看这个网站](http://autorun.moonvalley.com/)，有很多很好的信息和一个你可以玩的 autorun.inf 生成器。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-02T14:16:13.617

一氧化碳有正确的想法。我自己使用这种技术来管理我的音乐收藏。我的主要 PC 是一台笔记本电脑，但我的音乐收藏变得足够大，我不得不将它移到外部驱动器上。所以在外部驱动器上我放了以下**AUTORUN.INF**：

```
[autorun]
open=c:\progra~1\itunes\itunes.exe
label=Open iTunes
icon=c:\progra~1\itunes\itunes.exe,0 
```

如您所见，它提供了从 C: 启动 iTunes 的功能：连接此驱动器时。出于某种原因，标签和图标不会被自动播放窗口拾取，但是当在我的电脑中查看此驱动器时，标签确实会出现。您在 XP 中出现的自动播放对话框中看到的是默认选择是“运行程序/使用设备上提供的程序”。单击一下，您就可以开始运行了。

# c# - 非侵入式“实时”帮助系统

> ID：161499
> 
> 赞同：1
> 
> 时间：2008-10-02T09:27:40.313
> 
> 标签：c#, components, system, live

我正在搜索执行类似操作的 C# 组件或代码片段：

例如，如果他打开一个新窗口，我想告知新用户最重要的程序功能。它应该是一个显示文本的框（如果可能，格式化）当然不是模态的，并且如果用户进入文本框区域，它有一些机制可以“让开”。这样他就可以访问它下面的内容。或者，窗口也可以粘在窗口的边框上，但是如果窗口最大化，需要有一种方法也可以工作。

所以我想向他简要介绍一下他可以在我的应用程序的每个角落最轻松地做什么。

谢谢！

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-06T08:21:50.763

I use a "bar" at the top of every window to display some information about the current window/dialog.

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T15:21:49.417

使用工具提示。它们可以通过程序进行控制，您可以让它们随意出现。您需要将功能添加到您的应用程序以跟踪已向用户显示的工具提示。

您可以通过将 IsBalloon 属性设置为 true 来添加“气球”样式。

您还可以将它们替换为更小的描述，以便用户将鼠标悬停在控件上并再次显示它们。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-11-07T16:07:03.953

您是否考虑过为每个表单/页面设置一个上下文菜单，其中包含指向每个可用任务的 Adob​​e Captivate 样式演示文稿的链接？这样，用户可以调查一个示例，说明如何从应用程序/站点中实现与他们试图实现的目标相关的任务。

如果您的代码定期更改，这种方法将需要大量的维护和管理，但与培训部门协调可以在您的应用程序中提供丰富的帮助功能。

有关详细信息，请参阅[http://www.adobe.com/products/captivate/](http://www.adobe.com/products/captivate/)。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T15:35:59.430

我已经在大量使用工具提示。但是，当显示大量数据时，它们并不是很实用，并且它们与特定的用户操作绑定在一起。

# ruby - Ruby中的“通过引用传递参数”？

> ID：161510
> 
> 赞同：29
> 
> 时间：2008-10-02T09:33:16.930
> 
> 标签：ruby, parameter-passing, pass-by-reference

在 Ruby 中，是否可以通过引用传递具有值类型语义的参数（例如 Fixnum）？我正在寻找类似于 C# 的 ' **ref** ' 关键字的东西。

例子：

```
def func(x) 
    x += 1
end

a = 5
func(a)  #this should be something like func(ref a)
puts a   #should read '6' 
```

顺便提一句。我知道我可以使用：

```
a = func(a) 
```

* * *

## 回答 #1

> 赞同：32
> 
> 时间：2008-10-02T10:06:23.247

您可以通过显式传入当前绑定来完成此操作：

```
def func(x, bdg)
  eval "#{x} += 1", bdg
end

a = 5
func(:a, binding)
puts a # => 6 
```

* * *

## 回答 #2

> 赞同：20
> 
> 时间：2008-10-02T10:00:40.033

Ruby 根本不支持“按引用传递”。一切都是对象，对这些对象的引用总是按值传递。实际上，在您的示例中，您`Fixnum`通过值传递了对 Object 的引用的副本。

您的代码的问题是，它`x += 1`不会修改传递的`Fixnum`对象，而是创建一个全新的独立对象。

我认为，Java 程序员会称`Fixnum`对象为**不可变**的。

* * *

## 回答 #3

> 赞同：12
> 
> 时间：2008-10-02T10:13:23.933

在 Ruby 中，您不能通过引用传递参数。对于您的示例，您必须返回新值并将其分配给变量 a 或创建一个包含该值的新类并传递此类的实例。例子：

```
class Container
attr_accessor :value
 def initialize value
   @value = value
 end
end

def func(x)
  x.value += 1
end

a = Container.new(5)
func(a)
puts a.value 
```

* * *

## 回答 #4

> 赞同：8
> 
> 时间：2015-03-02T07:01:33.843

您可以尝试以下技巧：

```
def func(x) 
    x[0] += 1
end

a = [5]
func(a)  #this should be something like func(ref a)
puts a[0]   #should read '6' 
```

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2016-03-02T06:53:26.073

[http://ruby-doc.org/core-2.1.5/Fixnum.html](http://ruby-doc.org/core-2.1.5/Fixnum.html)

> Fixnum 对象具有直接的价值。这意味着当它们被分配或作为参数传递时，传递的是实际对象，而不是对该对象的引用。

Ruby也是[按值传递的](https://stackoverflow.com/questions/22827566/ruby-parameters-by-reference-or-by-value/22827949#22827949)。

* * *

## 回答 #6

> 赞同：-1
> 
> 时间：2019-05-16T12:08:34.733

但是，复合对象（如哈希）似乎是通过引用传递的：

```
fp = {}
def changeit(par)
  par[:abc] = 'cde'
end

changeit(fp)

p fp 
```

给

```
{:abc=>"cde"} 
```

# winforms - WinForms：彩色 DataGridView 边框

> ID：161513
> 
> 赞同：13
> 
> 时间：2008-10-02T09:34:00.393
> 
> 标签：winforms

当 BorderStyle = FixedSingle 时，如何更改 DataGridView 边框的颜色？

* * *

## 回答 #1

> 赞同：26
> 
> 时间：2008-10-02T09:39:28.103

您无法更改边框颜色，它是系统定义的。

相反，您可以尝试关闭边框设置，然后将 DataGridView 放在面板中。其中 DataGridView 设置为 Dock.Fill 并且面板的所有边缘都有 1 个像素的填充。然后设置 Panel 的背景颜色将显示为包含的 DataGridView 周围的边框。

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2009-08-04T19:29:54.947

this.dataGridView1.GridColor = Color.BlueViolet;

来源：http: [//msdn.microsoft.com/en-us/library/ehz9ksfa.aspx](http://msdn.microsoft.com/en-us/library/ehz9ksfa.aspx)

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2010-04-19T14:17:51.053

如果您制作自己的 DataGridView 并覆盖 OnPaint() 方法，则可以更改边框。在你做你自己的魔法之前一定要调用 base.OnPaint(e) 。

此外，您可以添加一个属性“GridBorderColor”来设置颜色，您自己的绘画将使用。

# java - 从 Xcode java 项目链接外部 .jar？

> ID：161518
> 
> 赞同：2
> 
> 时间：2008-10-02T09:36:24.927
> 
> 标签：java, xcode, jar, classpath

如何将外部 .jar 链接到我的 Xcode java 项目中？也就是说，在编译和执行期间将它放在类路径中。我正在使用 Xcode 3.0，这似乎从 2.4 开始发生了变化。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2009-02-12T05:07:04.637

在 Xcode 3.1.2
签入文件**build.xml**我们看到：

`<!-- lib directory should contain any pre-built jar files needed to build the project AppleJavaExtensions.jar is included to allow the built jars to run cross-platform if you depend on Apple eAWT or eIO classes. See http://developer.apple.com/samplecode/AppleJavaExtensions/index.html for more information --> <fileset id="lib.jars" dir="${lib}"> <include name="**/*.jar"/> </fileset>`

好吧，手动将外部 jar 复制到 projectName/lib 并编译。（也许先清洁）

**编辑：**我不得不手动复制罐子，Xcode 不会把它放在正确的位置

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T14:25:48.507

Xcode 3.1（我不确定 3.0）在其 Java 项目模板中使用了 ant 构建文件。有大量关于 Ant的[文档。](http://ant.apache.org/manual/using.html#path)要更改实际运行编译代码时使用的类路径，请编辑可执行文件并添加一个参数`-classpath path/to/lib`

* * *

## 回答 #3

> 赞同：-1
> 
> 时间：2008-10-02T09:47:10.953

我手头没有 Mac，但是如果你将 jar 文件放到 ~/Library/Java/extensions (IIRC) 文件夹中怎么办？

编辑：我假设您使用的是 Mac OS X 特定的 Java 库，因此您使用 Xcode？否则我会推荐 Eclipse。实际上，我愿意打赌 Eclipse 也可以使用 Mac OS X 特定的 Java API...

# html - 如何在保留格式的同时使用 Visual Basic 将 HTML 格式的字符串插入 Microsoft Word 文档？

> ID：161519
> 
> 赞同：8
> 
> 时间：2008-10-02T09:36:53.913
> 
> 标签：html, vba, ms-word

我使用 Visual Basic 和自动化接口从外部应用程序检索字符串。这些字符串包含简单的 html 格式代码（<b>、<i> 等）。Visual Basic for Word 中是否有任何简单的功能可以将这些字符串插入到 word 文档中并将 html 格式代码转换为 word 格式？

* * *

## 回答 #1

> 赞同：14
> 
> 时间：2008-10-02T17:18:55.703

这是使用 VB 将 HTML 添加到剪贴板的链接：

[http://support.microsoft.com/kb/274326](http://support.microsoft.com/kb/274326)

在剪贴板上获得 HTML 后，使用以下内容将其粘贴到 Word 文档中：

```
ActiveDocument.Range.PasteSpecial ,,,,WdPasteDataType.wdPasteHTML 
```

这几乎相当于您手动剪切和粘贴它。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2015-06-17T13:12:58.503

使用插入文件

```
Set objdoc = objInsp.WordEditor
Set objword = objdoc.Application
Set objsel = objword.Selection
objsel.WholeStory
vs_html = "<html><body>" + vs_body + "</body></html>"
vs_file = "C:\temp\1.html"
Call DumptoFile(vs_file, "", vs_html, False)
RetVal = objsel.InsertFile(vs_file, , , False, False) 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2019-04-07T01:11:08.560

我正在使用 2016。唯一有效的是 Range.InsertFile(path)。特殊粘贴不起作用。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T10:37:26.013

AFAIK 在 VBA 中没有内置函数可以做到这一点。您必须自己编写它，例如，如果您重新启动它以进行解析，这将不会太难`<b>, <i>, <a> and <p>,`。所有其他标签都必须被忽略。

# mysql - 这个查询看起来优化了吗？

> ID：161524
> 
> 赞同：1
> 
> 时间：2008-10-02T09:39:33.017
> 
> 标签：mysql, sql, optimization

我正在为需要列出所有产品及其购买次数的应用程序编写查询。

我想出了这个并且它有效，但我不太确定它的优化程度。由于我大量使用 ORM，我的 SQL 真的很生疏，但在这种情况下，查询是一个更优雅的解决方案。

您能在查询中发现任何错误（方法明智）吗？

* * *

```
SELECT  products.id, 
        products.long_name AS name, 
        count(oi.order_id) AS sold
FROM    products
LEFT OUTER JOIN 
      ( SELECT * FROM orderitems
        INNER JOIN orders ON orderitems.order_id = orders.id 
        AND orders.paid = 1 ) AS oi 
      ON oi.product_id = products.id
GROUP BY products.id 
```

* * *

架构（带有相关字段）如下所示：

```
*orders*      id, paid
*orderitems*  order_id, product_id
*products*    id 
```

## 更新

这是为 MySQL

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T09:55:32.337

我不确定 "(SELECT *" ... 业务。

这执行（总是一个好的开始），我认为相当于发布的内容。

```
SELECT  products.id, 
    products.long_name AS name, 
    count(oi.order_id) AS sold
FROM    products
LEFT OUTER JOIN
    orderitems AS oi
        INNER JOIN 
            orders 
            ON oi.order_id = orders.id AND orders.paid = 1
    ON oi.product_id = products.id
GROUP BY products.id 
```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-02T13:10:40.433

对于我们这些筑巢障碍的人来说，这是一个解决方案。（当我开始嵌套连接时我很困惑）

```
SELECT  products.id, 
    products.long_name AS name, 
    count(oi.order_id) AS sold
FROM orders 
    INNER JOIN orderitems  AS oi ON oi.order_id = orders.id AND orders.paid = 1
    RIGHT JOIN products ON oi.product_id = products.id
GROUP BY products.id 
```

但是，我在 MS SQL Server 上测试了您的解决方案，迈克和我的，查询计划是相同的。我不能代表 MySql，但如果 MS SQL Server 可以作为参考，您可能会发现所有三种解决方案的性能相当。如果是这种情况，我猜你会选择对你来说最清楚的解决方案。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T09:43:00.730

它能给你正确的答案吗？

除了只是修改它以摆脱内部查询中的 SELECT 之外，我看不出它有什么问题。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T09:51:35.903

好吧，您有“左外连接”，这可能是一个性能问题，具体取决于您的数据库。上次我记得它在 MySQL 上造成了地狱，它在 SQLite 中不存在。我认为 Oracle 可以处理它，我猜 DB 和 MSSQL 也是。

编辑：如果我没记错的话，在 MySQL 上 LEFT OUTER JOIN 可能会慢几个数量级，但如果我在这里过时了，请纠正我 :)

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T09:51:43.457

未经测试的代码，但试试看：

```
SELECT  products.id,
    MIN(products.long_name) AS name, 
    count(oi.order_id) AS sold
FROM    (products
LEFT OUTER JOIN orderitemss AS oi ON oi.product_id = products.id)
INNER JOIN orders AS o ON oi.order_id = o.id 
WHERE orders.paid = 1
GROUP BY products.id 
```

我不知道 LEFT OUTER JOIN 是否需要括号，如果 MySQL 允许多个连接也不需要，但是 MIN(products.long_name) 只给出描述，因为对于每个 products.id 你只有一个描述。

也许括号需要在 INNER JOIN 周围。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-03T17:38:05.790

这是一个子查询表单。

```
SELECT
  p.id,
  p.long_name AS name,
  (SELECT COUNT(*) FROM OrderItems oi WHERE oi.order_id in
    (SELECT o.id FROM Orders o WHERE o.Paid = 1 AND o.Product_id = p.id)
  ) as sold
FROM Products p 
```

它的性能应该大致相当于连接表单。如果没有，请告诉我。

# java - 是否有通过java访问操作系统中另一个进程的“最佳实践”？

> ID：161529
> 
> 赞同：3
> 
> 时间：2008-10-02T09:41:25.243
> 
> 标签：java, operating-system, native

我一直在阅读 Skype4Java（Skype 的 java api）并注意到他们使用 jni 来访问 Skype 客户端。

直观地说，我假设 java 中已经有一个标准库，它具有操作系统敏感的 jni 实现来访问其他进程。我打算找一个，但找不到。

有这样的图书馆吗？如果没有，是否有最佳实践来访问操作系统中的另一个进程，不一定是 Skype 客户端？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-02T09:51:00.010

从 Java 1.4 开始，您可以使用内存映射文件与另一个进程交换任意信息。有关详细信息，请参阅 java.nio.MappedByteBuffer。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T09:56:16.033

这不是您正在寻找的东西，但可能会有所帮助：java.net 上的[Java Native Access](https://github.com/twall/jna/)项目。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T10:39:50.813

别忘了插座...

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-03T03:49:35.610

我认为也许您需要定义“访问”对您意味着什么。如果您谈论的是普通的旧进程间通信，那么套接字或 JNI 确实是您最好的选择。

Garth 关于使用内存映射文件的评论很有趣——我在 C 应用程序之间多次使用 MMF 和虚拟文件进行 IPC，但我从未想过 Java 的 MMF 实现可能与本机 OS 虚拟文件系统兼容。这些类型的虚拟文件通常需要非常重要的设置，所以如果它可以工作我会感到惊讶......

总而言之，除非您在应用程序之间传输大量数据，否则使用套接字可能是最通用和最有效的方法。确保考虑到主机操作系统和 Java VM 之间的字节顺序 :-)

# c# - 通过在文本字段上按 enter 来提交用户控件上的表单不起作用

> ID：161531
> 
> 赞同：2
> 
> 时间：2008-10-02T09:42:31.917
> 
> 标签：c#, asp.net, user-controls

这似乎是一个常见问题，但我找不到解决方案。

我在我创建的登录控件中输入我的用户名和密码。然后，我输入密码后按 Enter 键，页面就会刷新。它会触发页面加载事件，但不会触发单击事件上的按钮。

如果我按下提交按钮，那么一切正常。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T11:08:00.887

使用表单默认按钮是正确的，但您需要为其提供正确的 id，因为它将呈现为 HTML。

所以你按照乔恩上面所说的那样做：

```
<form runat="server" DefaultButton="SubmitButton"> 
```

但请确保您使用将呈现的 Button 名称。您可以通过在您的控件中公开 Button 或返回其 ClientId 的方法来实现这一点。

假设您的按钮称为 btnSubmit，并且您的控件 ucLogin 的实现。

给你的表格一个id

```
<form runat="server" id="form1"> 
```

然后在您的页面加载页面后面的代码中，通过将您的按钮客户端 ID 交给它来设置 DefaultButton。

```
protected void Page_Load(object sender, EventArgs e)
{
   form1.DefaultButton = ucLogin.btnSubmit.ClientID;
} 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T09:52:35.013

如果您使用的是 ASP.NET 2.0 或更高版本，则可以为页面的表单设置默认按钮属性：

```
<form runat="server" DefaultButton="SubmitButton"> 
```

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T09:48:58.500

在文本输入上按 ENTER 会执行**Form.onsubmit**，而不是**Button.onclick**。

我想这是受到这样一个事实的启发，即您可以拥有一个没有实际提交按钮的表单（仅取决于 ENTER 的使用）。

# ruby - 没有类的模块中实例方法的目的是什么？

> ID：161539
> 
> 赞同：9
> 
> 时间：2008-10-02T09:46:56.510
> 
> 标签：ruby

想象一下下面的 Ruby 模块：

```
module Foo
  def inst_method
    puts "Called Foo.inst_method"
  end
  def self.class_method
    puts "Called Foo.class_method"
  end
end 
```

显然`Foo.class_method`可以在没有任何类实例的情况下调用。但是，发生了`Foo.inst_method`什么？是否可以在`Foo.inst_method`不包含/扩展课程的情况下进行调用？

免责声明：这个问题并不专注于解决真正的问题。我只是想提高我对 Ruby 对象系统的理解。

* * *

## 回答 #1

> 赞同：12
> 
> 时间：2008-10-02T14:36:06.797

模块中实例方法的主要目的是为包含它的类提供该功能。

以这种方式“混入”模块最常用作模拟[多重继承](http://en.wikipedia.org/wiki/Multiple_inheritance)的方法，或者在继承不是正确范例（不是很完美的“是”关系）但您想共享行为的其他情况下。它是另一种保持代码[DRY](http://en.wikipedia.org/wiki/DRY)的工具。

核心 Ruby 中的一个很好的例子是注意如何[`Array`](http://ruby-doc.org/core/classes/Array.html)以及[`Hash`](http://ruby-doc.org/core/classes/Hash.html)可以进行旅行和排序等。它们每个都从[`Enumerable`](http://ruby-doc.org/core/classes/Enumerable.html)模块中获取此功能（`each_with_index`、`select`、等都在包含的模块中定义`reject`，`sort`而不是在类中）。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-02T10:09:11.917

我的回答是：“不，如果不先扩展或在类中包含该模块，就不能调用模块实例方法”

现在知道了 ruby​​ 以及它包含的所有元编程技巧，可能*有*一种方法可以调用它，但它超出了模块的预期用途

```
module Tester
  def inst_meth
    puts "test inst meth\n"
  end

  def self.meth
    puts "test self meth\n"
  end
end

begin
  Tester.meth
rescue;
  puts $!
end
begin
  Tester.inst_meth
rescue
  puts $!
end
begin
  Tester.new.inst_meth
rescue
  puts $!
end
begin
  extend Tester
  inst_meth
rescue
  puts $!
end
begin
  include Tester
  inst_meth
rescue
  puts $!
end 
```

给

```
>ruby test.rb
test self meth
undefined method `inst_meth' for Tester:Module
undefined method `new' for Tester:Module
 test inst meth
 test inst meth 
```

# c++ - 特定于 Cell Linux 环境的 GDB 文档在哪里？

> ID：161540
> 
> 赞同：2
> 
> 时间：2008-10-02T09:47:00.020
> 
> 标签：c++, linux, gdb, cell

在哪里可以找到有关 GDB 功能和调试过程的文档，专门用于调试混合 PPU 和 SPU 代码的 Cell Linux 程序？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T13:11:27.483

可在此处找到 IBM developerWorks 站点上有关 Cell 的文档： [Cell @developerWorks](http://www.ibm.com/developerworks/power/cell/documents.html?S_TACT=105AGX16&S_CMP=LP)

您听起来像是想要通过调试 Cell 应用程序的[Programmer's Guide 。](http://www.ibm.com/chips/techlib/techlib.nsf/techdocs/1DAAA0A3B6404763002573530066008C?Open&S_TACT=105AGX16&S_CMP=LP)

编辑以添加示例主题：

*   第 3 章调试 Cell BE 应用程序
    *   ...
    *   调试 PPE 代码
    *   调试 SPE 代码
    *   ...
    *   在 Cell BE 环境中调试
    *   调试多线程代码
    *   调试架构
    *   在单个线程内切换架构
    *   ...
    *   使用组合调试器
    *   ...

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T10:40:04.773

一个全面的概述似乎在这里[http://www.redbooks.ibm.com/redpieces/abstracts/sg247575.html?Open](http://www.redbooks.ibm.com/redpieces/abstracts/sg247575.html?Open)

# git - 我应该使用 SVN 还是 Git？

> ID：161541
> 
> 赞同：324
> 
> 时间：2008-10-02T09:47:05.433
> 
> 标签：git, svn, version-control

我正在开始一个新的分布式项目。我应该使用 SVN 还是 Git，为什么？

* * *

## 回答 #1

> 赞同：255
> 
> 时间：2008-10-02T09:55:52.523

SVN is one repo and lots of clients. Git is a repo with lots of client repos, each with a user. It's decentralised to a point where people can track their own edits locally without having to push things to an external server.

SVN is designed to be more central where Git is based on each user having their own Git repo and those repos push changes back up into a central one. For that reason, Git gives individuals better local version control.

Meanwhile you have the choice between [TortoiseGit](http://code.google.com/p/tortoisegit/), [GitExtensions](http://code.google.com/p/gitextensions/) (and if you host your "central" git-repository on github, their own [client – GitHub for Windows](http://windows.github.com/)).

If you're looking on getting out of SVN, you might want to evaluate [Bazaar](http://bazaar-vcs.org/) for a bit. It's one of the next generation of version control systems that have this distributed element. It isn't POSIX dependant like git so **there are native Windows builds** and it has some powerful open source brands backing it.

But you might not even need these sorts of features yet. Have a look at [the features, advantages and disadvantages of the distributed VCSes](http://en.wikipedia.org/wiki/Distributed_revision_control). If you need more than SVN offers, consider one. If you don't, you might want to stick with SVN's (currently) superior desktop integration.

* * *

## 回答 #2

> 赞同：112
> 
> 时间：2008-10-02T10:17:26.497

我从来没有理解过“git 在 Windows 上不好”的概念；我专门在 Windows 下开发，我从来没有遇到过 git 的任何问题。

我肯定会推荐 git 而不是颠覆；它只是更加通用，并允许以颠覆从未真正做到的方式“离线开发”。它可以在几乎所有可以想象的平台上使用，并且具有比您可能使用的更多的功能。

* * *

## 回答 #3

> 赞同：76
> 
> 时间：2010-03-30T22:17:27.167

这是我对[一些重复问题的答案的副本，此后我删除](https://stackoverflow.com/questions/1438662/which-of-the-two-is-bettergit-or-svn)了关于 Git 与 SVN（2009 年 9 月）的问题。

更好的？除了通常的链接[WhyGitIsBetterThanX 之外](http://whygitisbetterthanx.com/)，它们是不同的：

一个是基于分支和标签的廉价副本的中央 VCS，另一个 (Git) 是基于修订图的分布式 VCS。另请参见[VCS 的核心概念](https://stackoverflow.com/questions/645008/what-are-the-basic-clearcase-concepts-every-developer-should-know/645771#645771)。

* * *

第一部分产生了一些错误的评论，假装这两个程序（SVN 和 Git）的基本目的是相同的，但它们的实现方式却截然不同。
为了阐明[SVN 和 Git 之间的根本区别](https://stackoverflow.com/questions/995636/popularity-of-git-mercurial-bazaar-vs-which-to-recommend/995799#995799)，让我改写一下：

*   SVN 是[**修订**控制](https://stackoverflow.com/questions/1056912/source-control-vs-revision-control/1056947#1056947)的第三个实现：[RCS，然后是 CVS，最后是 SVN](http://www.ibr.cs.tu-bs.de/kb/revision-control.html)管理版本化数据的目录。SVN 提供 VCS 功能（标签和合并），但它的标签只是一个目录副本（就像一个分支，除了你不“应该”接触标签目录中的任何东西），它的合并仍然很复杂，目前基于 meta -添加数据以记住已经合并的内容。

*   Git 是一个**文件内容管理**（一种用于合并文件的工具），**演变成一个真正的版本控制系统**，基于提交的 DAG（有向无[环图](http://en.wikipedia.org/wiki/Directed_acyclic_graph)），其中分支是数据历史的一部分（而不是数据本身)，并且标签是真正的元数据。

要说它们没有“根本上”不同，因为您可以实现相同的目标，解决相同的问题，这是……在很多层面上都是错误的。

*   如果您有许多复杂的合并，使用 SVN 执行它们会更长且更容易出错。如果您必须创建许多分支，则需要管理和合并它们，使用 Git 比使用 SVN 更容易，尤其是在涉及大量文件的情况下（速度变得很重要）
*   如果您对正在进行的工作进行了部分合并，您将利用 Git 暂存区域（索引）仅提交您需要的内容，存储其余部分，然后继续另一个分支。
*   如果您需要离线开发......那么使用 Git，您始终“在线”，拥有自己的本地存储库，无论您想与其他存储库遵循什么工作流程。

* * *

仍然对那个旧（已删除）答案的评论坚持：

> VonC：您将实现的根本差异（差异非常根本，我们都明确同意这一点）与目的差异混淆了。
> 它们都是用于相同目的的工具：这就是为什么许多以前使用 SVN 的团队能够非常成功地将其转储为 Git。
> 如果他们没有解决同样的问题，这种*替代*性就不会存在。

，我回复说：

“可替代性”...有趣的术语（[用于计算机编程](http://en.wikipedia.org/wiki/Substitutability)）。
当然，Git 几乎不是 SVN 的子类型。

您可以使用两者实现相同的技术特性（标记、分支、合并），但 Git 不会妨碍您，**让您可以专注于文件的内容**，而无需考虑工具本身。

您当然不能（总是）只用 Git 替换 SVN，“而不改变该程序的任何理想属性（正确性，执行的任务，......）”（这是对上述可[替换性定义](http://en.wikipedia.org/wiki/Substitutability)的引用）：

*   一个是扩展的修订工具，另一个是真正的版本控制系统。
*   一种适用于具有简单合并工作流程和（不是太多）并行版本的中小型单体项目。SVN 就足够了，你可能不需要所有的 Git 功能。
*   另一个允许基于多个组件的大中型项目（[每个组件一个 repo](https://stackoverflow.com/questions/984707/what-are-the-git-limits/984973#984973)），在复杂的合并工作流中在多个分支之间合并大量文件，分支中的并行版本，改造合并等等。您可以使用 SVN 来做到这一点，但使用 Git 会更好。
    SVN 根本无法通过任何合并工作流程管理任何规模的项目。吉特可以。

同样，**它们的性质是根本不同的**（这会导致不同的实现，但这不是重点）。
一种将修订控制视为目录和文件，另一种仅看到文件的内容（以至于空目录甚至不会在 Git 中注册！）。

一般的最终目标可能是相同的，但您不能以相同的方式使用它们，也不能解决同一类问题（范围或复杂性）。

* * *

## 回答 #4

> 赞同：37
> 
> 时间：2009-08-11T16:26:36.433

SVN 的 2 个很少被提及的主要优势：

1.  大文件支持。除了代码，我还使用 SVN 来管理我的主目录。SVN 是唯一一个不会阻塞我的 TrueCrypt 文件的 VCS（无论是否分发）（如果有另一个 VCS 可以有效处理 500MB 以上的文件，请纠正我）。这是因为差异比较是流式传输的（这是非常重要的一点）。Rsync 是不可接受的，因为它不是 2-way。

2.  部分存储库（子目录）签出/签入。Mercurial 和 bzr 不支持这个，git 的支持是有限的。这在团队环境中很糟糕，但如果我想从我的家庭目录中检查另一台计算机上的某些内容，这是非常宝贵的。

只是我的经历。

* * *

## 回答 #5

> 赞同：25
> 
> 时间：2010-11-13T09:26:48.030

在进行更多研究并查看此链接后：[https ://git.wiki.kernel.org/articles/g/i/t/GitSvnComparison_cb82.html](https://git.wiki.kernel.org/articles/g/i/t/GitSvnComparison_cb82.html)

（以下部分摘录）：

*   它非常快。我用过的其他 SCM 都无法跟上它，而且我用过很多，包括 Subversion、Perforce、darcs、BitKeeper、ClearCase 和 CVS。
*   它是完全分布式的。存储库所有者无法指定我的工作方式。我可以在笔记本电脑上断开连接时创建分支并提交更改，然后将其与任意数量的其他存储库同步。
*   同步可以发生在许多媒体上。SSH 通道，通过 HTTP 通过 WebDAV、通过 FTP 或通过发送包含要由消息接收者应用的补丁的电子邮件。中央存储库不是必需的，但可以使用。
*   分支甚至比它们在 Subversion 中的便宜。创建一个分支就像将一个 41 字节的文件写入磁盘一样简单。删除一个分支就像删除那个文件一样简单。
*   与 Subversion 分支不同的是，它们带有完整的历史记录。无需执行奇怪的副本并遍历副本。使用 Subversion 时，我总是发现查看分支上文件在创建分支之前发生的历史记录很尴尬。来自#git：spearce：我不了解页面中有关SVN的一件事。我在 SVN 上创建了一个分支并浏览历史记录显示了整个历史记录在分支中的一个文件
*   Git 中的分支合并更简单、更自动化。在 Subversion 中，您需要记住上次合并的修订版本，以便生成正确的合并命令。Git 会自动执行此操作，并且始终正确执行。这意味着将两个分支合并在一起时出错的可能性较小。
*   分支合并被记录为存储库正确历史的一部分。如果我将两个分支合并在一起，或者如果我将一个分支合并回它来自的主干，则该合并操作将作为我执行的存储库历史记录的一部分以及何时执行。当合并就在日志中时，很难争论谁执行了合并。
*   创建存储库是一个简单的操作： mkdir foo; 光盘富; git init 就是这样。这意味着我现在为所有东西创建了一个 Git 存储库。我倾向于每个班级使用一个存储库。大多数这些存储库的磁盘空间都在 1 MB 以下，因为它们只存储讲义、家庭作业和我的 LaTeX 答案。
*   存储库的内部文件格式非常简单。这意味着修复非常容易，但更好的是，因为它非常简单，很难被损坏。我认为没有人曾经有过 Git 存储库被损坏的情况。我已经看到带有 fsfs 的 Subversion 本身会损坏。而且我已经看到 Berkley DB 自我损坏太多次，以至于无法将我的代码信任到 Subversion 的 bdb 后端。
*   Git 的文件格式非常擅长压缩数据，尽管它是一种非常简单的格式。Mozilla 项目的 CVS 存储库大约 3 GB；Subversion 的 fsfs 格式大约为 12 GB。在 Git 中它大约是 300 MB。

在阅读了所有这些之后，我确信 Git 是正确的选择（尽管存在一点学习曲线）。我也在 Windows 平台上使用过 Git 和 SVN。

我很想听听其他人在阅读以上内容后要说什么？

* * *

## 回答 #6

> 赞同：12
> 
> 时间：2008-10-02T10:05:16.997

I would set up a Subversion repository. By doing it this way, individual developers can choose whether to use Subversion clients or Git clients (with `git-svn`). Using `git-svn` doesn't give you *all* the benefits of a full Git solution, but it does give individual developers a great deal of control over their own workflow.

I believe it will be a relatively short time before Git works just as well on Windows as it does on Unix and Mac OS X (since you asked).

Subversion has excellent tools for Windows, such as TortoiseSVN for Explorer integration and AnkhSVN for Visual Studio integration.

* * *

## 回答 #7

> 赞同：11
> 
> 时间：2008-10-02T13:04:55.893

有趣的是：我在 Subversion Repos 中托管项目，但通过 Git Clone 命令访问它们。

请阅读[在 Google 代码项目中使用 Git 进行开发](http://google-opensource.blogspot.com/2008/05/develop-with-git-on-google-code-project.html)

> 尽管 Google Code 原生使用 Subversion，但您可以在开发过程中轻松使用 Git。搜索“git svn”表明这种做法很普遍，我们也鼓励您尝试一下。

在 Svn 存储库上使用 Git 给我带来了好处：

1.  我可以在多台机器上进行*分布式*工作，向它们提交和拉取
2.  我有一个*中央* `backup/public`svn 存储库供其他人查看
3.  他们可以自由地为自己使用 Git

* * *

## 回答 #8

> 赞同：9
> 
> 时间：2008-10-02T10:34:55.207

没有真正回答你的问题，但如果你想要[分布式修订控制](http://en.wikipedia.org/wiki/Revision_control#Distributed_revision_control)的好处- 听起来像你 - 并且你正在使用 Windows，我认为你最好使用[Mercurial](http://www.selenic.com/mercurial/)而不是 Git 作为 Mercurial 有更好的 Windows 支持。Mercurial 也有 Mac 端口。

* * *

## 回答 #9

> 赞同：9
> 
> 时间：2008-10-02T11:32:56.067

如果您的团队已经熟悉 cvs 或 svn 等版本和源代码控制软件，那么对于一个简单且小型的项目（如您声称的那样），我建议您坚持使用 SVN。我对 svn 真的很满意，但是对于我在 django 上做的当前电子商务项目，我决定使用 git（我在 svn 模式下使用 git，即使用我推送和拉取的集中式 repo为了与至少一位其他开发人员合作）。另一位开发人员对 SVN 很满意，虽然其他人的经验可能不同，但我们俩都在为这个小项目拥抱 git 时遇到了非常糟糕的时光。（我们都是 Linux 的铁杆用户，如果这很重要的话。）

当然，您的里程可能会有所不同。

* * *

## 回答 #10

> 赞同：8
> 
> 时间：2008-10-02T09:55:25.257

The main point is, that Git is a distributed VCS and Subversion a centralized one. Distributed VCSs are a little bit more difficult to understand, but have many advantages. If you don't need this advantages, Subversion may the better choice.

Another question is tool-support. Which VCS is better supported by the tools you plan to use?

**EDIT:** Three years ago I answered this way:

> And Git works on Windows at the moment only via Cygwin or [MSYS](http://code.google.com/p/msysgit/). Subversion supported Windows from the beginning. As the git-solutions for windows may work for you, there may be problems, as the most developers of Git work with Linux and didn't have portability in the mind from the beginning. At the moment I would prefer Subversion for development under Windows. In a few years this may be irrelevant.

Now the world has changed a little bit. Git has a good implementation on windows now. Although I tested not thouroughly on windows (as I no longer use this system), I'm quite confident, that all the major VCS (SVN, Git, Mercurial, Bazaar) have proper Windows-implementation now. This advantage for SVN is gone. The other points (Centralized vs. Distributed and the check for tool support) stay valid.

* * *

## 回答 #11

> 赞同：7
> 
> 时间：2008-10-02T09:52:42.797

Definitely `svn`, since Windows is—at best—a second-class citizen in the world of `git` (see [http://en.wikipedia.org/wiki/Git_(software)#Portability](http://en.wikipedia.org/wiki/Git_(software)#Portability) for more details).

UPDATE: Sorry for the broken link, but I've given up trying to get SO to work with URIs that contain parentheses. [link fixed now. -ed]

* * *

## 回答 #12

> 赞同：6
> 
> 时间：2008-10-02T09:49:16.237

I would opt for SVN since it is more widely spread and better known.

I guess, Git would be better for Linux user.

* * *

## 回答 #13

> 赞同：4
> 
> 时间：2011-01-21T14:42:50.580

归结为：

你的发展会是线性的吗？如果是这样，你应该坚持使用 Subversion。

另一方面，如果您的开发不是线性的，这意味着您需要为不同的更改创建分支，然后将这些更改合并回主开发线（Git 称为主分支），那么 Git 会做给你更多。

* * *

## 回答 #14

> 赞同：4
> 
> 时间：2008-10-02T09:52:31.427

Git is not natively supported under Windows, just yet. It is optimized for Posix systems. However running Cygwin or MinGW lets you run Git successful.

Nowadays I prefer Git over SVN, but it takes a while to get over the threshold if you come from CVS, SVN land.

* * *

## 回答 #15

> 赞同：4
> 
> 时间：2008-10-02T09:53:47.227

I would probably choose Git because I feel it's much more powerful than SVN. There are cheap Code Hosting services available which work just great for me - you don't have to do backups or any maintenance work - [GitHub](http://www.github.com) is the most obvious candidate.

That said, I don't know anything regarding the integration of Visual Studio and the different SCM systems. I imagine the integration with SVN to notably better.

* * *

## 回答 #16

> 赞同：4
> 
> 时间：2010-11-13T09:12:17.050

我用SVN很久了，但是每次用Git的时候，都觉得Git强大很多，轻量级，虽然有点学习曲线但是比SVN好。

我注意到的是，每个 SVN 项目随着它的增长，都会变成一个非常大的项目，除非它被导出。其中，GIT 项目（连同 Git 数据）的重量非常轻。

在 SVN 中，我与从新手到专家的开发人员打过交道，新手和中级如果从另一个 SVN 项目复制一个文件夹以重用它，似乎会引入文件冲突。然而，我认为在 Git 中，您只需复制文件夹即可，因为 Git 不会在其所有子文件夹中引入 .git 文件夹（就像 SVN 那样）。

在与 SVN 打交道很久之后，我终于考虑将我和我的开发人员转移到 Git，因为它很容易协作和合并工作，还有一个很大的优势是可以提交本地副本的更改。需要，然后最后一口气推送到服务器上的分支，这与 SVN 不同（我们必须不时在服务器上的存储库中提交更改）。

谁能帮我决定我是否真的应该使用 Git？

* * *

## 回答 #17

> 赞同：3
> 
> 时间：2008-10-02T09:55:41.260

May I expand on the question and ask if Git work well on MacOS?

Reply to Comments: Thanks for the news, I'd been looking forward to trying it out. I'll install it at home on my Mac.

* * *

## 回答 #18

> 赞同：3
> 
> 时间：2008-10-02T10:07:05.227

have you tried [Bzr](http://bazaar-vcs.org/)?

It's pretty good, connonical (the people who make Ubuntu) made it because they didn't like anything else on the market...

* * *

## 回答 #19

> 赞同：3
> 
> 时间：2008-10-02T11:23:12.470

YouTube 上有一个关于此的有趣视频。它来自 Linus Torwalds 本人：[Goolge 技术讲座：Linus Torvalds on git](http://www.youtube.com/watch?v=4XpnKHJAok8)

* * *

## 回答 #20

> 赞同：2
> 
> 时间：2008-10-02T10:06:17.133

SVN seems like a good choice under Windows, as pointed by other people.

If some of your developper wants to try GIT, it may always use GIT-SVN where the SVN repository is recreated in a GIT repository. Then he should be able to work locally with GIT and then use SVN to publish its changes to the main repository.

* * *

## 回答 #21

> 赞同：1
> 
> 时间：2008-10-02T10:32:38.660

您必须使用 DVCS，这就像源管理方面的巨大飞跃。就我个人而言，我使用[Monotone](http://monotone.ca)，它加快了开发时间。我们在 Windows、Linux 和 Mac 上使用它，它非常稳定。我什至让 buildbot 在每个平台上进行项目的夜间构建。

分布式 DVCS 通常意味着您将创建一个中央服务器，供人们推送更改。

# ajax - AJAX 工具包 - AJAX 框架

> ID：161543
> 
> 赞同：0
> 
> 时间：2008-10-02T09:48:13.603
> 
> 标签：ajax, frameworks, toolkit

工具包和框架有什么区别？你知道一个好的比较吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T10:09:22.743

If I had to make a distinction, then I'd say a toolkit provides specific tools to do specific jobs, whereas a framework provides you with a foundation on which to build further, higher-level structures.

Tools are useful on their own, frameworks have no innate function.

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2009-06-08T01:23:41.197

[jQuery](http://jquery.com/)，[原型](http://www.prototypejs.org/)，[雅虎！User Interface](http://developer.yahoo.com/yui/)、[MooTools](http://mootools.net/)、[dojo](http://dojotoolkit.org/)和[ExtJS](http://www.extjs.com/)将让您使用非常可靠的代码。我无法为自己担保的其他可能性：[QooxDoo](http://qooxdoo.org/)

我相信他正在寻找 javascript 库/工具包的比较（无论他们如何称呼自己）。

* * *

## 回答 #3

> 赞同：-1
> 
> 时间：2008-10-02T10:00:08.380

The names say it all really, a toolkit is a set of tools that you can use however you wish. A framework is an empty frame that you can fill in to form your application. The line between them is blurry though a framework contains tools, and a toolkit sometimes forces you to perform actions in a specific sequence.

I wouldn't know of a generic comparison, i guess it depends on the toolkits and frameworks themselves.

* * *

## 回答 #4

> 赞同：-1
> 
> 时间：2008-10-02T10:14:35.100

虽然不是特定于 AJAX。但是一读..

[**框架和库有什么区别？**](https://stackoverflow.com/questions/148747/what-is-the-difference-between-a-framework-and-a-library)

* * *

## 回答 #5

> 赞同：-1
> 
> 时间：2008-10-02T10:22:00.137

工具包为构建某些东西提供了基本的、最小的构建块。框架已经为您提供了一种方法。框架（大多数时候）为您定义了应用程序架构，其中工具包只为您提供工具，因此您可以定义自己的架构。

例如，GWT（Google Web Tookit）是一个工具包；它没有强加某种做事方式，Java JDK 也是一个工具包（Java Developer's Kit），但 Rails（来自 Ruby on Rails）是一个框架。它鼓励使用他们的工作流和类（MVC、share-nothing 等）。

* * *

## 回答 #6

> 赞同：-1
> 
> 时间：2008-10-02T14:45:33.203

工具包就像一个图书馆。您将其拉入您的应用程序并使用它。框架为您的应用程序提供了一个结构，因此您的所有代码都在其中。框架的优势在于，通过遵循它的约定并留在它的流程中，它能够为你做很多繁重的工作。工具包更灵活，但框架可以更好地解决许多类型的问题。使用 Ajax，定义起来有点困难。例如，可以以工具包样式完成简单的小部件和 dom 操作，但是如果您的所有 javascript 都使用特殊的事件包装器和基于框架的类功能和继承，那么您的所有代码都会依赖于该框架并真正包含在其中.

# sql-server - Programmatically renaming a table in SQL Server 2000 - is sp_rename the only solution?

> ID：161549
> 
> 赞同：3
> 
> 时间：2008-10-02T09:49:30.637
> 
> 标签：sql-server, tsql, sql-server-2000

I recently had to rename a table (and a column and FK/PK contraints) in SQL Server 2000 without losing an data. There did not seem to be an obvious DDL T-SQL statements for performing this action, so I used sp_rename to directly fiddle with object names.

Was this the only solution to the problem? (other, than give the table the correct name in the first place - doh!)

* * *

## 回答 #1

> 赞同：13
> 
> 时间：2008-10-02T09:52:22.750

sp_rename is the correct way to do it.

```
EXEC sp_rename 'Old_TableName', 'New_TableName' 
```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2010-06-15T08:24:50.083

Ya
EXEC sp_rename 'Old_TableName', 'New_TableName' 工作正常，但任何关键字都像“alter tabel old_name to new_name”

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T09:55:16.317

Maybe not the only: I guess you could always toy with the master database and update the table name there - but this is highly unrecommendable.

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T10:11:41.427

有一种解决方案可以让您同时使用新旧版本的表。如果您的数据被复制和/或通过客户端界面访问（这意味着旧版本的客户端界面仍将使用旧表名），这一点尤其重要：

1.  `ALTER TABLE`通过“ ”命令修改表上的约束（包括 FK）
2.  不要更改表名或字段名，而是创建一个视图，例如：

    `SELECT oldTable.oldField1 as newField1, ...`

    将其保存为 newTable（如果需要，将其分发到不同的服务器上）

* * *

请注意，您不能以这种方式修改您的 PK。

# c# - 转换字典 小写键 (C#)

> ID：161556
> 
> 赞同：6
> 
> 时间：2008-10-02T09:51:47.917
> 
> 标签：c#, .net, idictionary

我有一个获取 IDictionary 作为参数的方法。现在我想提供一个从这个字典中检索值的方法，但它应该是大小写不变的。

所以我现在对此的解决方案是有一个静态函数，它遍历键并将它们转换为如下所示：

```
private static IDictionary<ILanguage, IDictionary<string, string>> ConvertKeysToLowerCase(
    IDictionary<ILanguage, IDictionary<string, string>> dictionaries)
{
    IDictionary<ILanguage, IDictionary<string, string>> resultingConvertedDictionaries 
        = new Dictionary<ILanguage, IDictionary<string, string>>();
    foreach(ILanguage keyLanguage in dictionaries.Keys)
    {
        IDictionary<string, string> convertedDictionatry = new Dictionary<string, string>();
        foreach(string key in dictionaries[keyLanguage].Keys)
        {
            convertedDictionatry.Add(key.ToLower(), dictionaries[keyLanguage][key]);
        }
        resultingConvertedDictionaries.Add(keyLanguage, convertedDictionatry);
    }
    return resultingConvertedDictionaries;
} 
```

现在，这没关系，但它仍然是一个相当大的代码块，与我的“干净和高效”的想法相矛盾。您是否知道任何替代方法，以便字典的 .ContainsKey() 方法不区分大小写？

* * *

## 回答 #1

> 赞同：35
> 
> 时间：2008-10-02T09:54:23.853

是的 - 传递 Dictionary 构造函数`StringComparer.OrdinalIgnoreCase`（或另一个忽略大小写的比较器，具体取决于您的文化敏感性需求）。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2009-02-09T14:50:20.090

通过使用 StringDictionary，键在创建时转换为小写。

[http://simiansoftware.blogspot.com/2008/11/have-const-string-with-ui-description.html](http://simiansoftware.blogspot.com/2008/11/have-const-string-with-ui-description.html)

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T10:07:03.573

您可以使用**var**关键字来消除一些混乱。从技术上讲，来源保持不变。此外，我将传递并返回 Dictionary<string, string> 因为您没有对该 ILanguage 参数做任何事情并使该方法更可重用：

```
private static IDictionary<string, string> ConvertKeysToLowerCase(
    IDictionary<string, string> dictionaries)
{
    var convertedDictionatry = new Dictionary<string, string>();
    foreach(string key in dictionaries.Keys)
    {
        convertedDictionatry.Add(key.ToLower(), dictionaries[key]);
    }
    return convertedDictionatry;
} 
```

...并这样称呼它：

```
// myLanguageDictionaries is of type IDictionary<ILanguage, IDictionary<string, string>>
foreach (var dictionary in myLanguageDictionaries.Keys)
{
  myLanguageDictionaries[dictionary].Value = 
      ConvertKeysToLowerCase(myLanguageDictionaries[dictionary].Value);
} 
```

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-02T11:51:17.193

您可以自己从 IDictionary 继承，并简单地将调用编组到内部 Dictionary 实例。

```
Add(string key, string value) { dictionary.Add(key.ToLowerInvariant(), value) ; }
public string this[string key]
{
    get { return dictionary[key.ToLowerInvariant()]; }
    set { dictionary[key.ToLowerInvariant()] = value; }
}
// And so forth. 
```

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-16T03:03:37.360

System.Collections.Specialized.StringDictionary() 可能会有所帮助。MSDN 状态：

“密钥以不区分大小写的方式处理；它在与字符串字典一起使用之前被转换为小写。

在 .NET Framework 1.0 版中，此类使用区分区域性的字符串比较。但是，在 .NET Framework 1.1 版及更高版本中，此类在比较字符串时使用 CultureInfo.InvariantCulture。有关区域性如何影响比较和排序的详细信息，请参阅比较和排序特定区域性的数据和执行不区分区域性的字符串操作。"

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2020-02-26T14:18:23.337

你也可以试试这个方法

```
convertedDictionatry = convertedDictionatry .ToDictionary(k => k.Key.ToLower(), k => k.Value.ToLower()); 
```

* * *

## 回答 #7

> 赞同：-1
> 
> 时间：2008-10-02T12:03:12.827

`IEnumerable<T>`使用扩展方法的 LINQ 版本：

```
 private static IDictionary<ILanguage, IDictionary<string, string>> ConvertKeysToLowerCase(
            IDictionary<ILanguage, IDictionary<string, string>> dictionaries)
        {
            return dictionaries.ToDictionary(
                x => x.Key, v => CloneWithComparer(v.Value, StringComparer.OrdinalIgnoreCase));
        }

        static IDictionary<K, V> CloneWithComparer<K,V>(IDictionary<K, V> original, IEqualityComparer<K> comparer)
        {
            return original.ToDictionary(x => x.Key, x => x.Value, comparer);
        } 
```

# air - 如何从 Adob e AIR 应用程序中启动独立 SWF？

> ID：161570
> 
> 赞同：1
> 
> 时间：2008-10-02T09:55:39.700
> 
> 标签：air, flash

我对 AIR 完全陌生，但我想做的事情感觉应该很容易。

我希望我的 AIR 应用程序在独立的 Flash Player 中执行（启动）一个 SWF（就像我要双击它一样）。

请注意，我不希望 AIR 应用程序嵌入 SWF。运行它。

这可以做到吗？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-08T17:26:53.780

使用 Adob​​e AIR，您可以将 SWF 启动/加载到单独的本机窗口中。它将在与 AIR 应用程序加载/启动它相同的过程中运行，但对于最终用户而言，即使不一样，体验也会相似。

迈克室

网格@adobe.com

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T10:10:02.287

AIR-Runtime（仍然）无法启动外部应用程序，除了用于 PDF 的 Acrobat Reader 和默认浏览器（您可以让浏览器显示 swf）。

我认为你需要一些这样的框架：

*   [FluorineFx 光圈](http://aperture.fluorinefx.com/)
*   [默拉皮](http://www.merapiproject.net/)

你的计划背后的意义是什么，为什么选择 AIR？

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T10:23:24.470

谢谢你，通过浏览器运行它可能是我的解决方案。仅供参考，我正在使用 AIR 将一些设置写入 SWF 然后可以读取的本地文本文件。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T12:32:32.257

大多数人没有独立播放器——只有安装了 Flash 的人，所以这不是一个好主意，我不认为。你能打开一个只包含 swf 的新 AIR 窗口吗？

# forms - 可用性：即使焦点未设置在 OK/DONE 按钮上，是否应按 ENTER 键将向导窗体关闭为 OK？

> ID：161591
> 
> 赞同：2
> 
> 时间：2008-10-02T10:00:58.847
> 
> 标签：forms, controls, usability

如果在键盘上按下 Enter 键，即使 OK/DONE 按钮没有聚焦，我认为将向导表单关闭为 Done 或 OK 在我看来很奇怪。

在我看来，这将是一个可用性错误。例如：在向导中，您可能有多个控件、按钮、复选框、多行控件，并且它们对 ENTER 键的操作都有不同的行为。并且不要忘记向导导航中的其他按钮，如果它们被聚焦怎么办？

这些控件不应该像以前预期的那样对 Enter 做出反应吗？他们是否应该执行他们的操作，但在其他情况下，Enter 对控件没有进一步的操作，它应该关闭表单 == 不一致？

我认为这是一个典型的要求，一个人的需求会帮助他，但会混淆其他人。

在我看来，向导非常特别，因为它们不仅可以让事情变得更容易，而且还经常关注那些对应用程序功能缺乏经验的人。因此，我认真对待每一个请求，并尝试调查支持和反对该请求的所有论据。

我的观点是否狭隘？是否有一些可用性研究或指南，特别是威世智可以支持我的观点或证明我错了？

非常感谢你！

迈克尔

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-02T10:17:39.167

好吧，事情是这样的：您必须在这里考虑两种用户。

第一类用户是婴儿潮一代和 X 一代（例如，70 年代/80 年代一直在使用计算机的人），他们习惯于按 Enter 键移动到下一个字段。这些人学习了如何在终端/控制台中使用计算机并输入意味着您已完成在该字段上的输入并将继续下一个。

第二种用户是那些在 Windows 上断奶的用户。这些人习惯于按 Tab 键移动到下一个字段。对他们按 Enter 意味着他们已经完成了整个事情。

那么你应该遵循哪个约定呢？这取决于您是针对第一类用户还是第二类用户、环境（Windows 还是 Web？）和操作系统。

如果您的目标是 Windows 表单，则建议与操作系统保持一致（例如，让人们使用 Tab 而不是 Enter）进行表单输入。在 Web 中，您处于两难境地，因为 Enter 被 Web 浏览器捕获为提交事件。

最后，我能提供的唯一有用的建议是与您的目标客户一起尝试，看看他们是否更喜欢 Enter 而不是 Tab。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T13:53:49.007

我认为关键是测试。您无法真正猜测您的用户会觉得舒服，您必须看着他们尝试。特别是由于您可以遵循多种不兼容的标准，您只需要查看此更改是否适用于您的受众中的大多数用户。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T10:03:04.893

我也有同样的看法，也许会向客户提及，让他们在两种模式下都使用最终版本。我想你必须在他们付款时给他们他们要求的东西。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T10:11:43.953

对我来说，这似乎也是一个奇怪的要求，但正如保罗所说，如果客户想要它，那么客户就会得到它。但是，从可用性/理解的角度来看，我会让 ok/done 按钮的边框比正常的要厚得多，这样它会显得有点突出，并且可能向人们表明它有特殊的行为。此外，我可能会在对话框/向导框中记下，按 Enter 将导致向导关闭，就好像按下了 OK/Done 按钮一样。虽然一个用户可能知道按 Enter 会关闭它，但除非特别告知其他人，否则他们不会期待这种行为。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T10:30:55.297

这个请求是否可能是因为在向导上执行的 UAT 涉及的用户不知道按 ENTER 将与单击按钮具有相同的效果？

如果在显示向导的最后一页时，“完成”按钮已经突出显示（如我所料），这可能是给用户一些提示，他们此时也可以按 ENTER 键。

如果你以谷歌为例，我似乎记得如果你倾向于系统地输入你的搜索词，然后用鼠标单击“搜索”按钮，搜索结果顶部会显示一条消息，善意地提示你你也可以按 ENTER 键。显然，这不是您可以轻松完成的事情，因为这是向导的最后一页，但也许这是您的客户试图让您设计的那种事情？

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-02T11:34:36.313

我认为你应该有一个完成页面来促进这一点。如果用户误按回车，最糟糕的是他不会完成向导，只能进入下一页（可能是完成页面）。这适用于核弹由所述巫师控制的情况。

在完成页面上按回车键将完成向导（并炸毁伊拉克、击落卫星或清除 Jimbob 的农场）。

如果用户可以重新运行向导，我认为如果他们不小心完成了它不会是灾难性的。

请记住，向导在完成之前绝不应该采取任何行动，以防用户取消等。完成时的确认对话框很乏味，如果你使用它们，我会追捕你，我认为一旦用户完成了向导，他就很确定他的意图。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T12:54:03.377

也许客户有充分的理由。想象一下以下情况：一个有很多可选字段的屏幕，这些字段经常打开/关闭，并且数据准确性并不重要。

想想一个小程序，它每半小时弹出一次，询问你一直在做什么，为什么客户服务，也许还有一些笔记，这样它就可以收集这些信息并生成你的时间表。

能够以尽可能少的麻烦打开屏幕、输入信息并关闭它，这比数据的准确性更重要。

我可以想象在很多情况下能够在没有焦点的情况下确认该领域是有用的。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-02T13:44:24.143

教育你的客户。向他们展示一些文档，说明为什么该建议可能不是一个好的可用性实践。

一些信誉良好的网站效果最好，因为客户通常会在相信您之前先相信第三方。毕竟，对他们来说，你可能只是懒惰，不想工作更多。

如果客户仍然不让步，那就做他们想做的事，并警告他们这不是好事。

尽管在您的情况下，“要做的好事”似乎有点在灰色地带。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-02T14:45:53.170

我认为您可以使用此功能在向导中继续前进，但前提是该页面上没有采取其他操作。

当字段完成或单击/突出显示按钮或光标从默认位置移动时，Enter 功能应恢复为标准操作系统的功能。

正如其他人所说，显然这只有在使用向导的人在他们的应用程序培训中意识到这一点时才有效，但它可能有助于快速浏览未使用的向导页面以到达用户需要的位置成为。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-11-18T11:36:26.467

没关系。选择并在您的所有应用程序中保持一致

# java - 如何在 JavaME 中获取抽象类（对象）的类？

> ID：161614
> 
> 赞同：1
> 
> 时间：2008-10-02T10:08:56.567
> 
> 标签：java, java-me

我需要在运行时获取对象的类。

对于非抽象类，我可以执行以下操作：

```
public class MyNoneAbstract{
    public static Class MYNONEABSTRACT_CLASS = new MyNoneAbstract().getClass(); 
```

但是对于一个抽象类，这不起作用（总是给我`Object`）

```
public abstract class MyAbstract{
    public static Class MYABSTRACT_CLASS = MyAbstract.class.getClass(); 
```

此代码将在 JavaME 环境中运行。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T10:11:01.520

您只需

```
MyAbstract.class 
```

该表达式返回代表 MyAbstract 的 Class 对象。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T13:44:36.610

您在抽象案例中想要的代码是：

```
public abstract class MyAbstract{
    public static Class MYABSTRACT_CLASS = MyAbstract.class;
} 
```

尽管我个人不会费心定义常量，而是始终使用 MyAbstract.class 。

我本来希望您编写的代码返回类“类”，而不是类“对象”。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-03T13:46:46.973

我认为这里需要更多信息。在 Java 中，不能实例化抽象类。这意味着运行时的对象不能使其类是抽象的。它需要是一个实现所有抽象方法的子类。在 JavaME 中，`Object.getClass()`应该就是您所需要的。您是否以某种方式尝试在运行时重构您的类层次结构？

在这种情况下，你可以实现这样的东西：

```
public String getClassHierarchy() {
    return super.getClassHierarchy() + ".MyAbstract";
} 
```

# ruby-on-rails - 为什么 Apache + Rails 会为代码 500 吐出两个状态标头？

> ID：161631
> 
> 赞同：4
> 
> 时间：2008-10-02T10:13:19.097
> 
> 标签：ruby-on-rails, ruby, apache, http-headers

我有一个运行良好的 Rails 应用程序，除了一件事。

当我请求不存在的内容（即 /not_a_controller_or_file.txt）并且 rails 抛出“No Route matches...”异常时，响应是这样的（有意空白行）：

```
HTTP/1.1 200 OK
Date: Thu, 02 Oct 2008 10:28:02 GMT
Content-Type: text/html
Content-Length: 122
Vary: Accept-Encoding
Keep-Alive: timeout=15, max=100
Connection: Keep-Alive

Status: 500 Internal Server Error
Content-Type: text/html

<html><body><h1>500 Internal Server Error</h1></body></html> 
```

我在 /vendor 中有 ExceptionLogger 插件，尽管这似乎不是问题。除了自定义的 500.html 之外，我还没有在公共场合添加任何错误处理（尽管响应不包含该 HTML），而且我不知道这部分 html 是从哪里来的。

所以，某处添加**HTTP/1.1 200**状态代码太早了，或者**Status: 500**太晚了。我怀疑它是 Apache，因为当我使用 Webrick 时，我得到了适当的 HTTP/1.1 500 标头（在顶部）。

我的生产堆栈如下：Apache 2 Mongrel（5 个实例）RubyOnRails 2.1.1（发生在 1.2 和 2.1.1 中）

* * *

我忘了提，**错误是由“没有路由匹配...”异常引起的**

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2010-04-21T14:12:50.560

这是一个相当古老的线程，但值得我找到一个很好的资源，其中包括对问题和解决方案的详细描述。显然，当与 Mongrel 一起使用时，此错误会影响 Rails < 2.3。

*   [帮助我理解问题](http://billkirtley.wordpress.com/2009/03/03/failsafe-handling-with-rails/)并编写自己的补丁的文章。
*   包含 Rails 2.2.2 补丁[的官方 Rails 错误票。](https://rails.lighthouseapp.com/projects/8994/tickets/1602-failsafe_response-200-ok)

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T10:35:00.060

这个 html 文件来自 Rails。它遇到某种错误（可能是某种异常，或其他一些不可恢复的错误）。

如果 Status: 标头和实际标头之间有额外的空白行，而不仅仅是拼写错误，那么这将有助于解释为什么 Apache 报告 200 OK 消息。

状态标头是 Rails、PHP 或任何告诉 Apache “发生错误，请返回此代码而不是 200 OK”的标题。有一个空行的事实意味着发生了一些额外的事情，并且 Ruby 出于某种原因在错误输出之前输出了一个空行。也许它是您脚本的先前输出。总而言之，额外的空白行意味着 Apache 认为“哦，空白行，没有额外的标题，这就是现在的所有内容。”，这与您提供的 Content-Length 标题一致。

我猜测为什么会有一个空行是以前的脚本输出，可能是在完整脚本页面末尾结束的行。至于为什么会发生 500 错误，这里没有足够的信息来告诉你。可能是文件 I/O 错误。

**编辑：**鉴于 Dave 提供的有关内部的额外信息，我想说这实际上是幕后进行的代理的一个问题……除了已经说过的内容之外，我无法确切地告诉你是什么。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-12T14:50:24.863

这是来自rails本身。

[http://github.com/rails/rails/tree/master/actionpack/lib/action_controller/dispatcher.rb#L60](http://github.com/rails/rails/tree/master/actionpack/lib/action_controller/dispatcher.rb#L60)

调度程序返回一个错误页面，状态码为 200（成功）。

# java - Java 接口中的方法是否应该使用或不使用公共访问修饰符来声明？

> ID：161633
> 
> 赞同：315
> 
> 时间：2008-10-02T10:13:22.140
> 
> 标签：java, interface, coding-style, public-method

Java 接口中的方法是否应该使用或不使用`public`访问修饰符声明？

当然，从技术上讲，这并不重要。实现 an 的类方法`interface`always `public`。但是什么是更好的约定呢？

Java 本身在这方面并不一致。参见例如`Collection`vs.`Comparable`或`Future`vs. `ScriptEngine`。

* * *

## 回答 #1

> 赞同：348
> 
> 时间：2008-10-02T11:20:35.300

[JLS](http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.4)清楚地表明了这一点：

> 允许但不鼓励为接口中声明的方法冗余地指定`public`和/或`abstract`修饰符。

* * *

## 回答 #2

> 赞同：46
> 
> 时间：2008-10-02T10:20:55.087

在 Java 接口中应该省略 public 修饰符（在我看来）。

由于它没有添加任何额外的信息，它只是将注意力从重要的东西上转移开。

大多数样式指南都会建议您将其排除在外，但当然，最重要的是在您的代码库中保持一致，尤其是对于每个界面。下面的例子很容易让那些不是 100% 精通 Java 的人感到困惑：

```
public interface Foo{
  public void MakeFoo();
  void PerformBar();
} 
```

* * *

## 回答 #3

> 赞同：11
> 
> 时间：2016-03-06T20:52:15.557

尽管这个问题很久以前就被问过了，但我觉得一个全面的描述会澄清为什么不需要在方法之前使用公共抽象，在接口的常量之前使用公共静态最终。

首先，接口用于为一组不相关的类指定通用方法，每个类都将具有唯一的实现。因此，不可能将访问修饰符指定为私有，因为它不能被其他类访问以被覆盖。

第二，虽然可以初始化接口类型的对象，但是接口是由实现它的类实现的，而不是继承的。并且由于接口可能由不在同一个包中的不同不相关类实现（实现），因此受保护的访问修饰符也无效。所以对于访问修饰符，我们只剩下公共选择了。

第三，接口没有任何数据实现，包括实例变量和方法。如果在接口中插入实现的方法或实例变量有逻辑上的原因，那么它必须是继承层次结构中的超类，而不是接口。考虑到这一事实，由于没有方法可以在接口中实现，因此接口中的所有方法都必须是抽象的。

第四，接口只能包含常量作为它的数据成员，这意味着它们必须是最终的，当然最终的常量被声明为静态的以只保留它们的一个实例。因此 static final 也是接口常量的必需品。

所以总而言之，虽然在接口的常量之前使用公共抽象和公共静态最终是有效的，但由于没有其他选项，它被认为是多余的并且不使用。

* * *

## 回答 #4

> 赞同：9
> 
> 时间：2017-07-02T08:31:06.707

随着 Java 8/9 中接口方法的`private`, `static`,`default`修饰符的引入，事情变得更加复杂，我倾向于认为完整的声明更具可读性（需要 Java 9 编译）：

```
public interface MyInterface {

    //minimal
    int CONST00 = 0;
    void method00();
    static void method01() {}
    default void method02() {}
    private static void method03() {}
    private void method04() {}

    //full
    public static final int CONST10 = 0;
    public abstract void method10();
    public static void method11() {}
    public default void method12() {}
    private static void method13() {}
    private void method14() {}

} 
```

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2008-10-02T10:33:00.937

我会避免放置默认应用的修饰符。正如所指出的，它可能导致不一致和混乱。

我看到的最糟糕的是一个声明了方法的接口`abstract`......

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2008-10-02T10:36:32.910

我使用了带有`public`修饰符的声明方法，因为它使代码更具可读性，尤其是在语法高亮的情况下。不过，在我们最新的项目中，我们使用了 Checkstyle，它会`public`在接口方法的修饰符的默认配置中显示警告，所以我转而省略它们。

所以我不确定什么是最好的，但我真正不喜欢的一件事是`public abstract`在接口方法上使用。Eclipse 在使用“提取接口”进行重构时有时会这样做。

* * *

## 回答 #7

> 赞同：5
> 
> 时间：2019-02-13T15:12:25.933

我不同意流行的答案，即公开意味着还有其他选择，因此不应该存在。事实是，现在有了 Java 9 及更高版本，还有其他选择。

我认为相反，Java 应该强制/要求指定“公共”。为什么？因为缺少修饰符意味着在其他任何地方都可以“打包”访问，而将其作为特殊情况会导致混淆。如果您只是简单地将其设置为带有明确消息的编译错误（例如“接口中不允许包访问。”），我们将摆脱选择省略“public”所引入的明显歧义。

注意当前的措辞：[https ://docs.oracle.com/javase/specs/jls/se9/html/jls-9.html#jls-9.4](https://docs.oracle.com/javase/specs/jls/se9/html/jls-9.html#jls-9.4)

> “接口主体中的方法可以声明为**公共**的或 **私有**的（第 6.6 节）。如果没有给出访问修饰符，则该方法是隐式公共的。允许但不鼓励过多地指定公共接口中方法声明的修饰符。”

看到现在允许“私人”。我认为最后一句话应该从 JLS 中删除。不幸的是，“隐式公共”行为曾经被允许，因为它现在可能会为了向后兼容而保留，并导致混淆，即没有访问修饰符意味着接口中的“公共”和其他地方的“包”。

* * *

## 回答 #8

> 赞同：4
> 
> 时间：2008-10-02T10:18:01.333

如果没有接口并且我正在编写直接实现，我总是写我会使用的东西，即我会使用`public`.

* * *

## 回答 #9

> 赞同：3
> 
> 时间：2010-08-10T09:07:21.047

我更喜欢跳过它，我在某处读到默认情况下的接口，`public`并且`abstract`.

令我惊讶的是这本书 - [Head First Design Patterns](http://shop.oreilly.com/product/9780596007126.do)，正在使用`public`接口声明和接口方法......这让我再次重新思考，我登上了这篇文章。

无论如何，我认为应该忽略多余的信息。

* * *

## 回答 #10

> 赞同：3
> 
> 时间：2013-07-31T07:08:23.670

接口中的方法默认为 public 和 abstract 的原因对我来说似乎非常合乎逻辑和明显。

接口中的方法默认情况下是抽象的，强制实现类提供实现，并且默认情况下是公共的，因此实现类可以访问。

在代码中添加这些修饰符是多余且无用的，只会导致您缺乏对 Java 基础知识和/或理解的结论。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-10-02T10:35:46.453

这完全是主观的。我省略了冗余`public`修饰符，因为它看起来很混乱。正如其他人所提到的 - 一致性是这个决定的关键。

有趣的是，C# 语言设计者决定强制执行这一点。 **在 C# 中将接口方法声明为 public 实际上是一个编译错误。** 不过，跨语言的一致性可能并不重要，所以我想这与 Java 并不直接相关。

* * *

## 回答 #12

> 赞同：-9
> 
> 时间：2012-03-31T08:12:49.490

人们将通过 IDE 或 Javadoc 中的代码完成来学习您的界面，而不是通过阅读源代码。因此，在源代码中放置“公共”是没有意义的——没有人在阅读源代码。

# visual-studio-2005 - Visual Studio 2005 - 无法在设计器上打开表单

> ID：161637
> 
> 赞同：0
> 
> 时间：2008-10-02T10:14:07.053
> 
> 标签：visual-studio-2005, windows-forms-designer

我的团队在 Visual Studio 2005 上开发了一个 GUI 应用程序，托管 C++。由于某些交付无法在设计器中打开表单，即使源代码和项目设置没有更改。设计器报这个错误：

**引发了“System.OutOfMemoryException”类型的异常。**

*在 Microsoft.VisualStudio.Design.VSDynamicTypeService.ShadowCopyAssembly(String fileName) 在 Microsoft.VisualStudio.Design.VSDynamicTypeService.CreateDynamicAssembly(String codeBase) 在 Microsoft.VisualStudio.Design.VSTypeResolutionService.AssemblyEntry.get_Assembly() 在 Microsoft.VisualStudio.Design.VSTypeResolutionService .AssemblyEntry.Search(String fullName, String typeName, Boolean ignoreTypeCase, Assembly& assembly, String description) ...*

我们成功地重新编译了项目，但我们仍然遇到这个问题。任何想法？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T10:21:31.137

这就是我过去调试这些问题的方式，启动 Visual Studio 的第二个实例，加载您的项目并附加到也加载了项目的第一个实例。现在在构造函数和页面加载事件中设置一个断点，以及您在第二个实例中可能在表单中拥有的任何自定义绘制事件，并尝试在第一个实例中打开设计器，断点应该被命中并且您应该能够看看发生了什么。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T10:23:36.437

我怀疑您有一个设计模式错误，其中在相关表单上发生了无限循环（或递归控件创建）。

在 Windows 窗体上帮助我解决此类错误的一件事是：

*   为您的 GUI 应用程序打开 Visual Studio 2005 解决方案。暂时不要打开您的表单
*   打开另一个 Visual Studio 2005 实例
*   在第二个实例中，将 devenv.exe 的第一个实例附加（调试 -> 附加到进程）到调试器。确保异常（调试 -> 异常）选中“抛出”下的所有异常复选框。
*   现在转到您的第一个 VS2005 实例并打开表单。第二个 VS2005 实例将停在发生错误的行。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-25T04:50:00.407

I've run into the same issue intermittently when working with a large multi-project solution, or a project with an exceedingly large and complicated windows form.

I was able to solve the problem by enabling Visual Studio to use more than 2GB of memory. Here's the process...

(note: this assumes XP and Visual Studio 2005 - Vista and/or VS2008 will require slight changes)

## Edit Boot.ini

Right-click *My Computer*, *properties*, *Advanced* tab. Under *Startup and Recovery* click *Settings*. Click the *Edit* button, and add the **/3GB** switch to the end of the [operating systems] line:

```
multi(0)disk(0)rdisk(0)partition(2)\WINDOWS="Microsoft Windows XP Professional" /noexecute=optin /fastdetect /3GB 
```

## Make Visual Studio "Large Address Aware"

Run a Visual Studio Command Prompt, and change to the IDE directory:

```
cd %ProgramFiles%\Microsoft Visual Studio 8\Common7\IDE 
```

Use the microsoft tool [editbin](http://msdn.microsoft.com/en-us/library/d25ddyfc(VS.80).aspx) to modify devenv.exe:

```
editbin /LARGEADDRESSAWARE devenv.exe 
```

Now reboot, and you're done!

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T10:19:56.867

这是一个很长的镜头，但请尝试连续多次关闭和打开设计器。我在使用 C# Windows 窗体设计器 (VS2005) 时遇到过同样的问题：窗体通常最终会正确打开（经过 5 次尝试，非常一致）。

# c++ - Windbg：如何在 C++ 函数的重载之一上设置断点？

> ID：161639
> 
> 赞同：12
> 
> 时间：2008-10-02T10:14:44.960
> 
> 标签：c++, debugging, windbg

我有两个 C++ 函数重载，我想在其中一个上设置断点：

```
0:000> bu myexe!displayerror
Matched: 00000000`ff3c6100 myexe!displayError (int, HRESULT, wchar_t *)
Matched: 00000000`ff3c60d0 myexe!displayError (int, HRESULT)
Ambiguous symbol error at 'myexe!displayerror' 
```

哎呀，我可以在所有重载上设置断点，但似乎无法弄清楚如何：

```
0:000> bu myexe!displayerror*
Matched: 00000000`ff3c6100 myexe!displayError (int, HRESULT, wchar_t *)
Matched: 00000000`ff3c60d0 myexe!displayError (int, HRESULT)
Ambiguous symbol error at 'myexe!displayerror*' 
```

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-02T10:20:29.220

尝试：

```
bu 0xff3c6100 
```

如果我没记错的话，WinDbg 也允许按地址设置断点。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-12-23T12:08:21.393

你试过“bm myexe！displayerror*”吗？

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2011-01-25T17:59:55.390

bp @@( MyClass::MyMethod ) 中断方法（如果相同的方法被重载并因此出现在多个地址上时很有用）

* * *

## 回答 #4

> 赞同：3
> 
> 时间：2010-11-14T06:40:06.387

```
bm myexe!displayerror 
```

这将为所有重载设置断点，而不是`bc`用来清除不需要的重载

```
bc 1-3 
```

或者只是禁用它们

```
bd 1-3 
```

问题`bm`在于它产生的断点有时无法评估并触发中断。有时很烦人。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2012-03-10T11:50:44.177

在您的 dll 中搜索与您的符号匹配的所有入口点

```
x myexe!displayerror 
```

这将输出与搜索字符串匹配的所有符号及其入口点，然后在地址上设置断点

```
bp ff3c6100 // for myexe!displayError (int, HRESULT, wchar_t *) 
```

当该地址被命中时，这将设置一个特定的断点，或者您针对另一个地址设置 bp。您可以将断点设置为只命中一次，清除断点并退出

```
bp /1 ff3c6100 
```

您还可以执行转储调用堆栈、变量和继续等命令：

```
bp ff3c6100 "kb;dv;g" 
```

您也可以在附加 WinDbg 时打开源代码，导航到要设置断点的代码行并按 F9（与使用 Visual Studio 的操作相同），它会在设置断点之前暂停一段时间在该行，这假设您可以访问源代码。

# windows - 哪个是最快的 TAR 应用程序？

> ID：161646
> 
> 赞同：2
> 
> 时间：2008-10-02T10:17:26.047
> 
> 标签：windows, compression, tar

我有一个脚本可以压缩整个源代码目录（大约 800MB），我希望它尽可能快地运行。出于某种原因，GNU Tar 在解压时有点慢。我想知道是否有人已经进行了这种比较并且知道哪个应用程序具有最快的 tar/untar 实现。对于 Windows，顺便说一句。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T13:07:52.343

将 GNU tar 与什么进行比较？

您的 tar 程序的性能最终将（当您移除防病毒等因素时）受 I/O 限制，因此获得更快 tar 的最大希望是获得更快的硬件。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-02T10:36:41.367

[http://www.7-zip.org/](http://www.7-zip.org/)可能会快一点，还没有直接相互测试它们。一种考虑可能是让您的 tar 脚本将文件存储在 tar 存档中而不是压缩它们，但这仅在文件大小不是考虑因素的情况下。如果您不需要它们变得更小，只需将它们存储在单个 tar 文件中，那么完全关闭压缩将为您带来显着的好处。

另外，只需检查并确保您没有在后台运行按访问病毒扫描程序，因为它会在每次更改时重新扫描您的 tar 文件并显着增加您的 tar 时间。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-05T12:27:54.103

我针对 GNU tar 测试了 7zip，它更慢.. :( WinRAR 也更慢。

# java - 截断方法调用

> ID：161654
> 
> 赞同：1
> 
> 时间：2008-10-02T10:20:02.933
> 
> 标签：java, code-formatting

这是一个主观问题，因为我想衡量是否值得我抱怨我的同事做了一些我觉得完全可憎的事情。

问题是我的一群同事会截断方法调用以适应宽度。我们都使用可以处理大分辨率的宽屏笔记本电脑（我的是 1920x1200），在调试和阅读代码时，我发现阅读单行方法调用比多行调用更容易。

这是一个方法的例子（我想要它）：

```
IReallyLongInterfaceName instanceOfInterfaceName = OurContainer.retrieveClass(IReallyLongInterfaceName.class, param1, param2, param3); 
```

（我也讨厌很长的接口/类名：）

这似乎在 StackOverflow 上渲染得不好，但我想你们中的大多数人都知道我的意思。无论如何，其他一些开发人员会执行以下操作。

```
IReallyLongInterfaceName instanceOfInterfaceName = OurContainer.retrieveClass(IReallyLongInterfaceName.class, 
                                                                              param1, 
                                                                              param2, 
                                                                              param3); 
```

在一天结束时对您来说哪个更容易阅读，我要求他们使用两者中的第一个（因为它是我们标准的一部分）是不合理的？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T10:45:52.497

我发现第一个示例通常更具可读性，但如果它超过某个预定义的限制（对我来说是 120 个字符），我会换行：

```
IReallyLongInterfaceName instanceOfInterfaceName =
        OurContainer.retrieveClass(IReallyLongInterfaceName.class,
                                   param1, param2, param3); 
```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-02T11:10:27.760

我更喜欢第二个例子。即使您可能拥有宽屏笔记本电脑，但您可能并不总是全屏显示 Windows，或者在您的 IDE 中，您可能在主要编码区域周围有很多其他面板，这些面板会减少显示代码的可用宽度。

如果不滚动就无法容纳该行，则垂直滚动比水平滚动更可取。由于我们从左到右阅读，因此水平滚动意味着一直向后和向前移动。

我更喜欢每行一个参数而不是 Avi 的建议，这对我来说是任意的。如果将参数分布在多行但每行有多个参数，则在阅读代码时查找特定参数会更加困难。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-02T10:24:26.277

也许您应该在标准构建过程中使用某种 checkstyle 插件来检查这种东西？如果您已与您的同事就该标准达成一致，要求他们遵守该标准似乎是合理的。

我个人认为这两个选项中的第二个更具可读性，但这只是因为我没有宽屏显示器；）

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-02T10:31:12.597

如果它在公司编码标准中明确指出方法一是正确的方法，那么无论如何都要抱怨他们，毕竟他们没有遵守公司标准。如果没有明确说明，那么我想现在是将其纳入标准的好时机。但是要注意的一件事是，如果您使用的是具有自动格式化功能的 IDE，它可能会在运行时自行将方法重新格式化为样式 2。因此，即使每个人都在写风格 1，当他们完成它时，它最终可能不会像那样。

和 Phil 一样，我发现方法 2 更具可读性，因为您可以看到您需要看到的所有内容，而无需侧身滚动 :)

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-03T03:43:34.847

我更喜欢选项 2，但可以选择对变量名称不明显的参数进行注释。当您有一个要求一堆参数的函数调用时，审阅者可能很难判断代码在做什么。

因此，如果给定函数的参数超过 3 个，我通常会这样编写代码：

```
applyEncryptionParameters(key,
                          certificate,
                          0, // strength - set to 0 to accept default for platform
                          algorithm); 
```

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-02T11:29:26.963

我也更喜欢选项＃2。问题不仅在于它在屏幕上的外观（如果我有 1920 个水平像素，我会有更多停靠的窗口），而是它在我需要打印和阅读时的外观。大多数 IDE 会打印出很长的行，而作者为了提高易读性而打断的行会打印得很好。

另一点是一般的易读性。杂志和报纸分栏印刷是有原因的——通常，更短的行和更好的布局/格式可以提高文本的可读性（尤其是屏幕上的文本）。

我认为 80 可能过于随意，但我使用的是 10pt Consolas，而且我似乎能够在标准 8.5" 打印页面上每行获得大约 100 个字符。

现在说到底，这是一场圣战。也许没有把花括号放在哪里那么糟糕，但它就在那里。我已经给了你我的偏好，但真正的问题又回到了你身上：你公司的标准是什么？在我看来，他们已经对选项 2 进行了标准化，这意味着为了团队的利益，您可能应该适应它们。

# svn - 如何维护移动到覆盖同名文件的目录的文件的历史记录

> ID：161655
> 
> 赞同：1
> 
> 时间：2008-10-02T10:20:08.020
> 
> 标签：svn, overwrite

考虑以下颠覆目录结构

/dir1/file.txt

/dir2/file.txt

我想移动 dir1 中的 file.txt 以替换 dir2 中的相同文件，并确保保留 dir1 文件的历史记录。我不关心原始 dir2 文件的历史。

这可以使用颠覆命令而不是破解后端吗？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2008-10-02T10:23:42.753

首先，您永远不应该考虑破解后端 - 它首先否定了使用 SVN 的意义。

我不明白为什么你不能做

```
svn rm /dir2/file.txt
svn mv /dir1/file.txt /dir2/file.txt 
```

文件的历史将在移动后跟随它。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-02T10:36:45.530

尝试

1.  删除 dir2/file.txt 并提交
2.  发出 svn move 命令将 dir1/file.txt 移动到 dir2/file.txt 并提交 - 应保留历史记录。

# scheme - SICP 练习 1.3 征求意见

> ID：161666
> 
> 赞同：24
> 
> 时间：2008-10-02T10:23:31.070
> 
> 标签：scheme, sicp

我正在尝试通过 SICP 学习方案。练习 1.3 如下： 定义一个以三个数字作为参数并返回两个较大数字的平方和的过程。请评论我如何改进我的解决方案。

```
(define (big x y)
    (if (> x y) x y))

(define (p a b c)
    (cond ((> a b) (+ (square a) (square (big b c))))
          (else (+ (square b) (square (big a c)))))) 
```

* * *

## 回答 #1

> 赞同：34
> 
> 时间：2009-07-21T21:18:43.463

仅使用本书当时提出的概念，我会这样做：

```
(define (square x) (* x x))

(define (sum-of-squares x y) (+ (square x) (square y)))

(define (min x y) (if (< x y) x y))

(define (max x y) (if (> x y) x y))

(define (sum-squares-2-biggest x y z)
  (sum-of-squares (max x y) (max z (min x y)))) 
```

* * *

## 回答 #2

> 赞同：14
> 
> 时间：2008-10-02T10:27:56.193

`big`称为`max`。使用标准库功能。

我的方法不同。我没有进行大量测试，而是简单地将所有三个的平方相加，然后减去最小的一个的平方。

```
(define (exercise1.3 a b c)
  (let ((smallest (min a b c))
        (square (lambda (x) (* x x))))
    (+ (square a) (square b) (square c) (- (square smallest))))) 
```

当然，您更喜欢这种方法还是一堆`if`测试，这取决于您。

* * *

[使用SRFI 95 的](http://srfi.schemers.org/srfi-95/srfi-95.html)替代实现：

```
(define (exercise1.3 . args)
  (let ((sorted (sort! args >))
        (square (lambda (x) (* x x))))
    (+ (square (car sorted)) (square (cadr sorted))))) 
```

如上所述，但作为单行（感谢 synx @ freenode #scheme）；还需要[SRFI 1](http://srfi.schemers.org/srfi-1/srfi-1.html)和[SRFI 26](http://srfi.schemers.org/srfi-26/srfi-26.html)：

```
(define (exercise1.3 . args)
  (apply + (map! (cut expt <> 2) (take! (sort! args >) 2)))) 
```

* * *

## 回答 #3

> 赞同：12
> 
> 时间：2009-03-04T14:09:37.620

这样的事情呢？

```
(define (p a b c)
  (if (> a b)
      (if (> b c)
          (+ (square a) (square b))
          (+ (square a) (square c)))
      (if (> a c)
          (+ (square a) (square b))
          (+ (square b) (square c))))) 
```

* * *

## 回答 #4

> 赞同：11
> 
> 时间：2009-10-05T03:36:37.813

我使用以下代码完成了它，它使用了内置的`min`、`max`和`square`过程。它们很简单，仅使用到目前为止在文本中介绍的内容即可实现。

```
(define (sum-of-highest-squares x y z)
   (+ (square (max x y))
      (square (max (min x y) z)))) 
```

* * *

## 回答 #5

> 赞同：6
> 
> 时间：2009-07-05T15:52:45.180

仅使用本文之前介绍的概念，*我认为这是相当重要的*，这里有一个不同的解决方案：

```
(define (smallest-of-three a b c)
        (if (< a b)
            (if (< a c) a c)
            (if (< b c) b c)))

(define (square a)
        (* a a))

(define (sum-of-squares-largest a b c) 
        (+ (square a)
           (square b)
           (square c)
           (- (square (smallest-of-three a b c))))) 
```

* * *

## 回答 #6

> 赞同：5
> 
> 时间：2012-01-30T14:08:06.917

```
(define (f a b c) 
  (if (= a (min a b c)) 
      (+ (* b b) (* c c)) 
      (f b c a))) 
```

* * *

## 回答 #7

> 赞同：4
> 
> 时间：2008-10-02T10:26:13.467

对我来说看起来不错，您有什么具体要改进的地方吗？

您可以执行以下操作：

```
(define (max2 . l)
  (lambda ()
    (let ((a (apply max l)))
      (values a (apply max (remv a l))))))

(define (q a b c)
  (call-with-values (max2 a b c)
    (lambda (a b)
      (+ (* a a) (* b b)))))

(define (skip-min . l)
  (lambda ()
    (apply values (remv (apply min l) l))))

(define (p a b c)
  (call-with-values (skip-min a b c)
    (lambda (a b)
      (+ (* a a) (* b b))))) 
```

而且这个（proc p）可以很容易地转换为处理任意数量的参数。

* * *

## 回答 #8

> 赞同：4
> 
> 时间：2012-01-30T09:28:24.650

```
(define (sum-sqr x y)
(+ (square x) (square y)))

(define (sum-squares-2-of-3 x y z)
    (cond ((and (<= x y) (<= x z)) (sum-sqr y z))
             ((and (<= y x) (<= y z)) (sum-sqr x z))
             ((and (<= z x) (<= z y)) (sum-sqr x y)))) 
```

* * *

## 回答 #9

> 赞同：3
> 
> 时间：2009-12-10T14:11:49.740

在 Scott Hoffman 和一些 irc 的帮助下，我纠正了我的错误代码，这里是

```
(define (p a b c)
    (cond ((> a b)
        (cond ((> b c)
            (+ (square a) (square b)))
            (else (+ (square a) (square c)))))
        (else
            (cond ((> a c)
                (+ (square b) (square a))))
             (+ (square b) (square c))))) 
```

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-10-02T10:44:23.860

您还可以对列表进行排序并添加排序列表的第一个和第二个元素的平方：

```
(require (lib "list.ss")) ;; I use PLT Scheme

(define (exercise-1-3 a b c)
  (let* [(sorted-list (sort (list a b c) >))
         (x (first sorted-list))
         (y (second sorted-list))]
    (+ (* x x) (* y y)))) 
```

* * *

## 回答 #11

> 赞同：2
> 
> 时间：2009-03-04T21:37:47.247

这是另一种方法：

```
#!/usr/bin/env mzscheme
#lang 方案/加载

（模块 ex-1.3 方案/基础
  （定义（ex-1.3 abc）
    (let* ((square (lambda (x) (* xx)))
           (p (lambda (abc) (+ (square a) (square (if (> bc) bc))))))
      (如果 (> ab) (pabc) (pbac))))

  （需要方案/合同）
  (提供/合同 [ex-1.3 (-> number?number?number?number?)]))

;; 测试
（模块 ex-1.3/test scheme/base
  （需要（行星“test.ss”（“原理图”“schemeunit.plt”2））
           （行星“text-ui.ss”（“原理图”“schemeunit.plt”2）））
  （需要'ex-1.3）

  （测试/文本-ui
   （测试套件
    “前 1.3”
    （测试等于？“1 2 3”（ex-1.3 1 2 3）13）
    （测试等于？“2 1 3”（ex-1.3 2 1 3）13）
    （测试等于？“2 1\. 3.5”（ex-1.3 2 1\. 3.5）16.25）
    （测试等于？“-2 -10。3.5”（ex-1.3 -2 -10。3.5）16.25）
    (test-exn "2+1i 0 0" exn:fail:contract? (lambda () (ex-1.3 2+1i 0 0)))
    （测试相等？“全部相等”（ex-1.3 3 3 3）18））））

（需要'ex-1.3/test）

```

例子：

```
$ mzscheme ex-1.3.ss
6 成功 0 失败 0 错误 6 测试运行
0

```

* * *

## 回答 #12

> 赞同：2
> 
> 时间：2018-07-27T03:21:46.980

很高兴看到其他人如何解决这个问题。这是我的解决方案：

```
(define (isGreater? x y z)
(if (and (> x z) (> y z))
(+ (square x) (square y))
0))

(define (sumLarger x y z)
(if (= (isGreater? x y z) 0)   
(sumLarger y z x)
(isGreater? x y z))) 
```

我通过迭代解决了它，但我更喜欢 ashitaka 和 (+ (square (max xy)) (square (max (min xy) z))) 解决方案，因为在我的版本中，如果 z 是最小的数字，isGreater? 被调用两次，创建了一个不必要的缓慢和迂回的过程。

* * *

## 回答 #13

> 赞同：1
> 
> 时间：2014-03-20T12:58:13.047

```
(define (sum a b) (+ a b))
(define (square a) (* a a))
(define (greater a b ) 
  ( if (< a b) b a))
(define (smaller a b ) 
  ( if (< a b) a b))
(define (sumOfSquare a b)
    (sum (square a) (square b)))
(define (sumOfSquareOfGreaterNumbers a b c)
  (sumOfSquare (greater a b) (greater (smaller a b) c))) 
```

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2010-01-04T04:35:26.947

我试过了：

```
(define (procedure a b c)
    (let ((y (sort (list a b c) >)) (square (lambda (x) (* x x))))
        (+ (square (first y)) (square(second y))))) 
```

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2011-01-12T02:43:43.233

```
;exercise 1.3
(define (sum-square-of-max a b c)
  (+ (if (> a b) (* a a) (* b b))
     (if (> b c) (* b b) (* c c)))) 
```

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2015-02-22T23:55:44.877

我认为这是最小和最有效的方法：

```
(define (square-sum-larger a b c)
 (+ 
  (square (max a b))
  (square (max (min a b) c)))) 
```

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2017-08-30T13:40:25.197

下面是我想出的解决方案。我发现将代码分解为小函数时更容易推理出解决方案。

```
 ; Exercise 1.3
(define (sum-square-largest a b c)
  (+ (square (greatest a b))
     (square (greatest (least a b) c))))

(define (greatest a b)
  (cond (( > a b) a)
    (( < a b) b)))

(define (least a b)
  (cond ((> a b) b)
    ((< a b) a)))

(define (square a)
  (* a a)) 
```

# c++ - 包含类变量初始化的 C++ 类初始化

> ID：161672
> 
> 赞同：13
> 
> 时间：2008-10-02T10:25:29.800
> 
> 标签：c++, class, coding-style

今天注意到一个同事的一些代码，它在初始化时初始化了类变量。然而，它引起了警告，他说，因为它们的顺序。我的问题是为什么最好在当前位置而不是在大括号内进行变量初始化？

```
DiagramScene::DiagramScene( int slideNo, QRectF screenRect, MainWindow* parent )
    : QGraphicsScene( screenRect, parent ),
    myParent( parent ), 
    slideUndoImageCurrentIndex(-1),
    nextGroupID(0),
    m_undoInProgress(false),
    m_deleteItemOnNextUndo(0)
    line(0),
    path(0)
{
    /* Setup default brush for background */
    scDetail->bgBrush.setStyle(Qt::SolidPattern);
    scDetail->bgBrush.setColor(Qt::white);
    setBackgroundBrush(scDetail->bgBrush);

} 
```

* * *

## 回答 #1

> 赞同：26
> 
> 时间：2008-10-02T10:34:12.137

*   它更有效（通常）。一个类的所有成员都在构造函数中初始化，无论你是否显式初始化它们。如果不指定初始化程序，则运行成员的默认构造函数。如果您在构造函数主体中赋值，则再次调用赋值运算符。这不适用于标量值，如您的示例所示，因为标量值没有构造函数。
*   您不能在初始化列表中意外地分配一个值两次。
*   编译器可以检查以确保您编写初始化程序的顺序与在类中定义成员的顺序相匹配。C++ 标准要求成员按照声明的顺序进行初始化，而不管您编写初始化程序的顺序如何。让编译器检查这个顺序可确保程序员知道初始化程序将以哪个顺序运行（同样，这对于非 POD 成员比对标量更重要）。
*   引用类型和`const`成员必须在初始化器列表中初始化，因为您不能分配给引用或`const`成员。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-02T10:42:34.237

最好对初始化列表中的成员进行初始化，因为成员只会被初始化一次。如果成员本身就是类，这可能会在性能（甚至行为）上产生巨大差异。如果成员都是非常量、非引用的基本数据类型，那么差异通常可以忽略不计。

**注意**：有时基本数据类型需要初始化列表——特别是当类型是常量或引用时。对于这些类型，数据只能初始化一次，因此不能在构造函数的主体中初始化。有关更多信息，请参阅[**本文**](http://www.cprogramming.com/tutorial/initialization-lists-c++.html)。

请注意，成员的初始化顺序是成员在类定义中声明的顺序，而不是成员在初始化列表中声明的顺序。如果可以通过更改初始化列表的顺序来修复警告，那么我强烈建议您这样做。

我的建议是：

*   你学会了喜欢初始化列表。
*   您的同事了解成员初始化顺序的规则（并避免警告）。

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2008-10-02T10:48:41.120

除了 Greg Hewgill 的[出色回答](https://stackoverflow.com/questions/161672/c-class-initialisation-containing-class-variable-initialisation#161684)之外- 必须在初始化列表中设置 const 变量。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-02T10:37:02.317

因为，在构造函数的主体中（“在大括号内”），成员变量已经是默认构造的。这可能会对性能产生一些影响，当您有一个具有非平凡构造的类型的成员变量时，当您首先将其默认构造，然后在构造函数中为其分配一些其他值时，当您可以自定义构造时它直接。

此外，某些类型可能不是默认构造的（例如引用），必须在初始化列表中构造。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2008-10-02T10:41:45.113

如果你有 const 变量，它们的值不能通过赋值来设置。

将值分配给对象（不是内置函数或内在函数）时，初始化也更有效，因为不会像分配那样创建临时对象。

有关详细信息，请参阅[C++ FAQ-Lite](http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.6)

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-02T10:40:49.437

看看在[http://web.tiscali.it/fanelia/cpp-faq-en/ctors.html#faq-10.6收集的智慧](http://web.tiscali.it/fanelia/cpp-faq-en/ctors.html#faq-10.6)

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T16:14:32.647

Greg 回答的另一个补充：必须在初始化列表中初始化没有默认构造函数的类型的成员。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2010-05-06T16:39:59.160

Greg Hegwell 的回答包含一些很好的建议，但它没有解释编译器生成警告的原因。

当编译器处理构造函数的初始化列表时，项目*按照它们在类声明中声明*的顺序进行初始化，而不是按照它们在初始化列表中出现的顺序。

如果初始化列表中的顺序与声明顺序不同，一些编译器会生成警告（因此当项目未按列表顺序初始化时，您不会感到惊讶）。您没有包含您的类声明，但这可能是您看到警告的原因。

这种行为的基本原理是类的成员应该始终以相同的顺序初始化：即使该类有多个构造函数（这可能使成员在其初始化列表中的顺序不同）。

# keyboard - zsh 中的 Home/End 键不适用于 putty

> ID：161676
> 
> 赞同：42
> 
> 时间：2008-10-02T10:30:12.287
> 
> 标签：keyboard, terminal, zsh, terminal-emulator

我在 Ubuntu 机器上将 zsh 作为默认 shell 运行，并且使用 gnome-terminal （据我所知模拟 xterm）一切正常。当我通过 ssh 和 putty（也模拟 xterm）从 Windows 框登录时，突然主页/结束键不再起作用。

我已经能够解决将这些行添加到我的 zshrc 文件中的问题...

```
bindkey '\e[1~' beginning-of-line
bindkey '\e[4~' end-of-line 
```

...但我仍然想知道这里有什么问题。任何的想法？

* * *

## 回答 #1

> 赞同：80
> 
> 时间：2009-03-26T16:15:48.820

我发现这是一个组合：

**一**

ZSH 开发人员认为 ZSH 不应该定义`Home`, `End`, `Del`, ... 键的操作。

`/etc/zsh/zshrc`Debian 和 Ubuntu 通过定义普通用户在全局文件中期望的正常操作来解决这个问题。按照相关代码（在 Debian 和 Ubuntu 上相同）：

```
if [[ "$TERM" != emacs ]]; then
[[ -z "$terminfo[kdch1]" ]] || bindkey -M emacs "$terminfo[kdch1]" delete-char
[[ -z "$terminfo[khome]" ]] || bindkey -M emacs "$terminfo[khome]" beginning-of-line
[[ -z "$terminfo[kend]" ]] || bindkey -M emacs "$terminfo[kend]" end-of-line
[[ -z "$terminfo[kich1]" ]] || bindkey -M emacs "$terminfo[kich1]" overwrite-mode
[[ -z "$terminfo[kdch1]" ]] || bindkey -M vicmd "$terminfo[kdch1]" vi-delete-char
[[ -z "$terminfo[khome]" ]] || bindkey -M vicmd "$terminfo[khome]" vi-beginning-of-line
[[ -z "$terminfo[kend]" ]] || bindkey -M vicmd "$terminfo[kend]" vi-end-of-line
[[ -z "$terminfo[kich1]" ]] || bindkey -M vicmd "$terminfo[kich1]" overwrite-mode

[[ -z "$terminfo[cuu1]" ]] || bindkey -M viins "$terminfo[cuu1]" vi-up-line-or-history
[[ -z "$terminfo[cuf1]" ]] || bindkey -M viins "$terminfo[cuf1]" vi-forward-char
[[ -z "$terminfo[kcuu1]" ]] || bindkey -M viins "$terminfo[kcuu1]" vi-up-line-or-history
[[ -z "$terminfo[kcud1]" ]] || bindkey -M viins "$terminfo[kcud1]" vi-down-line-or-history
[[ -z "$terminfo[kcuf1]" ]] || bindkey -M viins "$terminfo[kcuf1]" vi-forward-char
[[ -z "$terminfo[kcub1]" ]] || bindkey -M viins "$terminfo[kcub1]" vi-backward-char

# ncurses fogyatekos
[[ "$terminfo[kcuu1]" == "^[O"* ]] && bindkey -M viins "${terminfo[kcuu1]/O/[}" vi-up-line-or-history
[[ "$terminfo[kcud1]" == "^[O"* ]] && bindkey -M viins "${terminfo[kcud1]/O/[}" vi-down-line-or-history
[[ "$terminfo[kcuf1]" == "^[O"* ]] && bindkey -M viins "${terminfo[kcuf1]/O/[}" vi-forward-char
[[ "$terminfo[kcub1]" == "^[O"* ]] && bindkey -M viins "${terminfo[kcub1]/O/[}" vi-backward-char
[[ "$terminfo[khome]" == "^[O"* ]] && bindkey -M viins "${terminfo[khome]/O/[}" beginning-of-line
[[ "$terminfo[kend]" == "^[O"* ]] && bindkey -M viins "${terminfo[kend]/O/[}" end-of-line
[[ "$terminfo[khome]" == "^[O"* ]] && bindkey -M emacs "${terminfo[khome]/O/[}" beginning-of-line
[[ "$terminfo[kend]" == "^[O"* ]] && bindkey -M emacs "${terminfo[kend]/O/[}" end-of-line
fi 
```

因此，如果您连接到 Debian 或 Ubuntu 机器，您无需执行任何操作。一切都应该自动运行（如果没有，请参见下文）。

但是...如果您要连接到另一个机器（例如 FreeBSD），则可能没有用户友好的默认值`zshrc`。解决方案当然是将 Debian/Ubuntu 中的行添加`zshrc`到您自己的`.zshrc`.

**二**

Putty`xterm`作为终端类型发送到远程主机。但是在某处搞砸了，并且没有发送正确的控制代码`Home`, `End`, ... 这是人们期望从`xterm`. 或者`xterm`终端不应该发送那些或任何东西......（但是，如果您在 ZSH 中配置它，则`Del`密钥确实有效）。`xterm`另请注意，您的 Numpad 键在 Vim 中的行为很有趣，例如在`xterm`终端中。

解决方案是配置 Putty 发送另一种终端类型。我试过`xterm-color`和`linux`。`xterm-color`修复了`Home`/`End`问题，但小键盘仍然很有趣。将其设置为`linux`解决了这两个问题。

您可以在连接 -> 数据下的 Putty 中设置终端类型。不要试图在`.zshrc`with中设置终端类型`export TERM=linux`，这是错误的。终端类型应由您的终端应用程序指定。因此，例如，如果您从带有 Mac SSH 客户端的 Mac 机器连接，它可以设置自己的终端类型。

请注意，TERM 指定您的终端类型，与您要连接的主机无关。我可以将终端类型设置为`linux`Putty 并毫无问题地连接到 FreeBSD 服务器。

所以，解决这两个问题，你应该没事:)

* * *

## 回答 #2

> 赞同：19
> 
> 时间：2009-08-19T10:50:46.117

在 PuTTY 配置对话框中，转到 Connection -> Data 并在连接前在 Terminal-type 字符串中键入**linux 。**

* * *

## 回答 #3

> 赞同：7
> 
> 时间：2014-11-11T09:08:45.140

这对我有用

```
bindkey -v

bindkey '\eOH'  beginning-of-line
bindkey '\eOF'  end-of-line 
```

* * *

## 回答 #4

> 赞同：6
> 
> 时间：2012-04-30T02:38:03.560

应该在*所有*发行版中移植的适当答案（尽管不一定是所有版本的 zsh，这里是 ymmv）是使用 zkbd 的 zkbd 帮助程序实用程序。

> 键盘定义
> 键盘、工作站、终端、仿真器和窗口系统的大量可能组合使得 zsh 不可能在每种情况下都有内置的键绑定。在 Functions/Misc 中找到的 zkbd 实用程序可以帮助您快速为您的配置创建键绑定。

> 运行 zkbd 作为自动加载的函数，或者作为 shell 脚本：

```
zsh -f ~/zsh-4.3.17/Functions/Misc/zkbd 
```

> 当你运行 zkbd 时，它首先要求你输入你的终端类型；如果它提供的默认值是正确的，只需按回车键。然后它会要求您按多个不同的键来确定键盘和终端的特性；如果 zkbd 发现任何异常情况，例如既不发送 ^H 也不发送 ^? 的 Delete 键，zkbd 就会向您发出警告。

> zkbd 读取的击键记录为名为 key 的关联数组的定义，写入 HOME 或 ZDOTDIR 目录中的子目录 .zkbd 中的文件。文件名由 TERM、VENDOR 和 OSTYPE 参数组成，由连字符连接。

> `source`您可以使用or命令将此文件读入您​​的 .zshrc 或另一个启动文件`.`，然后在 bindkey 命令中引用 key 参数，如下所示：

```
 source ${ZDOTDIR:-$HOME}/.zkbd/$TERM-$VENDOR-$OSTYPE
          [[ -n ${key[Left]} ]] && bindkey "${key[Left]}" backward-char
          [[ -n ${key[Right]} ]] && bindkey "${key[Right]}" forward-char
          # etc. 
```

> 请注意，为了`autoload zkbd`正常工作，该`zkbd`文件必须位于 fpath 数组中指定的目录之一中（请参阅 zshparam(1)）。如果您有标准的 zsh 安装，这应该已经是这种情况了；如果不是，请将 Functions/Misc/zkbd 复制到适当的目录。

请参阅`man -P "less -p 'keyboard definition'" zshcontrib`或搜索元手册页`zshall`

* * *

## 回答 #5

> 赞同：5
> 
> 时间：2019-11-26T15:41:11.157

自首次发布此问题以来，已经将近 11 年了。当时，一些发行版确实附带了一个`putty`terminfo 条目，但充其量只是平庸。从那以后的几年里，情况有所改善，不再需要十多年来必要的黑客攻击。为了兼容性，PuTTY 仍默认设置`TERM`为`xterm``putty-256color`

1.  确保主机有一个 terminfo 条目`putty-256color`：`toe -a | grep -F putty`
2.  撤消您可能启用的任何 hack，以使 PuTTY 与 zsh 或其他程序正常工作。
3.  确保 PuTTY 是最新的。它不会在更新可用时通知您，如果它已过时，您可能会遇到很多相同的问题。您可能希望使用[Chocolatey](https://chocolatey.org/)之类的东西自动保持最新状态。
4.  在 PuTTY 的配置对话框中，转到 Connection -> Data 并将“Terminal-type string”设置为`putty-256color`.
5.  当您使用它时，在同一个配置屏幕上，添加一个新的环境变量以启用 24 位颜色。这个变量不是标准化的，但它是由许多其他主流终端仿真器（例如，iTerm2）发送的，并且许多程序都可以理解它。
    1.  多变的：`COLORTERM`
    2.  价值：`truecolor`
6.  在撰写本文时，我还没有找到默认通过 SSH 接受 COLORTERM 变量的发行版。您需要在主机上编辑 OpenSSH 配置以允许它。例如，在类似 Debian 的发行版上，编辑`/etc/ssh/sshd_config`并添加`COLORTERM`到该`AcceptEnv`行。
7.  现在一切都应该“正常工作”。如果没有：
    1.  确保您在进行更改后重新连接，或者至少`exec zsh`在更改后运行`TERM`。zsh 在运行时不会对更改做出反应`TERM`。
    2.  确保`TERM`实际设置为您想要的：`echo $TERM`
    3.  您使用的是最新版本的发行版吗？例如，如果您正在进行长期支持生命周期构建，即使您的版本在技术上仍受支持，它也可能没有最新的 terminfo 条目。
    4.  你是用`screen`还是`tmux`？那是另一整罐蠕虫。在没有先行者的情况下进行测试，以缩小问题发生的范围。在 tmux 中，尝试设置`TERM=tmux-256color`. 在屏幕内，尝试`TERM=screen-256color`.
    5.  您使用的是最新版本的 PuTTY 吗？
    6.  你有实现键绑定或其他黑客的 RC 文件吗？尝试使用默认的 RC 文件。
    7.  在尝试使用 terminfo 修复之前，您是否已经更改了各种 PuTTY 设置以尝试修复该问题？您可能需要重置这些设置。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-10-02T12:59:56.000

这似乎是一个腻子的东西。Gnome-terminal 分别发送 Home 和 End 的代码`^[OH`和`^[OF`，而 putty 发送`^[[1~`和`^[[4~`。putty 中有一个选项可以将 Home/End 键从*标准*模式更改为*rxvt*模式，这似乎可以修复 Home 键，但不能修复 End 键（现在发送`^[Ow`）。猜猜是时候在某处提交错误报告了...... :-)

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T11:55:42.253

这些绑定根本不像是在 emacs 模式下设置的默认绑定的一部分。

在运行“bindkey -e”后在我的默认 zsh 安装上执行“where-is beginning-of-line”表明它只绑定到 ^a。也许你应该问 zsh 开发人员为什么 :-)

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2021-11-26T15:00:25.357

这对我有用。

将这些行添加到 ~/.zshrc

```
bindkey "\e[1;5D" backward-word
bindkey "\e[1;5C" forward-word

# ctrl-bs and ctrl-del
bindkey "\e[3;5~" kill-word
bindkey "\C-_"    backward-kill-word

# del, home and end
bindkey "\e[3~" delete-char
bindkey "\e[H"  beginning-of-line
bindkey "\e[F"  end-of-line

# alt-bs
bindkey "\e\d"  undo 
```

# date - iCalendar 格式（Outlook 2007）

> ID：161677
> 
> 赞同：2
> 
> 时间：2008-10-02T10:30:54.033
> 
> 标签：date, outlook, icalendar

我有一个小问题，我需要能够在每个月的第二个星期二之后的第二天重复发生一个事件（永远）。

你可能在想，为什么不只是每个月的星期三。2008 年 10 月就是一个例子，它从星期三开始。:(

真的我只需要它在 Outlook 中，可能（但不限于）一些 iCalendar 格式文件。

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T14:15:47.877

以下 iCalendar 规则*应该*有效：

```
RRULE:FREQ=MONTHLY;BYDAY=WE;BYMONTHDAY=9,10,11,12,13,14,15 
```

它应该读作“每个月的第一个星期三，在 9 号或之后”。

**编辑：**要使用，请创建一个包含重复事件的日历并将其导出到 .ics。打开 ics 文件，找到现有的`RRULE`，用这个替换它，然后将 ics 导入到 Outlook 中。

# gwt - 支持排序、滚动和过滤的 GWT Table

> ID：161686
> 
> 赞同：12
> 
> 时间：2008-10-02T10:34:42.760
> 
> 标签：gwt, gwt-2.2-celltable

我有一个使用 GWT 的项目，它在表格中显示数据。

我需要一个支持 GWT 的表：

*   按特定列排序
*   滚动数据，而标题是不动的
*   过滤表中搜索数据的行

该项目是为公司的内部目的而创建的，因此我寻找一种不需要商业许可即可用于此类用途的解决方案。

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2011-02-17T14:39:25.247

标准[CellTable](http://code.google.com/intl/hu-HU/webtoolkit/doc/latest/DevGuideUiCellWidgets.html#celltable)支持排序。（希望很快会有更多功能。）

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-02T10:58:33.467

这是一个支持排序和过滤的表格：[http ://code.google.com/p/gwt-advanced-table/](http://code.google.com/p/gwt-advanced-table/)

谷歌自己也在努力。在支持多列排序和固定标题但不幸的是没有过滤的孵化器中查看此示例：[http ://code.google.com/p/google-web-toolkit-incubator/wiki/ScrollTable](http://code.google.com/p/google-web-toolkit-incubator/wiki/ScrollTable)

孵化器中的其他表格和表格可在此地址获得：[http ://code.google.com/docreader/#p=google-web-toolkit-incubator&s=google-web-toolkit-incubator&t=Tables](http://code.google.com/docreader/#p=google-web-toolkit-incubator&s=google-web-toolkit-incubator&t=Tables)

Ext GWT 提出了一个非常好的表，但它不是免费的（在你的情况下）：[http ://extjs.com/products/gxt/](http://extjs.com/products/gxt/)

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-02T18:00:36.417

还有[EXT GWT](http://extjs.com/products/gxt/)（不要与 GWT EXT 混淆），完全用 Java 构建。不过，您可能需要为许可证付费。如果应用程序是内部使用，我不知道您是否需要付费。

Grid 小部件将完全符合您的要求。

他们的其他小部件也令人印象深刻。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2012-06-10T20:29:00.720

只是为了保持最新：CellTable 现在支持分页和单列排序：[https ://developers.google.com/web-toolkit/doc/latest/DevGuideUiCellTable?hl=de](https://developers.google.com/web-toolkit/doc/latest/DevGuideUiCellTable?hl=de)

您可能希望调整后端请求以进行过滤，因为这通常性能更高。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T11:56:35.307

[GWT Ext](http://code.google.com/p/gwt-ext/)提供了一个满足这些要求的表。

它为 Ext javascript 库提供了一个包装器，因此最好只使用 GWT Ext 小部件或 GWT 小部件。它们可以组合，但有时不能很好地相互配合。

# perl - Perl 挑战 - 目录迭代器

> ID：161687
> 
> 赞同：5
> 
> 时间：2008-10-02T10:34:44.133
> 
> 标签：perl, code-analysis

你有时会听到关于 Perl 的说法，可能有 6 种不同的方法来解决同一个问题。优秀的 Perl 开发人员通常对在各种可能的实现方法之间做出选择有充分的洞察力。

所以一个例子 Perl 问题：

一个简单的脚本，它递归地遍历目录结构，查找最近修改的文件（在某个日期之后，这将是可变的）。将结果保存到文件中。

Perl 开发人员的问题是：您最好的方法是什么？

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2008-10-02T14:02:54.130

这听起来像是[File::Find::Rule](http://search.cpan.org/perldoc?File::Find::Rule)的工作：

```
#!/usr/bin/perl
use strict;
use warnings;
use autodie;  # Causes built-ins like open to succeed or die.
              # You can 'use Fatal qw(open)' if autodie is not installed.

use File::Find::Rule;
use Getopt::Std;

use constant SECONDS_IN_DAY => 24 * 60 * 60;

our %option = (
    m => 1,        # -m switch: days ago modified, defaults to 1
    o => undef,    # -o switch: output file, defaults to STDOUT
);

getopts('m:o:', \%option);

# If we haven't been given directories to search, default to the
# current working directory.

if (not @ARGV) {
    @ARGV = ( '.' );
}

print STDERR "Finding files changed in the last $option{m} day(s)\n";

# Convert our time in days into a timestamp in seconds from the epoch.
my $last_modified_timestamp = time() - SECONDS_IN_DAY * $option{m};

# Now find all the regular files, which have been modified in the last
# $option{m} days, looking in all the locations specified in
# @ARGV (our remaining command line arguments).

my @files = File::Find::Rule->file()
                            ->mtime(">= $last_modified_timestamp")
                            ->in(@ARGV);

# $out_fh will store the filehandle where we send the file list.
# It defaults to STDOUT.

my $out_fh = \*STDOUT;

if ($option{o}) {
    open($out_fh, '>', $option{o});
}

# Print our results.

print {$out_fh} join("\n", @files), "\n"; 
```

* * *

## 回答 #2

> 赞同：15
> 
> 时间：2008-10-02T11:07:23.133

在主要通过标准库解决问题的地方使用它们。

File::Find 在这种情况下工作得很好。

在 perl 中可能有很多方法可以做某事，但是如果存在一个非常标准的库来做某事，则应该使用它，除非它有自己的问题。

```
#!/usr/bin/perl

use strict;
use File::Find();

File::Find::find( {wanted => \&wanted}, ".");

sub wanted {
  my (@stat);
  my ($time) = time();
  my ($days) = 5 * 60 * 60 * 24;

  @stat = stat($_);
  if (($time - $stat[9]) >= $days) {
    print "$_ \n";
  }
} 
```

* * *

## 回答 #3

> 赞同：9
> 
> 时间：2008-10-02T14:14:27.303

没有六种方法可以做到这一点，有旧方法和新方法。旧的方法是使用 File::Find，你已经有几个例子了。File::Find 有一个非常糟糕的回调接口，20 年前它很酷，但从那时起我们就继续前进了。

这是一个真实的（稍微修改过的）程序，我用它来清除我的一个生产服务器上的垃圾。它使用 File::Find::Rule，而不是 File::Find。File::Find::Rule 有一个很好的声明式接口，易于阅读。

Randal Schwartz 还编写了 File::Finder，作为 File::Find 的包装器。它非常好，但它并没有真正起飞。

```
#! /usr/bin/perl -w

# delete temp files on agr1

use strict;
use File::Find::Rule;
use File::Path 'rmtree';

for my $file (

    File::Find::Rule->new
        ->mtime( '<' . days_ago(2) )
        ->name( qr/^CGItemp\d+$/ )
        ->file()
        ->in('/tmp'),

    File::Find::Rule->new
        ->mtime( '<' . days_ago(20) )
        ->name( qr/^listener-\d{4}-\d{2}-\d{2}-\d{4}.log$/ )
        ->file()
        ->maxdepth(1)
        ->in('/usr/oracle/ora81/network/log'),

    File::Find::Rule->new
        ->mtime( '<' . days_ago(10) )
        ->name( qr/^batch[_-]\d{8}-\d{4}\.run\.txt$/ )
        ->file()
        ->maxdepth(1)
        ->in('/var/log/req'),

    File::Find::Rule->new
        ->mtime( '<' . days_ago(20) )
        ->or(
            File::Find::Rule->name( qr/^remove-\d{8}-\d{6}\.txt$/ ),
            File::Find::Rule->name( qr/^insert-tp-\d{8}-\d{4}\.log$/ ),
        )
        ->file()
        ->maxdepth(1)
        ->in('/home/agdata/import/logs'),

    File::Find::Rule->new
        ->mtime( '<' . days_ago(90) )
        ->or(
            File::Find::Rule->name( qr/^\d{8}-\d{6}\.txt$/ ),
            File::Find::Rule->name( qr/^\d{8}-\d{4}\.report\.txt$/ ),
        )
        ->file()
        ->maxdepth(1)
        ->in('/home/agdata/redo/log'),

) {
    if (unlink $file) {
        print "ok $file\n";
    }
    else {
        print "fail $file: $!\n";
    }
}

{
    my $now;
    sub days_ago {
        # days as number of seconds
        $now ||= time;
        return $now - (86400 * shift);
    }
} 
```

* * *

## 回答 #4

> 赞同：8
> 
> 时间：2008-10-02T11:02:43.597

[File::Find](http://search.cpan.org/~rgarcia/perl-5.10.0/lib/File/Find.pm)是解决这个问题的正确方法。重新实现其他模块中已经存在的东西是没有用的，但是应该不鼓励重新实现标准模块中的东西。

* * *

## 回答 #5

> 赞同：8
> 
> 时间：2008-10-02T14:56:52.160

其他人提到了 File::Find，这是我要走的路，但你要求一个迭代器，File::Find 不是（File::Find::Rule 也不是）。您可能想查看[File::Next](http://search.cpan.org/dist/File-Next/)或[File::Find::Object](http://search.cpan.org/dist/File-Find-Object/)，它们确实具有迭代接口。Mark Jason Dominus 在[Higher Order Perl](http://hop.perl.plover.com/book/)的第 4.2.2 章中详细介绍了构建您自己的内容。

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2008-10-02T11:03:52.597

我的首选方法是这样使用 File::Find 模块：

```
use File::Find;
find (\&checkFile, $directory_to_check_recursively);

sub checkFile()
{
   #examine each file in here. Filename is in $_ and you are chdired into it's directory
   #directory is also available in $File::Find::dir
} 
```

* * *

## 回答 #7

> 赞同：4
> 
> 时间：2008-10-05T06:24:17.537

如前所述，有我的[File::Finder ，但也有来自](http://search.cpan.org/perldoc/File::Finder)[Find Files Incrementally (Linux Magazine)](http://www.stonehenge.com/merlyn/LinuxMag/col30.html)的 iterator-as-a-tied-hash 解决方案。

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2008-10-02T22:42:50.543

我将[File::Find::Closures](http://search.cpan.org/dist/File-Find-Closures)写成一组可以与 File::Find 一起使用的闭包，因此您不必自己编写。有几个 mtime 函数应该处理

```
使用文件::查找；
使用 File::Find::Closures qw(:all);

我的（$wanted，$list_reporter）=find_by_modified_after（时间 - 86400）；
#my( $wanted, $list_reporter ) = find_by_modified_before( 时间 - 86400 );

File::Find::find( $wanted, @directories );

我的@modified = $list_reporter->();

```

您实际上并不需要使用该模块，因为我主要将其设计为一种您可以查看代码并窃取您想要的部分的方式。在这种情况下，它有点棘手，因为处理 stat 的所有子例程都依赖于第二个子例程。不过，您会很快从代码中获得灵感。

祝你好运，

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2011-01-07T01:19:37.413

使用标准模块确实是一个好主意，但出于兴趣，我回到了不使用外部模块的基本方法。我知道这里的代码语法可能不是每个人都喜欢的。

可以通过提供迭代器访问来改进使用更少的内存（输入列表在达到一定大小后可能会暂时暂停），并且可以通过回调 ref 扩展条件检查。

```
sub mfind {
    my %done;

    sub find {
        my $last_mod = shift;
        my $path = shift;

        #determine physical link if symlink
        $path = readlink($path) || $path;        

        #return if already processed
        return if $done{$path} > 1;

        #mark path as processed
        $done{$path}++;

        #DFS recursion 
        return grep{$_} @_
               ? ( find($last_mod, $path), find($last_mod, @_) ) 
                : -d $path
                   ? find($last_mod, glob("$path/*") )
                       : -f $path && (stat($path))[9] >= $last_mod 
                           ? $path : undef;
    }

    return find(@_);
}

print join "\n", mfind(time - 1 * 86400, "some path"); 
```

* * *

## 回答 #10

> 赞同：-1
> 
> 时间：2008-10-02T10:55:37.403

我编写了一个子程序，它用 读取目录`readdir`，抛出“。” 和“..”目录，如果它找到一个新目录，则递归，并检查我正在寻找的文件（在你的情况下，你会想要使用`utime`or `stat`）。到递归完成时，应该已经检查了每个文件。

我认为此脚本所需的所有功能都在这里简要描述： [http ://www.cs.cf.ac.uk/Dave/PERL/node70.html](http://www.cs.cf.ac.uk/Dave/PERL/node70.html)

输入和输出的语义是一个相当简单的练习，我将留给你。

* * *

## 回答 #11

> 赞同：-2
> 
> 时间：2008-10-02T10:57:42.453

我冒着被否决的风险，但恕我直言，“ls”（带有适当的参数）命令以一种最知名的高性能方式进行。在这种情况下，通过 shell 将 perl 代码中的“ls”通过管道传输，将结果返回到数组或散列，这可能是一个很好的解决方案。

编辑：也可以“查找”使用，如评论中所建议的那样。

# ajax - 用于 Web 开发的最佳 Linux 发行版？

> ID：161697
> 
> 赞同：6
> 
> 时间：2008-10-02T10:37:06.357
> 
> 标签：ajax, linux

我想开始使用 Linux 发行版学习 HTML 和 AJAX。

任何人都可以推荐具有以下要求的发行版：

*   本地主机管理界面（如 PHPmyAdmin）
*   用于 Javascript 的 IDE... 等

* * *

## 回答 #1

> 赞同：17
> 
> 时间：2008-10-02T10:43:47.980

Web 开发没有真正的最佳发行版。您需要的所有工具都可以在任何 Linux 发行版上运行。

选择你有经验的东西。如果您没有任何经验，我建议您使用“用户友好”的发行版之一，例如 Ubuntu 或 SuSe。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-02T11:30:53.327

第一个问题 - 为什么要在 Linux 上执行此操作？您可以从任何平台执行基本的 AJAX 请求，只需放入您选择的 JavaScript 框架（[JQuery](http://jquery.com/)、[Prototype](http://www.prototypejs.org/)甚至[MooTools](http://mootools.net/)，您就可以在现有的开发平台上启动并运行。

熟悉一个体面的编辑器，它会为您提供基本的语法着色。您可能想要查看的一个工具是基于 Eclipse的[Aptana Web 开发 IDE。](http://aptana.com/)这将使您能够编写和调试您所做的任何 AJAX 工作，并为您提供一些文档和访问其他动态语言（如 PHP、Rails、Python 以及基本的 HTML 编辑器）的权限。

这应该足以让你远离你想要做的事情。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-02T10:43:13.003

我刚刚设置了我的第一个 linux 主机来做同样的事情。我环顾四周，被文章和朋友推荐使用 Ubuntu。所以我做到了，一切都很好。

我正在使用[slicehost](http://slicehost.com/)他们有很多教程可以帮助您学习。

[http://articles.slicehost.com/ubuntu-gutsy](http://articles.slicehost.com/ubuntu-gutsy)

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-02T10:43:53.783

我想不出有很多发行版不能满足您的需求。我建议有一个好的包管理器，并且在你的硬件上运行良好。对于所有主要发行版，您的要求将有很多选择。

你目前正在使用什么？

安德鲁

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T11:07:51.057

Ubuntu 应该可以完成这项工作，但您可能会考虑使用更面向服务器的发行版。在我的商店中，我们使用 CentOS 5，它更像是一个面向企业的发行版。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2009-03-28T20:59:35.050

它存在专门的发行版：

对我来说最好的一个：Noys

[http://www.noysweb.net/](http://www.noysweb.net/)

另一个是 Excelixis：

[http://excelixis.wordpress.com/excelixis/](http://excelixis.wordpress.com/excelixis/)

干杯

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T10:47:08.907

HTML 和 AJAx 不需要在任何特定的发行版上，Ubuntu 可以很容易地安装所有必需的功能。我个人喜欢fedora。

尝试[http://www.eclipse.org/webtools](http://www.eclipse.org/webtools)和[http://www.zend.com/phpide](http://www.zend.com/phpide)虽然 screem [http://www.screem.org/](http://www.screem.org/)如果它是纯粹的 html、javascript 和css

# maven-2 - 如何加快我的 maven2 构建速度？

> ID：161698
> 
> 赞同：35
> 
> 时间：2008-10-02T10:37:23.907
> 
> 标签：maven-2

我正在使用本地工件来代理请求，但构建和测试阶段仍然有点慢。慢的不是实际的编译和测试，而是 maven2 框架的“热身”。有任何想法吗？

* * *

## 回答 #1

> 赞同：24
> 
> 时间：2009-02-19T09:15:12.210

有一些可能性可以优化一些构建任务。例如，“清理”任务可以使用简单的技巧从几分钟优化到几毫秒——重命名“目标”文件夹而不是删除。

要获取详细信息，请参阅[加速 Maven 构建](http://bosy.dailydev.org/2009/02/speed-up-your-maven-build-four-times.html)。

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2008-10-02T10:42:30.837

我不知道您使用的是哪个版本的 Maven，我假设是 2，但我会给出我用于 Maven 1.x 的内容以加快速度并使构建速度更快。

这些会将junit测试分叉到一个新进程中（当您在测试等中使用环境变量时也会有所帮助，并为测试提供更多内存。

```
-Dmaven.junit.fork=true
-Dmaven.junit.jvmargs=-Xmx512m 
```

这会分叉编译，这可能会为您加快速度

```
-Dmaven.compile.fork=true 
```

我希望这可以帮助一点，试试看。

另请参阅[get more speed with your maven2 build](http://www.waltercedric.com/index.php?option=com_content&view=article&id=1360&catid=129:maven-build-system&Itemid=332)。

* * *

## 回答 #3

> 赞同：9
> 
> 时间：2015-07-15T09:56:34.957

如果您使用的是 Maven3 ( `$ mvn -version`)，您也可以按照本[指南](https://cwiki.apache.org/confluence/display/MAVEN/Parallel+builds+in+Maven+3)进行操作。就我而言，结果是：

正常执行：

```
$ mvn clean install 
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 03:05 min
[INFO] Finished at: 2015-07-15T11:47:02+02:00
[INFO] Final Memory: 88M/384M 
```

使用并行处理（4 个线程）：

```
$ mvn -T 4 clean install
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 02:22 min (Wall Clock)
[INFO] Finished at: 2015-07-15T11:50:57+02:00
[INFO] Final Memory: 80M/533M 
```

并行处理（每个核心 2 个线程）

```
$ mvn -T 2C clean install

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 02:12 min (Wall Clock)
[INFO] Finished at: 2015-07-15T12:00:29+02:00
[INFO] Final Memory: 87M/519M
[INFO] ------------------------------------------------------------------------ 
```

正如我们所看到的，差异几乎是一分钟，速度提高了近 20-30%。

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2013-09-20T08:10:42.227

1.  将内存配置调整为最佳，例如：将此行添加到 mvn.bat set MAVEN_OPTS=-Xmx512m -XX:MaxPermSize=256m

2.  mvn 的清理阶段通常会删除目标文件夹。相反，如果我们重命名目标文件夹，清理阶段会快得多。< [quickClean](http://bosy.dailydev.org/2009/02/speed-up-your-maven-build-four-times.html) >

3.  -Dmaven.test.skip=true 将跳过测试执行。

4.  将 -Denforcer.skip=true 添加到 mvn 命令行参数（这是强制执行 maven、jdk 等版本，我们可以在初始运行后跳过它）

5.  在构建阶段禁用非关键操作：分析、javadoc 生成、源打包。这将节省大量时间。

6.  Spawnig 新进程还有助于及时改进 -Dmaven.junit.fork=true（将 junit 测试分叉到新进程中） -Dmaven.compile.fork=true（分叉编译）

    希望能帮助到你。

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2011-12-28T20:41:42.023

您可以使用`-DskipTests=true`跳过单元测试。这将加快构建

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2008-10-02T15:25:01.173

我发现解析反应器项目比单 pom 项目慢得多。如果您的构建是反应器（多模块）并且您的开发人员没有同时处理所有模块，您可以删除父 POM 并单独构建它们，使用本地 repo 解决依赖关系。缺点是您需要安装或部署模块才能使其依赖项看到更改。

此外，您可能想查看新的 Maven 2.1 M1，其中包含一些显着的速度改进。

如果这些都没有帮助，请发布有关您的项目配置（模块结构和插件）、命令行参数和硬件配置（内存和磁盘）的更多详细信息。使用 -X 运行 Maven 也可能显示它在哪里花费时间。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2009-02-19T19:11:46.253

我会使用本地安装的 Nexus。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2016-05-09T08:49:22.090

最初，您应该使用类似的方法对构建时间进行更精细的分析，[并](https://github.com/timgifford/maven-buildtime-extension)确定花费最多时间的候选者。

测试是否会在每个测试中启动 H2 数据库？下载外部jar文件是否需要时间？这将指导您将调查重点放在哪里。仅仅应用 go-fast 标志通常不起作用，因为默认情况下它们已经包含在内，并且您不希望用跳过标志来牺牲您的测试。

# generics - 在服务组件上使用通用列表

> ID：161704
> 
> 赞同：0
> 
> 时间：2008-10-02T10:40:34.227
> 
> 标签：generics, com, list

我正在尝试将通用列表用作`ServicedComponent`类的属性...

```
public class MyCOM : ServicedComponent {
    public enum MyEnumType {
        Value1, Value2, Value3
    }
    public List<MyEnumType> MyList { private set; get; }
    public MyCOM()
    {
        MyList = new List<MyEnumType>();
    }
} 
```

代码编译没有错误，但是当我尝试使用`MyList`来自不同类的 com 对象上的属性时，没有值被添加到列表中。谷歌“告诉我”我不能在组件上使用泛型，但我还没有找到一个很好的解释为什么会这样以及一个很好的解决问题的方法。

有人可以帮我吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T11:03:09.913

来自 MSDN：

> [使用泛型类型进行互操作](http://msdn.microsoft.com/en-us/library/ms229590.aspx)
> 
> COM 模型不支持泛型类型的概念。因此，泛型类型不能直接用于 COM 互操作。

不支持泛型的答案很简单，泛型是在运行时构造的类型，因此对于 COM 可以引用的构造类型没有静态接口声明。在您的情况下， List< MyEnumType > 在 CLR 构造它之前不作为类型存在，因此 COM 不能使用标识符 (GUID) 来引用它。

这就是解决方法的来源，如果您的泛型类型实现了非泛型接口，那么它们可以用于使用非泛型接口的 com 互操作。

# caching - 经典asp中应用程序对象的大小限制是多少？

> ID：161712
> 
> 赞同：3
> 
> 时间：2008-10-02T10:42:40.120
> 
> 标签：caching, asp-classic, vbscript

我正在创建一个使用应用程序对象来存储页面的 ASP 脚本。我心中的问题是这个对象是否有大小限制。有人知道吗？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T11:43:48.910

应用程序池可以指定工作进程可以分配的最大虚拟内存大小。此设置将影响应用程序对象可以容纳的最大数据大小。

如果未指定此设置（或大于 2GB），则另一个因素将是进程是否在 32 位模式下运行。如果是这样，那么无论服务器上有多少内存，您只能期望在应用程序对象中获得最多 1.5GB（如果有的话）。

在将工作进程作为 64 位进程运行的 64 位服务器上，它将能够消耗尽可能多的 RAM 和页面文件。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T10:50:32.020

我很确定没有明确的限制 - 但当然在某些时候你会用完太多的内存，你会看到其他影响 - 例如，你的应用程序被回收，因为它超过了它的内存限制，或者你的应用程序研磨到当服务器内存不足时停止。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T11:31:17.770

我很确定限制实际上是托管服务器的 RAM。如果您有大量页面，则对不常访问的页面使用数据库或文件可能会有所帮助，但我从未见过任何具有硬限制的特定问题。

# sql-server - 如何远程启动/停止 SQLServer 服务以启动现有连接？

> ID：161715
> 
> 赞同：2
> 
> 时间：2008-10-02T10:43:40.383
> 
> 标签：sql-server, winapi

我知道已经有一个关于这个的[问题](https://stackoverflow.com/questions/133883/stop-and-start-a-service-via-batch-or-cmd-file)，但我的问题更面向远程场景。

使用*net start/stop*，您可以指定*/y*参数以使用户退出当前会话，但您不能远程启动/停止。

使用*sc*您可以远程启动/停止，但如果正在使用 SQLServer 实例，它不会让您停止服务（带有“[SC] ControlService FAILED 1051：停止控制已发送到其他正在运行的服务的服务依赖于。”消息）

所以我的问题是：踢出远程停止 SqlServer 服务的用户的最佳方法是什么？

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2008-10-02T11:40:01.493

我认为 /y 只是对“你确定吗？”回答“是”。迅速的。我认为 sc 也可以使用，尽管如果有很多飞行中的交易，它可能会超时等待服务停止。它有没有告诉你为什么它不能停止的细节？

这是停止远程 SQL 实例的其他几种方法。除了 SHUTDOWN WITH NOWAIT，我会推荐其中任何一个。

*   [psexec](http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx)将让您远程运行 net stop。
*   还有[SQL SHUTDOWN](http://msdn.microsoft.com/en-us/library/ms188767.aspx)命令 - 您可以发出 WITH NOWAIT 以避免等待当前事务完成和检查点，这将使关闭更快（但随后的启动速度更慢，并可能导致数据丢失）。
*   或者，您可以使用[Configuration Manager](http://msdn.microsoft.com/en-us/library/ms187071.aspx)或[Management Studio](http://msdn.microsoft.com/en-us/library/ms190681.aspx)来停止远程实例。

编辑：这个错误[很容易解释](http://www.microsoft.com/technet/prodtechnol/windows2000serv/reskit/w2000Msgs/3301.mspx?mfr=true)。这意味着您必须首先停止依赖服务。Sql Agent 可能至少是其中之一。检查 Admin Tools->Services 会告诉你剩下的。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2015-04-23T13:26:50.293

使用 SSMS 是最好的方法，确保您有适当的权限来关闭并检查复制状态和始终开启和日志传送。

# javascript - 在 jQuery 中添加和删除内容

> ID：161717
> 
> 赞同：2
> 
> 时间：2008-10-02T10:43:48.087
> 
> 标签：javascript, jquery

如果我使用 jQuery 创建一个添加空 div 的函数，在 div 创建的空白空间内执行一些动画，然后删除 div，浏览器永远不会为空 div 腾出空间（设置了高度和宽度）。

如果我不删除函数中的空 div，那么浏览器将创建所需的空间并且一切正常。但是，我真的需要在动画完成时删除 div 创建的空白空间。

有没有办法将 div 移除排队，以便浏览器显示所需的行为？

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-11-05T00:03:55.190

一些 jQuery 效果有回调，会在效果之后运行，例如：

```
$('#someDiv').slideDown(100, function() { 
    $(this).remove(); 
}); 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T11:29:49.727

通过在 jQuery 和 setTimeout 上进行 Google 搜索，我找到了一个让我走上不同轨道的示例。我认为问题出现了，因为 div 操作位于与实际动画不同的选择器上。即使动画仍在发生，这也会导致创建和删除 div。通过在 div 中添加一个简单的动画语句，将删除延迟到主动画完成后，我可以达到预期的效果。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T23:56:19.913

问题是在你的函数结束之前 DOM 不会更新。所以使用 setTimeout 会导致 dom 更新，100 毫秒后你的函数的其余部分可以继续。如果您不想看到新的 div，我会将位置设置为绝对位置，将顶部设置为 -5000 之类的值。它会有尺寸等，只是不可见。您还可以将可见性（在 css 中）设置为隐藏，以防您担心它会出现在屏幕上。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T10:48:31.383

如果您使用 setTimeout 是否有效？-)

# asp.net - 要监视的最佳 ASP.NET 性能计数器是什么？

> ID：161737
> 
> 赞同：28
> 
> 时间：2008-10-02T10:51:36.493
> 
> 标签：asp.net, testing, performancecounter

ASP.NET 的 perfmon 中有大量可用的计数器。什么是最好的（我正在考虑选择 5-10），这将是我们测试环境中最好的监控，以便我们可以反馈给开发人员。

我正在考虑请求时间、请求队列长度、活动会话等。

* * *

## 回答 #1

> 赞同：21
> 
> 时间：2008-10-02T11:52:49.123

对于正常（不是性能/压力测试），您可以使用以下内容：

*   Request Bytes Out Total *（非常重要，尤其是对于 Web（不是 Intranet）应用程序）*
*   请求失败
*   请求/秒
*   执行期间的错误
*   执行期间未处理的错误
*   会话 SQL Server 连接总数
*   状态服务器会话活动

对于性能测试，您可能需要以下内容：

*   % CPU Utilization *（确保您正在检查非常低的 CPU 利用率以及它可能表明某些东西已经死了）*
*   排队的请求
*   输出缓存命中

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2008-10-02T11:52:52.167

我使用最多的是内存计数器。他们都是。我知道它们并非特定于 ASP.NET，但我在使用 Web 应用程序时遇到的唯一问题是内存问题。

过多的堆、第 2 代收集和 GC 中的 % 时间是最重要的。如果您在 GC 中的时间逐渐失控，则表明您的 UI 和视图状态太大了。大堆和大量 gen 2 集合表明您在内存中保留了太多东西（例如，inproc 会话状态）。

Regular ASP.NET apps based on web controls require lots of objects being created and then destroyed quickly, as a page is reconstructed and then disposed. High gen0 collections isn't bad. Its when you start seeing lots of objects make it into gen1 and then gen2 that suggests you're either leaking memory or are holding onto too much state.

* * *

## 回答 #3

> 赞同：3
> 
> 时间：2009-02-27T21:21:24.020

Be aware of memory counters when running more than one ASP.NET Application Pool check out the problem at [http://blog.dynatrace.com/2009/02/27/can-you-trust-your-net-heap-performance-counters/](http://blog.dynatrace.com/2009/02/27/can-you-trust-your-net-heap-performance-counters/)

# regex - 检查字符串是否为有效 URL 的最佳正则表达式是什么？

> ID：161738
> 
> 赞同：940
> 
> 时间：2008-10-02T10:53:17.550
> 
> 标签：regex, url, language-agnostic

如何检查给定的字符串是否是有效的 URL 地址？

我对正则表达式的了解是基础知识，无法从我已经在网上看到的数百个正则表达式中进行选择。

* * *

## 回答 #1

> 赞同：444
> 
> 时间：2008-10-10T07:23:01.503

我编写了符合 RFC 3987 ( [http://www.faqs.org/rfcs/rfc3987.html](http://www.faqs.org/rfcs/rfc3987.html) ) 的 URL（实际上是 IRI，国际化）模式。这些是 PCRE 语法。

对于绝对 IRI（国际化）：

```
/^[a-z](?:[-a-z0-9\+\.])*:(?:\/\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:])*@)?(?:\[(?:(?:(?:[0-9a-f]{1,4}:){6}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|::(?:[0-9a-f]{1,4}:){5}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[-a-z0-9\._~!\$&'\(\)\*\+,;=:]+)\]|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}|(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=])*)(?::[0-9]*)?(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*|\/(?:(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*)?|(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*|(?!(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])))(?:\?(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])|[\x{E000}-\x{F8FF}\x{F0000}-\x{FFFFD}\x{100000}-\x{10FFFD}\/\?])*)?(?:\#(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])|[\/\?])*)?$/i 
```

还允许相对 IRI：

```
/^(?:[a-z](?:[-a-z0-9\+\.])*:(?:\/\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:])*@)?(?:\[(?:(?:(?:[0-9a-f]{1,4}:){6}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|::(?:[0-9a-f]{1,4}:){5}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[-a-z0-9\._~!\$&'\(\)\*\+,;=:]+)\]|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}|(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=])*)(?::[0-9]*)?(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*|\/(?:(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*)?|(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*|(?!(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])))(?:\?(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])|[\x{E000}-\x{F8FF}\x{F0000}-\x{FFFFD}\x{100000}-\x{10FFFD}\/\?])*)?(?:\#(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])|[\/\?])*)?|(?:\/\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:])*@)?(?:\[(?:(?:(?:[0-9a-f]{1,4}:){6}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|::(?:[0-9a-f]{1,4}:){5}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[-a-z0-9\._~!\$&'\(\)\*\+,;=:]+)\]|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}|(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=])*)(?::[0-9]*)?(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*|\/(?:(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*)?|(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=@])+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*|(?!(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])))(?:\?(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])|[\x{E000}-\x{F8FF}\x{F0000}-\x{FFFFD}\x{100000}-\x{10FFFD}\/\?])*)?(?:\#(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])|[\/\?])*)?)$/i 
```

它们是如何编译的（在 PHP 中）：

```
<?php

/* Regex convenience functions (character class, non-capturing group) */
function cc($str, $suffix = '', $negate = false) {
    return '[' . ($negate ? '^' : '') . $str . ']' . $suffix;
}
function ncg($str, $suffix = '') {
    return '(?:' . $str . ')' . $suffix;
}

/* Preserved from RFC3986 */

$ALPHA = 'a-z';
$DIGIT = '0-9';
$HEXDIG = $DIGIT . 'a-f';

$sub_delims = '!\\$&\'\\(\\)\\*\\+,;=';
$gen_delims = ':\\/\\?\\#\\[\\]@';
$reserved = $gen_delims . $sub_delims;
$unreserved = '-' . $ALPHA . $DIGIT . '\\._~';

$pct_encoded = '%' . cc($HEXDIG) . cc($HEXDIG);

$dec_octet = ncg(implode('|', array(
    cc($DIGIT),
    cc('1-9') . cc($DIGIT),
    '1' . cc($DIGIT) . cc($DIGIT),
    '2' . cc('0-4') . cc($DIGIT),
    '25' . cc('0-5')
)));

$IPv4address = $dec_octet . ncg('\\.' . $dec_octet, '{3}');

$h16 = cc($HEXDIG, '{1,4}');
$ls32 = ncg($h16 . ':' . $h16 . '|' . $IPv4address);

$IPv6address = ncg(implode('|', array(
    ncg($h16 . ':', '{6}') . $ls32,
    '::' . ncg($h16 . ':', '{5}') . $ls32,
    ncg($h16, '?') . '::' . ncg($h16 . ':', '{4}') . $ls32,
    ncg($h16 . ':' . $h16, '?') . '::' . ncg($h16 . ':', '{3}') . $ls32,
    ncg(ncg($h16 . ':', '{0,2}') . $h16, '?') . '::' . ncg($h16 . ':', '{2}') . $ls32,
    ncg(ncg($h16 . ':', '{0,3}') . $h16, '?') . '::' . $h16 . ':' . $ls32,
    ncg(ncg($h16 . ':', '{0,4}') . $h16, '?') . '::' . $ls32,
    ncg(ncg($h16 . ':', '{0,5}') . $h16, '?') . '::' . $h16,
    ncg(ncg($h16 . ':', '{0,6}') . $h16, '?') . '::',
)));

$IPvFuture = 'v' . cc($HEXDIG, '+') . cc($unreserved . $sub_delims . ':', '+');

$IP_literal = '\\[' . ncg(implode('|', array($IPv6address, $IPvFuture))) . '\\]';

$port = cc($DIGIT, '*');

$scheme = cc($ALPHA) . ncg(cc('-' . $ALPHA . $DIGIT . '\\+\\.'), '*');

/* New or changed in RFC3987 */

$iprivate = '\x{E000}-\x{F8FF}\x{F0000}-\x{FFFFD}\x{100000}-\x{10FFFD}';

$ucschar = '\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}' .
    '\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}' .
    '\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}' .
    '\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}' .
    '\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}' .
    '\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}';

$iunreserved = '-' . $ALPHA . $DIGIT . '\\._~' . $ucschar;

$ipchar = ncg($pct_encoded . '|' . cc($iunreserved . $sub_delims . ':@'));

$ifragment = ncg($ipchar . '|' . cc('\\/\\?'), '*');

$iquery = ncg($ipchar . '|' . cc($iprivate . '\\/\\?'), '*');

$isegment_nz_nc = ncg($pct_encoded . '|' . cc($iunreserved . $sub_delims . '@'), '+');
$isegment_nz = ncg($ipchar, '+');
$isegment = ncg($ipchar, '*');

$ipath_empty = '(?!' . $ipchar . ')';
$ipath_rootless = ncg($isegment_nz) . ncg('\\/' . $isegment, '*');
$ipath_noscheme = ncg($isegment_nz_nc) . ncg('\\/' . $isegment, '*');
$ipath_absolute = '\\/' . ncg($ipath_rootless, '?'); // Spec says isegment-nz *( "/" isegment )
$ipath_abempty = ncg('\\/' . $isegment, '*');

$ipath = ncg(implode('|', array(
    $ipath_abempty,
    $ipath_absolute,
    $ipath_noscheme,
    $ipath_rootless,
    $ipath_empty
))) . ')';

$ireg_name = ncg($pct_encoded . '|' . cc($iunreserved . $sub_delims . '@'), '*');

$ihost = ncg(implode('|', array($IP_literal, $IPv4address, $ireg_name)));
$iuserinfo = ncg($pct_encoded . '|' . cc($iunreserved . $sub_delims . ':'), '*');
$iauthority = ncg($iuserinfo . '@', '?') . $ihost . ncg(':' . $port, '?');

$irelative_part = ncg(implode('|', array(
    '\\/\\/' . $iauthority . $ipath_abempty . '',
    '' . $ipath_absolute . '',
    '' . $ipath_noscheme . '',
    '' . $ipath_empty . ''
)));

$irelative_ref = $irelative_part . ncg('\\?' . $iquery, '?') . ncg('\\#' . $ifragment, '?');

$ihier_part = ncg(implode('|', array(
    '\\/\\/' . $iauthority . $ipath_abempty . '',
    '' . $ipath_absolute . '',
    '' . $ipath_rootless . '',
    '' . $ipath_empty . ''
)));

$absolute_IRI = $scheme . ':' . $ihier_part . ncg('\\?' . $iquery, '?');

$IRI = $scheme . ':' . $ihier_part . ncg('\\?' . $iquery, '?') . ncg('\\#' . $ifragment, '?');

$IRI_reference = ncg($IRI . '|' . $irelative_ref); 
```

2011 年 3 月 7 日编辑：由于 PHP 处理带引号的字符串中的反斜杠的方式，默认情况下这些是不可用的。您需要对反斜杠进行双重转义，除非反斜杠在正则表达式中具有特殊含义。你可以这样做：

```
$escape_backslash = '/(?<!\\)\\(?![\[\]\\\^\$\.\|\*\+\(\)QEnrtaefvdwsDWSbAZzB1-9GX]|x\{[0-9a-f]{1,4}\}|\c[A-Z]|)/';
$absolute_IRI = preg_replace($escape_backslash, '\\\\', $absolute_IRI);
$IRI = preg_replace($escape_backslash, '\\\\', $IRI);
$IRI_reference = preg_replace($escape_backslash, '\\\\', $IRI_reference); 
```

* * *

## 回答 #2

> 赞同：171
> 
> 时间：2011-11-22T22:38:54.220

我刚刚写了一篇博文，为识别最常用格式的 URL 提供了一个很好的解决方案，例如：

*   `www.google.com`
*   `http://www.google.com`
*   `mailto:somebody@google.com`
*   `somebody@google.com`
*   `www.url-with-querystring.com/?url=has-querystring`

使用的正则表达式是：

```
/((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))?)/ 
```

* * *

## 回答 #3

> 赞同：84
> 
> 时间：2008-10-02T11:00:58.530

什么平台？如果使用 .NET，请使用[`System.Uri.TryCreate`](http://msdn.microsoft.com/en-us/library/system.uri.trycreate)，而不是正则表达式。

例如：

```
static bool IsValidUrl(string urlString)
{
    Uri uri;
    return Uri.TryCreate(urlString, UriKind.Absolute, out uri)
        && (uri.Scheme == Uri.UriSchemeHttp
         || uri.Scheme == Uri.UriSchemeHttps
         || uri.Scheme == Uri.UriSchemeFtp
         || uri.Scheme == Uri.UriSchemeMailto
            /*...*/);
}

// In test fixture...

[Test]
void IsValidUrl_Test()
{
    Assert.True(IsValidUrl("http://www.example.com"));
    Assert.False(IsValidUrl("javascript:alert('xss')"));
    Assert.False(IsValidUrl(""));
    Assert.False(IsValidUrl(null));
} 
```

（感谢[@Yoshi](https://stackoverflow.com/users/450141/yoshi)的提示`javascript:`）

* * *

## 回答 #4

> 赞同：65
> 
> 时间：2008-10-02T17:53:23.687

这是[RegexBuddy](http://en.wikipedia.org/wiki/RegexBuddy)使用的内容。

```
(\b(https?|ftp|file)://)?[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|] 
```

它与以下这些匹配（在`** **`标记内）：

```
**http://www.regexbuddy.com**  
**http://www.regexbuddy.com/**  
**http://www.regexbuddy.com/index.html**  
**http://www.regexbuddy.com/index.html?source=library** 
```

**[您可以在http://www.regexbuddy.com/download.html](http://www.regexbuddy.com/download.html)**下载 RegexBuddy 。

* * *

## 回答 #5

> 赞同：54
> 
> 时间：2012-02-14T21:32:43.170

Mathias Bynens 有一篇很棒的文章，介绍了许多正则表达式的最佳比较：[In search of the perfect URL validation regex](http://mathiasbynens.be/demo/url-regex)

[发布的最好](https://gist.github.com/729294)的一个有点长，但它几乎可以匹配任何你可以扔给它的东西。

### JavaScript 版本

```
/^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/i 
```

### PHP版本

```
_^(?:(?:https?|ftp)://)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\x{00a1}-\x{ffff}0-9]-*)*[a-z\x{00a1}-\x{ffff}0-9]+)(?:\.(?:[a-z\x{00a1}-\x{ffff}0-9]-*)*[a-z\x{00a1}-\x{ffff}0-9]+)*(?:\.(?:[a-z\x{00a1}-\x{ffff}]{2,}))\.?)(?::\d{2,5})?(?:[/?#]\S*)?$_iuS 
```

* * *

## 回答 #6

> 赞同：49
> 
> 时间：2010-01-06T19:17:40.413

关于**eyelidness**的回答帖子，上面写着“这是基于我对 URI 规范的阅读。”：谢谢 Eyelidness，你的解决方案是我寻求的完美解决方案，因为它基于 URI 规范！精湛的工作。:)

我不得不做两处修改。第一个使用 preg_match() 函数在 PHP (v5.2.10) 中获取正则表达式以正确匹配 IP 地址 URL。

我不得不在管道周围的“IP地址”上方的行中再添加一组括号：

```
)|((\d|[1-9]\d|1\d{2}|2[0-4][0-9]|25[0-5])\.){3}(?# 
```

不知道为什么。

我还将顶级域的最小长度从 3 个字母减少到 2 个字母，以支持 .co.uk 和类似的。

最终代码：

```
/^(https?|ftp):\/\/(?#                                      protocol
)(([a-z0-9$_\.\+!\*\'\(\),;\?&=-]|%[0-9a-f]{2})+(?#         username
)(:([a-z0-9$_\.\+!\*\'\(\),;\?&=-]|%[0-9a-f]{2})+)?(?#      password
)@)?(?#                                                     auth requires @
)((([a-z0-9]\.|[a-z0-9][a-z0-9-]*[a-z0-9]\.)*(?#             domain segments AND
)[a-z][a-z0-9-]*[a-z0-9](?#                                 top level domain  OR
)|((\d|[1-9]\d|1\d{2}|2[0-4][0-9]|25[0-5])\.){3}(?#
    )(\d|[1-9]\d|1\d{2}|2[0-4][0-9]|25[0-5])(?#             IP address
))(:\d+)?(?#                                                port
))(((\/+([a-z0-9$_\.\+!\*\'\(\),;:@&=-]|%[0-9a-f]{2})*)*(?# path
)(\?([a-z0-9$_\.\+!\*\'\(\),;:@&=-]|%[0-9a-f]{2})*)(?#      query string
)?)?)?(?#                                                   path and query string optional
)(#([a-z0-9$_\.\+!\*\'\(\),;:@&=-]|%[0-9a-f]{2})*)?(?#      fragment
)$/i 
```

这个修改后的版本没有根据 URI 规范检查，所以我不能保证它的合规性，它被修改为处理本地网络环境和两位数 TLD 以及其他类型的 Web URL 上的 URL，并在 PHP 中更好地工作我使用的设置。

作为**PHP**代码：

```
define('URL_FORMAT', 
'/^(https?):\/\/'.                                         // protocol
'(([a-z0-9$_\.\+!\*\'\(\),;\?&=-]|%[0-9a-f]{2})+'.         // username
'(:([a-z0-9$_\.\+!\*\'\(\),;\?&=-]|%[0-9a-f]{2})+)?'.      // password
'@)?(?#'.                                                  // auth requires @
')((([a-z0-9]\.|[a-z0-9][a-z0-9-]*[a-z0-9]\.)*'.                      // domain segments AND
'[a-z][a-z0-9-]*[a-z0-9]'.                                 // top level domain  OR
'|((\d|[1-9]\d|1\d{2}|2[0-4][0-9]|25[0-5])\.){3}'.
'(\d|[1-9]\d|1\d{2}|2[0-4][0-9]|25[0-5])'.                 // IP address
')(:\d+)?'.                                                // port
')(((\/+([a-z0-9$_\.\+!\*\'\(\),;:@&=-]|%[0-9a-f]{2})*)*'. // path
'(\?([a-z0-9$_\.\+!\*\'\(\),;:@&=-]|%[0-9a-f]{2})*)'.      // query string
'?)?)?'.                                                   // path and query string optional
'(#([a-z0-9$_\.\+!\*\'\(\),;:@&=-]|%[0-9a-f]{2})*)?'.      // fragment
'$/i'); 
```

这是一个使用正则表达式验证各种 URL 的 PHP 测试程序：

```
<?php

define('URL_FORMAT',
'/^(https?):\/\/'.                                         // protocol
'(([a-z0-9$_\.\+!\*\'\(\),;\?&=-]|%[0-9a-f]{2})+'.         // username
'(:([a-z0-9$_\.\+!\*\'\(\),;\?&=-]|%[0-9a-f]{2})+)?'.      // password
'@)?(?#'.                                                  // auth requires @
')((([a-z0-9]\.|[a-z0-9][a-z0-9-]*[a-z0-9]\.)*'.                      // domain segments AND
'[a-z][a-z0-9-]*[a-z0-9]'.                                 // top level domain  OR
'|((\d|[1-9]\d|1\d{2}|2[0-4][0-9]|25[0-5])\.){3}'.
'(\d|[1-9]\d|1\d{2}|2[0-4][0-9]|25[0-5])'.                 // IP address
')(:\d+)?'.                                                // port
')(((\/+([a-z0-9$_\.\+!\*\'\(\),;:@&=-]|%[0-9a-f]{2})*)*'. // path
'(\?([a-z0-9$_\.\+!\*\'\(\),;:@&=-]|%[0-9a-f]{2})*)'.      // query string
'?)?)?'.                                                   // path and query string optional
'(#([a-z0-9$_\.\+!\*\'\(\),;:@&=-]|%[0-9a-f]{2})*)?'.      // fragment
'$/i');

/**
 * Verify the syntax of the given URL. 
 * 
 * @access public
 * @param $url The URL to verify.
 * @return boolean
 */
function is_valid_url($url) {
  if (str_starts_with(strtolower($url), 'http://localhost')) {
    return true;
  }
  return preg_match(URL_FORMAT, $url);
}

/**
 * String starts with something
 * 
 * This function will return true only if input string starts with
 * niddle
 * 
 * @param string $string Input string
 * @param string $niddle Needle string
 * @return boolean
 */
function str_starts_with($string, $niddle) {
      return substr($string, 0, strlen($niddle)) == $niddle;
}

/**
 * Test a URL for validity and count results.
 * @param url url
 * @param expected expected result (true or false)
 */

$numtests = 0;
$passed = 0;

function test_url($url, $expected) {
  global $numtests, $passed;
  $numtests++;
  $valid = is_valid_url($url);
  echo "URL Valid?: " . ($valid?"yes":"no") . " for URL: $url. Expected: ".($expected?"yes":"no").". ";
  if($valid == $expected) {
    echo "PASS\n"; $passed++;
  } else {
    echo "FAIL\n";
  }
}

echo "URL Tests:\n\n";

test_url("http://localserver/projects/public/assets/javascript/widgets/UserBoxMenu/widget.css", true);
test_url("http://www.google.com", true);
test_url("http://www.google.co.uk/projects/my%20folder/test.php", true);
test_url("https://myserver.localdomain", true);
test_url("http://192.168.1.120/projects/index.php", true);
test_url("http://192.168.1.1/projects/index.php", true);
test_url("http://projectpier-server.localdomain/projects/public/assets/javascript/widgets/UserBoxMenu/widget.css", true);
test_url("https://2.4.168.19/project-pier?c=test&a=b", true);
test_url("https://localhost/a/b/c/test.php?c=controller&arg1=20&arg2=20", true);
test_url("http://user:password@localhost/a/b/c/test.php?c=controller&arg1=20&arg2=20", true);

echo "\n$passed out of $numtests tests passed.\n\n";

?> 
```

再次感谢正则表达式的**眼睑**！

* * *

## 回答 #7

> 赞同：36
> 
> 时间：2008-10-02T10:59:09.923

[获取 URL 的组成部分 (Regex)](https://stackoverflow.com/questions/27745/getting-parts-of-a-url-regex#27755)这篇文章讨论了解析 URL 以识别其各种组件。如果您想检查一个 URL 是否格式正确，它应该足以满足您的需求。

如果您需要检查它是否真的有效，您最终将不得不尝试访问另一端的任何内容。

不过，一般来说，您最好使用框架或其他库提供给您的函数。许多平台都包含解析 URL 的函数。例如，有 Python 的[urlparse](https://docs.python.org/3/library/urllib.parse.html)模块，在 .NET 中，您可以使用[System.Uri 类的构造函数](http://msdn.microsoft.com/en-us/library/aa332621.aspx)来验证 URL。

* * *

## 回答 #8

> 赞同：28
> 
> 时间：2013-09-10T16:51:55.613

**这可能不是正则表达式的工作，而是您选择的语言的现有工具。** 您可能希望使用已经编写、测试和调试过的现有代码。

在 PHP 中，使用该[`parse_url`](http://php.net/manual/en/function.parse-url.php)函数。

Perl：[`URI`模块](http://search.cpan.org/dist/URI/)。

红宝石：[`URI`模块](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/uri/rdoc/URI.html)。

.NET：[“Uri”类](http://msdn.microsoft.com/en-us/library/txt7706a.aspx)

**正则表达式不是你在碰巧涉及字符串的每个问题上挥舞的魔杖。**

* * *

## 回答 #9

> 赞同：21
> 
> 时间：2014-06-05T10:46:03.170

这将匹配所有 URL

*   有或没有*http* / *https*
*   有或没有*www*

...包括子域和那些新的顶级域名扩展，例如 . *博物馆*，。*学院*，. *Foundation* 等，最多可包含 63 个字符（不仅仅是*.com*、*.net*、*.info*等）

```
(([\w]+:)?//)?(([\d\w]|%[a-fA-f\d]{2,2})+(:([\d\w]|%[a-fA-f\d]{2,2})+)?@)?([\d\w][-\d\w]{0,253}[\d\w]\.)+[\w]{2,63}(:[\d]+)?(/([-+_~.\d\w]|%[a-fA-f\d]{2,2})*)*(\?(&?([-+_~.\d\w]|%[a-fA-f\d]{2,2})=?)*)?(#([-+_~.\d\w]|%[a-fA-f\d]{2,2})*)? 
```

因为今天可用的顶级域名扩展的最大长度是 13 个字符，例如 . *国际*，你可以将表达式中的数字 63 更改为 13 以防止有人滥用它。

作为 javascript

```
var urlreg=/(([\w]+:)?\/\/)?(([\d\w]|%[a-fA-f\d]{2,2})+(:([\d\w]|%[a-fA-f\d]{2,2})+)?@)?([\d\w][-\d\w]{0,253}[\d\w]\.)+[\w]{2,63}(:[\d]+)?(\/([-+_~.\d\w]|%[a-fA-f\d]{2,2})*)*(\?(&?([-+_~.\d\w]|%[a-fA-f\d]{2,2})=?)*)?(#([-+_~.\d\w]|%[a-fA-f\d]{2,2})*)?/;

$('textarea').on('input',function(){
  var url = $(this).val();
  $(this).toggleClass('invalid', urlreg.test(url) == false)
});

$('textarea').trigger('input');
```

```
textarea{color:green;}
.invalid{color:red;}
```

```
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<textarea>http://www.google.com</textarea>
<textarea>http//www.google.com</textarea>
<textarea>googlecom</textarea>
<textarea>https://www.google.com</textarea>
```

维基百科文章：[所有互联网顶级域名列表](http://en.wikipedia.org/wiki/List_of_Internet_top-level_domains)

* * *

## 回答 #10

> 赞同：19
> 
> 时间：2008-10-02T11:14:58.340

# 非验证 URI 引用解析器

出于参考目的，这里是 IETF 规范：( [TXT](http://www.ietf.org/rfc/rfc3986.txt) | [HTML](https://www.rfc-editor.org/rfc/rfc3986#appendix-B) )。特别是，*附录 B.使用正则表达式**解析**URI 引用*演示了如何解析**有效的正则表达式**。这被描述为，

> 一个非验证 URI 引用解析器的示例，它将采用任何给定的字符串并提取 URI 组件。

这是他们提供的正则表达式：

```
 ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))? 
```

正如其他人所说，最好将其留给您已经在使用的库/框架。

* * *

## 回答 #11

> 赞同：12
> 
> 时间：2013-07-18T04:47:04.287

The best regular expression for URL for me would be:

```
"(([\w]+:)?//)?(([\d\w]|%[a-fA-F\d]{2,2})+(:([\d\w]|%[a-fA-f\d]{2,2})+)?@)?([\d\w][-\d\w]{0,253}[\d\w]\.)+[\w]{2,4}(:[\d]+)?(/([-+_~.\d\w]|%[a-fA-f\d]{2,2})*)*(\?(&?([-+_~.\d\w]|%[a-fA-f\d]{2,2})=?)*)?(#([-+_~.\d\w]|%[a-fA-f\d]{2,2})*)?" 
```

* * *

## 回答 #12

> 赞同：11
> 
> 时间：2019-05-09T09:54:24.290

这是一个涵盖所有可能情况的好规则：端口、参数等

```
/(https?:\/\/(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9])(:?\d*)\/?([a-z_\/0-9\-#.]*)\??([a-z_\/0-9\-#=&]*)/g 
```

* * *

## 回答 #13

> 赞同：9
> 
> 时间：2012-10-25T12:57:33.617

```
 function validateURL(textval) {
            var urlregex = new RegExp(
            "^(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(\:[0-9]+)*(/($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+))*$");
            return urlregex.test(textval);
        } 
```

匹配 [http://site.com/dir/file.php?var=moo](http://site.com/dir/file.php?var=moo) | [ftp://user:pass@site.com:21/file/dir](ftp://user:pass@site.com:21/file/dir)

不匹配 site.com | [http://site.com/dir//](http://site.com/dir//)

* * *

## 回答 #14

> 赞同：8
> 
> 时间：2013-06-19T07:53:23.743

我找不到我正在寻找的正则表达式，所以我修改了一个正则表达式来满足我的要求，显然它现在似乎工作正常。我的要求是：

*   匹配无协议的 URL (www.gooogle.com)
*   将 URL 与查询参数和路径匹配 ( [http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2e](http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2e) )
*   不要匹配包含不可接受字符（例如“'£）的 URL，例如：（www.google.com/somthing”/somethingmore）

这是我想出的，任何建议表示赞赏：

```
@Test
    public void testWebsiteUrl(){
        String regularExpression = "((http|ftp|https):\\/\\/)?[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:/~\\+#]*[\\w\\-\\@?^=%&amp;/~\\+#])?";

        assertTrue("www.google.com".matches(regularExpression));
        assertTrue("www.google.co.uk".matches(regularExpression));
        assertTrue("http://www.google.com".matches(regularExpression));
        assertTrue("http://www.google.co.uk".matches(regularExpression));
        assertTrue("https://www.google.com".matches(regularExpression));
        assertTrue("https://www.google.co.uk".matches(regularExpression));
        assertTrue("google.com".matches(regularExpression));
        assertTrue("google.co.uk".matches(regularExpression));
        assertTrue("google.mu".matches(regularExpression));
        assertTrue("mes.intnet.mu".matches(regularExpression));
        assertTrue("cse.uom.ac.mu".matches(regularExpression));

        assertTrue("http://www.google.com/path".matches(regularExpression));
        assertTrue("http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2e".matches(regularExpression));
        assertTrue("http://www.google.com/?queryparam=123".matches(regularExpression));
        assertTrue("http://www.google.com/path?queryparam=123".matches(regularExpression));

        assertFalse("www..dr.google".matches(regularExpression));

        assertFalse("www:google.com".matches(regularExpression));

        assertFalse("https://www@.google.com".matches(regularExpression));

        assertFalse("https://www.google.com\"".matches(regularExpression));
        assertFalse("https://www.google.com'".matches(regularExpression));

        assertFalse("http://www.google.com/path'".matches(regularExpression));
        assertFalse("http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2e'".matches(regularExpression));
        assertFalse("http://www.google.com/?queryparam=123'".matches(regularExpression));
        assertFalse("http://www.google.com/path?queryparam=12'3".matches(regularExpression));

    } 
```

* * *

## 回答 #15

> 赞同：8
> 
> 时间：2019-04-02T06:41:18.737

```
^(http:\/\/www\.|https:\/\/www\.|http:\/\/|https:\/\/)?[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$ 
```

现场演示：[https ://regex101.com/r/HUNasA/2](https://regex101.com/r/HUNasA/2)

我已经测试了各种表达式来满足我的要求。

作为用户，我可以使用以下字符串点击浏览器搜索栏：

**有效网址**

*   [https://www.google.com](https://www.google.com)
*   [http://www.google.com](http://www.google.com)
*   [http://google.com/](http://google.com/)
*   [https://google.com/](https://google.com/)
*   www.google.com
*   google.com
*   [https://www.google.com.ua](https://www.google.com.ua)
*   [http://www.google.com.ua](http://www.google.com.ua)
*   [http://google.com.ua](http://google.com.ua)
*   [https://google.com.ua/](https://google.com.ua/)
*   www.google.com.ua
*   google.com.ua
*   [https://mail.google.com](https://mail.google.com)
*   [http://mail.google.com](http://mail.google.com)
*   mail.google.com

**无效的网址**

*   [http://谷歌](http://google)
*   [https://google.c](https://google.c)
*   谷歌
*   谷歌。
*   。谷歌
*   .google.com
*   古尔.c
*   ...

* * *

## 回答 #16

> 赞同：7
> 
> 时间：2012-10-25T12:53:26.067

```
function validateURL(textval) {
            var urlregex = new RegExp(
            "^(http|https|ftp)\://[a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\-\._\?\,\'/\\\+&amp;%\$#\=~])*$");
            return urlregex.test(textval);
        } 
```

匹配 [http://www.asdah.com/~joe](http://www.asdah.com/~joe) | [ftp://ftp.asdah.co.uk:2828/asdah%20asdah.gif](ftp://ftp.asdah.co.uk:2828/asdah%20asdah.gif) | [https://asdah.gov/asdh-ah.as](https://asdah.gov/asdh-ah.as)

* * *

## 回答 #17

> 赞同：7
> 
> 时间：2012-12-04T23:03:39.543

我写了一个你可以运行的小版本

它与以下 URL 匹配（这对我来说已经足够了）

```
public static void main(args) {
    String url = "go to http://www.m.abut.ly/abc its awesome"
    url = url.replaceAll(/https?:\/\/w{0,3}\w*?\.(\w*?\.)?\w{2,3}\S*|www\.(\w*?\.)?\w*?\.\w{2,3}\S*|(\w*?\.)?\w*?\.\w{2,3}[\/\?]\S*/ , { it ->
        "woof${it}woof"
    })
    println url 
} 
```

```
http://google.com
http://google.com/help.php
http://google.com/help.php?a=5

http://www.google.com
http://www.google.com/help.php
http://www.google.com?a=5

google.com?a=5
google.com/help.php
google.com/help.php?a=5

http://www.m.google.com/help.php?a=5 (and all its permutations)
www.m.google.com/help.php?a=5 (and all its permutations)
m.google.com/help.php?a=5 (and all its permutations) 
```

对于任何不以`http`or开头的 URL，重要的`www`是它们必须包含`/`or`?`

我敢打赌这可以再调整一点，但它的工作非常好，因为它如此短而紧凑......因为你几乎可以将它分成 3 部分：

查找以 开头的任何内容`http`：

```
https?:\/\/w{0,3}\w*?\.\w{2,3}\S* 
```

查找以 开头的任何内容`www`：

```
www\.\w*?\.\w{2,3}\S* 
```

或找到任何必须有文本然后是点然后至少有 2 个字母然后是`?`or的内容`/`：

```
\w*?\.\w{2,3}[\/\?]\S* 
```

* * *

## 回答 #18

> 赞同：7
> 
> 时间：2008-10-02T11:08:46.750

如果你真的在寻找**终极**匹配，你可能会在“ [A Good Url Regular Expression?](http://flanders.co.nz/2009/11/08/a-good-url-regular-expression-repost/) ”上找到它。

但是一个真正匹配所有可能的域并允许根据 RFC 允许的任何内容的正则表达式非常长且不可读，相信我 ;-)

* * *

## 回答 #19

> 赞同：5
> 
> 时间：2015-02-15T14:49:19.893

这是来自 Android 源代码的现成 Java 版本。这是我找到的最好的一个。

```
public static final Matcher WEB  = Pattern.compile(new StringBuilder()                 
.append("((?:(http|https|Http|Https|rtsp|Rtsp):")                      
.append("\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)")                         
.append("\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_")                         
.append("\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?")                         
.append("((?:(?:[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}\\.)+")   // named host                            
.append("(?:")   // plus top level domain                         
.append("(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])")                         
.append("|(?:biz|b[abdefghijmnorstvwyz])")                         
.append("|(?:cat|com|coop|c[acdfghiklmnoruvxyz])")                         
.append("|d[ejkmoz]")                         
.append("|(?:edu|e[cegrstu])")                         
.append("|f[ijkmor]")                         
.append("|(?:gov|g[abdefghilmnpqrstuwy])")                         
.append("|h[kmnrtu]")                         
.append("|(?:info|int|i[delmnoqrst])")                         
.append("|(?:jobs|j[emop])")                         
.append("|k[eghimnrwyz]")                         
.append("|l[abcikrstuvy]")                         
.append("|(?:mil|mobi|museum|m[acdghklmnopqrstuvwxyz])")                         
.append("|(?:name|net|n[acefgilopruz])")                         
.append("|(?:org|om)")                         
.append("|(?:pro|p[aefghklmnrstwy])")                         
.append("|qa")                         
.append("|r[eouw]")                         
.append("|s[abcdeghijklmnortuvyz]")                         
.append("|(?:tel|travel|t[cdfghjklmnoprtvwz])")                         
.append("|u[agkmsyz]")                         
.append("|v[aceginu]")                         
.append("|w[fs]")                         
.append("|y[etu]")                         
.append("|z[amw]))")                         
.append("|(?:(?:25[0-5]|2[0-4]") // or ip address                                                 
.append("[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]")                             
.append("|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]")                         
.append("[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}")                         
.append("|[1-9][0-9]|[0-9])))")                         
.append("(?:\\:\\d{1,5})?)") // plus option port number                             
.append("(\\/(?:(?:[a-zA-Z0-9\\;\\/\\?\\:\\@\\&\\=\\#\\~")  // plus option query params                         
.append("\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?")                         
.append("(?:\\b|$)").toString()                 
).matcher(""); 
```

* * *

## 回答 #20

> 赞同：5
> 
> 时间：2011-03-11T01:36:54.457

我一直在写一篇深入的文章，讨论使用正则表达式进行 URI 验证。它基于 RFC3986。

[正则表达式 URI 验证](http://jmrware.com/articles/2009/uri_regexp/URI_regex.html)

虽然这篇文章还没有完成，但我已经提出了一个 PHP 函数，它可以很好地验证 HTTP 和 FTP URL。这是当前版本：

```
// function url_valid($url) { Rev:20110423_2000
//
// Return associative array of valid URI components, or FALSE if $url is not
// RFC-3986 compliant. If the passed URL begins with: "www." or "ftp.", then
// "http://" or "ftp://" is prepended and the corrected full-url is stored in
// the return array with a key name "url". This value should be used by the caller.
//
// Return value: FALSE if $url is not valid, otherwise array of URI components:
// e.g.
// Given: "http://www.jmrware.com:80/articles?height=10&width=75#fragone"
// Array(
//    [scheme] => http
//    [authority] => www.jmrware.com:80
//    [userinfo] =>
//    [host] => www.jmrware.com
//    [IP_literal] =>
//    [IPV6address] =>
//    [ls32] =>
//    [IPvFuture] =>
//    [IPv4address] =>
//    [regname] => www.jmrware.com
//    [port] => 80
//    [path_abempty] => /articles
//    [query] => height=10&width=75
//    [fragment] => fragone
//    [url] => http://www.jmrware.com:80/articles?height=10&width=75#fragone
// )
function url_valid($url) {
    if (strpos($url, 'www.') === 0) $url = 'http://'. $url;
    if (strpos($url, 'ftp.') === 0) $url = 'ftp://'. $url;
    if (!preg_match('/# Valid absolute URI having a non-empty, valid DNS host.
        ^
        (?P<scheme>[A-Za-z][A-Za-z0-9+\-.]*):\/\/
        (?P<authority>
          (?:(?P<userinfo>(?:[A-Za-z0-9\-._~!$&\'()*+,;=:]|%[0-9A-Fa-f]{2})*)@)?
          (?P<host>
            (?P<IP_literal>
              \[
              (?:
                (?P<IPV6address>
                  (?:                                                (?:[0-9A-Fa-f]{1,4}:){6}
                  |                                                ::(?:[0-9A-Fa-f]{1,4}:){5}
                  | (?:                          [0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){4}
                  | (?:(?:[0-9A-Fa-f]{1,4}:){0,1}[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){3}
                  | (?:(?:[0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){2}
                  | (?:(?:[0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})?::   [0-9A-Fa-f]{1,4}:
                  | (?:(?:[0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})?::
                  )
                  (?P<ls32>[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}
                  | (?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
                       (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)
                  )
                |   (?:(?:[0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})?::   [0-9A-Fa-f]{1,4}
                |   (?:(?:[0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})?::
                )
              | (?P<IPvFuture>[Vv][0-9A-Fa-f]+\.[A-Za-z0-9\-._~!$&\'()*+,;=:]+)
              )
              \]
            )
          | (?P<IPv4address>(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
                               (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))
          | (?P<regname>(?:[A-Za-z0-9\-._~!$&\'()*+,;=]|%[0-9A-Fa-f]{2})+)
          )
          (?::(?P<port>[0-9]*))?
        )
        (?P<path_abempty>(?:\/(?:[A-Za-z0-9\-._~!$&\'()*+,;=:@]|%[0-9A-Fa-f]{2})*)*)
        (?:\?(?P<query>       (?:[A-Za-z0-9\-._~!$&\'()*+,;=:@\\/?]|%[0-9A-Fa-f]{2})*))?
        (?:\#(?P<fragment>    (?:[A-Za-z0-9\-._~!$&\'()*+,;=:@\\/?]|%[0-9A-Fa-f]{2})*))?
        $
        /mx', $url, $m)) return FALSE;
    switch ($m['scheme']) {
    case 'https':
    case 'http':
        if ($m['userinfo']) return FALSE; // HTTP scheme does not allow userinfo.
        break;
    case 'ftps':
    case 'ftp':
        break;
    default:
        return FALSE;   // Unrecognized URI scheme. Default to FALSE.
    }
    // Validate host name conforms to DNS "dot-separated-parts".
    if ($m['regname']) { // If host regname specified, check for DNS conformance.
        if (!preg_match('/# HTTP DNS host name.
            ^                      # Anchor to beginning of string.
            (?!.{256})             # Overall host length is less than 256 chars.
            (?:                    # Group dot separated host part alternatives.
              [A-Za-z0-9]\.        # Either a single alphanum followed by dot
            |                      # or... part has more than one char (63 chars max).
              [A-Za-z0-9]          # Part first char is alphanum (no dash).
              [A-Za-z0-9\-]{0,61}  # Internal chars are alphanum plus dash.
              [A-Za-z0-9]          # Part last char is alphanum (no dash).
              \.                   # Each part followed by literal dot.
            )*                     # Zero or more parts before top level domain.
            (?:                    # Explicitly specify top level domains.
              com|edu|gov|int|mil|net|org|biz|
              info|name|pro|aero|coop|museum|
              asia|cat|jobs|mobi|tel|travel|
              [A-Za-z]{2})         # Country codes are exactly two alpha chars.
              \.?                  # Top level domain can end in a dot.
            $                      # Anchor to end of string.
            /ix', $m['host'])) return FALSE;
    }
    $m['url'] = $url;
    for ($i = 0; isset($m[$i]); ++$i) unset($m[$i]);
    return $m; // return TRUE == array of useful named $matches plus the valid $url.
} 
```

该函数使用两个正则表达式；一个用于匹配有效通用 URI 的子集（具有非空主机的绝对 URI），另一个用于验证 DNS“点分隔部分”主机名。尽管此功能目前仅验证 HTTP 和 FTP 方案，但它的结构使其可以轻松扩展以处理其他方案。

* * *

## 回答 #21

> 赞同：5
> 
> 时间：2014-08-27T23:52:07.263

我使用这个正则表达式：

```
((https?:)?//)?(([\d\w]|%[a-fA-f\d]{2,2})+(:([\d\w]|%[a-fA-f\d]{2,2})+)?@)?([\d\w][-\d\w]{0,253}[\d\w]\.)+[\w]{2,63}(:[\d]+)?(/([-+_~.\d\w]|%[a-fA-f\d]{2,2})*)*(\?(&?([-+_~.\d\w]|%[a-fA-f\d]{2,2})=?)*)?(#([-+_~.\d\w]|%[a-fA-f\d]{2,2})*)? 
```

支持两者：

```
http://stackoverflow.com
https://stackoverflow.com 
```

和：

```
//stackoverflow.com 
```

* * *

## 回答 #22

> 赞同：4
> 
> 时间：2013-05-07T18:14:33.893

对于 Python，这是 Django 1.5.1 中使用的实际 URL 验证正则表达式：

```
import re
regex = re.compile(
        r'^(?:http|ftp)s?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'  # ...or ipv4
        r'\[?[A-F0-9]*:[A-F0-9:]+\]?)'  # ...or ipv6
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE) 
```

这会处理 ipv4 和 ipv6 地址以及端口和 GET 参数。

在这里的[代码](https://github.com/django/django/blob/master/django/core/validators.py)中找到，第 44 行。

* * *

## 回答 #23

> 赞同：4
> 
> 时间：2013-07-07T11:33:28.050

这个非常适合我。`(https?|ftp)://(www\d?|[a-zA-Z0-9]+)?\.[a-zA-Z0-9-]+(\:|\.)([a-zA-Z0-9.]+|(\d+)?)([/?:].*)?`

* * *

## 回答 #24

> 赞同：4
> 
> 时间：2017-08-30T17:20:08.040

我希望它对你有帮助...

```
^(http|https):\/\/+[\www\d]+\.[\w]+(\/[\w\d]+)? 
```

* * *

## 回答 #25

> 赞同：4
> 
> 时间：2018-12-10T18:31:57.653

这是我制作的一个正则表达式，它从 URL 中提取不同的部分：

`^((?:https?|ftp):\/\/?)?([^:/\s.]+\.[^:/\s]|localhost)(:\d+)?((?:\/\w+)*\/)?([\w\-.]+[^#?\s]+)?([^#]+)?(#[\w-]+)?$`

`((?:https?|ftp):\/\/?)?`*（组 1）*：提取协议
`([^:/\s.]+\.[^:/\s]|localhost)`*（组 2）*：提取主机名
`(:\d+)?`*（组 3）*：提取端口号
`((?:\/\w+)*\/)?([\w\-.]+[^#?\s]+)?`*（组 4 和 5）*：提取路径部分
`([^#]+)?`*（组 6）*：提取查询部分
`(#[\w-]+)?`*（组 7）*：提取哈希部分

对于上面列出的正则表达式的每个部分，您可以删除结尾`?`以强制它（或添加一个以使其成为兼性）。您还可以删除正则表达式`^`开头和`$`结尾的 ，这样它就不需要匹配整个字符串。

在[regex101](https://regex101.com/r/Q2ilqN/7)上查看。

***注意：****这个正则表达式不是 100% 安全的，它可能接受一些不一定是有效 URL 的字符串，但它确实验证了一些标准。它的主要目标是提取 URL 的不同部分而不是对其进行验证。*

* * *

## 回答 #26

> 赞同：3
> 
> 时间：2014-12-09T12:48:49.777

为方便起见，这里有一个用于 URL 的单行正则表达式，它也将匹配 localhost，您更有可能拥有比`.com`或类似的端口。

```
(http(s)?:\/\/.)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}(\.[a-z]{2,6}|:[0-9]{3,4})\b([-a-zA-Z0-9@:%_\+.~#?&\/\/=]*) 
```

* * *

## 回答 #27

> 赞同：3
> 
> 时间：2015-10-09T00:50:48.497

我找到了以下 URL 的正则表达式，**用 500 多个 URL 成功测试**：

`/\b(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\x{00a1}-\x{ffff}0-9]+-?)*[a-z\x{00a1}-\x{ffff}0-9]+)(?:\.(?:[a-z\x{00a1}-\x{ffff}0-9]+-?)*[a-z\x{00a1}-\x{ffff}0-9]+)*(?:\.(?:[a-z\x{00a1}-\x{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?\b/gi`

*我知道它看起来很丑，但好的是它可以工作。:)*

[**正则表达式 101 上的581 个随机 URL**的解释和演示。](https://regex101.com/r/hU9aV3/5)

来源：[寻找完美的 URL 验证正则表达式](https://mathiasbynens.be/demo/url-regex)

* * *

## 回答 #28

> 赞同：3
> 
> 时间：2016-10-07T01:56:06.470

要匹配 URL，有多种选项，这取决于您的要求。下面是少数。

```
_(^|[\s.:;?\-\]<\(])(https?://[-\w;/?:@&=+$\|\_.!~*\|'()\[\]%#,☺]+[\w/#](\(\))?)(?=$|[\s',\|\(\).:;?\-\[\]>\)])_i

#\b(([\w-]+://?|www[.])[^\s()<>]+(?:\([\w\d]+\)|([^[:punct:]\s]|/)))#iS 
```

还有一个链接可以为您提供超过 10 种不同的 URL 验证变体。

[https://mathiasbynens.be/demo/url-regex](https://mathiasbynens.be/demo/url-regex)

* * *

## 回答 #29

> 赞同：2
> 
> 时间：2011-07-22T11:30:47.267

我认为由于隐含的修饰符，有些人无法使用您的 php 代码。我按原样复制了您的代码并用作示例：

```
if(
    preg_match(
        "/^{$IRI_reference}$/iu",
        'http://www.url.com'
    )
){
    echo 'true';
} 
```

注意“i”和“u”修饰符。没有“u” php 会抛出异常：

```
Warning: preg_match() [function.preg-match]: Compilation failed: character value in \x{...} sequence is too large at offset XX 
```

* * *

## 回答 #30

> 赞同：2
> 
> 时间：2012-12-06T07:46:36.123

我试图制定我的 url 版本。我的要求是在可能的 url 可以是 cse.uom.ac.mu 的字符串中捕获实例 - 注意它前面没有 http 或 www

```
String regularExpression = "((((ht{2}ps?://)?)((w{3}\\.)?))?)[^.&&[a-zA-Z0-9]][a-zA-Z0-9.-]+[^.&&[a-zA-Z0-9]](\\.[a-zA-Z]{2,3})";

assertTrue("www.google.com".matches(regularExpression));
assertTrue("www.google.co.uk".matches(regularExpression));
assertTrue("http://www.google.com".matches(regularExpression));
assertTrue("http://www.google.co.uk".matches(regularExpression));
assertTrue("https://www.google.com".matches(regularExpression));
assertTrue("https://www.google.co.uk".matches(regularExpression));
assertTrue("google.com".matches(regularExpression));
assertTrue("google.co.uk".matches(regularExpression));
assertTrue("google.mu".matches(regularExpression));
assertTrue("mes.intnet.mu".matches(regularExpression));
assertTrue("cse.uom.ac.mu".matches(regularExpression));

//cannot contain 2 '.' after www
assertFalse("www..dr.google".matches(regularExpression));

//cannot contain 2 '.' just before com
assertFalse("www.dr.google..com".matches(regularExpression));

// to test case where url www must be followed with a '.'
assertFalse("www:google.com".matches(regularExpression));

// to test case where url www must be followed with a '.'
//assertFalse("http://wwwe.google.com".matches(regularExpression));

// to test case where www must be preceded with a '.'
assertFalse("https://www@.google.com".matches(regularExpression)); 
```

* * *

## 回答 #31

> 赞同：2
> 
> 时间：2013-06-19T00:48:36.400

简单的 FILTER_VALIDATE_URL 有什么问题？

```
 $url = "http://www.example.com";

if(!filter_var($url, FILTER_VALIDATE_URL))
  {
  echo "URL is not valid";
  }
else
  {
  echo "URL is valid";
  } 
```

我知道这不是问题，但是当我需要验证 url 时它为我完成了这项工作，所以认为它可能对遇到这篇文章寻找相同内容的其他人有用

* * *

## 回答 #32

> 赞同：2
> 
> 时间：2013-10-09T19:21:04.277

以下正则表达式将起作用：

```
"@((((ht)|(f))tp[s]?://)|(www\.))([a-z][-a-z0-9]+\.)?([a-z][-a-z0-9]+\.)?[a-z][-a-z0-9]+\.[a-z]+[/]?[a-z0-9._\/~#&=;%+?-]*@si" 
```

* * *

## 回答 #33

> 赞同：2
> 
> 时间：2014-05-28T11:08:58.690

使用这个对我有用

```
function validUrl(Url) {
    var myRegExp  =/^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]+-?)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]+-?)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/i;

    if (!RegExp.test(Url.value)) {
        $("#urlErrorLbl").removeClass('highlightNew');
        return false;
    } 

    $("#urlErrorLbl").addClass('highlightNew'); 
    return true; 
} 
```

* * *

## 回答 #34

> 赞同：2
> 
> 时间：2015-05-14T13:19:38.723

您没有指定您使用的语言。如果是 PHP，则有一个本机函数：

```
$url = 'http://www.yoururl.co.uk/sub1/sub2/?param=1&param2/';

if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) {
    // Wrong
}
else {
    // Valid
} 
```

返回过滤后的数据，如果过滤器失败，则返回 FALSE。

[在这里查看>>](http://php.net/manual/en/function.filter-var.php)

希望能帮助到你。

* * *

## 回答 #35

> 赞同：2
> 
> 时间：2019-02-14T12:26:52.900

```
https?:\/{2}(?:[\/-\w.]|(?:%[\da-fA-F]{2}))+ 
```

您可以使用此模式来检测 URL。

以下是概念证明

[RegExr：网址检测器](https://regexr.com/48chr)

* * *

## 回答 #36

> 赞同：1
> 
> 时间：2013-12-12T11:27:45.377

检查 URL 正则表达式将是：

```
^http(s{0,1})://[a-zA-Z0-9_/\\-\\.]+\\.([A-Za-z/]{2,5})[a-zA-Z0-9_/\\&\\?\\=\\-\\.\\~\\%]* 
```

* * *

## 回答 #37

> 赞同：1
> 
> 时间：2017-08-17T06:43:02.920

这不是一个正则表达式，但完成了同样的事情（仅限 Javascript）：

```
function isAValidUrl(url) {
  try {
    new URL(url);
    return true;
  } catch(e) {
    return false;
  }
} 
```

* * *

## 回答 #38

> 赞同：1
> 
> 时间：2017-09-07T06:00:39.617

这个怎么样：

```
^(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})$ 
```

这些是测试用例：

[![测试用例](https://i.stack.imgur.com/Mm9y0.png)](https://i.stack.imgur.com/Mm9y0.png)

你可以在[这里试试：https://regex101.com/r/mS9gD7/41](https://regex101.com/r/mS9gD7/41)

* * *

## 回答 #39

> 赞同：1
> 
> 时间：2018-01-01T09:08:52.340

据我发现，这个表达对我来说很好——

```
(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,}) 
```

工作示例-

```
function RegExForUrlMatch()
{
  var expression = /(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g;

  var regex = new RegExp(expression);
  var t = document.getElementById("url").value;

  if (t.match(regex)) {
    document.getElementById("demo").innerHTML = "Successful match";
  } else {
    document.getElementById("demo").innerHTML = "No match";
  }
}
```

```
<input type="text" id="url" placeholder="url" onkeyup="RegExForUrlMatch()">

<p id="demo">Please enter a URL to test</p>
```

* * *

## 回答 #40

> 赞同：0
> 
> 时间：2014-09-14T07:53:35.257

这是这种情况下最好和最匹配的正则表达式

```
^(?:http(?:s)?:\/\/)?(?:www\.)?(?:[\w-]*)\.\w{2,}$ 
```

* * *

## 回答 #41

> 赞同：0
> 
> 时间：2015-01-14T14:20:24.950

要将 URL 与域匹配：

```
(^(\bhttp)(|s):\/{2})(?=[a-z0-9-_]{1,255})\.\1\.([a-z]{3,7}$) 
```

可以简化为：

```
(^(\bhttp)(|s):\/{2})(?=[a-z0-9-_.]{1,255})\.([a-z]{3,7}) 
```

后者不检查结束行的结尾，以便以后可以使用它来创建具有完整路径和查询字符串的完整 URL。

* * *

## 回答 #42

> 赞同：0
> 
> 时间：2012-10-24T12:06:38.157

现在这是一个相当古老的线程，问题要求使用基于正则表达式的 URL 验证器。我在寻找完全相同的东西时遇到了线程。虽然很可能编写一个非常全面的正则表达式来验证 URL。我最终选择了另一种方式来做事——使用 PHP 的[parse_url](http://php.net/manual/en/function.parse-url.php)函数。

如果无法解析 url，则返回布尔值 false。否则返回方案、主机等信息。这可能不足以单独进行全面的 URL 检查，但可以深入研究以进行进一步分析。如果目的是简单地捕捉拼写错误、无效方案等。这是完全足够的！

* * *

## 回答 #43

> 赞同：0
> 
> 时间：2015-04-06T13:36:43.973

这应该有效：

```
function validateUrl(value){
	return /^(http(s)?:\/\/.)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)$/gi.test(value);
}

console.log(validateUrl('google.com')); // true
console.log(validateUrl('www.google.com')); // true
console.log(validateUrl('http://www.google.com')); // true
console.log(validateUrl('http:/www.google.com')); // false
console.log(validateUrl('www.google.com/test')); // true
```

* * *

## 回答 #44

> 赞同：0
> 
> 时间：2019-05-02T12:19:50.610

**改进**

检测如下 URL：

*   [https://www.example.pl](https://www.example.pl)
*   [http://www.example.com](http://www.example.com)
*   www.example.pl
*   例子.com
*   [http://blog.example.com](http://blog.example.com)
*   [http://www.example.com/product](http://www.example.com/product)
*   [http://www.example.com/products?id=1&page=2](http://www.example.com/products?id=1&page=2)
*   [http://www.example.com#up](http://www.example.com#up)
*   [http://255.255.255.255](http://255.255.255.255)
*   255.255.255.255
*   http://www.site.com:8008

正则表达式：

```
/^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&'\(\)\*\+,;=.]+$/gm 
```

* * *

## 回答 #45

> 赞同：0
> 
> 时间：2019-05-08T09:09:09.630

如果您想应用更严格的规则，这是我开发的：

```
isValidUrl(input) {
    var regex = /^(((H|h)(T|t)(T|t)(P|p)(S|s)?):\/\/)?[-a-zA-Z0-9@:%._\+~#=]{2,100}\.[a-zA-Z]{2,10}(\/([-a-zA-Z0-9@:%_\+.~#?&//=]*))?/
    return regex.test(input)
} 
```

* * *

## 回答 #46

> 赞同：0
> 
> 时间：2020-07-26T17:59:08.170

无论提出的广泛问题，我都会为将来寻找简单事物的任何人发布此内容......因为我认为验证 URL 没有适合所有需求的完美正则表达式，这取决于您的要求，即：在我的情况下，我只需要验证 URL 的形式是否为，`domain.extension`并且我想允许该`www`或任何其他子域，例如`blog.domain.extension`我不关心 http(s)，因为在我的应用程序中我有一个字段显示“输入 URL”所以很明显输入的字符串是什么。

所以这里是正则表达式：

```
/^(www\.|[a-zA-Z0-9](.*[a-zA-Z0-9])?\.)?((?!www)[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9])\.[a-z]{2,5}(:[0-9]{1,5})?$/i 
```

此正则表达式中的第一个块是：

`(www\.|[a-zA-Z0-9](.*[a-zA-Z0-9])?\.)?`---> 我们开始检查 URL 是否以`www.`或`[a-zA-Z0-9](.*[a-zA-Z0-9])?`表示一个 letterOrNumber + **(anyCharacter(0 or multiple times) + another letterOrNumber) 后跟一个点**

请注意，`(.*[a-zA-Z0-9])?\.)?`我们翻译的**(anyCharacter(0 or multiple times) + another letterOrNumber)** 是可选的（可以是或不是），这就是为什么我们将它分组在括号之间并后跟问号`?`

到目前为止我们讨论的整个块也放在括号之间，然后是？这意味着 www 或任何其他词（代表子域）都是可选的。

第二部分是：`((?!www)[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9])\.`--->代表“域”部分，可以是任何以字母或数字开头的单词（www除外）+任何其他字母（包括破折号“-”）重复一次或多次，并以任何字母或数字结尾，后跟一个点。

最后一部分是`[a-z]{2,}`---> 代表“扩展名”，可以是任何字母重复 2 次或更多次，所以它可以是 com、net、org、art 基本上任何扩展名

* * *

## 回答 #47

> 赞同：0
> 
> 时间：2018-03-07T14:44:14.337

经过严格的搜索，我终于解决了以下问题

```
^[a-zA-Z0-9]+\:\/\/[a-zA-Z0-9]+\.[-a-zA-Z0-9]+\.?[a-zA-Z0-9]+$|^[a-zA-Z0-9]+\.[-a-zA-Z0-9]+\.[a-zA-Z0-9]+$ 
```

这个东西在未来的 URL 中通用。

* * *

## 回答 #48

> 赞同：0
> 
> 时间：2016-09-13T20:34:37.120

我创建了一个与RFC3987 以及其他 RFC 文档之后提供的 @eyelidlessness类似的正则表达式 ( **PCRE )。**@eyelidlessness 和我的正则表达式之间的主要区别主要是可读性和 URN 支持。

下面的正则表达式是一个整体（而不是与 PHP 混合），因此它可以很容易地用于不同的语言（只要它们支持 PCRE）

**测试此正则表达式的最简单方法是使用[regex101](http://regex101.com)并使用适当的修饰符 ( ) 复制粘贴下面的代码和测试字符串`gmx`。**

要在 PHP 中使用此正则表达式，请将下面的正则表达式插入以下代码：

```
$regex = <<<'EOD'
// Put the regex here
EOD; 
```

* * *

您可以通过执行以下操作来匹配没有方案的链接：
要匹配没有方案的链接（即`john.doe@gmail.com`或`www.google.com/pathtofile.php?query`），请替换此部分：

```
 (?:
    (?<scheme>
      (?<urn>urn)|
      (?&d_scheme)
    )
    :
  )? 
```

有了这个：

```
 (?:
    (?<scheme>
      (?<urn>urn)|
      (?&d_scheme)
    )
    :
  )? 
```

但是请注意，通过替换它，正则表达式不会变得 100% 可靠。

* * *

**带有修饰符的正则**表达式 (PCRE)**`gmx` ，用于下面的多行测试字符串

```
(?(DEFINE)
  # Definitions
  (?<ALPHA>[\p{L}])
  (?<DIGIT>[0-9])
  (?<HEX>[0-9a-fA-F])
  (?<NCCHAR>
    (?&UNRESERVED)|
    (?&PCT_ENCODED)|
    (?&SUB_DELIMS)|
    @
  )
  (?<PCHAR>
    (?&UNRESERVED)|
    (?&PCT_ENCODED)|
    (?&SUB_DELIMS)|
    :|
    @|
    \/
  )
  (?<UCHAR>
    (?&UNRESERVED)|
    (?&PCT_ENCODED)|
    (?&SUB_DELIMS)|
    :
  )
  (?<RCHAR>
    (?&UNRESERVED)|
    (?&PCT_ENCODED)|
    (?&SUB_DELIMS)
  )
  (?<PCT_ENCODED>%(?&HEX){2})
  (?<UNRESERVED>
    ((?&ALPHA)|(?&DIGIT)|[-._~])
  )
  (?<RESERVED>(?&GEN_DELIMS)|(?&SUB_DELIMS))
  (?<GEN_DELIMS>[:\/?#\[\]@])
  (?<SUB_DELIMS>[!$&'()*+,;=])
  # URI Parts
  (?<d_scheme>
    (?!urn)
    (?:
      (?&ALPHA)
      ((?&ALPHA)|(?&DIGIT)|[+-.])*
      (?=:)
    )
  )
  (?<d_hier_part_slashes>
    (\/{2})?
  )
  (?<d_authority>(?&d_userinfo)?)
  (?<d_userinfo>(?&UCHAR)*)
  (?<d_ipv6>
    (?![^:]*::[^:]*::[^:]*)
    (
      (
        ((?&HEX){0,4})
        :
      ){1,7}
      ((?&d_ipv4)|:|(?&HEX){1,4})
    )
  )
  (?<d_ipv4>
    ((?&octet)\.){3}
    (?&octet)
  )
  (?<octet>
    (
      25[]0-5]|
      2[0-4](?&DIGIT)|
      1(?&DIGIT){2}|
      [1-9](?&DIGIT)|
      (?&DIGIT)
    )
  )
  (?<d_reg_name>(?&RCHAR)*)
  (?<d_urn_name>(?&UCHAR)*)
  (?<d_port>(?&DIGIT)*)
  (?<d_path>
    (
      \/
      ((?&PCHAR)*)*
      (?=\?|\#|$)
    )
  )
  (?<d_query>
    (
      ((?&PCHAR)|\/|\?)*
    )?
  )
  (?<d_fragment>
    (
      ((?&PCHAR)|\/|\?)*
    )?
  )
)
^
(?<link>
  (?:
    (?<scheme>
      (?<urn>urn)|
      (?&d_scheme)
    )
    :
  )
  (?(urn)
    (?:
      (?<namespace_identifier>[0-9a-zA-Z\-]+)
      :
      (?<namespace_specific_string>(?&d_urn_name)+)
    )
    |
    (?<hier_part>
      (?<slashes>(?&d_hier_part_slashes))
      (?<authority>
        (?:
          (?<userinfo>(?&d_authority))
          @
        )?
        (?<host>
          (?<ipv4>\[?(?&d_ipv4)\]?)|
          (?<ipv6>\[(?&d_ipv6)\])|
          (?<domain>(?&d_reg_name))
        )
        (?:
          :
          (?<port>(?&d_port))
        )?
      )
      (?<path>(?&d_path))?
    )
    (?:
      \?
      (?<query>(?&d_query))
    )?
    (?:
      \#
      (?<fragment>(?&d_fragment))
    )?
  )
)
$ 
```

**测试字符串**

```
# Valid URIs
ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm
ftp://ftp.is.co.za/rfc/rfc1808.txt
http://www.ietf.org/rfc/rfc2396.txt
ldap://[2001:db8::7]/c=GB?objectClass?one
mailto:John.Doe@example.com
news:comp.infosystems.www.servers.unix
tel:+1-816-555-1212
telnet://192.0.2.16:80/
urn:isbn:0451450523
urn:oid:2.16.840
urn:isan:0000-0000-9E59-0000-O-0000-0000-2
urn:oasis:names:specification:docbook:dtd:xml:4.1.2
http://localhost/test/somefile.php?query=someval&variable=value#fragment
http://[2001:db8:a0b:12f0::1]/test
ftp://username:password@domain.com/path/to/file/somefile.html?queryVariable=value#fragment
https://subdomain.domain.com/path/to/file.php?query=value#fragment
https://subdomain.example.com/path/to/file.php?query=value#fragment
mailto:john.smith(comment)@example.com
mailto:user@[2001:DB8::1]
mailto:user@[255:192:168:1]
mailto:M.Handley@cs.ucl.ac.uk
http://localhost:4433/path/to/file?query#fragment
# Note that the example below IS a valid as it does follow RFC standards
localhost:4433/path/to/file

# These work with the optional scheme group although I'd suggest making the scheme mandatory as misinterpretations can occur
john.doe@gmail.com
www.google.com/pathtofile.php?query
[192a:123::192.168.1.1]:80/path/to/file.html?query#fragment 
```

* * *

## 回答 #49

> 赞同：0
> 
> 时间：2020-10-05T09:58:56.863

对 URL 的简单检查是

```
^(ftp|http|https):\/\/[^ "]+$ 
```

* * *

## 回答 #50

> 赞同：0
> 
> 时间：2018-07-27T15:02:42.167

我发现的最好的正则表达式是：`/(^|\s)((https?:\/\/)?[\w-]+(\.[\w-]+)+\.?(:\d+)?(\/\S*)?)/gi`

对于 ios 快速：`(^|\\s)((https?:\\/\\/)?[\\w-]+(\\.[\\w-]+)+\\.?(:\\d+)?(\\/\\S*)?)`

[http://jsfiddle.net/9BYdp/1/](http://jsfiddle.net/9BYdp/1/)

[在这里](https://codegolf.stackexchange.com/a/480)找到

* * *

## 回答 #51

> 赞同：0
> 
> 时间：2018-01-23T18:35:47.583

下面的表达式适用于所有流行的域。它将接受以下网址：

*   www.yourwebsite.com
*   [http://www.yourwebsite.com](http://www.yourwebsite.com)
*   www.yourwebsite.com
*   yourwebsite.com
*   yourwebsite.co.in

此外，它还会将带有 url 的消息作为链接，
例如`please visit yourwebsite.com`
在上面的示例中，它将`yourwebsite.com`作为超链接

```
if (new RegExp("([-a-z0-9]{1,63}\\.)*?[a-z0-9][-a-z0-9]{0,61}[a-z0-9]\\.(com|com/|org|gov|cm|net|online|live|biz|us|uk|co.us|co.uk|in|co.in|int|info|edu|mil|ca|co|co.au|org/|gov/|cm/|net/|online/|live/|biz/|us/|uk/|co.us/|co.uk/|in/|co.in/|int/|info/|edu/|mil/|ca/|co/|co.au/)(/[-\\w@\\+\\.~#\\?*&/=% ]*)?$").test(strMessage) || (new RegExp("^[a-z ]+[\.]?[a-z ]+?[\.]+[a-z ]+?[\.]+[a-z ]+?[-\\w@\\+\\.~#\\?*&/=% ]*").test(strMessage) && new RegExp("([a-zA-Z0-9]+://)?([a-zA-Z0-9_]+:[a-zA-Z0-9_]+@)?([a-zA-Z0-9.-]+\\.[A-Za-z]{2,4})(:[0-9]+)?(/.*)?").test(strMessage)) || (new RegExp("^[a-z ]+[\.]?[a-z ]+?[-\\w@\\+\\.~#\\?*&/=% ]*").test(strMessage) && new RegExp("([a-zA-Z0-9]+://)?([a-zA-Z0-9_]+:[a-zA-Z0-9_]+@)?([a-zA-Z0-9.-]+\\.[A-Za-z]{2,4})(:[0-9]+)?(/.*)?").test(strMessage))) {
  if (new RegExp("^[a-z ]+[\.]?[a-z ]+?[\.]+[a-z ]+?[\.]+[a-z ]+?$").test(strMessage) && new RegExp("([a-zA-Z0-9]+://)?([a-zA-Z0-9_]+:[a-zA-Z0-9_]+@)?([a-zA-Z0-9.-]+\\.[A-Za-z]{2,4})(:[0-9]+)?(/.*)?").test(strMessage)) {
    var url1 = /(^|&lt;|\s)([\w\.]+\.(?:com|org|gov|cm|net|online|live|biz|us|uk|co.us|co.uk|in|co.in|int|info|edu|mil|ca|co|co.au))(\s|&gt;|$)/g;
    var html = $.trim(strMessage);
    if (html) {
      html = html.replace(url1, '$1<a style="color:blue; text-decoration:underline;" target="_blank"  href="http://$2">$2</a>$3');
    }
    returnString = html;
    return returnString;
  } else {
    var url1 = /(^|&lt;|\s)(www\..+?\.(?:com|org|gov|cm|net|online|live|biz|us|uk|co.us|co.uk|in|co.in|int|info|edu|mil|ca|co|co.au)[^,\s]*)(\s|&gt;|$)/g,
      url2 = /(^|&lt;|\s)(((https?|ftp):\/\/|mailto:).+?\.(?:com|org|gov|cm|net|online|live|biz|us|uk|co.us|co.uk|in|co.in|int|info|edu|mil|ca|co|co.au)[^,\s]*)(\s|&gt;|$)/g,
      url3 = /(^|&lt;|\s)([\w\.]+\.(?:com|org|gov|cm|net|online|live|biz|us|uk|co.us|co.uk|in|co.in|int|info|edu|mil|ca|co|co.au)[^,\s]*)(\s|&gt;|$)/g;

    var html = $.trim(strMessage);
    if (html) {
      html = html.replace(url1, '$1<a style="color:blue; text-decoration:underline;" target="_blank"  href="http://$2">$2</a>$3').replace(url2, '$1<a style="color:blue; text-decoration:underline;" target="_blank"  href="$2">$2</a>$5').replace(url3, '$1<a style="color:blue; text-decoration:underline;" target="_blank"  href="http://$2">$2</a>$3');
    }
    returnString = html;

    return returnString;
  }
} 
```

* * *

## 回答 #52

> 赞同：0
> 
> 时间：2018-11-26T12:10:31.130

我认为这是一个非常简单的方法。而且效果很好。

```
var hasURL = (str) =>{
	var url_pattern = new RegExp("(www.|http://|https://|ftp://)\w*");
	if(!url_pattern.test(str)){
		document.getElementById("demo").innerHTML = 'No URL';
	}
	else
		document.getElementById("demo").innerHTML = 'String has a URL';
};
```

```
<p>Please enter a string and test it has any url or not</p>
<input type="text" id="url" placeholder="url" onkeyup="hasURL(document.getElementById('url').value)">
<p id="demo"></p>
```

* * *

## 回答 #53

> 赞同：0
> 
> 时间：2018-09-26T00:20:20.163

有趣的是，上面的答案都不能满足我的需要，所以我想我会提供我的解决方案。我需要能够执行以下操作：

*   匹配`http(s)://www.google.com`, `http://google.com`, `www.google.com`, 和`google.com`
*   匹配 Github 降价样式链接，例如`[Google](http://www.google.com)`
*   匹配所有可能的域扩展名，例如 .com、.io 或 .guru 等。基本上长度在 2-6 个字符之间
*   将所有内容分成适当的分组，以便我可以根据需要访问每个部分。

这是解决方案：

```
/^(\[[A-z0-9 _]*\]\()?((?:(http|https):\/\/)?(?:[\w-]+\.)+[a-z]{2,6})(\))?$ 
```

这给了我上述所有要求。如有必要，您可以选择添加 ftp 和文件功能：

```
/^(\[[A-z0-9 _]*\]\()?((?:(http|https|ftp|file):\/\/)?(?:[\w-]+\.)+[a-z]{2,6})(\))?$ 
```

* * *

## 回答 #54

> 赞同：0
> 
> 时间：2016-08-29T04:17:51.443

我想我找到了一个更通用的正则表达式来验证 url，尤其是网站

```
​(https?:\/\/)?(www\.)[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,4}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)|(https?:\/\/)?(www\.)?(?!ww)[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,4}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*) 
```

它不允许例如 www.something 或[http://www](http://www)或[http://www.something](http://www.something)

在这里检查：[http ://regexr.com/3e4a2](http://regexr.com/3e4a2)

* * *

## 回答 #55

> 赞同：-1
> 
> 时间：2020-09-21T11:34:50.377

```
/^(http|HTTP)+(s|S)?:\/\/[\w.-]+(?:\.[\w\.-]+)+[\w\-\._\$\(\)/]+$/g 
```

用测试检查演示：

[https://regexr.com/5cedu](https://regexr.com/5cedu)

* * *

## 回答 #56

> 赞同：-1
> 
> 时间：2021-11-22T14:17:05.693

Javascript 现在有一个名为`new URL()`. 它允许您完全跳过 REGEX。

```
/**
 * 
 * The URL() constructor returns a newly created URL object representing 
 * the URL defined by the parameters. 
 * 
 * https://developer.mozilla.org/en-US/docs/Web/API/URL/URL
 * 
 */
let requestUrl = new URL('https://username:password@developer.mozilla.org:8080/en-US/docs/search.html?par1=abc&par2=123&par3=true#Recent');

let urlParts = {
  origin: requestUrl.origin,
  href: requestUrl.href,
  protocol: requestUrl.protocol,
  username: requestUrl.username,
  password: requestUrl.password,
  host: requestUrl.host,
  hostname: requestUrl.hostname,
  port: requestUrl.port,
  pathname: requestUrl.pathname,
  search: requestUrl.search,
  searchParams: {
    par1: String(requestUrl.searchParams.get('par1')),
    par2: Number(requestUrl.searchParams.get('par2')),
    par3: Boolean(requestUrl.searchParams.get('par3')),
  },
  hash: requestUrl.hash      
};

console.log(urlParts);
```

* * *

## 回答 #57

> 赞同：-1
> 
> 时间：2021-11-19T12:17:00.567

最好的正则表达式是这里最好的答案的组合！哈哈哈！我刚刚测试了所有这些，并将最好的放在一起！我稍微改变了一下，只有一个捕获组！我能在这个页面的源代码中找到 637 个 URL！只有少数误报！

```
((?:(?:https?|ftp)://)(?:\S+(?::\S*)?@|\d{1,3}(?:\.\d{1,3}){3}|(?:(?:[a-z\d\x{00a1}-\x{ffff}]+-?)*[a-z\d\x{00a1}-\x{ffff}]+)(?:\.(?:[a-z\d\x{00a1}-\x{ffff}]+-?)*[a-z\d\x{00a1}-\x{ffff}]+)*(?:\.[a-z\x{00a1}-\x{ffff}]{2,6}))(?::\d+)?(?:[^\s]*)|(?:(?:(?:[A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+(?::[0-9]+)?|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)(?:(?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))?)|(?:(?:(?:(?:[A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)(?:(?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))?))|(?:(?:(?:[\\w]+:)?//)?(?:(?:[\\d\\w]|%[a-fA-f\\d]{2,2})+(?::(?:[\\d\\w]|%[a-fA-f\\d]{2,2})+)?@)?(?:[\\d\\w][-\\d\\w]{0,253}[\\d\\w]\\.)+[\\w]{2,4}(?::[\\d]+)?(?:/(?:[-+_~.\\d\\w]|%[a-fA-f\\d]{2,2})*)*(?:\\?(?:&?(?:[-+_~.\\d\\w]|%[a-fA-f\\d]{2,2})=?)*)?(?:#(?:[-+_~.\\d\\w]|%[a-fA-f\\d]{2,2})*)?)|(?:https?:\/\/(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9])(?::?\d*)\/?(?:[a-z_\/0-9\-#.]*)\??(?:[a-z_\/0-9\-#=&]*)|(?:(?:(?:https?:)?(?:\/?\/))(?:(?:[\d\w]|%[a-fA-f\d]{2,2})+(?::(?:[\d\w]|%[a-fA-f\d]{2,2})+)?@)?(?:[\d\w][-\d\w]{0,253}[\d\w]\.)+[\w]{2,63}(?::[\d]+)?(?:/(?:[-+_~.\d\w]|%[a-fA-f\d]{2,2})*)*(?:\?(?:&?(?:[-+_~.\d\w]|%[a-fA-f\d]{2,2})=?)*)?(?:#(?:[-+_~.\d\w]|%[a-fA-f\d]{2,2})*)?)|(?:(?:https?|ftp)://(?:www\d?|[a-zA-Z0-9]+)?\.[a-zA-Z0-9-]+(?:\:|\.)(?:[a-zA-Z0-9.]+|(?:\d+)?)(?:[/?:].*)?)|(?:\b(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\x{00a1}-\x{ffff}0-9]+-?)*[a-z\x{00a1}-\x{ffff}0-9]+)(?:\.(?:[a-z\x{00a1}-\x{ffff}0-9]+-?)*[a-z\x{00a1}-\x{ffff}0-9]+)*(?:\.(?:[a-z\x{00a1}-\x{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?\b)) 
```

* * *

## 回答 #58

> 赞同：-1
> 
> 时间：2021-04-08T06:24:14.887

以下正则表达式适用于我：

```
(http(s)?:\/\/.)?(ftp(s)?:\/\/.)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{0,256}\.[a-z] 
{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*) 
```

火柴：

```
https://google.com t.me https://t.me ftp://google.com http://sm.tj http://bro.tj t.me/rshss https:google.com www.cool.com.au http://www.cool.com.au http://www.cool.com.au/ersdfs http://www.cool.com.au/ersdfs?dfd=dfgd@s=1 http://www.cool.com:81/index.html 
```

# mediawiki - 如何允许 MediaWiki 登录用户编辑 Common.css？

> ID：161747
> 
> 赞同：6
> 
> 时间：2008-10-02T10:58:45.057
> 
> 标签：mediawiki

我想允许登录的用户编辑 MediaWiki/Common.css 而不将它们添加到 sysop 组。

我知道这将允许用户将其更改为有害的方式，但它是一个封闭的 wiki，所以这不是问题。

即使更改 php 代码，任何解决方案都是可以接受的 :)

* * *

## 回答 #1

> 赞同：15
> 
> 时间：2008-11-17T15:12:17.173

创建一个新组，添加给它“editinterface”权限。在 LocalSettings.php 中是这样完成的：

```
$wgGroupPermissions['mynewgroup']['editinterface'] = true; 
```

然后将用户添加到您的新组中。

或者，如果您想将该权限授予所有已登录用户，请执行以下操作：

```
$wgGroupPermissions['user']['editinterface'] = true;
// user is the default group for all logged-in users 
```

有关详细信息，请参阅[MediaWiki 手册](http://www.mediawiki.org/wiki/Manual:User_rights)。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2014-08-31T11:30:51.740

使用起来可能更安全；

```
$wgAllowUserCss = true; 
```

[有关完整的详细信息，请参阅 Mediawiki 手册](https://www.mediawiki.org/wiki/Manual:$wgAllowUserCss)。

*“启用后，用户可以在‘偏好’显示中的正常皮肤选择之上进行个性化定制。”*

Javascript 也有类似的设置。

# python - 你将如何在 python 中实现 ant 样式的模式集来选择文件组？

> ID：161755
> 
> 赞同：3
> 
> 时间：2008-10-02T11:00:56.160
> 
> 标签：python, file, ant

Ant 有一种选择文件组的好方法，最方便的是使用 ** 来指示目录树。例如

```
**/CVS/*            # All files immediately under a CVS directory.
mydir/mysubdir/**   # All files recursively under mysubdir 
```

更多示例可以在这里看到：

[http://ant.apache.org/manual/dirtasks.html](http://ant.apache.org/manual/dirtasks.html)

您将如何在 python 中实现它，以便您可以执行以下操作：

```
files = get_files("**/CVS/*")
for file in files:
    print file

=>
CVS/Repository
mydir/mysubdir/CVS/Entries
mydir/mysubdir/foo/bar/CVS/Entries 
```

* * *

## 回答 #1

> 赞同：4
> 
> 时间：2012-05-15T08:39:01.297

对不起，这是你的 OP 之后的很长一段时间。我刚刚发布了一个 Python 包，它就是这样做的——它被称为 Formic，它可以在[PyPI Cheeseshop 获得](http://pypi.python.org/pypi/formic)。使用 Formic，您的问题可以通过以下方式解决：

```
import formic
fileset = formic.FileSet(include="**/CVS/*", default_excludes=False)
for file_name in fileset.qualified_files():
    print file_name 
```

有一点复杂：default_excludes。Formic 与 Ant 一样，默认情况下会排除 CVS 目录（因为大多数情况下从它们中收集文件以进行构建是危险的），该问题的默认答案将导致没有文件。设置 default_excludes=False 会禁用此行为。

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-02T16:07:32.973

一旦遇到 a `**`，您将不得不遍历整个目录结构，所以我认为此时最简单的方法是使用 os.walk 遍历目录，构造路径，然后检查如果它与模式匹配。您可能可以通过以下方式转换为正则表达式：

```
def glob_to_regex(pat, dirsep=os.sep):
    dirsep = re.escape(dirsep)
    print re.escape(pat)
    regex = (re.escape(pat).replace("\\*\\*"+dirsep,".*")
                           .replace("\\*\\*",".*")
                           .replace("\\*","[^%s]*" % dirsep)
                           .replace("\\?","[^%s]" % dirsep))
    return re.compile(regex+"$") 
```

（但请注意，这并不是功能齐全 -`[a-z]`例如，它不支持样式 glob 模式，尽管这可能会被添加）。（第一个`\*\*/`匹配是覆盖像`\*\*/CVS`匹配这样的情况`./CVS`，以及只`\*\*`在尾部匹配。）

但是，显然你不想在不处理`**`模式时递归当前目录下的所有内容，所以我认为你需要一个两阶段的方法。我没有尝试实现以下内容，并且可能存在一些极端情况，但我认为它应该可以工作：

1.  在目录分隔符上拆分模式。IE`pat.split('/') -> ['**','CVS','*']`

2.  递归遍历目录，并查看此级别模式的相关部分。IE。`n levels deep -> look at pat[n]`.

3.  如果`pat[n] == '**'`切换到上述策略：

    *   重构模式`dirsep.join(pat[n:])`
    *   转换为正则表达式`glob\_to\_regex()`
    *   递归`os.walk`地通过当前目录，建立相对于您开始的级别的路径。如果路径与正则表达式匹配，则生成它。
4.  如果 pat 不匹配`"**"`，并且它是模式中的最后一个元素，则产生所有匹配的文件/目录`glob.glob(os.path.join(curpath,pat[n]))`

5.  如果 pat 不匹配`"**"`，并且它不是模式中的最后一个元素，那么对于每个目录，检查它是否匹配 (with glob) `pat[n]`。如果是这样，通过它向下递归，增加深度（所以它会看`pat[n+1]`）

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-02T11:42:20.350

`os.walk`是你的朋友。查看 Python 手册 ( [https://docs.python.org/2/library/os.html#os.walk](https://docs.python.org/2/library/os.html#os.walk) ) 中的示例并尝试从中构建一些东西。

要将“ `**/CVS/*`”与您获得的文件名匹配，您可以执行以下操作：

```
def match(pattern, filename):
    if pattern.startswith("**"):
        return fnmatch.fnmatch(file, pattern[1:])
    else:
        return fnmatch.fnmatch(file, pattern) 
```

在`fnmatch.fnmatch`中，“*”匹配任何内容（包括斜线）。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2010-12-24T10:34:20.340

“waf”构建系统源代码中有一个实现。 [http://code.google.com/p/waf/source/browse/trunk/waflib/Node.py?r=10755#471](http://code.google.com/p/waf/source/browse/trunk/waflib/Node.py?r=10755#471) 可能这应该包含在自己的库中吗？

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T11:54:28.323

是的。正如已经建议的那样，您最好的选择是使用“os.walk”。[或者，也许可以围绕“ glob](http://docs.python.org/library/glob.html) ”和“ [fnmatch](http://docs.python.org/library/fnmatch.html) ”模块编写包装器。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-02T14:47:57.440

[os.walk](http://www.python.org/doc/2.6/library/os.html#os.walk)是您最好的选择。我用 .svn 做了下面的例子，因为我很方便，而且效果很好：

```
import re

for (dirpath, dirnames, filenames) in os.walk("."):
    if re.search(r'\.svn$', dirpath):
        for file in filenames:
            print file 
```

# .net - 将配置信息放入 DLL

> ID：161763
> 
> 赞同：9
> 
> 时间：2008-10-02T11:05:02.513
> 
> 标签：.net, dll, configuration

在我的项目中，我的功能被用作 Web 应用程序和控制台应用程序（从任务调度程序启动）。为此，我将公共代码放入 Web 应用程序和控制台应用程序都在使用的 DLL 中。这工作正常。

但是，控制台和 Web 应用程序现在有一个几乎相同的 App.config 和 Web.config。是否可以将此配置也放入 DLL 并使其对两个应用程序都可用？

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-02T11:59:26.580

是的，您可以而且应该将通用配置设置放在 DLL 的配置文件中。只需将 app.config 文件添加到 DLL 项目，并确保从 DLL 中读取配置设置。部署后，您的配置文件需要具有名称“MyDLL.dll.config”（假设您的 DLL 名为“MyDLL.dll”）并且与 DLL 位于同一文件夹中。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T11:08:27.607

我建议您将配置加载移动到 dll 而不是整个配置，然后从不同的应用程序中调用它。这是这样的：

1.  您无需重新编译即可更改配置数据（总是有用的）
2.  如果您将来需要再次拆分配置，这已经可以使用 dll。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T12:02:01.020

您可以将通用配置放在 Windows 注册表下，随时随地访问

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T15:35:35.017

假设您使用的是 .Net，您可以设置一个 .settings 文件来存储您的配置数据 - 其中包含的数据将作为这些配置条目的默认值存储，因此即使没有 app.config 文件，您的应用程序也会运行使用这些默认值。

我不是说这是一件好事...... 8）

因此，如果您构建一个引用您的 DLL 的项目，您将向该项目添加相同的 .settings 文件，并且这些设置将出现在应用程序的 app.config 文件中，并且 DLL 将能够读取这些值。如果这些值不在 app.config 中，则 dll 将使用默认值。

大多数人会认为这是一件坏事，我倾向于同意，但你就是这样。

# php - php - imap - 在另一个帐户上移动电子邮件

> ID：161775
> 
> 赞同：0
> 
> 时间：2008-10-02T11:13:32.290
> 
> 标签：php, email, imap

我正在编写一个下载电子邮件并将它们存储在数据库中的脚本，我通常会在这个帐户上收到数千封电子邮件，一旦下载这些邮件就会被删除。

由于偏执狂，我希望我的电子邮件至少有一个月的备份，但我不能把我的主邮箱地址弄得乱七八糟，把它们留在里面。

所以我需要将邮件（通过 php 代码）从一个邮箱移动到另一个邮箱。我想出了这个使用 imap_append() 的解决方案。但是，此解决方案会重新创建电子邮件，并且不会真正移动它。

你有什么建议或替代方法吗？

请记住：它必须在 php 中完成，因为我需要将它集成到我的 readmail 脚本中。

我已经看过这个线程[，其中提出了 fetchmail 解决方案](https://stackoverflow.com/questions/57547/imap-forwarder)

下面是我为此任务编写的代码

```
<?php
/**
* Conn params
*/

$fromMboxServerPath = "{imap.from.server/notls/imap:143}";
$fromMboxMailboxPath = "INBOX";
$fromMboxMailAddress = "login";
$fromMboxMailPass = "pass";

$toMboxServerPath = "{imap.to.server/notls/imap:143}";
$toMboxMailboxPath = "INBOX";
$toMboxMailAddress = "login";
$toMboxMailPass = "pass";

$fromMboxConnStr = $fromMboxServerPath.$fromMboxMailboxPath;
$toMboxConnStr = $toMboxServerPath.$toMboxMailboxPath;

$fetchStartSeq = 1;
$fetchEndSeq = 10;

function myLog($str)
{
    echo "Log [".date('Y-m-d H:i:s')."]: $str\n";
}

myLog("Connecting to mailbox");

function mboxConn($connstr,$addr,$pass)
{
    if(!($mbox = @imap_open($connstr, $addr, $pass)))
    {
        myLog("Error: ".imap_last_error());
        die;
    }
    else
    {
        myLog("Connected to: $addr $connstr");
        return $mbox;
    }
}

function mboxCheck($mbox)
{
    if(!($mbox_data = imap_check($mbox)))
    {
       myLog("Error: ".imap_last_error());
       die;   
    }
    else
    {
        myLog("Mailbox check ".$mbox_data->Mailbox." OK");
        myLog($mbox_data->Nmsgs." messages present");
        return $mbox_data->Nmsgs;
    }
}

$fromMbox = mboxConn($fromMboxConnStr, $fromMboxMailAddress, $fromMboxMailPass);
$toMbox = mboxConn($toMboxConnStr, $toMboxMailAddress, $toMboxMailPass);

$fromMboxCount = mboxCheck($fromMbox);
$toMboxCount = mboxCheck($toMbox);

/**
* Loop on mails
*/

$fetchStartUID = imap_uid($fromMbox,$fetchStartSeq);
if ($fromMboxCount < $fetchEndSeq)
{
    $fetchEndSeq = $fromMboxCount;
}
$fetchEndUID = imap_uid($fromMbox,$fetchEndSeq);

/**
* Loop on mails
*/

myLog("Do stuff and backup from UID [$fetchStartUID] to UID [$fetchEndUID]");

for ($i=$fetchStartSeq;$i<=$fetchEndSeq;$i++)
{
    $pfx = "Msg #$i : ";
    $h = imap_header($fromMbox, $i);
    $fh = imap_fetchheader($fromMbox, $i);
    $fb = imap_body($fromMbox, $i);
    $message = $fh.$fb;

    $msgUID = imap_uid($fromMbox,$i);

    $struct = imap_fetchstructure ($fromMbox, $i);

    /**
     * We do some logging
     */

    myLog($pfx."UID [".$msgUID."] SEQ [".imap_msgno($fromMbox,$msgUID)."] Flags: [". $h->Unseen . $h->Recent . $h->Deleted . $h->Answered . $h->Draft . $h->Flagged."]");
    myLog($pfx."From: [". htmlspecialchars($h->fromaddress) . "] To: [".htmlspecialchars($h->toaddress)."]");
    myLog($pfx."Subject: [$h->subject]");

    /**
     * Here you do whaterver you need with your email
     */

    /**
     * Backup email
     */
    if (!($ret = imap_append($toMbox,$toMboxServerPath.$toMboxMailboxPath,$message))) 
    {
        myLog("Error: ".imap_last_error());
        die;
    }
    else
    {
        myLog("everything ok, mail [$fetchStartUID:$fetchEndUID] downloaded and moved in $newMailboxNameMOVE");
    }
}

/**
* End
*/

imap_close($fromMbox);
imap_close($toMbox);

myLog("Connection closed");

?> 
```

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-07T16:07:43.473

首先，IMAP 没有仅复制的 MOVE 命令，但即使有，您也可以直接从一个 IMAP 服务器复制到另一个。

为什么不使用帐户中的子文件夹进行备份。将它们下载到您的本地计算机，然后将它们复制到子文件夹，然后从收件箱中删除它们。

COPY 和 DELETE 是 imap 服务器端命令，因此它们不必离开服务器即可进行“移动”

如果两个帐户在同一台​​服务器上，还有另一个选项，允许主帐户用户访问备份帐户的收件箱。然后您可以使用服务器端复制/删除将其移动到备份文件夹。

并非所有 IMAP 服务器都允许共享文件夹。

php 确实有一个 imap_move 函数，但我认为它会进行复制/删除。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2011-04-29T17:16:54.627

我不知道任何其他解决方案，如 PHP。

但是对于您的代码和测试，您应该使用：

```
$fromMboxServerPath = "{imap.from.server/notls/imap/readonly:143}"; //ReadOnly 
```

在 imap_append() 你应该从 emailheader 中给出日期。参见 PHP 手册： http: [//php.net/manual/en/function.imap-append.php](http://php.net/manual/en/function.imap-append.php)

之后，您将在目标 IMAP-Server 中获得邮件的 1to1 副本。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T11:20:32.587

为什么要单独的帐户以及将涉及的所有麻烦？你也不能

a) 使用标准备份工具备份邮件帐户，例如。rdiff备份？

b）在数据库中备份它们？

甚至

c）创建一个别名，以便电子邮件发送到两个帐户，并且您有不同的标准从两个帐户中删除邮件（即，将它们在备份帐户中再保留一个月）

# asp.net - 什么是 ASP.NET 应用程序的最佳 MemCache 解决方案？

> ID：161782
> 
> 赞同：1
> 
> 时间：2008-10-02T11:19:14.290
> 
> 标签：asp.net, scalability, memcached

在 Windows 服务器环境中运行的 ASP.NET 应用程序的最佳 MemCache 解决方案是什么？为什么？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T11:35:36.187

您还可以查看[Microsoft Velocity](http://code.msdn.microsoft.com/velocity)，特别是如果您所在的地方更喜欢 Microsoft 产品。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T11:23:58.477

我的情绪完全 -[我的问题](https://stackoverflow.com/questions/161106/distributed-cachesession-where-should-i-turn)

从我收集到的信息来看，[memcacheddotnet](http://sourceforge.net/projects/memcacheddotnet/)是最好的免费选项， 如果你想付费，可以[横向扩展](http://www.scaleoutsoftware.com/)

# javascript - JavaScript 是单线程的吗？如果没有，我如何获得对共享数据的同步访问？

> ID：161783
> 
> 赞同：6
> 
> 时间：2008-10-02T11:19:18.877
> 
> 标签：javascript, multithreading, browser, dhtml, simile

`DIV`我有一个带有s的网页，其中包含一个`mouseover`旨在显示弹出信息气泡的处理程序。我不希望一次显示多个信息气泡。但是当用户将鼠标快速移动到两个项目上时，有时会出现两个气泡。这不应该发生，因为显示弹出窗口的代码取消了之前的弹出窗口。

如果这是一个多线程系统，那么问题将很明显：有两个线程试图显示一个弹出窗口，它们都取消现有的弹出窗口，然后弹出自己的弹出窗口。但我假设 JavaScript 始终是单线程运行的，这会阻止这种情况。我错了吗？事件处理程序是否异步运行，在这种情况下我需要同步访问共享数据，或者我应该在库代码中寻找错误以取消弹出窗口？

编辑添加：

*   有问题的库是[SIMILE Timeline](http://code.google.com/p/simile-widgets/)及其 Ajax 库；
*   事件处理程序确实调用`SimileAjax.DOM.cancelEvent(domEvt)`了，我假设基于名称取消了事件的冒泡；
*   只是为了让事情变得更复杂，我实际上正在做的是开始一个超时，如果没有被`moustout`显示弹出窗口取消，这是为了防止弹出窗口令人讨厌地闪烁但令人讨厌地产生相反的效果。

我会再戳一下，看看我能不能找出哪里出错了。:-)

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-10-02T11:23:09.927

是的，Javascript 是单线程的。即使使用像谷歌浏览器这样的浏览器，每个标签也有一个线程。

在不知道您是如何尝试取消另一个弹出窗口的情况下，很难说出问题的原因是什么。

如果您的 DIV 相互嵌套，您可能会遇到[事件传播](http://www.google.com/search?hl=en&client=firefox-a&rls=com.ubuntu:en-US:unofficial&hs=qp1&pwst=1&sa=X&oi=spell&resnum=0&ct=result&cd=1&q=javascript+event+propagation&spell=1)问题。

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2009-05-20T05:47:39.247

我不知道您正在使用的库，但如果您只是想一次显示一个工具提示......请使用享元对象。基本上，蝇量级是制造一次并反复使用的东西。想想一个单例类。因此，您静态调用一个类，该类在第一次调用时会自动创建一个自身的对象并存储它。一种情况是，每个静态都引用同一个对象，因此您不会得到多个工具提示或冲突。

我使用 ExtJS，他们将工具提示和消息框作为享元元素。我希望你的框架也有轻量元素，否则你只需要制作自己的单例并调用它。

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T11:24:47.867

它在浏览器中是单线程的。事件处理程序在一个线程中异步运行，非阻塞并不总是意味着多线程。你的一个div是另一个的孩子吗？因为事件在 dom 树中像气泡一样从子节点传播到父节点。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-02T11:33:21.947

和 pkaeding 说的类似，不看你的标记和脚本就很难猜出问题所在；但是，我敢说您没有正确停止事件传播和/或您没有正确隐藏现有元素。我不知道您是否使用了框架，但这里有一个使用 Prototype 的可能解决方案：

```
// maintain a reference to the active div bubble
this.oActiveDivBubble = null;

// event handler for the first div
$('exampleDiv1').observe('mouseover', function(evt) {
    evt.stop();
    if(this.oActiveDivBubble ) {
        this.oActiveDivBubble .hide();
    }
    this.oActiveDivBubble = $('exampleDiv1Bubble');
    this.oActiveDivBubble .show();

}.bind(this));

// event handler for the second div
$('exampleDiv2').observe('mouseover'), function(evt) {
    evt.stop();
    if(this.oActiveDivBubble) {
        this.oActiveDivBubble.hide();
    }
    this.oActiveDivBubble = $('exampleDiv2Bubble');
    this.oActiveDivBubble .show();
}.bind(this)); 
```

当然，这可以通过获取具有相同类的所有元素、遍历它们并对每个元素应用相同的事件处理函数来进一步概括。

无论哪种方式，希望这会有所帮助。

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T12:41:08.633

仅供参考：从 Firefox 3 开始，有一个与此讨论非常相关的更改：导致同步 XMLHttpRequest 请求的执行线程被分离（这就是接口在同步请求期间不会冻结在那里的原因）并且执行继续。同步请求完成后，其线程也会继续。它们不会同时执行，但是依赖于单线程停止而同步过程（请求）发生的假设不再适用。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-02T11:32:43.337

可能是显示器刷新速度不够快。根据您使用的 JS 库，您可能可以对弹出的“显示”效果稍加延迟。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T13:24:57.530

这是工作版本，或多或少。创建项目时，我们附加一个`mouseover`事件：

```
var self = this;
SimileAjax.DOM.registerEvent(labelElmtData.elmt, "mouseover", function (elt, domEvt, target) {
    return self._onHover(labelElmtData.elmt, domEvt, evt);
}); 
```

这会调用一个设置超时的函数（不同项目的预先存在的超时首先被取消）：

```
MyPlan.EventPainter.prototype._onHover = function(target, domEvt, evt) {            
    ... calculate x and y ...
    domEvt.cancelBubble = true;
    SimileAjax.DOM.cancelEvent(domEvt);
    this._futureShowBubble(x, y, evt);

    return false;
}
MyPlan.EventPainter.prototype._futureShowBubble = function (x, y, evt) {
    if (this._futurePopup) {
        if (evt.getID() == this._futurePopup.evt.getID()) {
            return;
        } else {
            /* We had queued a different event's pop-up; this must now be cancelled. */
            window.clearTimeout(this._futurePopup.timeoutID);
        } 
    }
    this._futurePopup = {
        x: x,
        y: y,
        evt: evt
    };    
    var self = this;
    this._futurePopup.timeoutID =  window.setTimeout(function () {
            self._onTimeout();
    }, this._popupTimeout);
} 
```

如果它在被取消之前触发，这反过来会显示气泡：

```
MyPlan.EventPainter.prototype._onTimeout = function () {
    this._showBubble(this._futurePopup.x, this._futurePopup.y, this._futurePopup.evt);

};

MyPlan.EventPainter.prototype._showBubble = function(x, y, evt) {
    if (this._futurePopup) {
        window.clearTimeout(this._futurePopup.timeoutID);
        this._futurePopup = null;
    }        
    ...

    SimileAjax.WindowManager.cancelPopups();
    SimileAjax.Graphics.createBubbleForContentAndPoint(...);
}; 
```

现在这似乎可行，我将超时设置为 200 毫秒而不是 100 毫秒。不知道为什么超时太短会导致多气泡的事情发生，但我猜窗口事件的排队或在布置新添加的元素时可能仍在发生某些事情。

# c - 在 C 中按值传递结构而不是传递指针有什么缺点吗？

> ID：161788
> 
> 赞同：173
> 
> 时间：2008-10-02T11:21:13.023
> 
> 标签：c, struct, parameter-passing, abi

在 C 中按值传递结构而不是传递指针有什么缺点吗？

如果结构很大，显然存在复制大量数据的性能方面，但对于较小的结构，它应该基本上与向函数传递多个值相同。

当用作返回值时，它可能会更有趣。C 只有函数的单个返回值，但您通常需要多个。所以一个简单的解决方案是将它们放在一个结构中并返回它。

是否有任何理由支持或反对这一点？

由于我在这里谈论的内容对每个人来说可能并不明显，所以我将举一个简单的例子。

如果您使用 C 进行编程，您迟早会开始编写如下所示的函数：

```
void examine_data(const char *ptr, size_t len)
{
    ...
}

char *p = ...;
size_t l = ...;
examine_data(p, l); 
```

这不是问题。唯一的问题是您必须与您的同事商定参数的顺序，以便您在所有函数中使用相同的约定。

但是当你想返回相同类型的信息时会发生什么？你通常会得到这样的东西：

```
char *get_data(size_t *len);
{
    ...
    *len = ...datalen...;
    return ...data...;
}
size_t len;
char *p = get_data(&len); 
```

这工作正常，但问题更多。返回值是返回值，但在此实现中不是。从上面无法看出函数 get_data 不允许查看 len 指向的内容。并且没有什么可以让编译器检查一个值是否实际上是通过该指针返回的。所以下个月，当其他人在没有正确理解的情况下修改代码（因为他没有阅读文档？）它会在没有人注意到的情况下被破坏，或者它开始随机崩溃。

所以，我提出的解决方案是简单的结构

```
struct blob { char *ptr; size_t len; } 
```

示例可以这样重写：

```
void examine_data(const struct blob data)
{
    ... use data.tr and data.len ...
}

struct blob = { .ptr = ..., .len = ... };
examine_data(blob);

struct blob get_data(void);
{
    ...
    return (struct blob){ .ptr = ...data..., .len = ...len... };
}
struct blob data = get_data(); 
```

出于某种原因，我认为大多数人会本能地让 Exam_data 获取指向结构 blob 的指针，但我不明白为什么。它仍然得到一个指针和一个整数，它们在一起更清楚了。而在 get_data 的情况下，不可能像我之前描述的那样搞砸，因为长度没有输入值，并且必须有一个返回的长度。

* * *

## 回答 #1

> 赞同：221
> 
> 时间：2008-10-02T11:39:50.777

对于小型结构（例如点、矩形），按值传递是完全可以接受的。但是，除了速度之外，您应该小心按值传递/返回大型结构的另一个原因：堆栈空间。

许多 C 编程是针对嵌入式系统的，其中内存非常宝贵，堆栈大小可能以 KB 甚至字节为单位……如果您按值传递或返回结构，这些结构的副本将被放置在堆栈，可能导致[该站点](https://www.stackoverflow.com)以...命名的情况

如果我看到一个似乎有过多堆栈使用的应用程序，那么按值传递的结构是我首先要寻找的东西之一。

* * *

## 回答 #2

> 赞同：66
> 
> 时间：2008-10-03T13:45:10.207

未提及的不这样做的一个原因是，这可能会导致二进制兼容性很重要的问题。

根据使用的编译器，结构可以通过堆栈或寄存器传递，具体取决于编译器选项/实现

见： http: [//gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html](http://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html)

> -fpcc-结构返回
> 
> -freg-struct-return

如果两个编译器不同意，事情可能会爆炸。不用说，不这样做的主要原因是堆栈消耗和性能原因。

* * *

## 回答 #3

> 赞同：20
> 
> 时间：2010-07-28T17:18:17.913

要*真正*回答这个问题，需要深入挖掘组装领域：

（以下示例在 x86_64 上使用 gcc。欢迎任何人添加其他架构，如 MSVC、ARM 等）

让我们有我们的示例程序：

```
// foo.c

typedef struct
{
    double x, y;
} point;

void give_two_doubles(double * x, double * y)
{
    *x = 1.0;
    *y = 2.0;
}

point give_point()
{
    point a = {1.0, 2.0};
    return a;
}

int main()
{
    return 0;
} 
```

用完全优化编译它

```
gcc -Wall -O3 foo.c -o foo 
```

看组装：

```
objdump -d foo | vim - 
```

这是我们得到的：

```
0000000000400480 <give_two_doubles>:
    400480: 48 ba 00 00 00 00 00    mov    $0x3ff0000000000000,%rdx
    400487: 00 f0 3f 
    40048a: 48 b8 00 00 00 00 00    mov    $0x4000000000000000,%rax
    400491: 00 00 40 
    400494: 48 89 17                mov    %rdx,(%rdi)
    400497: 48 89 06                mov    %rax,(%rsi)
    40049a: c3                      retq   
    40049b: 0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)

00000000004004a0 <give_point>:
    4004a0: 66 0f 28 05 28 01 00    movapd 0x128(%rip),%xmm0
    4004a7: 00 
    4004a8: 66 0f 29 44 24 e8       movapd %xmm0,-0x18(%rsp)
    4004ae: f2 0f 10 05 12 01 00    movsd  0x112(%rip),%xmm0
    4004b5: 00 
    4004b6: f2 0f 10 4c 24 f0       movsd  -0x10(%rsp),%xmm1
    4004bc: c3                      retq   
    4004bd: 0f 1f 00                nopl   (%rax) 
```

不包括`nopl`焊盘，`give_two_doubles()`有 27 个字节，而`give_point()`有 29 个字节。另一方面，`give_point()`产生的指令比`give_two_doubles()`

有趣的是，我们注意到编译器已经能够优化`mov`成更快的 SSE2 变体[`movapd`](http://en.wikipedia.org/wiki/MOVAPD)和`movsd`. 此外，`give_two_doubles()`实际上将数据从内存中移入和移出，这会使事情变慢。

显然，其中大部分可能不适用于嵌入式环境（这是当今大多数时间 C 的竞争环境）。我不是组装向导，所以欢迎任何意见！

* * *

## 回答 #4

> 赞同：16
> 
> 时间：2008-10-02T13:04:04.383

到目前为止，这里的人们忘记提及的一件事（或者我忽略了它）是结构通常有一个填充！

```
struct {
  short a;
  char b;
  short c;
  char d;
} 
```

每个 char 为 1 个字节，每个 short 为 2 个字节。结构有多大？不，它不是 6 个字节。至少在任何更常用的系统上都没有。在大多数系统上它将是 8。问题是，对齐方式不是恒定的，它取决于系统，因此相同的结构在不同的系统上会有不同的对齐方式和不同的大小。

填充不仅会进一步消耗您的堆栈，而且还会增加无法提前预测填充的不确定性，除非您知道系统如何填充，然后查看应用程序中的每个结构并计算大小为了它。传递一个指针会占用可预测的空间量——没有不确定性。指针的大小对于系统来说是已知的，它总是相等的，无论结构是什么样的，并且指针大小总是以它们对齐且不需要填充的方式选择。

* * *

## 回答 #5

> 赞同：15
> 
> 时间：2008-10-02T11:35:22.863

简单的解决方案将返回一个错误代码作为返回值，并将其他所有内容作为函数中的参数返回，
这个参数当然可以是一个结构，但看不到通过值传递它有什么特别的优势，只是发送了一个指针。
按值传递结构是危险的，你需要非常小心你传递的是什么，记住 C 中没有复制构造函数，如果结构参数之一是指针，则指针值将被复制它可能会非常混乱且难以维持。

只是为了完成答案（完全归功于[Roddy](https://stackoverflow.com/questions/161788/passing-structs-by-value-why-not#161845)），堆栈使用是不按值传递结构的另一个原因，相信我调试堆栈溢出是真正的 PITA。

重播评论：

通过指针传递 struct 意味着某个实体对该对象拥有所有权，并且完全了解应该释放什么以及何时释放。按值传递结构会创建对结构内部数据的隐藏引用（指向另一个结构的指针等..），这很难维护（可能但为什么？）。

* * *

## 回答 #6

> 赞同：10
> 
> 时间：2011-09-26T04:47:00.483

这是没有人提到的一件事：

```
void examine_data(const char *c, size_t l)
{
    c[0] = 'l'; // compiler error
}

void examine_data(const struct blob blob)
{
    blob.ptr[0] = 'l'; // perfectly legal, quite likely to blow up at runtime
} 
```

a 的成员`const struct`是`const`，但如果该成员是指针（如`char *`），它就变成`char *const`了而不是`const char *`我们真正想要的。当然，我们可以假设这`const`是意图的文档，并且任何违反这一点的人都在编写错误的代码（他们确实如此），但这对某些人来说还不够好（尤其是那些只花了四个小时追踪原因的人）碰撞）。

另一种方法可能是制作`struct const_blob { const char *c; size_t l }`并使用它，但这相当混乱 - 它会遇到与`typedef`ing 指针相同的命名方案问题。因此，大多数人坚持只使用两个参数（或者，对于这种情况，更可能的是使用字符串库）。

* * *

## 回答 #7

> 赞同：9
> 
> 时间：2008-10-02T11:24:36.837

我想说按值传递（不太大）结构，作为参数和返回值，是一种完全合法的技术。当然，必须注意结构是 POD 类型，或者复制语义是明确指定的。

更新：抱歉，我的 C++ 思维能力已达上限。我记得有一段时间在 C 中从函数返回结构是不合法的，但从那时起这可能已经改变了。只要您希望使用的所有编译器都支持这种做法，我仍然会说它是有效的。

* * *

## 回答 #8

> 赞同：9
> 
> 时间：2008-10-02T11:26:20.653

我认为你的问题总结得很好。

按值传递结构的另一个优点是内存所有权是明确的。毫无疑问，结构是否来自堆，以及谁有责任释放它。

* * *

## 回答 #9

> 赞同：5
> 
> 时间：2011-04-21T15:19:06.450

[http://www.drpaulcarter.com/pcasm/](http://www.drpaulcarter.com/pcasm/)上的 PC Assembly Tutorial 第 150 页清楚地解释了 C 如何允许函数返回结构：

> C 还允许将结构类型用作函数的返回值。显然不能在 EAX 寄存器中返回一个结构。不同的编译器以不同的方式处理这种情况。编译器使用的一种常见解决方案是在内部将函数重写为将结构指针作为参数的函数。指针用于将返回值放入在调用的例程之外定义的结构中。

我使用下面的 C 代码来验证上面的语句：

```
struct person {
    int no;
    int age;
};

struct person create() {
    struct person jingguo = { .no = 1, .age = 2};
    return jingguo;
}

int main(int argc, const char *argv[]) {
    struct person result;
    result = create();
    return 0;
} 
```

使用“gcc -S”为这段 C 代码生成程序集：

```
 .file   "foo.c"
    .text
.globl create
    .type   create, @function
create:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $16, %esp
    movl    8(%ebp), %ecx
    movl    $1, -8(%ebp)
    movl    $2, -4(%ebp)
    movl    -8(%ebp), %eax
    movl    -4(%ebp), %edx
    movl    %eax, (%ecx)
    movl    %edx, 4(%ecx)
    movl    %ecx, %eax
    leave
    ret $4
    .size   create, .-create
.globl main
    .type   main, @function
main:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $20, %esp
    leal    -8(%ebp), %eax
    movl    %eax, (%esp)
    call    create
    subl    $4, %esp
    movl    $0, %eax
    leave
    ret
    .size   main, .-main
    .ident  "GCC: (Ubuntu 4.4.3-4ubuntu5) 4.4.3"
    .section    .note.GNU-stack,"",@progbits 
```

调用创建前的堆栈：

```
 +---------------------------+
ebp     | saved ebp                 |
        +---------------------------+
ebp-4   | age part of struct person | 
        +---------------------------+
ebp-8   | no part of struct person  |
        +---------------------------+        
ebp-12  |                           |
        +---------------------------+
ebp-16  |                           |
        +---------------------------+
ebp-20  | ebp-8 (address)           |
        +---------------------------+ 
```

调用 create 后的堆栈：

```
 +---------------------------+
        | ebp-8 (address)           |
        +---------------------------+
        | return address            |
        +---------------------------+
ebp,esp | saved ebp                 |
        +---------------------------+ 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2016-09-05T15:00:18.267

我只想指出按值传递结构的一个优点是优化编译器可以更好地优化您的代码。

# c++ - 在 C++ 中的类初始化程序中初始化 const 数组

> ID：161790
> 
> 赞同：78
> 
> 时间：2008-10-02T11:23:08.493
> 
> 标签：c++, initialization, c++03, array-initialize

我在 C++ 中有以下类：

```
class a {
    const int b[2];
    // other stuff follows

    // and here's the constructor
    a(void);
} 
```

问题是，我如何在初始化列表中初始化 b ，因为我无法在构造函数的函数体内初始化它，因为 b 是`const`？

这不起作用：

```
a::a(void) : 
    b([2,3])
{
     // other initialization stuff
} 
```

编辑：典型的例子是我可以`b`为不同的实例设置不同的值，但已知这些值在实例的生命周期内是恒定的。

* * *

## 回答 #1

> 赞同：82
> 
> 时间：2011-10-18T11:11:53.877

使用 C++11，这个问题的答案现在已经改变，您实际上可以这样做：

```
struct a {
    const int b[2];
    // other bits follow

    // and here's the constructor
    a();
};

a::a() :
    b{2,3}
{
     // other constructor work
}

int main() {
 a a;
} 
```

* * *

## 回答 #2

> 赞同：35
> 
> 时间：2008-10-02T13:52:14.437

就像其他人说的那样，ISO C++ 不支持。但是你可以解决它。只需使用 std::vector 代替。

```
int* a = new int[N];
// fill a

class C {
  const std::vector<int> v;
public:
  C():v(a, a+N) {}
}; 
```

* * *

## 回答 #3

> 赞同：25
> 
> 时间：2008-10-02T11:31:48.083

在当前标准中是不可能的。我相信您将能够使用初始化列表在 C++0x 中执行此操作（请参阅Bjarne Stroustrup[的 A Brief Look at C++0x](http://www.artima.com/cppsource/cpp0x.html)，了解有关初始化列表和其他不错的 C++0x 功能的更多信息）。

* * *

## 回答 #4

> 赞同：13
> 
> 时间：2010-04-15T04:21:07.973

`std::vector`使用堆。天哪，这只是为了进行`const`健全性检查而造成的浪费。重点`std::vector`是运行时的动态增长，而不是任何应该在编译时进行的旧语法检查。如果你不打算增长，那么创建一个类来包装一个普通数组。

```
#include <stdio.h>

template <class Type, size_t MaxLength>
class ConstFixedSizeArrayFiller {
private:
    size_t length;

public:
    ConstFixedSizeArrayFiller() : length(0) {
    }

    virtual ~ConstFixedSizeArrayFiller() {
    }

    virtual void Fill(Type *array) = 0;

protected:
    void add_element(Type *array, const Type & element)
    {
        if(length >= MaxLength) {
            // todo: throw more appropriate out-of-bounds exception
            throw 0;
        }
        array[length] = element;
        length++;
    }
};

template <class Type, size_t Length>
class ConstFixedSizeArray {
private:
    Type array[Length];

public:
    explicit ConstFixedSizeArray(
        ConstFixedSizeArrayFiller<Type, Length> & filler
    ) {
        filler.Fill(array);
    }

    const Type *Array() const {
        return array;
    }

    size_t ArrayLength() const {
        return Length;
    }
};

class a {
private:
    class b_filler : public ConstFixedSizeArrayFiller<int, 2> {
    public:
        virtual ~b_filler() {
        }

        virtual void Fill(int *array) {
            add_element(array, 87);
            add_element(array, 96);
        }
    };

    const ConstFixedSizeArray<int, 2> b;

public:
    a(void) : b(b_filler()) {
    }

    void print_items() {
        size_t i;
        for(i = 0; i < b.ArrayLength(); i++)
        {
            printf("%d\n", b.Array()[i]);
        }
    }
};

int main()
{
    a x;
    x.print_items();
    return 0;
} 
```

`ConstFixedSizeArrayFiller`并且`ConstFixedSizeArray`可以重复使用。

第一个允许在初始化数组时进行运行时边界检查（与向量可能相同），稍后可以`const`在此初始化之后进行。

第二个允许将数组分配*在*另一个对象内部，该对象可以在堆上，如果对象所在的位置，则可以简单地在堆栈上。从堆中分配不会浪费时间。它还对数组执行编译时常量检查。

`b_filler`是一个提供初始化值的小型私有类。数组的大小在编译时使用模板参数进行检查，因此不会超出范围。

我敢肯定有更多奇特的方法来修改它。这是一个初步的刺。我认为您几乎可以弥补编译器在类方面的任何缺点。

* * *

## 回答 #5

> 赞同：10
> 
> 时间：2008-10-02T11:50:26.320

ISO 标准 C++ 不允许您这样做。如果是这样，语法可能是：

```
a::a(void) :
b({2,3})
{
    // other initialization stuff
} 
```

或类似的规定。从您的问题来看，实际上您想要的是一个常量类（又名静态）成员，它是数组。C++ 确实允许您这样做。像这样：

```
#include <iostream>

class A 
{
public:
    A();
    static const int a[2];
};

const int A::a[2] = {0, 1};

A::A()
{
}

int main (int argc, char * const argv[]) 
{
    std::cout << "A::a => " << A::a[0] << ", " << A::a[1] << "\n";
    return 0;
} 
```

输出为：

```
A::a => 0, 1 
```

现在当然，因为这是一个静态类成员，所以类 A 的每个实例都是相同的。如果这不是您想要的，即您希望 A 的每个实例在数组 a 中具有不同的元素值，那么您正在制作尝试使数组 const 开始的错误。你应该这样做：

```
#include <iostream>

class A 
{
public:
    A();
    int a[2];
};

A::A()
{
    a[0] = 9; // or some calculation
    a[1] = 10; // or some calculation
}

int main (int argc, char * const argv[]) 
{
    A v;
    std::cout << "v.a => " << v.a[0] << ", " << v.a[1] << "\n";
    return 0;
} 
```

* * *

## 回答 #6

> 赞同：4
> 
> 时间：2008-10-02T11:28:35.390

你不能从初始化列表中做到这一点，

看看这个：

[http://www.cprogramming.com/tutorial/initialization-lists-c++.html](http://www.cprogramming.com/tutorial/initialization-lists-c++.html)

:)

* * *

## 回答 #7

> 赞同：4
> 
> 时间：2008-10-02T11:34:56.857

在我有一个常量数组的地方，它总是作为静态的。如果您可以接受，则此代码应编译并运行。

```
#include <stdio.h>
#include <stdlib.h>

class a {
        static const int b[2];
public:
        a(void) {
                for(int i = 0; i < 2; i++) {
                        printf("b[%d] = [%d]\n", i, b[i]);
                }
        }
};

const int a::b[2] = { 4, 2 };

int main(int argc, char **argv)
{
        a foo;
        return 0;
} 
```

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2010-05-18T22:24:27.427

不使用堆的解决方案`std::vector`是使用`boost::array`，尽管您不能直接在构造函数中初始化数组成员。

```
#include <boost/array.hpp>

const boost::array<int, 2> aa={ { 2, 3} };

class A {
    const boost::array<int, 2> b;
    A():b(aa){};
}; 
```

* * *

## 回答 #9

> 赞同：3
> 
> 时间：2011-06-10T14:52:04.573

如何通过访问器函数模拟 const 数组？它是非静态的（根据您的要求），并且不需要 stl 或任何其他库：

```
class a {
    int privateB[2];
public:
    a(int b0,b1) { privateB[0]=b0; privateB[1]=b1; }
    int b(const int idx) { return privateB[idx]; }
} 
```

因为 a::privateB 是私有的，所以它在 a:: 之外实际上是常量，您可以像访问数组一样访问它，例如

```
a aobj(2,3);    // initialize "constant array" b[]
n = aobj.b(1);  // read b[1] (write impossible from here) 
```

如果你愿意使用一对类，你可以额外保护 privateB 免受成员函数的影响。这可以通过继承a来完成；但我认为我更喜欢[使用 const 类的 John Harrison 的 comp.lang.c++ 帖子。](http://coding.derkeiler.com/Archive/C_CPP/comp.lang.cpp/2004-10/1388.html)

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2009-05-28T17:44:12.840

有趣的是，在 C# 中，关键字 const 可以转换为 C++ 的静态 const，而不是 readonly，它只能在构造函数和初始化时设置，即使是非常量，例如：

```
readonly DateTime a = DateTime.Now; 
```

我同意，如果您有一个 const 预定义数组，您不妨将其设为静态。那时你可以使用这个有趣的语法：

```
//in header file
class a{
    static const int SIZE;
    static const char array[][10];
};
//in cpp file:
const int a::SIZE = 5;
const char array[SIZE][10] = {"hello", "cruel","world","goodbye", "!"}; 
```

但是，我没有找到绕过常量“10”的方法。原因很清楚，它需要它知道如何执行对数组的访问。一种可能的替代方法是使用#define，但我不喜欢该方法，并且我在标题末尾添加了#undef，并在CPP 中编辑注释以防发生更改。

# arrays - 如何在 CakePHP 中的视图之间发送数组

> ID：161794
> 
> 赞同：0
> 
> 时间：2008-10-02T11:23:22.783
> 
> 标签：arrays, cakephp, parameters

我不确定我是否正确地提出了这个问题，但仍然......

我有一个显示 Flash 嵌入的视图，并且此 Flash 将`/controller/action`生成 XML 的 URL 作为参数。我需要从这个视图发送一个数组到 XML 生成器操作。最好的方法是什么？是否有某种`helper->set()`方法，或者我必须创建一个特定的 URL 才能将此数组发送到该操作？

这是我的结构：

**`my_controller.php`**

```
function player() {} 
```

**`player.ctp`**

```
<div id="myDiv">Here it Goes</div>
<script type="text/javascript">
  var so = new SWFObject('player.swf','test','50','50','8');
  so.addVariable('file','/xml/generate'); // need to pass an array here
  so.write('myDiv');
</script> 
```

**`xml_controller.php`**

```
public function generate() {
  // I need to read an array here
} 
```

**`generate.ctp`**

```
echo "<xml><data>" . $array['contents'] . "</data>"; 
```

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T19:01:44.163

如果数组足够小，请对其进行序列化，然后对其进行 urlencode 并将其作为参数添加到您的生成操作的 url：

播放器.ctp

```
so.addVariable('file','/xml/generate/<?php echo urlencode(serialize($array)); ?>'); 
```

然后读回来：

```
public function generate($array) {
  $array = unserialize($array);
} 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T18:56:02.693

将数组保存在会话中，然后在对 XML 生成器操作的下一个请求中，从会话中读取它。

my_controller.php

```
function player() {
  $this->Session->write('key', $array);
} 
```

xml_controller.php

```
public function generate() {
  $array = $this->Session->read('key');
} 
```

但是，我听说过一些 flash 有时不发送会话 cookie 的问题，在这种情况下，将会话 id 附加到操作的 url：

```
so.addVariable('file','/xml/generate/<?php echo $session->id(); ?>'); 
```

并恢复会话：

```
public function generate($sessionId) {
  CakeSession::id($sessionId);
  $array = $this->Session->read('key');
} 
```

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T11:41:48.887

首先，您不能以您说话的方式将数据从一个视图发送到另一个视图。这些调用中的每一个都是一个单独的请求，这意味着它会离开框架然后再次进入。这意味着框架将在调用之间构建和拆除，从而无法在视图之间传递数据。

现在关于必须发送给您的操作的数组，我完全糊涂了。我认为您没有以正确的方式看待问题。如果该操作需要一组数据然后生成 XML 以便 Flash 对象可以获取它，那么它就更没有意义了。您确定 Flash 对象不是负责将数据数组发送到您提到的参数的对象吗？

好吧，即使您所说的一切都必须像那样完成，我建议您将该数组放在文件系统上，然后在 Flash 调用该操作时将其拾取。

或者另一个建议是使用 AJAX 将该数组发送到操作。

这两个建议都暗示我对您的谓词完全“一无所知”。

我还是要问，Flash Object难道不会在这一切中有所作为吗？

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2012-03-10T12:10:38.297

您可以像这样将包含数据的数组从视图发送到 CakePHP 中的控制器。

您可以向链接传递参数：

```
www.site.com/model/action/param1:foo/param2:test 
```

然后，您可以通过以下方式在控制器操作中检索它们：

```
$yourarray = $this->params['named']; 
```

当然，数组不应该太大。

# c - 一个人的补充是一个现实世界的问题，还是只是一个历史问题？

> ID：161797
> 
> 赞同：32
> 
> 时间：2008-10-02T11:24:07.930
> 
> 标签：c, history, numerical

[另一个问题](https://stackoverflow.com/questions/160930)是关于确定 C 中的奇数/偶数，并且惯用 (x & 1) 方法被正确标记为对于[基于补码的](http://en.wikipedia.org/wiki/Signed_number_representations#Ones.27_complement)系统已损坏，这是 C 标准允许的。

系统真的存在于计算机博物馆之外的“现实世界”中吗？自 1970 年代以来我一直在编码，我很确定我从未遇到过这样的野兽。

真的有人为这样的系统开发或测试代码吗？而且，如果没有，我们应该担心这些事情还是应该将它们与纸带和穿孔卡片一起放入[101房间......？](http://en.wikipedia.org/wiki/Room_101)

* * *

## 回答 #1

> 赞同：15
> 
> 时间：2008-10-02T11:47:57.233

我在遥测领域工作，我们的一些客户拥有仍然使用 1 补码的旧模数转换器。前几天我只需要编写代码将 1 的补码转换为 2 的补码以进行补偿。

所以是的，它仍然存在（但你不会经常遇到它）。

* * *

## 回答 #2

> 赞同：13
> 
> 时间：2008-10-02T11:32:00.157

这一切都归结为了解你的根源。
是的，这在技术上是一项古老的技术，我可能会按照其他人在该问题中的建议进行操作，并使用模 (%) 运算符来确定奇数或偶数。但是了解什么是 1s 补码（或 2s 补码）总是一件好事。无论您是否使用过它们，您的 CPU 一直在处理这些事情。所以理解这个概念永远不会有坏处。现在，现代系统做到了，因此您通常不必担心类似的事情，因此它在某种程度上已成为 Programming 101 课程的主题。但是您必须记住，有些人实际上仍然会在“现实世界”中使用它……例如，与普遍看法相反，有些人*仍在使用汇编！* 不多，但在 CPU 能够理解原始 C# 和 Java 之前，仍然需要*有人理解这些东西。*

哎呀，你永远不知道什么时候你会发现自己在做一些你真正需要执行二进制数学的事情，而 1s 补码可能会派上用场。

* * *

## 回答 #3

> 赞同：10
> 
> 时间：2008-10-09T08:00:03.347

我在 80 年代使用的 CDC Cyber​​ 18 是一台 1s 补码机器，但那是近 30 年前的事了，从那以后我就再也没有见过（然而，那也是我最后一次在非 PC 上工作）

* * *

## 回答 #4

> 赞同：10
> 
> 时间：2009-12-26T06:41:46.157

RFC 791 p.14 将 IP 标头校验和定义为：

> 校验和字段是报头中所有 16 位字的反码和的 16 位反码。为了计算校验和，校验和字段的值为零。

因此，在现实世界中，在发送的每个 IP 数据包中仍然**大量使用一个补码。**:)

* * *

## 回答 #5

> 赞同：7
> 
> 时间：2008-10-02T11:30:34.887

我从来没有遇到过一个人的补码系统，而且我一直在编码，只要你有。

但我确实遇到了 9 的补码系统——HP-41c 计算器的机器语言。我承认这可以被认为是过时的，我认为他们从来没有为这些提供过 C 编译器。

* * *

## 回答 #6

> 赞同：7
> 
> 时间：2017-09-27T05:48:28.957

我决定找一个。Unisys ClearPath 系统有一个**ANSI** C 编译器（是的，他们称其为“美国国家标准 C”，甚至 PDF 文档最后一次更新是在 2013 年。该文档可[在线获取](http://public.support.unisys.com/framework/publicterms.aspx?returnurl=%2f2200%2fdocs%2fcp14.0%2fpdf%2f78310422-011.pdf)；

有符号类型都使用一个补码表示，具有以下属性：

```
Type                 | Bits | Range
---------------------+------+-----------------
signed char          |   9  |  -2⁸+1 ...  2⁸-1
signed short         |  18  | -2¹⁷+1 ... 2¹⁷-1
signed int           |  36  | -2³⁵+1 ... 2³⁵-1
signed long int      |  36  | -2³⁵+1 ... 2³⁵-1
signed long long int |  72  | -2⁷¹+1 ... 2⁷¹-1 
```

值得注意的是，它还默认支持不符合条件的`unsigned int`和`unsigned long`，范围从`0 ... 2³⁶ - 2`，但可以`0 ... 2³⁶ - 1`使用编译指示更改为 。

* * *

## 回答 #7

> 赞同：6
> 
> 时间：2008-10-02T11:36:41.300

去年某个时候，我们从 1960 年代的[Honeyboxen 下车](http://en.wikipedia.org/wiki/Honeywell)，这使它成为我们现场最古老的机器。这是二进制补码。这并不是说知道或意识到自己的补语是一件坏事。只是，你今天可能永远不会遇到互补问题，不管你在工作中做了多少计算机考古。

您更可能在整数方面遇到的问题是[字节序](http://en.wikipedia.org/wiki/Endianness)问题（我在看您[PDP](http://en.wikipedia.org/wiki/PDP-11)）。此外，与整数格式相比，[浮点](http://en.wikipedia.org/wiki/VAX) [格式](http://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture)会遇到更多的“现实世界”（即今天）问题[。](http://en.wikipedia.org/wiki/IEEE_754-2008)

* * *

## 回答 #8

> 赞同：5
> 
> 时间：2016-07-13T19:47:36.557

有趣的是，人们*在 1993 年在*[comp.std.c](https://groups.google.com/d/topic/comp.std.c/GlZeSxBnCW0) 上提出了同样的问题，*没有人能指出当时使用的补码机器*。

 **所以是的，我认为我们可以自信地说，一个人的补语属于我们历史的一个黑暗角落，实际上已经死了，不再是一个问题。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2015-08-18T23:46:25.777

> 一个人的补充是一个现实世界的问题，还是只是一个历史问题？

是的，它仍然使用。它甚至用于现代英特尔处理器。来自[英特尔® 64 和 IA-32 架构软件开发人员手册](https://www-ssl.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)2A，第 3-8 页：

> ***3.1.1.8 描述部分***
> 
> 然后通过信息部分的数量来描述每条指令。“描述”部分更详细地描述了指令的用途和所需的操作数。
> 
> 描述部分可能使用的术语摘要：
> * Legacy SSE：指 SSE、SSE2、SSE3、SSSE3、SSE4、AESNI、PCLMULQDQ 以及任何未来的指令集，这些指令集引用 XMM 寄存器并在没有 VEX 前缀的情况下进行编码。
> * VEX.vvvv。指定源或目标寄存器的 VEX 位域（以 1 的补码形式）。
> * rm_field：ModR/M r/m 字段和任何 REX.B
> 的简写 * reg_field：ModR/M reg 字段和任何 REX.R 的简写

# git - 如何解决 Git 存储库中的合并冲突？

> ID：161813
> 
> 赞同：5164
> 
> 时间：2008-10-02T11:31:05.777
> 
> 标签：git, git-merge, merge-conflict-resolution, git-merge-conflict

我想解决我的**Git**存储库中的合并冲突。

我怎样才能做到这一点？

* * *

## 回答 #1

> 赞同：3237
> 
> 时间：2008-10-02T17:50:25.100

尝试：`git mergetool`

它会打开一个 GUI，引导您完成每个冲突，您可以选择如何合并。有时它需要在之后进行一些手工编辑，但通常它本身就足够了。这肯定比手动完成整个事情要好得多。

根据[Josh Glover 的评论](https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git-repository#comment6881558_163659)：

命令

> 除非您安装 GUI，否则不一定会打开 GUI。为我跑步`git mergetool`导致`vimdiff`被使用。您可以安装以下工具之一来使用它：`meld`, `opendiff`, `kdiff3`, `tkdiff`, `xxdiff`, `tortoisemerge`, `gvimdiff`, `diffuse`, `ecmerge`, `p4merge`, `araxis`, `vimdiff`, `emerge`.

以下是`vimdiff`用于解决合并冲突的示例过程。基于[此链接](http://www.rosipov.com/blog/use-vimdiff-as-git-mergetool/#fromHistor)

**第 1 步**：在终端中运行以下命令

```
git config merge.tool vimdiff
git config merge.conflictstyle diff3
git config mergetool.prompt false 
```

这会将 vimdiff 设置为默认的合并工具。

**第 2 步**：在终端中运行以下命令

```
git mergetool 
```

**第 3 步**：您将看到以下格式的 vimdiff 显示

```
 ╔═══════╦══════╦════════╗
  ║       ║      ║        ║
  ║ LOCAL ║ BASE ║ REMOTE ║
  ║       ║      ║        ║
  ╠═══════╩══════╩════════╣
  ║                       ║
  ║        MERGED         ║
  ║                       ║
  ╚═══════════════════════╝ 
```

这4个视图是

> LOCAL - 这是来自当前分支的文件

> BASE - 共同祖先，文件在两次更改之前的样子

> REMOTE - 您正在合并到您的分支的文件

> MERGED - 合并结果，这是保存在 repo 中的内容

`ctrl`您可以使用+在这些视图之间导航`w`。`ctrl`您可以使用+`w`后跟直接到达 MERGED 视图`j`。

关于 vimdiff 导航的更多信息在[这里](https://stackoverflow.com/questions/4556184/vim-move-window-left-right)和[这里](https://stackoverflow.com/questions/27151456/how-do-i-jump-to-the-next-prev-diff-in-git-difftool)。

**第 4 步**。您可以通过以下方式编辑 MERGED 视图

如果您想从 REMOTE 获取更改

```
:diffg RE 
```

如果您想从 BASE 获取更改

```
:diffg BA 
```

如果您想从 LOCAL 获取更改

```
:diffg LO 
```

**步骤 5**。保存、退出、提交和清理

`:wqa`保存并退出vi

`git commit -m "message"`

`git clean`删除 diff 工具创建的额外文件（例如 *.orig）。

* * *

## 回答 #2

> 赞同：1765
> 
> 时间：2010-08-04T17:04:57.563

这是一个可能的用例，从顶部开始：

您将进行一些更改，但是糟糕，您不是最新的：

```
git fetch origin
git pull origin master

From ssh://gitosis@example.com:22/projectname
 * branch            master     -> FETCH_HEAD
Updating a030c3a..ee25213
error: Entry 'filename.c' not uptodate. Cannot merge. 
```

所以你得到最新的，然后再试一次，但有一个冲突：

```
git add filename.c
git commit -m "made some wild and crazy changes"
git pull origin master

From ssh://gitosis@example.com:22/projectname
 * branch            master     -> FETCH_HEAD
Auto-merging filename.c
CONFLICT (content): Merge conflict in filename.c
Automatic merge failed; fix conflicts and then commit the result. 
```

所以你决定看看这些变化：

```
git mergetool 
```

哦，我的，哦，我的，上游改变了一些东西，但只是为了使用我的改变......不......他们的改变......

```
git checkout --ours filename.c
git checkout --theirs filename.c
git add filename.c
git commit -m "using theirs" 
```

然后我们尝试最后一次

```
git pull origin master

From ssh://gitosis@example.com:22/projectname
 * branch            master     -> FETCH_HEAD
Already up-to-date. 
```

达达！

* * *

## 回答 #3

> 赞同：772
> 
> 时间：2011-09-28T21:08:22.960

我发现合并工具很少能帮助我理解冲突或解决方案。我通常更成功地在文本编辑器中查看冲突标记并使用 git log 作为补充。

这里有一些提示：

# 提示一

我发现最好的方法是使用“diff3”合并冲突样式：

`git config merge.conflictstyle diff3`

这会产生这样的冲突标记：

```
<<<<<<<
Changes made on the branch that is being merged into. In most cases,
this is the branch that I have currently checked out (i.e. HEAD).
|||||||
The common ancestor version.
=======
Changes made on the branch that is being merged in. This is often a 
feature/topic branch.
>>>>>>> 
```

中间部分是共同祖先的样子。这很有用，因为您可以将其与顶部和底部版本进行比较，以更好地了解每个分支上的更改内容，从而更好地了解每个更改的目的。

如果冲突只有几行，这通常会使冲突非常明显。（知道如何解决冲突是非常不同的；你需要知道其他人在做什么。如果你感到困惑，最好把那个人叫到你的房间，这样他们就可以看到你在看什么在。）

如果冲突时间较长，那么我会将三个部分分别剪切并粘贴到三个单独的文件中，例如“mine”、“common”和“theirs”。

然后我可以运行以下命令来查看导致冲突的两个差异块：

```
diff common mine
diff common theirs 
```

这与使用合并工具不同，因为合并工具也会包含所有不冲突的差异数据块。我觉得这让人分心。

# 提示二

已经有人提到了这一点，但是了解每个 diff hunk 背后的意图通常对于了解冲突的来源以及如何处理它非常有帮助。

```
git log --merge -p <name of file> 
```

这显示了在共同祖先和您要合并的两个头之间触及该文件的所有提交。（因此它不包括合并之前两个分支中已经存在的提交。）这可以帮助您忽略明显不是当前冲突因素的差异大块。

# 提示三

使用自动化工具验证您的更改。

如果您有自动化测试，请运行它们。如果您有[lint](https://en.wikipedia.org/wiki/Lint_%28software%29)，请运行它。如果它是一个可构建的项目，则在提交之前构建它，等等。在所有情况下，您都需要进行一些测试以确保您的更改不会破坏任何东西。（哎呀，即使没有冲突的合并也会破坏工作代码。）

# 提示四

未雨绸缪; 与同事沟通。

提前计划并了解其他人正在做什么可以帮助防止合并冲突和/或帮助更早地解决它们 - 而细节仍然是新鲜的。

例如，如果您知道您和另一个人都在进行不同的重构，这些重构都会影响同一组文件，那么您应该提前互相交谈，并更好地了解你们每个人的更改类型制造。如果您按顺序而不是并行进行计划更改，您可能会节省大量时间和精力。

对于涉及大量代码的重大重构，您应该强烈考虑按顺序工作：每个人都停止在代码的该区域工作，而一个人执行完整的重构。

如果您不能连续工作（可能是由于时间压力），那么就预期的合并冲突进行沟通至少可以帮助您在细节仍然记忆犹新的情况下更快地解决问题。例如，如果一个同事在一周内进行了一系列破坏性的提交，您可以选择在该周内每天一次或两次在该同事分支上合并/rebase。这样，如果你确实发现了合并/变基冲突，你可以更快地解决它们，而不是等待几周将所有内容合并到一个大块中。

# 提示五

如果您不确定合并，请不要强行合并。

合并可能会让人感到不知所措，尤其是当有很多冲突文件并且冲突标记覆盖数百行时。通常在估算软件项目时，我们没有足够的时间来处理诸如处理复杂合并之类的开销项目，因此花几个小时剖析每个冲突感觉真的很累。

从长远来看，提前计划并了解其他人正在做什么是预测合并冲突并准备在更短的时间内正确解决它们的最佳工具。

* * *

## 回答 #4

> 赞同：364
> 
> 时间：2008-10-02T12:41:36.510

1.  确定哪些文件存在冲突（Git 应该告诉你这一点）。

2.  打开每个文件并检查差异；Git 对它们进行了划分。希望保留每个块的哪个版本是显而易见的。您可能需要与提交代码的其他开发人员讨论它。

3.  一旦你解决了文件中的冲突`git add the_file`。

4.  解决**所有**冲突后，执行`git rebase --continue`Git 完成时要求执行的任何命令。

* * *

## 回答 #5

> 赞同：123
> 
> 时间：2015-08-05T14:29:48.680

当同时对文件进行更改时，会发生合并冲突。以下是如何解决它。

## `git`命令行界面

以下是当您进入冲突状态时要执行的简单步骤：

1.  请注意冲突文件列表：（`git status`在`Unmerged paths`部分下）。
2.  通过以下方法之一分别解决每个文件的冲突：

    *   使用 GUI 解决冲突：（`git mergetool`最简单的方法）。

    *   要接受远程/其他版本，请使用：`git checkout --theirs path/file`. 这将拒绝您对该文件所做的任何本地更改。

    *   要接受本地/我们的版本，请使用：`git checkout --ours path/file`

        ^(但是，您必须小心，因为远程更改冲突是出于某种原因进行的。)

        相关：[git中“我们的”和“他们的”的确切含义是什么？](https://stackoverflow.com/q/25576415/55075)

    *   手动编辑冲突文件并在`<<<<<`/之间查找代码块，`>>>>>`然后从上面或下面选择版本`=====`。请参阅：[如何呈现冲突](http://git-scm.com/docs/git-merge#_how_conflicts_are_presented)。

    *   路径和文件名冲突可以通过`git add`/解决`git rm`。

3.  最后，使用以下命令查看准备提交的文件：`git status`.

    如果您仍然有任何文件`Unmerged paths`，并且您确实手动解决了冲突，那么让 Git 知道您通过以下方式解决了它`git add path/file`：

4.  如果所有冲突都已成功解决，请通过以下方式提交更改：`git commit -a`并像往常一样推送到远程。

另请参阅：从GitHub[的命令行解决合并冲突](https://help.github.com/articles/resolving-a-merge-conflict-from-the-command-line/)

有关实用教程，请查看：[Scenario 5 - Fixing Merge Conflicts by Katacoda](https://www.katacoda.com/courses/git/5)。

## 差异合并

我已经成功使用[DiffMerge](https://sourcegear.com/diffmerge/)，它可以在 Windows、macOS 和 Linux/Unix 上直观地比较和合并文件。

它可以以图形方式显示 3 个文件之间的更改，并允许自动合并（在安全的情况下）和对编辑结果文件的完全控制。

[![差异合并](https://i.stack.imgur.com/tAURE.png)](https://i.stack.imgur.com/tAURE.png)

^(图片来源：[DiffMerge](https://sourcegear.com/diffmerge/)（Linux 截图）)

只需下载它并在 repo 中运行：

```
git mergetool -t diffmerge . 
```

* * *

### 苹果系统

在 macOS 上，您可以通过以下方式安装：

```
brew install caskroom/cask/brew-cask
brew cask install diffmerge 
```

并且可能（如果未提供）您需要在 PATH 中放置以下额外的简单包装器（例如`/usr/bin`）：

```
#!/bin/sh
DIFFMERGE_PATH=/Applications/DiffMerge.app
DIFFMERGE_EXE=${DIFFMERGE_PATH}/Contents/MacOS/DiffMerge
exec ${DIFFMERGE_EXE} --nosplash "$@" 
```

然后，您可以使用以下键盘快捷键：

*   `⌘</kbd>-`Alt`-`Up`/`Down` to jump to previous/next changes.`
*   `⌘</kbd>-`Alt`-`Left`/`Right` to accept change from left or right`

或者，您可以使用[opendiff](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/opendiff.1.html)（Xcode 工具的一部分），它允许您将两个文件或目录合并在一起以创建第三个文件或目录。

* * *

## 回答 #6

> 赞同：111
> 
> 时间：2008-10-03T15:15:07.637

查看 Stack Overflow 问题*[Aborting a merge in Git](https://stackoverflow.com/questions/101752/aborting-a-merge-in-git)*中的答案，尤其是[Charles Bailey 的答案](https://stackoverflow.com/questions/101752/aborting-a-merge-in-git#107860)，它显示了如何查看有问题的文件的不同版本，例如，

```
# Common base version of the file.
git show :1:some_file.cpp

# 'Ours' version of the file.
git show :2:some_file.cpp

# 'Theirs' version of the file.
git show :3:some_file.cpp 
```

* * *

## 回答 #7

> 赞同：82
> 
> 时间：2008-10-02T16:11:18.143

如果您经常进行小型提交，请先查看带有`git log --merge`. 然后`git diff`将向您展示冲突。

对于涉及多行的冲突，更容易查看外部 GUI 工具中发生的情况。我喜欢 opendiff——Git 还支持 vimdiff、gvimdiff、kdiff3、tkdiff、meld、xxdiff、emerge 开箱即用，您可以安装其他工具：`git config merge.tool "your.tool"`将设置您选择的工具，然后`git mergetool`在合并失败后将在上下文中显示差异。

每次您编辑文件以解决冲突时，`git add filename`都会更新索引并且您的差异将不再显示它。当所有的冲突都得到处理并且它们的文件已经被`git add`编辑后，`git commit`将完成你的合并。

* * *

## 回答 #8

> 赞同：54
> 
> 时间：2016-09-29T13:02:01.233

我要么想要我的或他们的完整版本，要么想要查看个别更改并为每个更改做出决定。

**完全接受我或他们的版本**：

接受我的版本（本地，我们的）：

```
git checkout --ours -- <filename>
git add <filename>              # Marks conflict as resolved
git commit -m "merged bla bla"  # An "empty" commit 
```

接受他们的版本（远程，他们的）：

```
git checkout --theirs -- <filename>
git add <filename>
git commit -m "merged bla bla" 
```

如果要**对所有冲突文件**执行以下操作：

```
git merge --strategy-option ours 
```

或者

```
git merge --strategy-option theirs 
```

**查看所有更改并单独接受**

1.  `git mergetool`
2.  查看更改并接受每个版本的任一版本。
3.  `git add <filename>`
4.  `git commit -m "merged bla bla"`

默认`mergetool`在**命令行**中工作。如何使用命令行合并工具应该是一个单独的问题。

您还可以为此安装**可视化工具**，例如`meld`并运行

```
git mergetool -t meld 
```

它将打开本地版本（我们的）、“基础”或“合并”版本（合并的当前结果）和远程版本（他们的）。完成后保存合并的版本，`git mergetool -t meld`再次运行，直到出现“没有文件需要合并”，然后转到步骤 3 和 4。

* * *

## 回答 #9

> 赞同：50
> 
> 时间：2013-07-14T18:34:47.100

请参阅[如何呈现冲突](https://www.kernel.org/pub/software/scm/git/docs/git-merge.html#_how_conflicts_are_presented)或在 Git 中的`git merge`文档以了解什么是合并冲突标记。

此外，[如何解决冲突](https://www.kernel.org/pub/software/scm/git/docs/git-merge.html#_how_to_resolve_conflicts)部分解释了如何解决冲突：

> 看到冲突后，您可以做两件事：
> 
> *   决定不合并。您需要的唯一清理是将索引文件重置`HEAD`为反向提交 2\. 并清理 2\. 和 3\. 所做的工作树更改；`git merge --abort`可用于此。
>     
>     
> *   解决冲突。Git 将标记工作树中的冲突。将文件编辑成形状并将`git add`它们编辑到索引中。用来敲定`git commit`交易。
>     
>     
> 
> 您可以使用多种工具解决冲突：
> 
> *   使用合并工具。`git mergetool`启动图形合并工具，它将帮助您完成合并。
>     
>     
> *   看看差异。`git diff`将显示三向差异，突出显示`HEAD`和`MERGE_HEAD`版本的更改。
>     
>     
> *   查看每个分支的差异。`git log --merge -p <path>`将首先显示`HEAD`版本的差异，然后显示`MERGE_HEAD`版本。
>     
>     
> *   看看原件。`git show :1:filename`显示共同祖先，`git show :2:filename`显示`HEAD`版本，`git show :3:filename`显示`MERGE_HEAD`版本。

[您还可以在Pro Git](http://git-scm.com/book)书籍部分[Basic Merge Conflicts](http://git-scm.com/book/ch3-2.html#Basic-Merge-Conflicts)中阅读有关合并冲突标记以及如何解决它们的信息。

* * *

## 回答 #10

> 赞同：42
> 
> 时间：2013-02-22T23:04:53.277

对于想要半手动解决合并冲突的[Emacs用户：](http://en.wikipedia.org/wiki/Emacs)

```
git diff --name-status --diff-filter=U 
```

显示所有需要解决冲突的文件。

一个一个地打开每个文件，或者一次打开所有文件：

```
emacs $(git diff --name-only --diff-filter=U) 
```

在 Emacs 中访问需要编辑的缓冲区时，键入

```
ALT+x vc-resolve-conflicts 
```

这将打开三个缓冲区（我的、他们的和输出缓冲区）。按“n”（下一个区域）、“p”（预置区域）进行导航。按“a”和“b”分别将我的或他们的区域复制到输出缓冲区。和/或直接编辑输出缓冲区。

完成后：按“q”。Emacs 询问您是否要保存此缓冲区：是的。完成缓冲区后，通过从终端运行将其标记为已解决：

```
git add FILENAME 
```

完成所有缓冲区类型后

```
git commit 
```

完成合并。

* * *

## 回答 #11

> 赞同：37
> 
> 时间：2015-12-25T15:24:07.393

### 奖金：

在谈到之前答案中的拉/取/合并时，我想分享一个有趣且富有成效的技巧，

# **`git pull --rebase`**

上面这个命令是我 Git 生活中最有用的命令，它节省了很多时间。

在将新提交的更改推送到远程服务器之前，请尝试`git pull --rebase`手动`git pull`操作`merge`，它会自动同步最新的远程服务器更改（使用 fetch + merge）并将本地最新提交放在 Git 日志的顶部。无需担心手动拉/合并。

如果发生冲突，只需使用

```
git mergetool
git add conflict_file
git rebase --continue 
```

在以下位置查找详细信息：*[“git pull –rebase”是做什么的？](http://gitolite.com/git-pull--rebase)*

* * *

## 回答 #12

> 赞同：35
> 
> 时间：2016-01-26T17:42:46.997

简单地说，如果您很清楚其中一个存储库中的更改并不重要，并且想要解决所有更改以支持另一个存储库，请使用：

```
git checkout . --ours 
```

解决有利于**您的存储库**的更改，或

```
git checkout . --theirs 
```

解决有利于**其他或主存储库**的更改。

否则，您将不得不使用 GUI 合并工具逐个遍历文件，例如合并工具是`p4merge`，或者写下您已经安装的任何人的名字

```
git mergetool -t p4merge 
```

完成一个文件后，您必须保存并关闭，以便打开下一个文件。

* * *

## 回答 #13

> 赞同：33
> 
> 时间：2015-04-16T07:02:03.280

请按照以下步骤修复 Git 中的合并冲突：

1.  检查 Git 状态： ***git status***

2.  获取补丁集： ***git fetch***（从你的 Git 提交中签出正确的补丁）

3.  签出本地分支（此处为 temp1）： ***git checkout -b temp1***

4.  从 master 拉取最近的内容： ***git pull --rebase origin master***

5.  启动合并工具并检查冲突并修复它们......并使用当前分支检查远程分支中的更改： ***git mergetool***

6.  再次检查状态： ***git status***

7.  删除mergetool本地创建的不需要的文件，通常mergetool会创建带有*.orig扩展名的额外文件。请删除该文件，因为它只是重复的并在本地修复更改并添加正确版本的文件。 ***git add #your_changed_correct_files***

8.  再次检查状态： ***git status***

9.  将更改提交到相同的提交 ID（这避免了新的单独补丁集）： ***git commit --amend***

10.  推送到主分支： ***git push***（到您的 Git 存储库）

* * *

## 回答 #14

> 赞同：33
> 
> 时间：2017-06-23T14:38:06.647

分为三个步骤：

1.  通过命令查找哪些文件导致冲突

    ```
     git status 
    ```

2.  检查文件，您会在其中找到标记为的冲突

    ```
     <<<<<<<<head
     blablabla 
    ```

3.  将其更改为您想要的方式，然后使用命令提交

    ```
     git add solved_conflicts_files
     git commit -m 'merge msg' 
    ```

* * *

## 回答 #15

> 赞同：30
> 
> 时间：2014-01-25T16:17:01.463

CoolAJ86 的回答几乎概括了一切。如果您在同一段代码中对两个分支进行了更改，则必须进行手动合并。在任何文本编辑器中打开冲突文件，您应该会看到以下结构。

```
(Code not in Conflict)
>>>>>>>>>>>
(first alternative for conflict starts here)
Multiple code lines here
===========
(second alternative for conflict starts here)
Multiple code lines here too    
<<<<<<<<<<<
(Code not in conflict here) 
```

以您希望新代码的方式选择一个替代方案或两者的组合，同时删除等号和尖括号。

```
git commit -a -m "commit message"
git push origin master 
```

* * *

## 回答 #16

> 赞同：29
> 
> 时间：2013-04-19T01:08:18.483

正如其他人所详述的那样，您可以通过多种方式修复合并冲突。

我认为真正的关键是了解本地和远程存储库的变化是如何流动的。关键是理解跟踪分支。我发现我认为跟踪分支是我的本地实际文件目录和定义为源的远程目录之间的“中间缺失的部分”。

我个人已经养成了两件事来帮助避免这种情况的习惯。

代替：

```
git add .
git commit -m"some msg" 
```

这有两个缺点 -

a) 添加所有新的/更改的文件，其中可能包括一些不需要的更改。
b) 您没有先查看文件列表。

所以我这样做：

```
git add file,file2,file3...
git commit # Then type the files in the editor and save-quit. 
```

这样，您可以更仔细地考虑添加哪些文件，并且您还可以查看列表并在使用消息编辑器时进行更多思考。我发现当我使用全屏编辑器而不是`-m`选项时，它也会改善我的提交消息。

[更新 - 随着时间的流逝，我已经切换到：

```
git status # Make sure I know whats going on
git add .
git commit # Then use the editor 
```

]

另外（并且与您的情况更相关），我尽量避免：

```
git pull 
```

或者

```
git pull origin master. 
```

因为 pull 意味着合并，如果您在本地有不想合并的更改，您很容易以合并代码和/或不应该合并的代码的合并冲突告终。

相反，我尝试做

```
git checkout master
git fetch   
git rebase --hard origin/master # or whatever branch I want. 
```

您可能还会发现这很有帮助：

[git branch、fork、fetch、merge、rebase 和 clone，有什么区别？](https://stackoverflow.com/questions/3329943/git-branch-fork-fetch-merge-rebase-and-clone-what-are-the-differences/9204499#9204499)

* * *

## 回答 #17

> 赞同：26
> 
> 时间：2014-08-18T19:42:40.470

如果要从分支合并`test`到`master`，可以按照以下步骤操作：

**第一步**：去分行

```
git checkout test 
```

**第 2 步**：

```
git pull --rebase origin master 
```

**第三步**：如果有冲突，到这些文件去修改。

**第 4 步**：添加这些更改

```
git add #your_changes_files 
```

**第 5 步**：

```
git rebase --continue 
```

**步骤 6**：如果仍然存在冲突，请再次返回步骤 3。如果没有冲突，请执行以下操作：

```
git push origin +test 
```

**第7步**：然后test和master之间就没有冲突了。您可以直接使用合并。

* * *

## 回答 #18

> 赞同：19
> 
> 时间：2016-11-30T19:51:37.433

### 使用`patience`

对于大的合并冲突，使用`patience`为我提供了很好的结果。它将尝试匹配块而不是单个行。

例如，如果您更改程序的缩进，默认的 Git 合并策略有时会匹配`{`属于不同函数的单个大括号。这可以避免`patience`：

```
git merge -s recursive -X patience other-branch 
```

从文档中：

```
With this option, merge-recursive spends a little extra time to avoid 
mismerges that sometimes occur due to unimportant matching lines 
(e.g., braces from distinct functions). Use this when the branches to 
be merged have diverged wildly. 
```

### 与共同祖先的比较

如果您有合并冲突并想看看其他人在修改他们的分支时的想法，有时将他们的分支直接与共同的祖先（而不是我们的分支）进行比较更容易。为此，您可以使用`merge-base`：

```
git diff $(git merge-base <our-branch> <their-branch>) <their-branch> 
```

通常，您只想查看特定文件的更改：

```
git diff $(git merge-base <our-branch> <their-branch>) <their-branch> <file> 
```

* * *

## 回答 #19

> 赞同：18
> 
> 时间：2014-12-11T15:19:55.277

```
git log --merge -p [[--] path] 
```

似乎并不总是对我有用，并且通常最终显示两个分支之间不同的每个提交，即使使用`--`将路径与命令分开也会发生这种情况。

我要解决此问题的方法是打开两个命令行并一次运行

```
git log ..$MERGED_IN_BRANCH --pretty=full -p [path] 
```

而在另一个

```
git log $MERGED_IN_BRANCH.. --pretty=full -p [path] 
```

`$MERGED_IN_BRANCH`用我合并的分支和`[path]`有冲突的文件替换。此命令将以补丁形式记录 ( `..`) 两次提交之间的所有提交。如果您像上面的命令一样将一侧留空，git 将自动使用`HEAD`（在这种情况下您要合并到的分支）。

这将允许您查看两个分支在分歧后进入文件的提交。它通常使解决冲突变得容易得多。

* * *

## 回答 #20

> 赞同：17
> 
> 时间：2017-01-09T19:45:15.063

截至 2016 年 12 月 12 日，您可以**在 github.com 上合并分支并解决冲突**

因此，如果您不想使用*旧答案中提供的命令行或任何第 3 方工具*，请使用 GitHub 的本机工具。

[这篇博](https://github.com/blog/2293-resolve-simple-merge-conflicts-on-github)文进行了详细解释，但基本原理是，通过 UI “合并”两个分支后，您现在将看到一个“解决冲突”选项，该选项将带您进入允许您处理这些合并冲突的编辑器。

[![在此处输入图像描述](https://i.stack.imgur.com/1YX5P.gif)](https://i.stack.imgur.com/1YX5P.gif)

* * *

## 回答 #21

> 赞同：15
> 
> 时间：2016-06-18T05:29:19.257

合并冲突可能发生在不同的情况下：

*   运行时`git fetch`然后`git merge`
*   运行时`git fetch`然后`git rebase`
*   运行时`git pull`（实际上等于上述条件之一）
*   跑步时`git stash pop`
*   当您应用 git 补丁时（导出到要传输的文件的提交，例如，通过电子邮件）

您需要安装与 Git 兼容的合并工具来解决冲突。我个人使用[KDiff3](http://kdiff3.sourceforge.net/)，我发现它很好用而且很方便。您可以在此处下载其 Windows 版本：

[https://sourceforge.net/projects/kdiff3/files/](https://sourceforge.net/projects/kdiff3/files/)

顺便说一句，如果你安装了 Git Extensions，它的设置向导中有一个选项可以安装 Kdiff3。

然后设置 Git 配置以使用 KDiff3 作为其合并工具：

```
$ git config --global --add merge.tool kdiff3
$ git config --global --add mergetool.kdiff3.path "C:/Program Files/KDiff3/kdiff3.exe"
$ git config --global --add mergetool.kdiff3.trustExitCode false

$ git config --global --add diff.guitool kdiff3
$ git config --global --add difftool.kdiff3.path "C:/Program Files/KDiff3/kdiff3.exe"
$ git config --global --add difftool.kdiff3.trustExitCode false 
```

（记得用KDiff3 EXE文件的实际路径替换路径。）

然后每次遇到合并冲突时，只需运行以下命令：

```
$ git mergetool 
```

然后它打开 Kdiff3，并首先尝试自动解决合并冲突。大多数冲突会自发解决，您需要手动修复其余冲突。

这是 Kdiff3 的样子：

[![在此处输入图像描述](https://i.stack.imgur.com/Xw3nw.png)](https://i.stack.imgur.com/Xw3nw.png)

然后一旦你完成，保存文件，它会转到下一个有冲突的文件，你再次做同样的事情，直到所有的冲突都得到解决。

要检查所有内容是否合并成功，只需再次运行 mergetool 命令。你应该得到这个结果：

```
$ git mergetool
No files need merging 
```

* * *

## 回答 #22

> 赞同：14
> 
> 时间：2015-02-12T04:25:58.150

我总是按照以下步骤来避免冲突。

*   `git checkout master`（来到master分支）
*   `git pull`（更新你的主人以获得最新的代码）
*   `git checkout -b mybranch`（检查一个新的分支并开始在该分支上工作，以便您的主干始终保持在主干的顶部。）
*   `git add .` *和* *git push*（在您更改后的本地分支上`git commit` *）*
**   `git checkout master`（回到你的主人那里）*

 *现在，您可以做同样的事情并维护您想要的多个本地分支，并且只需`git checkout`在必要时对您的分支执行一个操作即可同时工作。

* * *

## 回答 #23

> 赞同：9
> 
> 时间：2019-01-05T18:33:46.963

## 适用于 Visual Studio 代码的 GitLens

您可以尝试[使用 GitLens](https://github.com/eamodio/vscode-gitlens) for Visual Studio Code。主要特点是：

### 3\. 轻松解决冲突

我已经喜欢这个功能了：

[![在此处输入图像描述](https://i.stack.imgur.com/4YBdY.png)](https://i.stack.imgur.com/4YBdY.png)

### 2\. 当前线责。

[![在此处输入图像描述](https://i.stack.imgur.com/LuqoC.png)](https://i.stack.imgur.com/LuqoC.png)

### 3\. 天沟责备

[![在此处输入图像描述](https://i.stack.imgur.com/giS9K.png)](https://i.stack.imgur.com/giS9K.png)

### 4.状态栏责备

[![在此处输入图像描述](https://i.stack.imgur.com/ZO7pm.png)](https://i.stack.imgur.com/ZO7pm.png)

并且有很多特点。你可以[在这里](https://github.com/eamodio/vscode-gitlens)查看它们。

* * *

## 回答 #24

> 赞同：8
> 
> 时间：2017-10-16T06:01:29.347

这个答案是为像我这样喜欢在编辑器中做所有事情的 Vim 用户添加一个替代方案。

* * *

### TL;博士

[![在此处输入图像描述](https://i.stack.imgur.com/iW2iC.gif)](https://i.stack.imgur.com/iW2iC.gif)

* * *

*Tpope*为 Vim 提出了这个很棒的插件，叫做[fugitive](https://github.com/tpope/vim-fugitive)。安装后，您可以运行`:Gstatus`检查有冲突的文件，并`:Gdiff`以三向合并方式打开 Git。

一旦进入三路合并，*fugitive*将让您以下列方式获取您正在合并的任何分支的更改：

*   `:diffget //2`，从原始（*HEAD*）分支获取更改：
*   `:diffget //3`，从合并分支获取更改：

完成文件合并后，输入`:Gwrite`合并的缓冲区。

Vimcasts 发布[了一个很棒的视频](http://vimcasts.org/episodes/fugitive-vim-resolving-merge-conflicts-with-vimdiff/)，详细解释了这些步骤。

* * *

## 回答 #25

> 赞同：7
> 
> 时间：2021-02-09T11:24:09.860

我明白什么是合并冲突，但是当我看到 的输出时`git diff`，起初对我来说似乎是无稽之谈：

```
git diff
++<<<<<<< HEAD
 + display full last name boolean in star table
++=======
+ users viewer.id/star.id, and conversation uses user.id
+
++>>>>>>> feat/rspec-tests-for-cancancan 
```

但这[对](https://www.youtube.com/watch?v=JtIX3HJKwfo#t=3m45s)我有帮助：

*   **`<<<<<<<`和之间的所有`=======`内容都是一个文件中的内容**，并且

*   **`=======`和之间的所有`>>>>>>>`内容都是另一个文件中的内容**

*   因此，从字面上看，您所要做的就是打开存在合并冲突的文件，然后从任一分支中删除这些行（或者只是使它们相同），然后`merge`就会立即成功。问题解决了！

* * *

## 回答 #26

> 赞同：5
> 
> 时间：2017-07-05T13:25:30.940

```
git fetch <br>
git checkout **your branch**<br>
git rebase master<br> 
```

在此步骤中，您将尝试使用首选 IDE 修复冲突。

您可以按照[此链接](https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/)检查如何修复文件中的冲突。

```
git add<br>
git rebase --continue<br>
git commit --amend<br>
git push origin HEAD:refs/drafts/master  (push like a drafts)<br> 
```

现在一切都很好，你会在[Gerrit](https://en.wikipedia.org/wiki/Gerrit_(software))中找到你的提交。

* * *

## 回答 #27

> 赞同：4
> 
> 时间：2019-10-02T06:53:35.250

我正在使用 Microsoft 的 Visual Studio Code 来解决冲突。使用起来非常简单。我在工作区中保持我的项目打开。它检测并突出显示冲突。此外，它提供了 GUI 选项来选择我想从 HEAD 保留或传入的任何更改。

[![在此处输入图像描述](https://i.stack.imgur.com/RXgnQ.png)](https://i.stack.imgur.com/RXgnQ.png)

* * *

## 回答 #28

> 赞同：3
> 
> 时间：2016-12-29T16:46:35.800

解决冲突的一种更安全的方法是使用[git-mediate](https://github.com/Peaker/git-mediate)（这里建议的常见解决方案很容易出错，恕我直言）。

有关如何使用它的快速介绍，请参阅[这篇文章。](https://medium.com/@yairchu/how-git-mediate-made-me-stop-fearing-merge-conflicts-and-start-treating-them-like-an-easy-game-of-a2c71b919984)

* * *

## 回答 #29

> 赞同：3
> 
> 时间：2017-07-10T20:29:53.717

对于那些使用 Visual Studio 的人（在我的例子中是[Visual Studio 2015 ）](https://en.wikipedia.org/wiki/Microsoft_Visual_Studio#2015)

1.  在 Visual Studio 中关闭您的项目。尤其是在大型项目中，Visual Studio 在使用 UI 进行合并时往往会崩溃。

2.  在命令提示符下进行合并。

    git checkout target_branch

    git 合并 source_branch

3.  然后在 Visual Studio 中打开项目并转到 Team Explorer → *Branch*。现在有一条消息显示*Merge is pending*并且冲突文件列在消息下方。

4.  单击冲突文件，您将拥有*Merge*、*Compare*、*Take Source*和*Take Target*选项。Visual Studio 中的合并工具非常易于使用。

* * *

## 回答 #30

> 赞同：3
> 
> 时间：2017-07-11T16:23:52.803

如果您使用[IntelliJ IDEA](https://en.wikipedia.org/wiki/IntelliJ_IDEA)作为 IDE，请尝试通过以下方式将父级合并到您的分支：

```
git checkout <localbranch>
git merge origin/<remotebranch> 
```

它将显示所有冲突，如下所示：

> A_MBPro:test anu$ git merge origin/ Auto-merging src/test/java/com/.../TestClass.java CONFLICT (content): Merge conflict in src/test/java/com/.../TestClass.java

现在请注意，文件 TestClass.java 在 IntelliJ IDEA 中显示为红色。

还会`git status`显示：

```
Unmerged paths:
(use "git add <file>..." to mark resolution)
both modified:   src/test/java/com/.../TestClass.java 
```

在 IntelliJ IDEA 中打开文件。它将有部分

```
 <<<<<<< HEAD
    public void testMethod() {
    }
    =======
    public void testMethod() { ...
    }
    >>>>>>> origin/<remotebranch> 
```

其中 HEAD 是本地分支上的更改，而 origin/<remotebranch> 是远程分支上的更改。在这里保留您需要的东西并删除您不需要的东西。之后，应该执行正常步骤。那是

```
 git add TestClass.java
   git commit -m "commit message"
   git push 
```

* * *

## 回答 #31

> 赞同：3
> 
> 时间：2018-03-16T06:26:08.890

如果您还没有，请尝试使用 Visual Studio Code 进行编辑。

在您尝试合并（并陷入合并冲突）后，Visual Studio Code 会自动检测合并冲突。

它可以通过显示对原始更改所做的更改以及您是否应该接受`incoming`或

`current change`（意思是合并前的原始）'。

它帮助了我，它也可以为你工作！

PS：仅当您使用代码和 Visual Studio Code 配置了 Git 时，它才会起作用。

* * *

## 回答 #32

> 赞同：1
> 
> 时间：2017-10-13T21:49:32.427

我遵循以下过程。

修复合并冲突的过程：

1.  首先，从要合并到的目标分支中提取最新的`git pull origin develop`

2.  当您从目的地获得最新信息时，现在通过删除那些多余的字符在 IDE 中手动解决冲突。

3.  执行 a`git add`将这些已编辑的文件添加到 Git 队列，以便它可以`commit`和`push`您正在处理的同一分支。

4.  `git add`完成后，执行 a以`git commit`提交更改。

5.  现在将更改推送到您的工作分支`git push origin HEAD`

就是这样，如果您使用的是 Bitbucket 或 GitHub，您将在拉取请求中看到它已解决。

* * *

## 回答 #33

> 赞同：0
> 
> 时间：2020-07-23T07:13:54.163

我喜欢使用[WinMerge](https://en.wikipedia.org/wiki/WinMerge)（免费工具），它既可以进行完整的整个目录树比较/合并，也可以进行完整目录树比较的单个文件比较/合并。

Git 合并冲突告诉您您的拉取请求将撤消/丢失/覆盖同事的更改，通常是因为您的内容副本不够新。

解决的步骤可以是：

*   将源的另一个新克隆复制到新命名的文件夹中，
*   使用 WinMerge 比较您的内容和最近的内容以了解冲突，
*   对于您和您的同事更改的导致 Git 合并冲突的文件，请查看您的同事添加/更改/删除的行与您添加/更改的代码行相比/删除。
*   使用 WinMerge 左/右代码部分移动箭头，以确保您同事的工作在您的文件副本中，并且您不会破坏他们的工作。

即，除了手动查看每个人对相同源文件所做的操作之外，没有什么神奇的方法可以解决 Git 合并冲突。

这就是我的想法。

注意：WinMerge 创建 .bak 文件 .. 并且您不希望将它们复制到源代码控制 AzOps、TFS 等，因此如果您确定您已正确完成编辑，请删除 .bak 文件。

* * *

## 回答 #34

> 赞同：0
> 
> 时间：2020-08-09T12:11:01.347

好吧，所有已经给出的答案似乎都解释了您可以使用哪些工具来检测合并冲突或如何启动合并请求......

然而，您的问题的答案既简单又令人沮丧。合并冲突几乎总是手动手动解决。如果您使用诸如 GitLab 之类的工具，GUI 可能会帮助您找到两个代码版本之间的差异，但归根结底，您必须决定应该保留哪一行，删除哪一行。

一个简单的例子：程序员 A 和程序员 B 都将相同的 - 不同修改的 - 文件推送到远程存储库。程序员 A 打开一个合并请求，GitLab 会突出显示两个版本之间发生冲突的几行代码。现在由程序员 A 和 B 来决定，谁在这些特定的行中编写了更好的代码。他们必须做出妥协。

* * *

## 回答 #35

> 赞同：-3
> 
> 时间：2020-06-05T16:51:32.540

如果您只是想恢复远程主机，那么

```
git reset --hard origin/master 
```

**警告**：所有本地更改都将丢失，请参阅[https://stackoverflow.com/a/8476004/11769765](https://stackoverflow.com/a/8476004/11769765)。

* * *

## 回答 #36

> 赞同：-5
> 
> 时间：2014-06-10T08:11:14.560

如果不使用工具进行合并，请先将代码复制到外面：

```
- `checkout master`
- `git pull` / get new commit
- `git checkout` to your branch
- `git rebase master` 
```

它解决了冲突，您可以复制您的代码。

# maven-2 - 要使用的主要/最佳 Maven 存储库是什么？

> ID：161819
> 
> 赞同：26
> 
> 时间：2008-10-02T11:32:12.980
> 
> 标签：maven-2

要使用的主要/最佳 Maven 存储库是什么，它将包含您的大部分开源 Java 包依赖项。

还应该以什么顺序包括这些？有关系吗？

* * *

## 回答 #1

> 赞同：27
> 
> 时间：2008-10-02T11:39:57.627

这是我们正在构建的项目中的当前设置：

*   MavenCentral
*   对象网
*   JBoss Maven2
*   和一些快照（见下文）

    ```
    <repository>
        <id>MavenCentral</id>
        <name>Maven repository</name>
        <url>http://repo1.maven.org/maven2</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>objectweb</id>
        <name>Objectweb repository</name>
        <url>http://maven.objectweb.org/maven2</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>jboss</id>
        <name>JBoss Maven2 repository</name>
        <url>http://repository.jboss.com/maven2/</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
        <releases>
            <enabled>true</enabled>
        </releases>
    </repository>
    <repository>
        <id>glassfish</id>
        <name>Glassfish repository</name>
        <url>http://download.java.net/maven/1</url>
        <layout>legacy</layout>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>apache.snapshots</id>
        <name>Apache Snapshot Repository</name>
        <url>
            http://people.apache.org/repo/m2-snapshot-repository
        </url>
        <releases>
            <enabled>false</enabled>
        </releases>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>ops4j.repository</id>
        <name>OPS4J Repository</name>
        <url>http://repository.ops4j.org/maven2</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>Codehaus Snapshots</id>
        <url>http://snapshots.repository.codehaus.org/</url>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
        <releases>
            <enabled>false</enabled>
        </releases>
    </repository> 
    ```

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-02T15:32:05.603

我建议使用像 Archiva、Artifactory 或 Nexus 这样的 Maven 代理，并在服务器端定义你的 repo 列表。顺序仅在代理服务器逐个尝试代理存储库并指定边缘存储库作为第一个将减慢未缓存工件的分辨率的范围内重要（Artifactory 允许您为每个代理存储库指定白名单和黑名单表达式，这解决了这个问题）

总体而言，使用您自己的 repo 可以为您提供更多控制和可靠的构建（“中央”通常非常缓慢）。它还为您提供了放置您自己的工件和任何非免费的第 3 方工件的地方。

# c# - How to indicate that a method was unsuccessful

> ID：161822
> 
> 赞同：13
> 
> 时间：2008-10-02T11:32:56.817
> 
> 标签：c#, methods, return-value

I have several similar methods, say eg. CalculatePoint(...) and CalculateListOfPoints(...). Occasionally, they may not succeed, and need to indicate this to the caller. For CalculateListOfPoints, which returns a generic List, I could return an empty list and require the caller to check this; however Point is a value type and so I can't return null there.

Ideally I would like the methods to 'look' similar; one solution could be to define them as

```
public Point CalculatePoint(... out Boolean boSuccess);
public List<Point> CalculateListOfPoints(... out Boolean boSuccess); 
```

or alternatively to return a Point? for CalculatePoint, and return null to indicate failure. That would mean having to cast back to the non-nullable type though, which seems excessive.

Another route would be to return the Boolean boSuccess, have the result (Point or List) as an 'out' parameter, and call them TryToCalculatePoint or something...

What is best practice?

Edit: I do not want to use Exceptions for flow control! Failure is sometimes expected.

* * *

## 回答 #1

> 赞同：24
> 
> 时间：2008-10-02T11:35:56.090

Personally, I think I'd use the same idea as TryParse() : using an out parameter to output the real value, and returning a boolean indicating whether the call was successful or not

`public bool CalculatePoint(... out Point result);`

I am not a fan of using exception for "normal" behaviors (if you expect the function not to work for some entries).

* * *

## 回答 #2

> 赞同：7
> 
> 时间：2008-10-02T11:48:53.750

Why would they fail? If it's because of something the caller has done (i.e. the arguments provided) then throwing ArgumentException is entirely appropriate. A Try[...] method which avoids the exception is fine.

I think it's a good idea to provide the version which throws an exception though, so that callers who expect that they will always provide good data will receive a suitably strong message (i.e. an exception) if they're ever wrong.

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-10-02T11:36:15.637

Another alternative is to throw an exception. However, you generally only want to throw exceptions in "exceptional cases".

If the failure cases are common (and not exceptional), then you've already listed out your two options. **EDIT**: There may be a convention in your project as how to handle such non-exceptional cases (whether one should return success or the object). If there is no existing convention, then I agree with lucasbfr and suggest you return success (which agrees with how TryParse(...) is designed).

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-02T11:50:35.073

If the failure is for a specific reason then I think its ok to return null, or bool and have an out parameter. If however you return null regardless of the failure then I don't recommend it. Exceptions provide a rich set of information including the reason WHY something failed, if all you get back is a null then how do you know if its because the data is wrong, you've ran out of memory or some other weird behavior.

Even in .net the TryParse has a Parse brother so that you can get the exception if you want to.

If I provided a TrySomething method I would also provide a Something method that threw an exception in the event of failure. Then it's up to the caller.

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T11:40:21.197

The model I've used is the same one MS uses with the TryParse methods of various classes.

Your original code:
public Point CalculatePoint(... out Boolean boSuccess);
public List CalculateListOfPoints(... out Boolean boSuccess);

Would turn into public bool CalculatePoint(... out (or ref) Point CalculatedValue);
public bool CalculateListOfPoints(... out (or ref) List CalculatedValues);

Basically you make the success/failure the return value.

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T11:47:04.037

To summarise there are a couple of approaches you can take:

1.  When the return type is a value-type, like Point, use the Nullable feature of C# and return a Point? (aka Nullable), that way you can still return null on a failure
2.  Throw an exception when there's a failure. The whole argument/discussion regarding what is and isn't "exceptional" is a moot point, it's your API, you decide what's exceptional behaviour.
3.  Adopt a model similar to that implemented by Microsoft in the base types like Int32, provide a CalculatePoint and TryCalculatePoint (int32.Parse and int32.TryParse) and have one throw and one return a bool.
4.  Return a generic struct from your methods that has two properties, bool Success and GenericType Value.

Dependent on the scenario I tend to use a combination of returning null or throwing an exception as they seem "cleanest" to me and fit best with the existing codebase at the company I work for. So my personal best practice would be approaches 1 and 2.

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-02T11:47:35.253

It mostly depends on the behavior of your methods and their usage.

If failure is common and non-critical, then have your methods return a boolean indicating their success and use an out parameter to convey the result. Looking up a key in a hash, attempting to read data on a non-blocking socket when no data is available, all these examples fall in that category.

If failure is unexpected, return directly the result and convey errors with exceptions. Opening a file read-only, connecting to a TCP server, are good candidates.

And sometimes both ways make sense...

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2008-10-02T13:06:15.670

Return **Point.Empty**. It's a .NET design patter to return a special field when you want to check if structure creation was successful. Avoid *out* parameters when you can.

```
public static readonly Point Empty 
```

* * *

## 回答 #9

> 赞同：1
> 
> 时间：2008-10-02T13:23:14.023

A pattern that I'm experimenting with is returning a *Maybe*. It has the semantics of the *TryParse* pattern, but a similar signature to the null-return-on-error pattern.

I'm not yet convinced one way or the other, but I offer it for your collective consideration. It does have the benefit of not requiring a variable to defined before the method call to hold the out parameter at the call site of the method. It could also be extended with an *Errors* or *Messages* collection to indicate the reason for the failure.

The Maybe class looks something like this:

```
/// <summary>
/// Represents the return value from an operation that might fail
/// </summary>
/// <typeparam name="T"></typeparam>
public struct Maybe<T>
{
    T _value;
    bool _hasValue;

    public Maybe(T value)
    {
        _value = value;
        _hasValue = true;
    }

    public Maybe()
    {
        _hasValue = false;
        _value = default(T);
    }

    public bool Success
    {
        get { return _hasValue; }
    }

    public T Value
    {
        get 
            { // could throw an exception if _hasValue is false
              return _value; 
            }
    }
} 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2008-10-02T11:34:36.640

I would say best practice is a return value means success, and an [exception](http://www.c-sharpcorner.com/UploadFile/rajeshvs/ExceptionHandlinginCSharp11282005051444AM/ExceptionHandlinginCSharp.aspx) means failure.

I see no reason in the examples you provided that you shouldn't be using [exceptions](http://www.c-sharpcorner.com/UploadFile/rajeshvs/ExceptionHandlinginCSharp11282005051444AM/ExceptionHandlinginCSharp.aspx) in the event of a failure.

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2008-10-02T11:39:12.340

Using an exception is a bad idea in some cases (especially when writing a server). You would need two flavors of the method. Also look at the dictionary class for an indication of what you should do.

```
// NB:  A bool is the return value. 
//      This makes it possible to put this beast in if statements.
public bool TryCalculatePoint(... out Point result) { }

public Point CalculatePoint(...)
{
   Point result;
   if(!TryCalculatePoint(... out result))
       throw new BogusPointException();
   return result;
} 
```

Best of both worlds!

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2008-10-02T11:39:36.580

The bool TrySomething() is at least a practice, which works ok for .net's parse methods, but I don't think I like it in general.

Throwing an exception is often a good thing, though it should not be used for situations you would expect to happen in many normal situations, and it has an associated performance cost.

Returning null when possible is in most cases ok, when you don't want an exception.

***However*** - your approach is a bit procedural - what about creating something like a PointCalculator class - taking the required data as parameters in the constructor? Then you call CalculatePoint on it, and access the result through properties (separate properties for Point and for Success).

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-10-02T11:41:18.263

You don't want to be throwing exceptions when there is something expected happening, as @Kevin stated exceptions are for exceptional cases.

You should return something that is expected for the 'failure', generally null is my choice of bad return.

The documentation for your method should inform the users of what to expect when the data *does not compute*.

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-10-02T12:02:54.437

We once wrote an entire Framework where all the public methods either returned true (executed successfully) or false (an error occurred). If we needed to return a value we used output parameters. Contrary to popular belief, this way of programming actually simplified a lot of our code.

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-10-02T12:32:34.363

Well with Point, you can send back Point.Empty as a return value in case of failure. Now all this really does is return a point with 0 for the X and Y value, so if that can be a valid return value, I'd stay away from that, but if your method will never return a (0,0) point, then you can use that.

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2008-10-08T11:02:12.577

Sorry, I just remembered the Nullable type, you should look at that. I am not too sure what the overhead is though.

# xml - 在 SAS 中读取 XML 数据时设置数据类型

> ID：161828
> 
> 赞同：2
> 
> 时间：2008-10-02T11:34:50.477
> 
> 标签：xml, types, sas

在 SAS 中读取 XML 数据时需要控制数据类型。使用 SAS 中的 XML libname 引擎写入和访问 XML 数据。

SAS 似乎根据列的内容猜测数据类型：如果我将“20081002”写入字符列中的 XML 数据，它将作为数值变量读回。

一个例子：

```
filename my_xml '/tmp/my.xml'; * Yes, I use SAS on Unix *;
libname my_xml XML;

data my_xml.data_type_test;
  text_char="This is obviously text";
  date_char="20081002";
  num_char="42";
  genuine_num=42;
run;

proc copy inlib=my_xml outlib=WORK;
run;

libname my_xml;
filename my_xml CLEAR; 
```

在 XML 数据中，只有最后一列被定义为数值数据类型，但是当我将其复制到我的 WORK 库中时，只有*text_char*列是字符。其他 3 个现在是数字。

在 SAS 中读取 XML 数据时如何控制数据类型？

* * *

## 回答 #1

> 赞同：6
> 
> 时间：2009-02-11T13:36:48.887

看看 SAS XML 映射器。它允许您创建一个映射来读取（并在 9.2 中写入）XML 文件并指定列属性。

如果这是您的 XML 文件：

这显然是文本 20081002 42 42 你可以像这样创建一个 MAP：

```
<!-- ############################################################ -->
<TABLE name="DATA_TYPE_TEST">
    <TABLE-PATH syntax="XPath">/TABLE/DATA_TYPE_TEST</TABLE-PATH>

    <COLUMN name="text_char">
        <PATH syntax="XPath">/TABLE/DATA_TYPE_TEST/text_char</PATH>
        <TYPE>character</TYPE>
        <DATATYPE>string</DATATYPE>
        <LENGTH>22</LENGTH>
    </COLUMN>

    <COLUMN name="date_char">
        <PATH syntax="XPath">/TABLE/DATA_TYPE_TEST/date_char</PATH>
        <TYPE>numeric</TYPE>
        <DATATYPE>integer</DATATYPE>
        <FORMAT width="9">DATE</FORMAT>
        <INFORMAT width="8">ND8601DA</INFORMAT>
    </COLUMN>

    <COLUMN name="num_char">
        <PATH syntax="XPath">/TABLE/DATA_TYPE_TEST/num_char</PATH>
        <TYPE>character</TYPE>
        <DATATYPE>string</DATATYPE>
        <LENGTH>2</LENGTH>
    </COLUMN>

    <COLUMN name="genuine_num">
        <PATH syntax="XPath">/TABLE/DATA_TYPE_TEST/genuine_num</PATH>
        <TYPE>numeric</TYPE>
        <DATATYPE>integer</DATATYPE>
    </COLUMN>

</TABLE> 
```

然后读取 XML 文件：

```
filename  my 'C:\temp\my.xml';
filename  SXLEMAP 'C:\temp\MyMap.map';
libname   my xml xmlmap=SXLEMAP access=READONLY;

title 'Table DATA_TYPE_TEST';
proc contents data=my.DATA_TYPE_TEST varnum; 
run;
proc print data=my.DATA_TYPE_TEST(obs=10); 
run; 
```

结果：

```
Table DATA_TYPE_TEST

The CONTENTS Procedure

Data Set Name        MY.DATA_TYPE_TEST    Observations            
Member Type          DATA                 Variables             4 
Engine               XML                  Indexes               0 
Created              .                    Observation Length    0 
Last Modified        .                    Deleted Observations  0 
Protection                                Compressed            NO
Data Set Type                             Sorted                NO
Label                                                             
Data Representation  Default                                      
Encoding             Default                                      

Variables in Creation Order

#    Variable       Type    Len    Format    Informat      Label

1    text_char      Char     22    $22\.      $22\.          text_char  
2    date_char      Num       8    DATE9\.    ND8601DA8\.    date_char  
3    num_char       Char      2    $2\.       $2\.           num_char   
4    genuine_num    Num       8    F8\.       F8\.           genuine_num

Table DATA_TYPE_TEST

                                                               genuine_
     Obs    text_char                 date_char    num_char      num

       1    This is obviously text    02OCT2008       42             42 
```

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T12:43:44.243

我认为您需要使用您的 libname XML 语句来定义一些 xml 特定选项以进行导出：

```
libname my_xml_out XML XMLMETA=SCHEMADATA; 
```

包括数据模式。此外，您可能希望将 XML 模式保存到单独的文件以供以后导入：

```
libname my_xml_in XML XMLSCHEMA='external-file' 
```

`XMLMETA=SCHEMA`在您使用当然导出架构之后。我认为[这是您需要的文档](http://support.sas.com/documentation/cdl/en/engxml/59528/HTML/default/a002484784.htm#a002994559)。

除了在原始数据集创建上自由使用格式语句之外，还建议使用。

# linux - 是否可以在套接字上不监听？

> ID：161838
> 
> 赞同：14
> 
> 时间：2008-10-02T11:36:59.613
> 
> 标签：linux, posix, sockets, listen

调用listen（fd，backlog）后是否可以在套接字上取消监听？

编辑：我没有让自己清楚的错误。我希望能够暂时不听套接字。调用 close() 将使套接字处于 M2LS 状态并阻止我重新打开它（或者更糟糕的是，某些恶意程序可能会绑定到该套接字）

暂时不监听是向上游负载均衡器发出信号表明此应用暂时无法接受更多请求的一种方式（可能不是最好的方式）

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-02T12:03:42.343

关闭套接字后，您的程序可能仍会告诉您套接字正在“使用中”，这是因为一些我不完全了解的怪异。但是关于套接字的手册页显示有一个标志可以重复使用同一个套接字，懒惰地称为：“SO_REUSEADDR”。使用“setsockopt()”设置它。

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-02T11:39:29.093

关闭它。据我回忆;

```
close(fd); 
```

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-10-03T21:40:38.797

一些套接字库允许您专门拒绝传入的连接。例如：[GNU 的 CommonC++：TCPsocket 类](ftp://ftp.tu-clausthal.de/pub/mirror/gnu/www/software/commoncpp/docs/refman/html/class_t_c_p_socket.html)有一个[*拒绝*](ftp://ftp.tu-clausthal.de/pub/mirror/gnu/www/software/commoncpp/docs/refman/html/class_t_c_p_socket.html#a2)方法。

BSD Sockets 没有这个功能。您可以*接受*连接，然后立即*关闭*它，同时保持套接字打开：

```
while (running) {

  int i32ConnectFD = accept(i32SocketFD, NULL, NULL);
  while (noConnectionsPlease) {
    shutdown(i32ConnectFD, 2);
    close(i32ConnectFD);
    break;
  }

} 
```

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-02T21:42:30.063

根据您编辑的问题版本，我不确定您是否必须“不听”或关闭（）。想到两个选择：

1) 在调用listen() 之后，连接实际上不会被接受，直到（从逻辑上讲）你调用accept()。您可以通过简单地忽略套接字活动并推迟任何 accept() 直到您准备好来“不听”。任何入站连接尝试积压到在侦听模式下打开端口时创建的队列。一旦堆栈中的积压队列已满，进一步的连接尝试就会被简单地丢弃在地板上。当您使用 accept() 恢复时，您将快速将积压工作出列并为更多连接做好准备。

2) 如果您真的希望端口暂时完全关闭，您可以动态地将内核级别的数据包过滤器应用于端口，以防止入站连接尝试到达网络堆栈。例如，您可以在大多数 *nix 平台上使用 Berkeley Packet Filter (BPF)。也就是说，您希望使用平台的防火墙功能丢弃进入感兴趣端口的入站数据包。当然，这因平台而异，但这是一种可能的方法。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2010-08-13T15:49:17.183

我认为这不是向上游负载均衡器发出信号的好方法。在消息通过之前，它实际上必须向您的服务器发送一些连接——这些连接可能会被拒绝。

同样，关闭侦听套接字时挂起的任何连接都将在没有数据的情况下关闭。

如果您想向上游负载均衡器发出信号，您应该有一个协议来执行此操作。不要试图滥用 TCP 来做到这一点。

幸运的是，如果客户端是普通的 Web 浏览器，你可以摆脱很多 - 简单地关闭套接字通常会导致它们对用户透明地重试（到一定程度）。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T11:56:17.773

没有明确的方法可以不听！

您可以`close(fd)`或`shutdown(fd, how)`

```
fd is the socket file descriptor you want to shutdown, and how is one of the following:

0 Further receives are disallowed

1 Further sends are disallowed

2 Further sends and receives are disallowed (like close()) 
```

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T21:26:21.897

在基本层面上，套接字要么是打开的，要么是关闭的（我们将在这里忽略 TCP/IP 状态图的细节）。

如果您的套接字已关闭，则无法向其发送数据。如果它是打开的，那么传入的数据将被 TCP/IP 堆栈接受并确认，直到它的缓冲算法发出“够了！”。届时，将不会确认进一步的数据。

我可以看到你有两个选择。当您想“取消侦听”时关闭（）套接字，然后稍后重新打开它 - 使用带有 SO_REUSEADDR 标志的 setsockopt（），以允许您在 TIME_WAIT2 到期之前重新绑定到众所周知的端口。

另一种选择是保持套接字打开，但在您“忙”时根本不接受（）。假设您对请求有应用程序级别的确认，您的负载均衡器会意识到它没有得到响应并采取相应的行动。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-03T18:07:03.673

根据您编辑的问题，这是一种相当丑陋的方法：

打开一个套接字以正常积压进行侦听。继续。

当你想“关闭”时，打开一个积压为 1 和 SO_REUSEADDR 的第二个。关闭第一个。当准备好恢复时，对一个正常积压的套接字进行另一个套接字处理。

从您正在关闭的套接字中排出接受队列的挑剔细节将成为这里的杀手。可能足以使这种方法不可行的杀手。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2009-07-09T03:42:56.923

我不一定认为这是一个好主意，但是...

你也许可以再打电话听一下。POSIX 规范并没有说不。当您想“不听”时，也许您可​​以使用积压参数 0 再次调用它。

当使用积压为 0 调用 listen 时会发生什么似乎是实现定义的。POSIX 规范说它**可能**允许接受连接，这意味着如果 backlog 参数为 0，某些实现可能会选择拒绝所有连接。但更有可能的是，当您传入 0（可能是 1 或索马克康）。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2010-10-05T19:31:14.037

问题没有说什么样的插座。如果是 unix 套接字，您可以使用 rename(2) 停止并开始侦听。您还可以使用 unlink(2) 永久停止侦听，并且由于套接字保持打开状态，您可以继续为您的积压工作提供服务。这种方法似乎很方便，虽然我以前没有见过使用过，只是自己在探索。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2012-09-07T20:36:43.530

您已经得到了一些关于无法通过套接字 API 执行此操作的答案。

您可以使用其他操作系统方法（即 Host firwewall/iptables/ipfilter）来设置临时拒绝规则。

我发现大多数负载均衡器在识别连接问题的可能性方面都受到限制（大多数负载均衡器仅在连接探测中识别 RST，而不是对合法连接尝试的回答。）

无论如何，如果您受到检测不可用的探针的限制，您可以设置一个应用程序级别的探针，它会执行 HTTP 请求或 FTP 登录或类似的事情，如果您在接受后简单地关闭它就会识别。它甚至可以解释诸如“500 服务不可用”之类的错误消息，无论如何这对我来说似乎更干净。使用 SNMP，一些负载平衡器也可以将结果用作负载提示。

# c++ - 如何从 wfstream 读取二进制数据？

> ID：161852
> 
> 赞同：5
> 
> 时间：2008-10-02T11:41:05.237
> 
> 标签：c++, stl, binary, stream

我从文件中读取数据时遇到了小问题。我希望能够读取 wstring 以及任意大小的原始数据块（大小以字节为单位）。

```
std::wfstream stream(file.c_str());

std::wstring comType;
stream >> comType;

int comSize;
stream >> comSize;

char *comData = new char[comSize];
memset(comData, 0, comSize);
stream.read(comData, comSize); 
//error C2664 : 'std::basic_istream<_Elem,_Traits>::read' 
//            : cannot convert parameter 1 from 'char *' to 'wchar_t *' 
```

也许我使用了错误的流，或者类似的东西。基本上，我想读取一个 wstring，数据的大小（可以是任意数量的字节），然后是那么多字节的组件数据。显然，我无法读取 char，因为模板假定为 wchar_t。

我可以读取 wchar_t，但必须确保数据按 sizeof(wchar_t) 对齐存储。否则，我最终可能会破坏流。一种情况是数据为 15 个字节。我必须读取 16 个字节，然后屏蔽不需要的字节，将流寻找到 15 个字节的偏移量（如果可能的话，使用 wchar_t 模板化？）以便能够读取下一个数据块。

显然，*应该*有更好的方法来实现我想要做的事情。

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T12:55:26.320

stream.read 的问题在于它使用 wchar_t 作为 wfstream 的“字符单元”。如果您使用 fstream 它使用 char 作为“字符单元”。

如果您想阅读宽字符，这将起作用：

```
wchar_t *comData = new wchar_t[comSize];
stream.read(comData, comSize); 
```

另外15字节的数据不能用宽流读取，因为最小的单位至少是2字节（见下文），所以只能读取sizwof(wchar_t) * n的块。

但是，如果您担心应用程序的可移植性，wfstream/wchar_t 可能不是最好的解决方案，因为 wchar_t 的宽度没有标准（例如，在 windows 上 wchar_t 是 16 位，在许多 unix/linux 系统上是 32 位）。

将文本存储为宽字符的第二个问题是字节序，我建议使用 UTF-8 进行文本存储。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T11:52:07.037

考虑到您的要求，我认为 wfstream 不是要走的路。考虑使用类似以下代码片段的内容。

```
#include "stdafx.h"
#include <fstream>
#include <iostream>

int _tmain(int argc, _TCHAR* argv[])
{
    std::wstring str(L"hello");
    size_t size1 = str.length();
    char data[] = { 0x10, 0x20, 0x30 };
    size_t size2 = 3;

    FILE* output = NULL;
    if (_wfopen_s(&output, L"c:\\test.bin", L"wb") == 0) {
        fwrite(&size1, sizeof(size_t), 1, output);
        fwrite(str.c_str(), size1 * sizeof(wchar_t), 1, output);
        fwrite(&size2, sizeof(size_t), 1, output);
        fwrite(data, size2, 1, output);

        fclose(output);
    }

    FILE* input = NULL;
    if (_wfopen_s(&input, L"c:\\test.bin", L"rb") == 0) {
        fread(&size1, sizeof(size_t), 1, input);
        wchar_t* wstr = new wchar_t[size1 + 1];
        fread(wstr, size1 * sizeof(wchar_t), 1, input);
        std::wstring str(wstr, size1);
        delete[] wstr;
        fread(&size2, sizeof(size_t), 1, input);
        char* data1 = new char[size2];
        fread(data1, size2, 1, input);

        std::wcout << str.c_str() << std::endl;
        for (size_t i = 0; i < size2; ++i) {
            std::wcout << std::hex << "0x" << int(data1[i]) << std::endl;
        }

        delete[] data1;

        fclose(input);
    }

    return 0;
} 
```

这输出：

```
hello
0x10
0x20
0x30 
```

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2014-01-15T02:53:15.897

```
# ifdef UNICODE
#     define tfstream wfstream
# else
#     define tfstream fstream
# endif

tfstream fs( _T("filename.bin"), tfstream::binary );
byte buffer[1023];
fs.read( buffer, sizeof(buffer) ) 
```

我认为， _T("filename.bin") 和 tfstream 是 UI 表达式；缓冲区和 read() 是 DATA LOGIC 表达式。wfstream 不得将缓冲区限制为 wchar_t 类型。UI 不得与 DATA LOGIC 混合使用！wfstream 在这里做错事

# java - 在 getRuntime().exec 中使用引号

> ID：161859
> 
> 赞同：25
> 
> 时间：2008-10-02T11:43:15.760
> 
> 标签：java, exec, runtime.exec

我想使用字符串作为输入来调用 bash。就像是：

```
sh -l -c "./foo" 
```

我想从 Java 中做到这一点。不幸的是，当我尝试使用 调用命令时`getRuntime().exec`，出现以下错误：

```
 foo": -c: line 0: unexpected EOF while looking for matching `"'

      foo": -c: line 1: syntax error: unexpected end of file 
```

这似乎与我的字符串没有被 EOF 终止有关。

有没有办法将特定于平台的 EOF 插入到 Java 字符串中？还是我应该寻找另一种方法，例如在调用 "sh" 之前写入临时脚本？

* * *

## 回答 #1

> 赞同：52
> 
> 时间：2008-10-02T11:54:21.960

用这个：

```
Runtime.getRuntime().exec(new String[] {"sh", "-l", "-c", "./foo"}); 
```

要点：不要放双引号。这仅在在shell中编写命令行时使用！

例如，`echo "Hello, world!"`（在 shell 中输入）被翻译成：

```
Runtime.getRuntime().exec(new String[] {"echo", "Hello, world!"}); 
```

（暂时忘记shell通常有一个内置的 for `echo`，`/bin/echo`而是调用。:-)）

* * *

## 回答 #2

> 赞同：10
> 
> 时间：2008-10-02T14:26:14.793

Windows 命令行的行为与 UNIX、Mac OS X 和 GNU/Linux 不同。

在 Windows 上，该进程在可执行文件名称（和空格）之后逐字接收输入文本。然后由程序来解析命令行（这通常是隐式完成的，程序员通常对这个过程一无所知）。

在 GNU/Linux 中，shell 处理命令行，确保将熟悉的字符串数组传递给 C`main`函数。你没有那个壳。最好的方法（即使在 Windows 上）是**使用一种 exec 形式，您可以在其中单独传递每个命令行参数`String`**。

```
Process exec​(String[] cmdarray)    
Process exec​(String[] cmdarray, String[] envp)     
Process exec​(String[] cmdarray, String[] envp, File dir) 
```

**或者更好，`java.lang.ProcessBuilder`.**

如果你真的想要，你可以得到一个 shell 来为你做解析。这将使您的示例看起来像（未经测试）：

```
Runtime.getRuntime().exec(new String[] {
    "sh", "-c", "sh -l -c \"echo foo; echo bar;\""
}); 
```

* * *

## 回答 #3

> 赞同：4
> 
> 时间：2008-10-02T11:45:02.357

EOF 不是字符，因此无法编写 EOF。您忘记关闭带引号的字符串。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T11:47:06.517

此错误的原因很可能是缺少 bash 期望的语法标记，但您传递的字符串在 bash 遇到它之前就结束了。寻找没有关闭 fi 或 done 的 ifs、fors 等。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T12:05:34.583

在字符串中时，引号需要被转义。而不是写“写\”。

例如

strcpy(c, "这是一个字符串 \"with\" 引号");

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-02T14:48:29.780

如果我是你，我会将字符串的内容写入一个临时 bash 文件，然后查看 bash 是否在没有任何错误的情况下执行该文件。如果执行没有错误，那么我会考虑进一步调试；

# perl - Perl 的隐藏特性？

> ID：161872
> 
> 赞同：143
> 
> 时间：2008-10-02T11:49:22.907
> 
> 标签：perl, hidden-features

Perl 中有哪些真正有用但深奥的语言特性，您实际上已经能够使用它们来完成有用的工作？

指导方针：

*   尝试将答案限制在 Perl 核心而不是 CPAN
*   请给出一个例子和一个简短的描述

* * *

## 在其他语言的隐藏功能中也可以找到隐藏功能：

（这些都来自[Corion的回答](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162257)）

*   [C](https://stackoverflow.com/questions/132241/hidden-features-of-c#)
    *   达夫的装置
    *   便携性和标准性
*   [C＃](https://stackoverflow.com/questions/9033/hidden-features-of-c)
    *   空格分隔列表和字符串的引号
    *   别名命名空间
*   [爪哇](https://stackoverflow.com/questions/15496/hidden-features-of-java)
    *   静态初始化器
*   [JavaScript](https://stackoverflow.com/questions/61088/hidden-features-of-javascript)
    *   函数是一等公民
    *   块范围和闭包
    *   通过变量间接调用方法和访问器
*   [红宝石](https://stackoverflow.com/questions/63998/hidden-features-of-ruby)
    *   通过代码定义方法
*   [PHP](https://stackoverflow.com/questions/61401/hidden-features-of-php)
    *   无处不在的在线文档
    *   魔术方法
    *   符号引用
*   [Python](https://stackoverflow.com/questions/101268/hidden-features-of-python)
    *   一行值交换
    *   甚至可以用您自己的功能替换核心功能

## 其他隐藏功能：

运营商：

*   [bool 准算子](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162094)
*   [触发器运算符](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162058)
    *   也用于[列表构建](https://stackoverflow.com/questions/161872/hidden-features-of-perl#205627)
*   [和`++`一元运算`-`符处理字符串](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162004)
*   [重复运算符](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162075)
*   [宇宙飞船操作员](https://stackoverflow.com/questions/161872/hidden-features-of-perl#161943)
*   [|| 运算符（和 // 运算符）从一组选项中进行选择](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162239)
*   [钻石算子](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162152)
*   [`m//`运营商的特殊情况](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162249)
*   [波浪号“运算符”](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162060)

引用构造：

*   [qw 运算符](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163416)
*   [字母可以用作类似 q{} 的结构中的引号分隔符](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162094)
*   [报价机制](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163374)

语法和名称：

*   [印记后面可以有一个空格](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162094)
*   [您可以给 subs 数字名称与符号引用](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162094)
*   [合法的尾随逗号](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163416)
*   [分组整数文字](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162601)
*   [哈希片](https://stackoverflow.com/questions/161872/hidden-features-of-perl#168925)
*   [从数组中填充哈希的键](https://stackoverflow.com/questions/161872/hidden-features-of-perl#195254)

模块、编译指示和命令行选项：

*   [使用严格和使用警告](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163440)
*   [污点检查](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163440)
*   [-n 和 -p 的深奥用法](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162085)
*   [CPAN](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163541)
*   [`overload::constant`](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162601)
*   [IO::处理模块](https://stackoverflow.com/questions/161872/hidden-features-of-perl#164255)
*   [安全隔间](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163725)
*   [属性](https://stackoverflow.com/questions/161872/hidden-features-of-perl#310083)

变量：

*   [自生化](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162357)
*   [`$[`变量_](https://stackoverflow.com/questions/161872/hidden-features-of-perl#161985)
*   [领带](https://stackoverflow.com/questions/161872/hidden-features-of-perl#168947)
*   [动态范围](https://stackoverflow.com/questions/161872/hidden-features-of-perl#172118)
*   [使用单个语句进行变量交换](https://stackoverflow.com/questions/161872/hidden-features-of-perl#205627)

循环和流量控制：

*   [魔术转到](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163440)
*   [`for`在单个变量上](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163481)
*   [继续子句](https://stackoverflow.com/questions/161872/hidden-features-of-perl#169592)
*   [绝望模式](https://stackoverflow.com/questions/161872/hidden-features-of-perl#205104)

常用表达：

*   [`\G`锚_](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162565)
*   [`(?{})`和正则表达式中的 '(??{})`](https://stackoverflow.com/questions/161872/hidden-features-of-perl#161976)

其它功能：

*   [调试器](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163440)
*   [特殊代码块，例如 BEGIN、CHECK 和 END](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162206)
*   [`DATA`块_](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163700)
*   [新区块操作](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162601)
*   [源过滤器](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162601)
*   [信号挂钩](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162601)
*   [地图](https://stackoverflow.com/questions/161872/hidden-features-of-perl#167309)（[两次](https://stackoverflow.com/questions/161872/hidden-features-of-perl#167809)）
*   [包装内置函数](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162842)
*   [`eof`功能_](https://stackoverflow.com/questions/161872/hidden-features-of-perl/189883#189883)
*   [`dbmopen`功能_](https://stackoverflow.com/questions/161872/hidden-features-of-perl#194796)
*   [将警告转化为错误](https://stackoverflow.com/questions/161872/hidden-features-of-perl#205104)

其他技巧和元答案：

*   [cat 文件，如果需要解压缩 gzip](https://stackoverflow.com/questions/161872/hidden-features-of-perl#163532)
*   [Perl 技巧](https://stackoverflow.com/questions/161872/hidden-features-of-perl#162271)

* * *

**也可以看看：**

*   [C的隐藏特征](https://stackoverflow.com/questions/132241/hidden-features-of-c)
*   [C#的隐藏特性](https://stackoverflow.com/questions/9033/hidden-features-of-c)
*   [C++的隐藏特性](https://stackoverflow.com/questions/75538/hidden-features-of-c)
*   [Java的隐藏特性](https://stackoverflow.com/questions/15496/hidden-features-of-java)
*   [JavaScript 的隐藏特性](https://stackoverflow.com/questions/61088/hidden-features-of-javascript)
*   [Ruby 的隐藏特性](https://stackoverflow.com/questions/63998/hidden-features-of-ruby)
*   [PHP的隐藏特性](https://stackoverflow.com/questions/61401/hidden-features-of-php)
*   [Python的隐藏特性](https://stackoverflow.com/questions/101268/hidden-features-of-python)
*   [Clojure 的隐藏特性](https://stackoverflow.com/questions/2493996/hidden-features-of-clojure)

* * *

## 回答 #1

> 赞同：54
> 
> 时间：2008-10-02T12:41:44.920

在循环文件句柄返回的记录（通常是行）时，触发器运算符对于跳过第一次迭代很有用，而不使用标志变量：

```
while(<$fh>)
{
  next if 1..1; # skip first record
  ...
} 
```

运行`perldoc perlop`并搜索“触发器”以获取更多信息和示例。

* * *

## 回答 #2

> 赞同：47
> 
> 时间：2008-10-02T12:50:58.907

Perl 中有许多不明显的特性。

例如，你知道印记后面可以有一个空格吗？

```
 $ perl -wle 'my $x = 3; print $ x'
 3 
```

或者如果您使用符号引用，您可以给 subs 数字名称？

```
$ perl -lwe '*4 = sub { print "yes" }; 4->()' 
yes 
```

还有一个“bool”准运算符，它为真表达式返回 1，为假返回空字符串：

```
$ perl -wle 'print !!4'
1
$ perl -wle 'print !!"0 but true"'
1
$ perl -wle 'print !!0'
(empty line) 
```

其他有趣的东西：`use overload`你可以重载字符串文字和数字（例如使它们成为 BigInts 或其他）。

许多这些东西实际上都记录在某个地方，或者从记录的功能中合乎逻辑地遵循，但仍有一些不是很为人所知。

*更新*：另一个不错的。下面提到了`q{...}`引用结构，但是您知道可以使用字母作为分隔符吗？

```
$ perl -Mstrict  -wle 'print q bJet another perl hacker.b'
Jet another perl hacker. 
```

同样，您可以编写正则表达式：

```
m xabcx
# same as m/abc/ 
```

* * *

## 回答 #3

> 赞同：46
> 
> 时间：2008-10-02T17:23:05.117

*通过magic ARGV*添加对压缩文件的支持：

```
s{ 
    ^            # make sure to get whole filename
    ( 
      [^'] +     # at least one non-quote
      \.         # extension dot
      (?:        # now either suffix
          gz
        | Z 
       )
    )
    \z           # through the end
}{gzcat '$1' |}xs for @ARGV; 
```

*（处理带有 shell 元字符的文件名所必需的 $_ 引号）*

现在该`<>`功能将解压缩`@ARGV`以“.gz”或“.Z”结尾的所有文件：

```
while (<>) {
    print;
} 
```

* * *

## 回答 #4

> 赞同：40
> 
> 时间：2008-10-02T13:23:29.577

Perl 中我最喜欢的功能之一是使用布尔`||`运算符在一组选项之间进行选择。

```
 $x = $a || $b;

 # $x = $a, if $a is true.
 # $x = $b, otherwise 
```

这意味着可以写：

```
 $x = $a || $b || $c || 0; 
```

从`$a`、`$b`和中获取第一个真值`$c`，或者默认值`0`。

在 Perl 5.10 中，还有一个`//`运算符，如果已定义则返回左侧，否则返回右侧。下面从、、或其他中选择第一个*定义*的值：`$a``$b``$c``0`

```
$x = $a // $b // $c // 0;

```

这些也可以与它们的简写形式一起使用，这对于提供默认值非常有用：

```
$x ||= 0; # 如果 $x 为假，它现在的值为 0。

$x //= 0; # 如果 $x 未定义，它现在的值为零。

```

干杯，

*保罗*

* * *

## 回答 #5

> 赞同：39
> 
> 时间：2008-10-02T12:26:31.867

运算符 ++ 和一元 - 不仅适用于数字，也适用于字符串。

```
my $_ = "a"
print -$_ 
```

打印*-a*

```
print ++$_ 
```

打印*b*

```
$_ = 'z'
print ++$_ 
```

打印*aa*

* * *

## 回答 #6

> 赞同：36
> 
> 时间：2008-10-02T13:27:11.487

由于 Perl 几乎包含其他列表中的所有“深奥”部分，我将告诉您 Perl 无法做到的一件事：

~~Perl 不能做的一件事是在您的代码中使用任意 URL，因为`//`运算符用于正则表达式。~~

以防万一您不清楚 Perl 提供了哪些功能，这里有一个可能不完全明显的条目的选择性列表：

[Duff 的设备](https://stackoverflow.com/questions/132241/hidden-features-of-c#132274)-[在 Perl 中](http://perlmonks.org/?node=388976)

[可移植性和标准性](https://stackoverflow.com/questions/132241/hidden-features-of-c#132269)-[使用 Perl 的计算机可能比使用 C 编译器的计算机多](http://activestate.com)

[文件/路径操作类](https://stackoverflow.com/questions/9033/hidden-features-of-c#9401)- [File::Find 在比 .Net 更多的操作系统上工作](http://search.cpan.org/perldoc?File::Find)

[空格分隔列表](https://stackoverflow.com/questions/9033/hidden-features-of-c#9406) [和字符串](https://stackoverflow.com/questions/9033/hidden-features-of-c#9114)的引号- [Perl 允许您为列表和字符串分隔符选择几乎任意的引号](http://perldoc.org/perlop.html)

[Aliasable 命名空间](https://stackoverflow.com/questions/75538/hidden-features-of-c#78484)- Perl 通过 glob 分配拥有这些：

```
*My::Namespace:: = \%Your::Namespace 
```

[静态初始化器](https://stackoverflow.com/questions/15496/hidden-features-of-java#47493)——Perl 几乎可以在编译和对象实例化的每个阶段运行代码，从`BEGIN`（代码解析）到`CHECK`（代码解析后）到`import`（在模块导入时）到`new`（对象实例化）到`DESTROY`（对象销毁）到`END`（程序退出）

[函数是一等公民](https://stackoverflow.com/questions/61088/hidden-features-of-javascript#61094)——就像在 Perl 中一样

[块作用域和闭包](https://stackoverflow.com/questions/61088/hidden-features-of-javascript#61173)——Perl 两者都有

[通过变量间接调用方法和访问器](https://stackoverflow.com/questions/61088/hidden-features-of-javascript#61125)——Perl 也这样做：

```
my $method = 'foo';
my $obj = My::Class->new();
$obj->$method( 'baz' ); # calls $obj->foo( 'baz' ) 
```

[通过代码定义方法](https://stackoverflow.com/questions/63998/hidden-features-of-ruby#64080)——Perl[也允许这样做](http://perldoc.perl.org/functions/sub.html)：

```
*foo = sub { print "Hello world" }; 
```

[无处不在的在线文档](https://stackoverflow.com/questions/61401/hidden-features-of-php#61491)- [Perl 文档在线并且可能也在您的系统上](http://perldoc.com/)

[每当您调用“不存在”的函数时都会调用的魔术方法](https://stackoverflow.com/questions/61401/hidden-features-of-php#61482)- Perl 在 AUTOLOAD 函数中实现了它

[符号引用](https://stackoverflow.com/questions/61401/hidden-features-of-php#62525)- 建议您远离这些。[他们会吃掉你的孩子。](http://perl.plover.com/varvarname.html)但是当然，Perl 允许您将您的孩子提供给嗜血的恶魔。

[单行值交换](https://stackoverflow.com/questions/101268/hidden-features-of-python#102037)- Perl 允许列表赋值

[甚至可以用您自己的功能替换核心功能](https://stackoverflow.com/questions/101268/hidden-features-of-python#101744)

```
use subs 'unlink'; 
sub unlink { print 'No.' } 
```

或者

```
BEGIN{
    *CORE::GLOBAL::unlink = sub {print 'no'}
};

unlink($_) for @ARGV 
```

* * *

## 回答 #7

> 赞同：35
> 
> 时间：2008-10-02T13:48:56.880

[自生化](http://en.wikipedia.org/wiki/Autovivification)。AFAIK**没有其他语言有它**。

* * *

## 回答 #8

> 赞同：31
> 
> 时间：2008-10-02T16:43:04.557

It's simple to quote almost any kind of strange string in Perl.

```
my $url = q{http://my.url.com/any/arbitrary/path/in/the/url.html}; 
```

In fact, the various quoting mechanisms in Perl are quite interesting. The Perl regex-like quoting mechanisms allow you to quote anything, specifying the delimiters. You can use almost any special character like #, /, or open/close characters like (), [], or {}. Examples:

```
my $var  = q#some string where the pound is the final escape.#;
my $var2 = q{A more pleasant way of escaping.};
my $var3 = q(Others prefer parens as the quote mechanism.); 
```

Quoting mechanisms:

q : literal quote; only character that needs to be escaped is the end character. qq : an interpreted quote; processes variables and escape characters. Great for strings that you need to quote:

```
my $var4 = qq{This "$mechanism" is broken.  Please inform "$user" at "$email" about it.}; 
```

qx : Works like qq, but then executes it as a system command, non interactively. Returns all the text generated from the standard out. (Redirection, if supported in the OS, also comes out) Also done with back quotes (the ` character).

```
my $output  = qx{type "$path"};      # get just the output
my $moreout = qx{type "$path" 2>&1}; # get stuff on stderr too 
```

qr : Interprets like qq, but then compiles it as a regular expression. Works with the various options on the regex as well. You can now pass the regex around as a variable:

```
sub MyRegexCheck {
    my ($string, $regex) = @_;
    if ($string)
    {
       return ($string =~ $regex);
    }
    return; # returns 'null' or 'empty' in every context
}

my $regex = qr{http://[\w]\.com/([\w]+/)+};
@results = MyRegexCheck(q{http://myurl.com/subpath1/subpath2/}, $regex); 
```

qw : A very, very useful quote operator. Turns a quoted set of whitespace separated words into a list. Great for filling in data in a unit test.

```
 my @allowed = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z { });
   my @badwords = qw(WORD1 word2 word3 word4);
   my @numbers = qw(one two three four 5 six seven); # works with numbers too
   my @list = ('string with space', qw(eight nine), "a $var"); # works in other lists
   my $arrayref = [ qw(and it works in arrays too) ]; 
```

They're great to use them whenever it makes things clearer. For qx, qq, and q, I most likely use the {} operators. The most common habit of people using qw is usually the () operator, but sometimes you also see qw//.

* * *

## 回答 #9

> 赞同：27
> 
> 时间：2008-10-02T17:11:11.650

"for" 语句的使用方式与 Pascal 中使用 "with" 的方式相同：

```
for ($item)
{
    s/&‎nbsp;/ /g;
    s/<.*?>/ /g;
    $_ = join(" ", split(" ", $_));
} 
```

您可以对同一个变量应用一系列 s/// 操作等，而无需重复变量名。

注意：上面的不间断空格 (&‎nbsp;) 在其中隐藏了 Unicode 以规避 Markdown。不要复制粘贴它:)

* * *

## 回答 #10

> 赞同：27
> 
> 时间：2008-10-02T17:25:18.247

没有真正隐藏，但是每天都有许多 Perl 程序员不知道[CPAN](http://search.cpan.org)。这尤其适用于不是全职程序员或不全职使用 Perl 编程的人。

* * *

## 回答 #11

> 赞同：26
> 
> 时间：2008-10-02T16:54:51.003

quoteword 运算符是我最喜欢的东西之一。相比：

```
my @list = ('abc', 'def', 'ghi', 'jkl'); 
```

和

```
my @list = qw(abc def ghi jkl); 
```

噪音少得多，眼睛更舒服。关于 Perl 的另一件非常好的事情，在编写 SQL 时确实错过了，那就是结尾的逗号是合法的：

```
print 1, 2, 3, ; 
```

这看起来很奇怪，但如果您以另一种方式缩进代码则不会：

```
print
    results_of_foo(),
    results_of_xyzzy(),
    results_of_quux(),
    ; 
```

向函数调用添加附加参数不需要您在前一行或后一行摆弄逗号。单行更改对其周围的行没有影响。

这使得使用可变参数函数变得非常愉快。这可能是 Perl 最被低估的特性之一。

* * *

## 回答 #12

> 赞同：26
> 
> 时间：2008-10-02T17:57:38.670

解析直接粘贴到**DATA**块中的数据的能力。无需保存到要在程序或类似文件中打开的测试文件。例如：

```
my @lines = <DATA>;
for (@lines) {
    print if /bad/;
}

__DATA__
some good data
some bad data
more good data 
more good data 
```

* * *

## 回答 #13

> 赞同：24
> 
> 时间：2008-10-02T12:45:51.430

二进制“x”是[重复运算符](http://perldoc.perl.org/perlop.html#Multiplicative-Operators)：

```
print '-' x 80;     # print row of dashes 
```

它也适用于列表：

```
print for (1, 4, 9) x 3; # print 149149149 
```

* * *

## 回答 #14

> 赞同：24
> 
> 时间：2008-10-02T17:00:49.243

污点检查。`-t`启用污点检查后，如果您尝试将受污染的数据（粗略地说，来自程序外部的数据）传递给不安全的函数（打开文件、运行外部命令等），perl 将死机（或警告）。在编写 setuid 脚本或 CGI 或脚本比提供数据的人具有更大权限的任何内容时，它非常有用。

魔术转到。 `goto &sub`进行优化的尾调用。

调试器。

`use strict`和`use warnings`。这些可以使您免于一大堆拼写错误。

* * *

## 回答 #15

> 赞同：24
> 
> 时间：2008-10-02T14:31:18.243

### 新区块操作

我想说扩展语言的能力，创建伪块操作就是其中之一。

1.  你声明一个 sub 的原型，表明它首先需要一个代码引用：

    ```
    sub do_stuff_with_a_hash (&\%) {
        my ( $block_of_code, $hash_ref ) = @_;
        while ( my ( $k, $v ) = each %$hash_ref ) { 
            $block_of_code->( $k, $v );
        }
    } 
    ```

2.  然后你可以像这样在体内调用它

    ```
    use Data::Dumper;

    do_stuff_with_a_hash {
        local $Data::Dumper::Terse = 1;
        my ( $k, $v ) = @_;
        say qq(Hey, the key   is "$k"!);
        say sprintf qq(Hey, the value is "%v"!), Dumper( $v );

    } %stuff_for
    ; 
    ```

（`Data::Dumper::Dumper`是另一个半隐藏的宝石。）注意你不需要`sub`在块前面的关键字，或者在哈希之前的逗号。它最终看起来很像：`map { } @list`

### 源过滤器

此外，还有源过滤器。Perl 会将代码传递给您，以便您可以操作它。这和块操作几乎都是在家中不要尝试的类型。

我用源过滤器做了一些巧妙的事情，例如创建一种非常简单的语言来检查时间，允许使用简短的 Perl 单行代码进行一些决策：

```
perl -MLib::DB -MLib::TL -e 'run_expensive_database_delete() if $hour_of_day < AM_7'; 
```

`Lib::TL`只需扫描“变量”和常量，创建它们并根据需要替换它们。

同样，源过滤器可能很混乱，但功能强大。但是它们可能会使调试器搞砸一些可怕的事情——甚至可以用错误的行号打印警告。我停止使用 Damian 的[Switch](http://search.cpan.org/perldoc?Switch)，因为调试器将失去告诉我我真正在哪里的所有能力。但我发现你可以通过修改一小段代码，将它们保持在同一行，从而将损害降到最低。

### 信号挂钩

它通常已经足够完成，但并不是那么明显。这是一个背负旧的模具处理程序。

```
my $old_die_handler = $SIG{__DIE__};
$SIG{__DIE__}       
    = sub { say q(Hey! I'm DYIN' over here!); goto &$old_die_handler; }
    ; 
```

这意味着只要代码中的其他模块想要死掉，它们就会来找你（除非其他人对`$SIG{__DIE__}`. 并且您可以被通知某人某事是错误的。

当然`END { }`，如果你想做的只是清理，你可以只使用一个块来处理足够多的事情。

### `overload::constant`

您可以在包含您的模块的包中检查某种类型的文字。例如，如果你在你的`import`sub 中使用它：

```
overload::constant 
    integer => sub { 
        my $lit = shift;
        return $lit > 2_000_000_000 ? Math::BigInt->new( $lit ) : $lit 
    }; 
```

这意味着调用包中每个大于 20 亿的整数都将被更改为一个`Math::BigInt`对象。（参见[重载::constant](http://search.cpan.org/perldoc?overload#Overloading_constants)）。

### 分组整数文字

当我们在做的时候。Perl 允许您将大数分成三位数的组，并且仍然可以从中得到一个可解析的整数。请注意`2_000_000_000`上面的 20 亿。

* * *

## 回答 #16

> 赞同：22
> 
> 时间：2008-10-02T12:48:32.377

根据Perl 5 中实现`"-n"`和开关的方式，您可以编写一个看似不正确的程序，包括：`"-p"``}{`

```
ls |perl -lne 'print $_; }{ print "$. Files"' 
```

在内部转换为此代码：

```
LINE: while (defined($_ = <ARGV>)) {
    print $_; }{ print "$. Files";
} 
```

* * *

## 回答 #17

> 赞同：18
> 
> 时间：2008-10-02T12:09:33.030

让我们从[Spaceship Operator](http://en.wikipedia.org/wiki/Spaceship_operator)开始。

```
$a = 5 <=> 7;  # $a is set to -1
$a = 7 <=> 5;  # $a is set to 1
$a = 6 <=> 6;  # $a is set to 0 
```

* * *

## 回答 #18

> 赞同：18
> 
> 时间：2008-10-02T13:30:52.413

这是一个元答案，但[Perl Tips](http://perltraining.com.au/tips/)档案包含各种可以用 Perl 完成的有趣技巧。以前的提示存档可在线浏览，可通过邮件列表或 atom 订阅源订阅。

我最喜欢的一些技巧包括[使用 PAR 构建可执行文件](http://perltraining.com.au/tips/2008-05-23.html)，[使用 autodie 自动抛出异常](http://perltraining.com.au/tips/2008-08-20.html)，以及在 Perl 5.10 中使用[switch](http://perltraining.com.au/tips/2008-03-12.html)和[smart-match结构。](http://perltraining.com.au/tips/2008-04-18.html)

*披露：*我是 Perl Tips 的作者和维护者之一，所以我显然对他们评价很高。;)

* * *

## 回答 #19

> 赞同：18
> 
> 时间：2008-10-03T15:04:33.620

[map](http://perldoc.perl.org/functions/map.html) - 不仅因为它使一个人的代码更具表现力，而且因为它让我有一种冲动去阅读更多关于这个“函数式编程”的内容。

* * *

## 回答 #20

> 赞同：15
> 
> 时间：2008-10-02T12:19:21.633

我会投给 Perl 正则表达式中的 (?{}) 和 (??{}) 组。第一个执行 Perl 代码，忽略返回值，第二个执行代码，使用返回值作为正则表达式。

* * *

## 回答 #21

> 赞同：15
> 
> 时间：2008-10-04T02:29:35.123

循环的 continue 子句。它将在每个循环的底部执行，即使是那些下一个循环。

```
while( <> ){
  print "top of loop\n";
  chomp;

  next if /next/i;
  last if /last/i;

  print "bottom of loop\n";
}continue{
  print "continue\n";
} 
```

* * *

## 回答 #22

> 赞同：13
> 
> 时间：2008-10-02T14:25:00.380

```
while(/\G(\b\w*\b)/g) {
     print "$1\n";
} 
```

\G 锚。**很热**。_

* * *

## 回答 #23

> 赞同：13
> 
> 时间：2008-10-02T13:25:59.167

`m//`运算符有一些晦涩的特殊情况：

*   如果您`?`用作分隔符，除非您调用，否则它只会匹配一次`reset`。
*   如果您将`'`其用作分隔符，则不会对模式进行插值。
*   如果模式为空，则使用上次成功匹配的模式。

* * *

## 回答 #24

> 赞同：12
> 
> 时间：2008-10-02T13:06:18.650

空文件句柄[菱形运算符](http://perldoc.perl.org/perlop.html#I%2fO-Operators) `<>`在构建命令行工具中占有一席之地。它的作用就像`<FH>`从句柄中读取，除了它神奇地选择首先找到的那个：命令行文件名或 STDIN。取自 perlop：

```
while (<>) {
...         # code for each line
} 
```

* * *

## 回答 #25

> 赞同：11
> 
> 时间：2008-10-02T13:16:24.493

[特殊代码块](http://perldoc.perl.org/perlmod.html#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END)`BEGIN`，例如`CHECK`和`END`。它们来自 Awk，但在 Perl 中的工作方式不同，因为它不是基于记录的。

该`BEGIN`块可用于为解析阶段指定一些代码；它也会在您执行 syntax-and-variable-check 时执行`perl -c`。例如，要加载配置变量：

```
BEGIN {
    eval {
        require 'config.local.pl';
    };
    if ($@) {
        require 'config.default.pl';
    }
} 
```

* * *

## 回答 #26

> 赞同：11
> 
> 时间：2008-10-02T17:12:40.680

```
rename("$_.part", $_) for "data.txt"; 
```

将 data.txt.part 重命名为 data.txt 而不必重复自己。

* * *

## 回答 #27

> 赞同：10
> 
> 时间：2008-10-02T12:42:14.277

有点晦涩的是波浪号-波浪号“运算符”，它强制标量上下文。

```
print ~~ localtime; 
```

是相同的

```
print scalar localtime; 
```

并且不同于

```
print localtime; 
```

* * *

## 回答 #28

> 赞同：9
> 
> 时间：2009-05-31T03:13:52.790

山羊操作员`*`：

```
$_ = "foo bar";
my $count =()= /[aeiou]/g; #3 
```

或者

```
sub foo {
    return @_;
}

$count =()= foo(qw/a b c d/); #4 
```

它之所以有效，是因为标量上下文中的列表分配会产生分配的列表中的元素数量。

`*`注意，不是真正的操作员

* * *

## 回答 #29

> 赞同：9
> 
> 时间：2008-10-15T15:13:09.137

Perl 的循环控制结构的“绝望模式”导致它们查找堆栈以找到匹配的标签，这使得 Test::More 可以利用一些奇怪的行为，无论好坏。

```
SKIP: {
    skip() if $something;

    print "Never printed";
}

sub skip {
    no warnings "exiting";
    last SKIP;
} 
```

有一个鲜为人知的 .pmc 文件。“使用 Foo”将在 Foo.pm 之前在 @INC 中查找 Foo.pmc。这旨在允许首先加载已编译的字节码，但[Module::Compile](http://search.cpan.org/dist/Module-Compile)利用这一点来缓存源过滤模块，以加快加载时间和更容易调试。

将警告转化为错误的能力。

```
local $SIG{__WARN__} = sub { die @_ };
$num = "two";
$sum = 1 + $num;
print "Never reached"; 
```

这就是我能想到的尚未提及的事情。

* * *

## 回答 #30

> 赞同：9
> 
> 时间：2009-06-22T12:39:06.350

输入记录分隔符可以设置为对数字的引用以读取固定长度的记录：

```
$/ = \3; print $_,"\n" while <>; # output three chars on each line 
```

* * *

## 回答 #31

> 赞同：9
> 
> 时间：2008-10-03T21:15:27.940

tie，变量绑定接口。

* * *

## 回答 #32

> 赞同：7
> 
> 时间：2008-10-03T21:09:09.013

我不知道它有多深奥，但我最喜欢的之一是[hash slice](http://www.webquills.net/scroll/2008/05/perl-5-hash-slices-can-replace.html)。我用它来做各种各样的事情。例如合并两个哈希：

```
我的 %number_for = (一 => 1, 二 => 2, 三 => 3);
我的 %your_numbers = (二 => 2, 四 => 4, 六 => 6);
@number_for{keys %your_numbers} = 值 %your_numbers;
打印排序值 %number_for; #12346

```

* * *

## 回答 #33

> 赞同：7
> 
> 时间：2009-02-09T23:00:07.557

这个不是特别有用，但它非常深奥。我在 Perl 解析器中挖掘时偶然发现了这一点。

在出现 POD 之前，perl4 有一个技巧可以让您将手册页作为 nroff 直接嵌入到您的程序中，这样它就不会丢失。perl4 使用了一个名为[wrapman](http://www.cpan.org/scripts/nutshell/ch6/wrapman)的程序（有关详细信息，请参阅 Pink Camel 第 319 页）巧妙地将 nroff 手册页嵌入到您的脚本中。

它的工作原理是告诉 nroff 忽略所有代码，然后将手册页的内容放在告诉 Perl 停止处理代码的**END标记之后。**看起来像这样：

```
#!/usr/bin/perl
'di';
'ig00';

...Perl code goes here, ignored by nroff...

.00;        # finish .ig

'di         \" finish the diversion
.nr nl 0-1  \" fake up transition to first page
.nr % 0     \" start at page 1
'; __END__

...man page goes here, ignored by Perl... 
```

roff 魔法的细节让我无法理解，但您会注意到 roff 命令是 void 上下文中的字符串或数字。通常 void 上下文中的常量会产生警告。`op.c`允许以某些 roff 命令开头的 void 上下文字符串存在特殊例外情况。

```
 /* perl4's way of mixing documentation and code
                 (before the invention of POD) was based on a
                 trick to mix nroff and perl code. The trick was
                 built upon these three nroff macros being used in
                 void context. The pink camel has the details in
                 the script wrapman near page 319\. */
                const char * const maybe_macro = SvPVX_const(sv);
                if (strnEQ(maybe_macro, "di", 2) ||
                    strnEQ(maybe_macro, "ds", 2) ||
                    strnEQ(maybe_macro, "ig", 2))
                        useless = NULL; 
```

这意味着 that`'di';`不会产生警告，但`'die';` `'did you get that thing I sentcha?';`or也不会`'ignore this line';`。

此外，数字常量也有例外，`0`它`1`允许裸`.00;`. 该代码声称这是出于更一般的目的。

```
 /* the constants 0 and 1 are permitted as they are
               conventionally used as dummies in constructs like
                    1 while some_condition_with_side_effects;  */
            else if (SvNIOK(sv) && (SvNV(sv) == 0.0 || SvNV(sv) == 1.0))
                useless = NULL; 
```

你知道什么，`2 while condition`确实警告！

* * *

## 回答 #34

> 赞同：7
> 
> 时间：2009-05-31T02:39:22.660

您可以使用 @{[...]} 获得复杂 perl 表达式的插值结果

```
$a = 3;
$b = 4;

print "$a * $b = @{[$a * $b]}"; 
```

印刷：`3 * 4 = 12`

* * *

## 回答 #35

> 赞同：6
> 
> 时间：2009-03-26T17:13:49.820

```
use diagnostics; 
```

如果您开始使用 Perl 并且以前从未这样做过，那么此模块将为您节省大量时间和麻烦。对于您可以获得的几乎所有基本错误消息，此模块将为您提供有关代码破坏原因的冗长解释，包括一些有关如何修复它的有用提示。例如：

```
use strict;
use diagnostics;

$var = "foo"; 
```

给你这个有用的信息：

```
全局符号“$var”在第 4 行需要明确的包名。
执行 - 由于编译错误而中止 (#1)
    (F) 你说过“use strict vars”，表示所有变量
    必须是词法范围（使用“my”），事先声明使用
    “我们的”，或明确限定说明全局变量是哪个包
    在（使用“::”）。

用户代码中未捕获的异常：
        全局符号“$var”在第 4 行需要明确的包名。
由于编译错误，执行 - 中止。
 在 - 第 5 行

```

```
use diagnostics;
use strict;

sub myname {
    print { " Some Error " };
}; 
```

你会得到这么一大段有用的文本：

```
语法错误 - 第 5 行，“};”附近
执行 - 由于编译错误而中止 (#1)
(F) 可能意味着您有语法错误。常见原因包括：

    关键字拼写错误。
    缺少一个分号。
    缺少一个逗号。
    缺少左括号或右括号。
    缺少左大括号或右大括号。
    缺少结束引号。

通常会有另一个与语法相关的错误消息
错误提供更多信息。（有时打开 -w 会有所帮助。）
错误消息本身通常会告诉您它在行中的位置
它决定放弃。有时实际错误是几个令牌
在此之前，因为 Perl 擅长理解随机输入。
偶尔行号可能会产生误导，而且千载难逢
找出触发错误的唯一方法是调用
perl -c 反复，每次砍掉一半程序看
如果错误消失了。有点像 S 的控制论版本。

用户代码中未捕获的异常：
    语法错误 - 第 5 行，“};”附近
由于编译错误，执行 - 中止。
在 - 第 7 行

```

从那里你可以推断你的程序可能有什么问题（在这种情况下，打印格式完全错误）。诊断中有大量已知错误。现在，虽然这在生产环境中使用不是一件好事，但对于那些刚接触 Perl 的人来说，它可以作为一个很好的学习帮助。

* * *

## 回答 #36

> 赞同：6
> 
> 时间：2008-10-02T17:15:17.523

```
sub load_file
{
    local(@ARGV, $/) = shift;
    <>;
} 
```

以及一个返回适当数组的版本：

```
sub load_file
{
    local @ARGV = shift;
    local $/ = wantarray? $/: undef;
    <>;
} 
```

* * *

## 回答 #37

> 赞同：5
> 
> 时间：2008-10-15T17:22:31.870

($x, $y) = ($y, $x) 是我想要学习 Perl 的原因。

列表构造函数 1..99 或 'a'..'zz' 也很不错。

* * *

## 回答 #38

> 赞同：5
> 
> 时间：2008-10-02T12:21:46.230

还有 $[ 决定数组从哪个索引开始的变量。默认值为 0，因此数组从 0 开始。通过设置

```
$[=1; 
```

如果你真的想的话，你可以让 Perl 的行为更像[AWK （或 Fortran）。](http://en.wikipedia.org/wiki/AWK)

* * *

## 回答 #39

> 赞同：5
> 
> 时间：2010-08-19T23:05:10.487

@Schwern 提到通过本地化将警告变成错误`$SIG{__WARN__}`。您也可以使用`use warnings FATAL => "all";`. 见`perldoc lexwarn`。

关于这一点，自 Perl 5.12 以来，您已经可以说`perldoc foo`而不是完整的`perldoc perlfoo`. 最后！:)

* * *

## 回答 #40

> 赞同：4
> 
> 时间：2009-08-13T06:33:44.747

[Schwartzian 变换](http://en.wikipedia.org/wiki/Schwartzian_transform)是一种允许您按计算的二级索引有效排序的技术。假设您想按 md5 总和对字符串列表进行排序。下面的评论最好向后阅读（这就是我最终写这些的顺序）：

```
my @strings = ('one', 'two', 'three', 'four');

my $md5sorted_strings = 
    map { $_->[0] }               # 4) map back to the original value
    sort { $a->[1] cmp $b->[1] }  # 3) sort by the correct element of the list
    map { [$_, md5sum_func($_)] } # 2) create a list of anonymous lists
    @strings                      # 1) take strings 
```

这样，您只需进行 N 次昂贵的 md5 计算，而不是 N log N 次。

* * *

## 回答 #41

> 赞同：4
> 
> 时间：2008-11-19T15:58:50.260

使用左值使您的代码非常混乱：

```
my $foo = undef ;
sub bar:lvalue{ return $foo ;}

# Then later

bar = 5 ;
print bar ; 
```

* * *

## 回答 #42

> 赞同：4
> 
> 时间：2008-10-02T19:53:54.227

核心[`IO::Handle`](http://search.cpan.org/perldoc?IO::Handle)模块。对我来说最重要的是它允许在文件句柄上自动刷新。例子：

```
use IO::Handle;    
$log->autoflush(1); 
```

* * *

## 回答 #43

> 赞同：4
> 
> 时间：2009-10-31T08:49:34.737

有条件地将字符串或列表添加到其他列表中的一种有用的复合运算符是`x!!`运算符：

```
 print 'the meaning of ', join ' ' =>  
     'life,'                x!! $self->alive,
     'the universe,'        x!! ($location ~~ Universe),
     ('and', 'everything.') x!! 42; # this is added as a list 
```

此运算符允许使用类似于以下的反转语法

```
 do_something() if test(); 
```

* * *

## 回答 #44

> 赞同：4
> 
> 时间：2008-10-03T16:43:33.107

使用能力怎么样

```
my @symbols = map { +{ 'key' => $_ } } @things;
```

从一个数组生成一个 hashref 数组—— hashref 前面的 + 消除了块的歧义，因此解释器知道它是一个 hashref 而不是代码块。惊人的。

（感谢 Dave Doyle 在上次多伦多 Perlmongers 会议上向我解释了这一点。）

* * *

## 回答 #45

> 赞同：4
> 
> 时间：2008-10-02T18:03:06.753

安全隔间。

使用 Safe 模块，您可以只使用 perl 构建您自己的沙盒式环境。然后您就可以将 perl 脚本加载到沙箱中。

此致，

* * *

## 回答 #46

> 赞同：4
> 
> 时间：2008-10-05T15:12:40.870

好的。这是另一个。[动态范围](http://en.wikipedia.org/wiki/Scope_(programming)#Static_versus_dynamic_scoping)。在另一篇文章中对此进行了一些讨论，但我没有在隐藏功能中看到它。

像 Autovivification 这样的动态作用域使用它的语言数量非常有限。**Perl 和 Common Lisp 是我所知道的仅有的两个使用动态作用域的。**

* * *

## 回答 #47

> 赞同：4
> 
> 时间：2011-06-05T16:43:19.027

这个单行代码说明了如何使用 glob 为指定长度的单词 (4) 生成字母表（A、T、C 和 G -> DNA）的所有单词组合：

```
perl -MData::Dumper -e '@CONV = glob( "{A,T,C,G}" x 4 ); print Dumper( \@CONV )' 
```

* * *

## 回答 #48

> 赞同：3
> 
> 时间：2008-10-28T12:48:30.290

您可以用其他任何东西替换正则表达式和字符串中的分隔符。这对于“倾斜牙签综合症”特别有用，这里举例说明：

```
$url =~ /http:\/\/www\.stackoverflow\.com\//; 
```

您可以通过更改分隔符来消除大部分的回击。 是与 相同`/bar/`的简写。`m/bar/``m!bar!`

```
$url =~ m!http://www\.stackoverflow\.com/!; 
```

您甚至可以使用平衡的分隔符，例如 {} 和 []。我个人喜欢这些。 `q{foo}`是一样的`'foo'`。

```
$code = q{
    if( this is awesome ) {
        print "Look ma, no escaping!";
    }
}; 
```

要混淆你的朋友（和你的语法荧光笔）试试这个：

```
$string = qq'You owe me $1,000 dollars!'; 
```

* * *

## 回答 #49

> 赞同：3
> 
> 时间：2010-05-26T14:10:53.300

您可以在 HEREDOCS 上使用不同的引号来获得不同的行为。

```
my $interpolation = "We will interpolated variables";
print <<"END";
With double quotes, $interpolation, just like normal HEREDOCS.
END

print <<'END';
With single quotes, the variable $foo will *not* be interpolated.
(You have probably seen this in other languages.)
END

## this is the fun and "hidden" one
my $shell_output = <<`END`;
echo With backticks, these commands will be executed in shell.
echo The output is returned.
ls | wc -l
END

print "shell output: $shell_output\n"; 
```

* * *

## 回答 #50

> 赞同：3
> 
> 时间：2008-10-10T02:11:14.207

我最喜欢 Perl 的半隐藏特性是`eof`函数。这是一个非常直接的示例，`perldoc -f eof`它显示了如何使用它`$.`轻松地在命令行加载的多个文件中重置文件名和（当前行号）：

```
while (<>) {
  print "$ARGV:$.\t$_";
} 
continue {
  close ARGV if eof
} 
```

* * *

## 回答 #51

> 赞同：3
> 
> 时间：2009-02-09T23:28:12.107

我个人喜欢 s/// 操作的 /e 修饰符：

```
while(<>) {
  s/(\w{0,4})/reverse($1);/e; # reverses all words between 0 and 4 letters
  print;
} 
```

输入：

```
This is a test of regular expressions
^D 
```

输出（我认为）：

```
sihT si a tset fo regular expressions 
```

* * *

## 回答 #52

> 赞同：3
> 
> 时间：2009-07-09T18:29:22.713

[`Quantum::Superpositions`](http://search.cpan.org/~dconway/Quantum-Superpositions-1.03/lib/Quantum/Superpositions.pm)

```
use Quantum::Superpositions;

if ($x == any($a, $b, $c)) { ...  } 
```

* * *

## 回答 #53

> 赞同：3
> 
> 时间：2008-11-21T20:27:52.090

晚会很晚，但是：属性。

属性本质上允许您定义与变量或子例程的声明相关联的任意代码。使用这些的最好方法是使用[Attribute::Handlers](http://search.cpan.org/perldoc?Attribute::Handlers)；这使得定义属性变得容易（就属性而言，还有什么！）。

[我在 YAPC::2006 在线演示了](http://www.ibiblio.org/mcmahon/talks/designing4pluggability/)使用它们以声明方式组装可插入类及其插件。这是一个非常独特的功能。

* * *

## 回答 #54

> 赞同：3
> 
> 时间：2010-04-13T10:33:13.140

有一种更强大的方法可以检查程序的语法错误：

```
perl -w -MO=Lint,no-context myscript.pl 
```

它可以做的最重要的事情是报告“不存在的子程序”错误。

* * *

## 回答 #55

> 赞同：3
> 
> 时间：2010-04-16T20:08:08.943

`use re debug`
[关于使用重新调试的文档](http://perldoc.perl.org/re.html)

和

`perl -MO=Concise[,OPTIONS]`
[简明文档](http://perldoc.perl.org/B/Concise.html)

除了非常灵活、富有表现力和适合以 C、Pascal、Python 和其他语言的风格进行编程之外，还有几个 pragma 命令开关使 Perl 成为我对算法、正则表达式或快速问题进行初始 kanoodling 的“goto”语言需要解决。我相信这两个是 Perl 独有的，也是我的最爱。

`use re debug`: 大多数现代风格的正则表达式的当前形式和功能都归功于 Perl。虽然有许多 Perl 形式的正则表达式无法用其他语言表达，但几乎没有其他语言的正则表达式形式无法用 Perl 表达。此外，Perl 内置了一个出色的正则表达式调试器，以显示正则表达式引擎如何解释您的正则表达式并匹配目标字符串。

示例：我最近试图编写一个简单的 CSV 例程。（是的，是的，我知道，我应该一直在使用[Text::CSV...](http://search.cpan.org/~ALANCITT/Text-CSV-0.01/CSV.pm)）但是 CSV 值没有被引用和简单。

我的第一个想法是`/^(^(?:(.*?),){$i}/`在 n CSV 记录上提取 i 记录。这很好——除了最后一条记录或 n 中的 n。我可以在没有调试器的情况下看到这一点。

接下来我尝试`/^(?:(.*?),|$){$i}/`了这不起作用，我无法立即看到原因。我以为我说`(.*?)`的是逗号或 EOL。然后我`use re debug`在顶部添加了一个小测试脚本。啊，是的，两者之间的变化`,|$`并没有被这样解释；它被解释为`((.*?),) | ($)`——不是我想要的。

[需要一个新的分组](http://perldoc.perl.org/perlrequick.html#Grouping-things-and-hierarchical-matching)。于是我到了工作岗位`/^(?:(.*?)(?:,|$)){$i}/`。当我在正则表达式调试器中时，我很惊讶匹配到字符串末尾需要多少循环。这是一个`.*?`非常模糊的术语，需要过度回溯才能满足。所以我尝试`/^(?:(?:^|,)([^,]*)){$i}/`了这做两件事：1）减少回溯，因为除了逗号之外的所有贪婪匹配 2）允许正则表达式优化器只在第一个字段上使用一次更改。使用 Benchmark，这比第一个正则表达式快 35%。正则表达式调试器很棒，很少有人使用它。

`perl -MO=Concise[,OPTIONS]`：B 和 Concise 框架是查看 Perl 如何解释您的杰作的绝佳工具。使用`-MO=Concise`打印源代码的 Perl 解释器翻译的结果。Concise 有很多选项，在 B 中，您可以编写自己的 OP 代码演示文稿。

正如[在这篇文章](https://stackoverflow.com/questions/885908/while-1-vs-for-is-there-a-speed-difference/885951#885951)中一样，您可以使用 Concise 来比较不同的代码结构。您可以将源代码行与这些行生成的 OP 代码交错。一探究竟。

* * *

## 回答 #56

> 赞同：2
> 
> 时间：2009-06-29T17:15:51.400

以下与“~~”一样短但更有意义，因为它们指示返回的内容，并且不会与智能匹配运算符混淆：

```
print "".localtime;   # Request a string

print 0+@array;       # Request a number 
```

* * *

## 回答 #57

> 赞同：2
> 
> 时间：2010-05-26T13:50:09.310

例如，您可以在字符串中展开函数调用；

```
print my $foo = "foo @{[scalar(localtime)]} bar"; 
```

> foo 2010 年 5 月 26 日星期三 15:50:30 酒吧

* * *

## 回答 #58

> 赞同：2
> 
> 时间：2011-04-12T03:33:03.423

我最喜欢的功能是语句修饰符。

不知道我想做多少次：

```
say 'This will output' if 1;
say 'This will not output' unless 1;
say 'Will say this 3 times. The first Time: '.$_ for 1..3; 
```

在其他语言中。ETC...

'etc' 让我想起了 5.12 的另一个功能，Yada Yada 运算符。

这很棒，对于您只想要一个占位符的时代。

```
sub something_really_important_to_implement_later {
    ...
} 
```

看看：[关于 Yada Yada Operator 的 Perl 文档](http://perldoc.perl.org/perlop.html#The-Triple-Dot-Operator)。

* * *

## 回答 #59

> 赞同：2
> 
> 时间：2008-10-02T15:04:15.637

Axeman 让我想起了包装一些内置函数是多么容易。

在 Perl 5.10 之前，Perl 没有像 Python 那样漂亮的打印（比如）。

因此，在您的本地程序中，您可以执行以下操作：

```
sub print {
     print @_, "\n";
} 
```

或添加一些调试。

```
sub print {
    exists $ENV{DEVELOPER} ?
    print Dumper(@_) :
    print @_;
} 
```

* * *

## 回答 #60

> 赞同：2
> 
> 时间：2010-05-26T08:44:19.653

有两件事可以很好地协同工作：IO 处理核心字符串，以及使用函数原型使您能够使用类似 grep/map 的语法编写自己的函数。

```
sub with_output_to_string(&) {           # allows compiler to accept "yoursub {}" syntax.
  my $function = shift;
  my $string   = '';
  my $handle   = IO::Handle->new();
  open($handle, '>', \$string) || die $!; # IO handle on a plain scalar string ref
  my $old_handle = select $handle;
  eval { $function->() };
  select $old_handle;
  die $@ if $@;
  return $string;
}

my $greeting = with_output_to_string {
  print "Hello, world!";
};

print $greeting, "\n"; 
```

* * *

## 回答 #61

> 赞同：2
> 
> 时间：2010-05-26T11:28:35.297

命令行上的新 -E 选项：

```
> perl -e "say 'hello"" # does not work 

String found where operator expected at -e line 1, near "say 'hello'"
        (Do you need to predeclare say?)
syntax error at -e line 1, near "say 'hello'"
Execution of -e aborted due to compilation errors.

> perl -E "say 'hello'" 
hello 
```

* * *

## 回答 #62

> 赞同：2
> 
> 时间：2010-05-26T10:35:01.773

在循环中使用哈希作为可见过滤器的能力。我还没有看到用另一种语言写得这么好的东西。例如，我无法在 python 中复制它。

例如，如果之前没有见过，我想打印一行。

```
my %seen;

for (<LINE>) {
  print $_ unless $seen{$_}++;
} 
```

* * *

## 回答 #63

> 赞同：1
> 
> 时间：2009-02-13T18:57:47.223

你可能认为你可以这样做来节省内存：

```
@is_month{qw(jan feb mar apr may jun jul aug sep oct nov dec)} = undef;

print "It's a month" if exists $is_month{lc $mon}; 
```

但它不会那样做。Perl 仍然为每个键分配不同的标量值。 [Devel::Peek](http://search.cpan.org/perldoc?Devel::Peek)显示了这一点。 `PVHV`是哈希。 `Elt`是一个键`SV`，接下来是它的值。请注意，每个 SV 都有不同的内存地址，表明它们没有被共享。

```
Dump \%is_month, 12;

SV = RV(0x81c1bc) at 0x81c1b0
  REFCNT = 1
  FLAGS = (TEMP,ROK)
  RV = 0x812480
  SV = PVHV(0x80917c) at 0x812480
    REFCNT = 2
    FLAGS = (SHAREKEYS)
    ARRAY = 0x206f20  (0:8, 1:4, 2:4)
    hash quality = 101.2%
    KEYS = 12
    FILL = 8
    MAX = 15
    RITER = -1
    EITER = 0x0
    Elt "feb" HASH = 0xeb0d8580
    SV = NULL(0x0) at 0x804b40
      REFCNT = 1
      FLAGS = ()
    Elt "may" HASH = 0xf2290c53
    SV = NULL(0x0) at 0x812420
      REFCNT = 1
      FLAGS = () 
```

undef 标量占用与整数标量一样多的内存，因此您可能会问，只需将它们全部分配给 1 并避免忘记检查的陷阱`exists`。

```
my %is_month = map { $_ => 1 } qw(jan feb mar apr may jun jul aug sep oct nov dec);

print "It's a month" if $is_month{lc $mon}); 
```

* * *

## 回答 #64

> 赞同：1
> 
> 时间：2009-11-05T16:21:50.237

匹配正则表达式的插值。一个有用的应用是在黑名单上进行匹配时。在不使用插值的情况下，它是这样写的：

```
#detecting blacklist words in the current line
/foo|bar|baz/; 
```

可以改为写

```
@blacklistWords = ("foo", "bar", "baz");
$anyOfBlacklist = join "|", (@blacklistWords);
/$anyOfBlacklist/; 
```

这更详细，但允许从数据文件中填充。此外，如果出于某种原因在源中维护列表，则维护数组比维护 RegExp 更容易。

* * *

## 回答 #65

> 赞同：1
> 
> 时间：2009-10-10T18:37:15.843

`defined &DB::DB`如果程序从调试器中运行，则表达式返回 true。

* * *

## 回答 #66

> 赞同：1
> 
> 时间：2010-01-25T22:51:46.463

为 unpack() 和 pack() 函数添加一个，如果您需要以其他程序使用的格式导入和/或导出数据，这非常有用。

当然，现在大多数程序都允许您以 XML 格式导出数据，并且许多常用的专有文档格式都有为它们编写的相关 Perl 模块。但这是在您需要时非常有用的功能之一，pack()/unpack() 可能是人们能够为如此多的专有数据格式编写 CPAN 模块的*原因。*

* * *

## 回答 #67

> 赞同：1
> 
> 时间：2008-10-11T23:07:37.183

我参加聚会有点晚了，但投票支持内置的捆绑哈希函数`dbmopen()`——它对我帮助很大。它不完全是一个数据库，但如果您需要将数据保存到磁盘，它可以解决很多问题并且可以正常工作。当我没有数据库、不了解 Storable.pm 时，它帮助我入门，但我知道我想超越阅读和写入文本文件。

* * *

## 回答 #68

> 赞同：1
> 
> 时间：2010-05-26T10:01:12.637

下次你参加一个极客派对时，把这个装在 bash 壳里的衬里拉出来，女人会蜂拥而至，你的朋友会崇拜你：

寻找 。-name "*.txt"|xargs perl -pi -e 's/1:(\S+)/uc($1)/ge'

处理所有 *.txt 文件并使用 perl 的正则表达式进行就地查找和替换。这个将'1：'之后的文本转换为大写并删除'1：'。使用 Perl 的“e”修饰符将查找/替换正则表达式的第二部分视为可执行代码。即时的单行模板系统。使用 xargs 可以让您处理大量文件，而不会遇到 bash 的命令行长度限制。

* * *

## 回答 #69

> 赞同：1
> 
> 时间：2009-11-19T12:21:56.950

使用哈希（其中键是唯一的）来获取列表的唯一元素：

```
my %unique = map { $_ => 1 } @list;
my @unique = keys %unique; 
```

* * *

## 回答 #70

> 赞同：0
> 
> 时间：2008-10-03T10:25:16.017

通过在同一行上打印来显示脚本的进度：

```
$| = 1; # flush the buffer on the next output 

for $i(1..100) {
    print "Progress $i %\r"
} 
```

* * *

## 回答 #71

> 赞同：0
> 
> 时间：2012-01-12T21:06:48.403

[B::Deparse](http://search.cpan.org/~flora/perl-5.14.2/dist/B-Deparse/Deparse.pm) - Perl 编译器后端生成 perl 代码。不是您在日常 Perl 编码中使用的东西，但在特殊情况下可能很有用。

如果您遇到一些混淆的代码或复杂的表达式，请将其传递给`Deparse`. 有助于找出一个 JAPH 或一个打高尔夫球的 Perl 代码。

```
$ perl -e '$"=$,;*{;qq{@{[(A..Z)[qq[0020191411140003]=~m[..]g]]}}}=*_=sub{print/::(.*)/};$\=$/;q<Just another Perl Hacker>->();'
Just another Perl Hacker

$ perl -MO=Deparse -e '$"=$,;*{;qq{@{[(A..Z)[qq[0020191411140003]=~m[..]g]]}}}=*_=sub{print/::(.*)/};$\=$/;q<Just another Perl Hacker>->();'
$" = $,;
*{"@{[('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z')['0020191411140003' =~ /../g]];}";} = *_ = sub {
    print /::(.*)/;
}
;
$\ = $/;
'Just another Perl Hacker'->();
-e syntax OK 
```

一个更有用的示例是使用 deparse 找出 coderef 背后的代码，您可能从另一个模块收到这些代码，或者

```
use B::Deparse;
my $deparse = B::Deparse->new;
$code = $deparse->coderef2text($coderef);
print $code; 
```

* * *

## 回答 #72

> 赞同：0
> 
> 时间：2008-10-02T19:48:08.403

@Corion - Perl 中的裸 URL？当然，即使在插值字符串中也可以。唯一重要的是在您实际用作正则表达式的字符串中。

* * *

## 回答 #73

> 赞同：0
> 
> 时间：2009-09-04T17:30:11.137

$0 是正在执行的 perl 脚本的名称。它可用于获取正在运行的模块的上下文。

```
# MyUsefulRoutines.pl

sub doSomethingUseful {
  my @args = @_;
  # ...
}

if ($0 =~ /MyUsefulRoutines.pl/) {
  # someone is running  perl MyUsefulRoutines.pl [args]  from the command line
  &doSomethingUseful (@ARGV);
} else {
  # someone is calling  require "MyUsefulRoutines.pl"  from another script
  1;
} 
```

这个习惯用法有助于将带有一些有用子例程的独立脚本处理成可以导入其他脚本的库。Python 具有与该`object.__name__ == "__main__"`成语类似的功能。

* * *

## 回答 #74

> 赞同：0
> 
> 时间：2009-01-26T07:36:20.793

多一个...

Perl 缓存：

```
my $processed_input = $records || process_inputs($records_file); 
```

关于 Elpeleg 开源，Perl CMS [http://www.web-app.net/](http://www.web-app.net/)

* * *

## 回答 #75

> 赞同：0
> 
> 时间：2010-05-26T09:54:13.967

Perl 非常适合作为灵活的 awk/sed。

例如，让我们使用简单的替换 for `ls | xargs stat`，天真地完成如下：

```
$ ls | perl -pe 'print "stat "' | sh 
```

当输入（文件名）包含空格或 shell 特殊字符（如 `|$\`. 因此在 Perl 输出中经常需要单引号。

通过命令行调用 perl 的一个复杂之`-ne`处在于，shell 会首先蚕食你的单行。这通常会导致痛苦的逃避来满足它。

我一直使用的一个“隐藏”功能是**`\x27`**包含一个单引号，而不是尝试使用 shell 转义`'\''`

所以：

```
$ ls | perl -nle 'chomp; print "stat '\''$_'\''"' | sh 
```

可以更安全地编写：

```
$ ls | perl -pe 's/(.*)/stat \x27$1\x27/' | sh 
```

这不适用于文件名中的有趣字符，即使是这样引用。但这将：

```
$ ls | perl -pe 's/\n/\0/' | xargs -0 stat 
```

* * *

## 回答 #76

> 赞同：0
> 
> 时间：2010-01-14T06:50:33.017

使用带有或其他控制字的裸块`redo`来创建自定义循环结构。

`->can('print')`遍历返回第一个方法的对象链表：

```
sub get_printer {
    my $self = shift;
    {$self->can('print') or $self = $self->next and redo}
} 
```

* * *

## 回答 #77

> 赞同：0
> 
> 时间：2010-09-06T17:25:31.913

“现在”

```
sub _now { 
        my ($now) = localtime() =~ /([:\d]{8})/;
        return $now;
}

print _now(), "\n"; #  15:10:33 
```

* * *

## 回答 #78

> 赞同：-1
> 
> 时间：2011-07-09T00:54:57.290

我喜欢我们可以在数组中的任何位置插入元素的方式，例如

=> 将 $x 插入到数组 @a 中的 $i 位置

```
@a = ( 11, 22, 33, 44, 55, 66, 77 );
$x = 10;
$i = 3;

@a = ( @a[0..$i-1], $x, @a[$i..$#a] ); 
```

# c - K & R 练习：我的代码有效，但感觉很臭；清理建议？

> ID：161873
> 
> 赞同：8
> 
> 时间：2008-10-02T11:49:42.937
> 
> 标签：c, kernighan-and-ritchie

我正在写 K&R 的书。我比我做的练习读得更远，主要是因为没有时间。我正在赶上进度，并且已经完成了第 1 章（即教程）中的几乎所有练习。

我的问题是练习 1-18。练习是为了：

> 编写一个程序从输入行中删除尾随空格和制表符，并删除完全空白行

我的代码（如下）可以做到这一点，并且可以工作。我的问题是我实现的修剪方法。感觉……错了……不知何故。就像我在代码审查中看到 C# 中的类似代码一样，我可能会发疯。（C# 是我的专长之一。）

任何人都可以提供一些关于清理这个问题的建议 - 说建议只能使用 K&R 第 1 章中的知识。（我知道有无数种方法可以使用完整的 C 库来清理这个问题；我们'这里只是谈论第 1 章和基本的 stdio.h。）另外，在给出建议时，你能解释一下为什么它会有所帮助吗？（毕竟，我是在努力学习！还有谁比这里的专家更适合学习呢？）

```
#include <stdio.h>

#define MAXLINE 1000

int getline(char line[], int max);
void trim(char line[], char ret[]);

int main()
{
    char line[MAXLINE];
    char out[MAXLINE];
    int length;

    while ((length = getline(line, MAXLINE)) > 0)
    {
        trim(line, out);
        printf("%s", out);
    }

    return 0;
}

int getline(char line[], int max)
{
    int c, i;

    for (i = 0; i < max - 1 && (c = getchar()) != EOF && c != '\n'; ++i)
        line[i] = c;

    if (c == '\n')
    {
        line[i] = c;
        ++i;
    }

    line[i] = '\0'; 
    return i;
}

void trim(char line[], char ret[])
{
    int i = 0;

    while ((ret[i] = line[i]) != '\0')
        ++i;

    if (i == 1)
    {
        // Special case to remove entirely blank line
        ret[0] = '\0';
        return;
    }

    for (  ; i >= 0; --i)
    {
        if (ret[i] == ' ' || ret[i] == '\t')
            ret[i] = '\0';
        else if (ret[i] != '\0' && ret[i] != '\r' && ret[i] != '\n')
            break;
    }

    for (i = 0; i < MAXLINE; ++i)
    {
        if (ret[i] == '\n')
        {
            break;
        }
        else if (ret[i] == '\0')
        {
            ret[i] = '\n';
            ret[i + 1] = '\0';
            break;
        }
    }
} 
```

编辑：我感谢我在这里看到的所有有用的提示。我想提醒人们，我仍然是 C 的 n00b，特别是还没有得到指针。（记住关于 K&R 的 Ch.1 的一点——Ch.1 不做指针。）我“有点”得到了一些解决方案，但对于我所处的位置，它们仍然有点先进......

我正在寻找的大部分内容是修剪方法本身——特别是我循环了**3**次的事实（感觉很脏）。我觉得如果我稍微聪明一点（即使没有 C 的高级知识），这本可以更干净。

* * *

## 回答 #1

> 赞同：9
> 
> 时间：2008-10-02T11:56:01.550

如果您坚持使用第 1 章，那对我来说看起来不错。从代码审查的角度来看，这是我的建议：

在 C 中检查相等性时，始终将常量放在首位

```
if (1 == myvar) 
```

这样你就不会意外地做这样的事情：

```
if (myvar = 1) 
```

在 C# 中你无法摆脱它，但它在 C 中编译得很好，并且可以成为真正的调试恶魔。

* * *

## 回答 #2

> 赞同：5
> 
> 时间：2008-10-02T12:06:31.930

没有理由有两个缓冲区，您可以将输入行修剪到位

```
int trim(char line[])
{
    int len = 0;
    for (len = 0; line[len] != 0; ++len)
        ;

    while (len > 0 &&
           line[len-1] == ' ' && line[len-1] == '\t' && line[len-1] == '\n')
        line[--len] = 0;

    return len;
} 
```

通过返回行长度，您可以通过测试非零长度行来消除空白行

```
if (trim(line) != 0)
    printf("%s\n", line); 
```

编辑：假设 ASCII 编码，您可以使 while 循环更加简单。

```
while (len > 0 && line[len-1] <= ' ')
    line[--len] = 0; 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T12:19:00.340

个人对于 while 构造：

我更喜欢以下内容：

```
while( (ret[i] = line[i]) )
        i++; 
```

到：

```
while ((ret[i] = line[i]) != '\0')
        ++i; 
```

他们都检查了 != 0 但第一个看起来更干净一些。如果 char 不是 0，则循环体将执行，否则它将跳出循环。

同样对于“for”语句，虽然在语法上是有效的，但我发现以下内容：

```
for (  ; i >= 0; --i) 
```

对我来说只是看起来“奇怪”，确实是潜在错误的潜在噩梦解决方案。如果我正在审查这段代码，那就像一个发光的红色警告一样。通常，您希望使用 for 循环来迭代已知次数，否则考虑使用 while 循环。（与往常一样，该规则也有例外，但我发现这通常是正确的）。上面的 for 语句可以变成：

```
while (i)
{
        if (ret[i] == ' ' || ret[i] == '\t')
        {
            ret[i--] = '\0';
        }
        else if (ret[i] != '\0' && ret[i] != '\r' && ret[i] != '\n')
        {
            break;
        }
} 
```

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-02T12:39:36.483

trim() 太大了。

我认为您需要的是一个类似 strlen 的函数（继续写 int stringlength(const char *s)）。

然后你需要一个名为 int scanback(const char *s, const char *matches, int start) 的函数，它从 start 开始，只要在匹配中包含的 s id 处扫描的字符就会下降到 z，返回最后一个索引，其中找到匹配项。

然后你需要一个名为 int scanfront(const char *s, const char *matches) 的函数，它从 0 开始，只要在 s 处扫描的字符包含在匹配项中，就会向前扫描，返回找到匹配项的最后一个索引。

然后你需要一个名为 int charinstring(char c, const char *s) 的函数，如果 c 包含在 s 中，则返回非零，否则返回 0。

您应该能够根据这些来编写修剪。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T12:26:23.380

首先：

> 诠释主要（无效）

您知道 main() 的参数。他们什么都不是。（或 argc&argv，但我认为这不是第 1 章的材料。）

风格方面，您可能想尝试 K&R 风格的括号。它们在垂直空间上要容易得多：

```
void trim(char line[], char ret[])
{
    int i = 0;

    while ((ret[i] = line[i]) != '\0')
        ++i;

    if (i == 1) { // Special case to remove entirely blank line
        ret[0] = '\0';
        return;
    }

    for (; i>=0; --i) { //continue backwards from the end of the line
        if ((ret[i] == ' ') || (ret[i] == '\t')) //remove trailing whitespace
            ret[i] = '\0';

        else if ((ret[i] != '\0') && (ret[i] != '\r') && (ret[i] != '\n')) //...until we hit a word character
            break;
    }

    for (i=0; i<MAXLINE-1; ++i) { //-1 because we might need to add a character to the line
        if (ret[i] == '\n') //break on newline
            break;

        if (ret[i] == '\0') { //line doesn't have a \n -- add it
            ret[i] = '\n';
            ret[i+1] = '\0';
            break;
        }
    }
} 
```

（还添加了评论并修复了一个错误。）

一个大问题是 MAXLINE 常量的使用—— main() 专门将它用于*line*和*out*变量；trim()，它只对它们起作用，不需要使用常量。您应该像在 getline() 中那样将大小作为参数传递。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-02T13:21:41.220

这是我在不知道第 1 章或 K&R 中的内容的情况下进行的练习。我假设指针？

```
#include "stdio.h"

size_t StrLen(const char* s)
{
    // this will crash if you pass NULL
    size_t l = 0;
    const char* p = s;
    while(*p)
    {
        l++;
        ++p;
    }
    return l;
}

const char* Trim(char* s)
{
    size_t l = StrLen(s);
    if(l < 1)
        return 0;

    char* end = s + l -1;
    while(s < end && (*end == ' ' || *end == '\t'))
    {
        *end = 0;
        --end;
    }

    return s;
}

int Getline(char* out, size_t max)
{
    size_t l = 0;
    char c;
    while(c = getchar())
    {
        ++l;

        if(c == EOF) return 0;
        if(c == '\n') break;

        if(l < max-1)
        {
            out[l-1] = c;
            out[l] = 0;
        }
    }

    return l;
}

#define MAXLINE 1024

int main (int argc, char * const argv[]) 
{
    char line[MAXLINE];
    while (Getline(line, MAXLINE) > 0)
    {
        const char* trimmed = Trim(line);
        if(trimmed)
            printf("|%s|\n", trimmed);

        line[0] = 0;
    }

    return 0;
} 
```

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T13:29:30.123

我个人会这样写代码：

```
ret[i] != '\0' && ret[i] != '\r' && ret[i] != '\n' 
```

进入一个单独的函数（甚至是一个定义宏）

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-02T13:42:40.623

1.  trim 确实应该只使用 1 个缓冲区（正如@Ferruccio 所说）。
2.  正如@plinth 所说，修剪需要分解
3.  trim 不需要返回任何值（如果你想检查空字符串，测试 line[0] == 0）
4.  对于额外的 C 风格，使用指针而不是索引

- 到行尾（以 0 结尾； - 虽然不在行首且当前字符为空格，但将其替换为 0。 - 后退一个字符

```
char *findEndOfString(char *string) {
  while (*string) ++string;
  return string; // string is now pointing to the terminating 0
}

void trim(char *line) {
  char *end = findEndOfString(line);
   // note that we start at the first real character, not at terminating 0
  for (end = end-1; end >= line; end--) {
      if (isWhitespace(*end)) *end = 0;
      else return;
  }
} 
```

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-02T19:03:06.343

做同样事情的另一个例子。通过使用 C99 特定的东西做了一些轻微的违规行为。在 K&R 中找不到。还使用了作为starndard 库一部分的assert() 函数，但可能未在K&R 的第一章中介绍。

```
#include <stdbool.h> /* needed when using bool, false and true. C99 specific. */
#include <assert.h> /* needed for calling assert() */

typedef enum {
  TAB = '\t',
  BLANK = ' '
} WhiteSpace_e;

typedef enum {
  ENDOFLINE = '\n',
  ENDOFSTRING = '\0'
} EndofLine_e;

bool isWhiteSpace(
  char character
) {
  if ( (BLANK == character) || (TAB == character ) ) {
    return true;
  } else {
    return false;
  }
}

bool isEndOfLine( 
  char character
) {
 if ( (ENDOFLINE == character) || (ENDOFSTRING == character ) ) {
    return true;
  } else {
    return false;
  }
}   

/* remove blanks and tabs (i.e. whitespace) from line-string */
void removeWhiteSpace(
  char string[]
) {
  int i;
  int indexOutput;

  /* copy all non-whitespace character in sequential order from the first to the last.
    whitespace characters are not copied */
  i = 0;
  indexOutput = 0;
  while ( false == isEndOfLine( string[i] ) ) {
    if ( false == isWhiteSpace( string[i] ) ) {
      assert ( indexOutput <= i );
      string[ indexOutput ] = string[ i ];
      indexOutput++;
    }
    i++; /* proceed to next character in the input string */
  }

  assert( isEndOfLine( string[ i ] ) );
  string[ indexOutput ] = ENDOFSTRING;

} 
```

# c - C中返回值的括号

> ID：161879
> 
> 赞同：82
> 
> 时间：2008-10-02T11:52:25.397
> 
> 标签：c, syntax, coding-style

在 ANSI C 代码中，我经常可以看到围绕单个返回值的括号。

像这样：-

```
int foo(int x) {
  if (x)
    return (-1);
  else
    return (0);
} 
```

为什么在这些情况下在返回值周围使用 () ？有任何想法吗？我看不出有什么理由。

* * *

## 回答 #1

> 赞同：60
> 
> 时间：2008-10-02T11:56:37.710

真的没有理由......这只是旧惯例。

为了节省空间，程序员通常会在返回行而不是自己的行中进行最终数学运算，并且括号确保大部分都在那里，以便更容易看到它是返回的单个语句，如下所示：

```
return (x+i*2); 
```

代替

```
int y = x+i*2;
return y; 
```

括号变成了一种习惯，并且卡住了。

* * *

## 回答 #2

> 赞同：55
> 
> 时间：2008-10-02T19:26:01.797

一个实际但不太可能的动机是，如果你在值周围加上括号，你可以将 return 定义为一个宏，然后插入一些日志代码来观察你的所有返回。

* * *

## 回答 #3

> 赞同：26
> 
> 时间：2017-10-21T20:32:30.863

[在最初的 C 规范中，需要在返回值周围加上括号。](https://www.bell-labs.com/usr/dmr/www/cman.pdf#page=14) 虽然现代 C 编译器和 ANSI C 标准不需要它们，但括号的存在不会影响返回值，并且程序员有时仍然出于习惯、不熟悉标准而将它们包括在内，以与需要它们的风格约定保持一致，或者可能是为了向后兼容。

I should add, for people that are thinking about C++: *This* question is about C and C is not C++; these are two different languages with different standards, capabilities, levels of difficulty, and different styles of usage that emerge -- whatever they have in common, it is wise to treat them as two totally separate things. For a similar question that covers C++, see [Are parentheses around the result significant in a return statement?](https://stackoverflow.com/questions/4762662/are-parentheses-around-the-result-significant-in-a-return-statement/25615981#25615981).

* * *

## 回答 #4

> 赞同：23
> 
> 时间：2008-10-02T12:24:06.427

我个人的风格是，如果有复杂的表达，就用括号；例如，

```
return (a + b); 
```

但如果表达式是一个简单的术语，则不要使用它们

```
return a; 
```

我不能说我为什么要那样做；只是我很久以前捡到的东西。

顺便说一句，我认为让它看起来像一个函数调用，像这样：

```
return(a);  // ugh 
```

非常丑陋，而且是错误的。

* * *

## 回答 #5

> 赞同：13
> 
> 时间：2008-10-02T14:35:21.107

有几个原因：

1.  如果/而/对于/等。都是必须有括号的控制关键字。因此，总是将它们归还似乎很自然。

2.  sizeof 是唯一可以包含或不包含它们的其他关键字，除了在某些情况下您*必须*使用括号。所以更容易养成总是使用括号的习惯。对于 sizeof，这意味着一个逻辑：如果可以，总是这样做。

3.  case/goto 是您从不使用括号的唯一关键字。...人们倾向于将这些视为特殊情况（并且喜欢它们以从其他控制关键字中脱颖而出，尤其是 goto）。

* * *

## 回答 #6

> 赞同：8
> 
> 时间：2008-10-08T13:31:22.103

在您的示例中返回 -1 时，我认为使用括号更易读，因为减号更明显：

```
return 1 
```

或者

```
return -1 
```

或者

```
return (-1) 
```

* * *

## 回答 #7

> 赞同：4
> 
> 时间：2014-04-25T16:29:01.023

也许这是习惯——毕竟，给我们带来 Unix 和 C 的人来自 Multics 项目。Multics 是用 PL/I 编写的，在 PL/I 中，括号是强制性的。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-10-02T11:55:46.073

与使用括号的情况一样，我认为这只是为了便于阅读（例如，Ruby 支持方法调用不带括号括住参数，但最近的书籍和文章建议不这样做）。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2008-10-02T20:26:53.710

我曾与至少一位认为 return*是*某种特殊类型的函数调用的程序员合作过，当他看到我的代码在没有括号的情况下编译时感到很惊讶。

* * *

## 回答 #10

> 赞同：-4
> 
> 时间：2016-03-26T06:33:42.770

return 语句中的括号向编译器表明您打算将此值返回到堆栈而不是内存中。

在过去，这是严格执行的（通常），但今天大多数编译器仅将其作为提示。

这是我经常做的事情，因为错误可能会破坏通过内存引用返回的任何内容，但通常不会影响在堆栈上返回的变量。

将堆栈用于瞬态变量还可以减少内存使用，并且通常会使函数调用/返回更快，因为这就是堆栈的设计目的，即瞬态数据/变量。

* * *

## 回答 #11

> 赞同：-5
> 
> 时间：2011-01-21T19:09:49.367

`C/C++`在 return 语句中使用括号表明对语法的掌握不足。就这么简单。但这并不像把所有东西都放在花括号里那么糟糕：

```
int foo(int x) {
  if (x) {
    return (-1);
  }
  else {
    return (0);
  }
} 
```

很多程序员都是这样做的。如果你们中的一个人读到这个，也许你可能想解释一下。

# c# - WPF 绑定到对象的集合，按 C# 中另一个集合中按顺序存储的 ID 排序

> ID：161884
> 
> 赞同：1
> 
> 时间：2008-10-02T11:53:18.843
> 
> 标签：c#, wpf, data-binding, sorting, collections

对于那些喜欢谜题的人：我最近遇到了这个问题，相信一定有更好的解决方案。

考虑 ：

*   **Foo**对象的 ObservableCollection称为*foos*。
*   **Foo**包含一个字符串 ID 字段
*   我无法控制*foos*
*   *foos*会改变

然后：

*   我有另一个名为*sortLikeThis的集合*
*   *sortListThis*包含字符串
*   *字符串是按照foo*显示顺序的 ID

加：

*   *foos*中可能有ID 不在*sortLikeThis*中的对象。这些需要放在最后。
*   *同样， sortLikeThis*中可能有一些字符串不会出现在*foos*中。

有没有一种很好的方法可以按照 sortLikeThis 中的 ID 定义的顺序绑定到 foos 中的 Foo 对象并在*wpf*中*显示***这些**对象？

 *** * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T12:04:23.730

听起来像是自定义 observable 集合的工作，它实现了 IEnumerable 并且有一个非常小的枚举器（aaah，yield）来处理自定义排序的逻辑。

```
public class SortFoosLolThx : ObservableCollection<Foo> {
public IList<string> SortList {/*...*/}
/*...*/
public override IEnumerator<Foo> GetEnumerator() { /*...*/ yield foo; /*...*/}
} 
```

* * *

## 回答 #2

> 赞同：2
> 
> 时间：2008-10-02T13:09:24.697

你看过[Bindable LINQ](http://www.paulstovell.com/blog/category/bindablelinq)吗？它允许您在可观察集合之上定义 LINQ 查询，并确保每次更改基础集合时都执行 LINQ 查询。在您的情况下，您可以在集合顶部添加一个 Orderby 查询。

您可以将 Orderby 方法传递给委托来进行比较。要进行此设置，您将

1.  通过创建一个 Dictionary 将 sortLikeThis 中的每个 id 映射到一个升序 int 来准备
2.  在比较委托中，在字典中查找传递用于比较的两个 foo 的 id。如果找不到项目，请执行适当的操作。

# linux - 如何在 Linux 上从系统缓存中驱逐文件？

> ID：161885
> 
> 赞同：6
> 
> 时间：2008-10-02T11:53:52.350
> 
> 标签：linux, performance, testing, caching, file-io

运行性能测试时，文件系统缓存命中或未命中会显着影响测试结果。因此，通常在运行此类测试之前，使用的文件会从系统缓存中逐出。如何在 Linux 上做到这一点？

**说明：**如果可能，该解决方案不应要求 root 权限。

* * *

## 回答 #1

> 赞同：11
> 
> 时间：2008-10-02T12:38:24.943

作为超级用户，您可以执行以下操作：

释放页面缓存：

*   回声 1 > /proc/sys/vm/drop_caches

要释放 dentry 和 inode：

*   回声 2 > /proc/sys/vm/drop_caches

要释放 pagecache、dentries 和 inode：

*   回声 3 > /proc/sys/vm/drop_caches

此操作不会“丢失”任何数据（缓存在数据被删除之前被写入磁盘），但是，要真正确保所有缓存都已清除，您应该先同步。例如，如果您运行，则应清除所有缓存

```
sync; echo 3 > /proc/sys/vm/drop_caches 
```

正如我所说，只有超级用户（root）可以这样做。

* * *

## 回答 #2

> 赞同：10
> 
> 时间：2008-10-02T14:58:52.157

哈，我有答案：

```
#include <unistd.h>
#include <fcntl.h>
int main(int argc, char *argv[]) {
  int fd;
  fd = open(argv[1], O_RDONLY);
  fdatasync(fd);
  posix_fadvise(fd, 0,0,POSIX_FADV_DONTNEED);
  close(fd);
  return 0;
} 
```

这是来自[http://insights.oetiker.ch/linux/fadvise.html](http://insights.oetiker.ch/linux/fadvise.html)

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2009-07-22T20:12:48.200

Eric Wong 提供了一个命令行实用程序，可以轻松调用 posix_fadvise：

[http://git.bogomips.org/cgit/pcu.git/tree/README](http://git.bogomips.org/cgit/pcu.git/tree/README)

然后就很简单了

```
$ pcu-fadvise -a dontneed filename-to-evict 
```

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T13:55:39.703

关于 O_DIRECT 的使用：这会以另一种方式扰乱结果。内核将尝试将文件系统数据直接 DMA 到您的 read() 缓冲区中，因此可以将其交给您的应用程序，而无需进行任何额外的复制。如果没有 O_DIRECT，内核会将文件数据 DMA 到页面缓存中，并将其从页面缓存复制到您的 read() 缓冲区。

如果您的应用程序真的要在生产中使用 O_DIRECT，这很好。如果您使用 O_DIRECT 运行性能测试，然后删除 O_DIRECT 进行生产，您的性能测试将不切实际。

* * *

## 回答 #5

> 赞同：-1
> 
> 时间：2008-10-12T11:35:31.870

如果您可以将测试数据放在单独的文件系统中，那么为测试重新安装文件系统将为您提供空缓存。

如果您在 /etc/fstab 中使用“用户”选项列出测试文件系统，那么您可以将其挂载以进行测试，而无需成为超级用户

# sql-server - 您如何跟踪 SQL Server 2005 中订阅服务器的复制行时间？

> ID：161890
> 
> 赞同：3
> 
> 时间：2008-10-02T11:54:25.453
> 
> 标签：sql-server, sql-server-2005, replication

基本问题是这样的：
订阅者使用事务复制成功地从发布者复制了一行。现在，我们如何跟踪最后一次成功复制该行的时间？

一位朋友提出了以下解决方案，他将其用于他的 SQL Server 2000：
1) 添加一个日期时间列。
2）更改复制存储过程以更新日期时间列（！）。

第 2 步引发了我内心的各种警钟，所以在我详细介绍他的解决方案之前，我想问在这种情况下是否有更好的 SQL Server 2005 解决方案。

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2009-09-14T16:20:39.300

几周前我遇到了这个确切的问题，试图查找最近更改的记录。

创建一个新列并将数据类型设置为 TIMESTAMP。SS2005 在行更新时自动更新此类型。唯一的问题是这个“时间戳”与日期或时间完全没有关系，它只是一个反映该行最后一次成功更新的数字（任何更新，而不仅仅是通过复制）。如果这就是你所需要的，那么你应该没问题。

如果您需要最后一次*复制*更新，事情可能会变得有些棘手，您需要亲自动手使用触发器和存储过程。

[http://www.sqlteam.com/article/timestamps-vs-datetime-data-types](http://www.sqlteam.com/article/timestamps-vs-datetime-data-types)

希望有帮助~

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-03T07:22:17.517

我会完全按照你朋友的建议去做。这样，只有对复制过程的调用才会更新时间戳。

这种方法的问题是你需要一个写锁，但我没有看到任何其他实用的方法。

否则，您可以使用在获取行时触发的触发器（不要引用我的话，我很少使用触发器），但这似乎不正确（您可能以误报结束）

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-07T08:49:52.640

如果您正在使用事务复制，为什么不记录主数据更新的时间并考虑在下一次复制作业中将其复制到其他数据库？

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-10T08:31:03.520

@Philippe：这种方法的主要问题是由于网络连接不良，复制可能需要一段时间才能到达一些更远程的数据库。因此，主记录的更新时间不会反映记录在远程数据库中实际复制的时间。

无论如何，我已经测试了我朋友的方法，它可以很好地满足我们的要求。

如果有人也想这样做，这里有一个重要的注意事项：在初始化订阅和未来的模式更改时要小心。

就我而言，我们决定[手动初始化快照](http://msdn.microsoft.com/en-us/library/ms151246(SQL.90).aspx)，以便将添加的日期时间列保留在订阅者数据库中。另一种可能的方法可能是允许初始化，但修改现有存储过程以忽略复制添加的日期时间列。

# asp.net - 我可以在同一个 Web 应用程序中同时运行 ASP 和 ASP.NET 页面吗？

> ID：161902
> 
> 赞同：4
> 
> 时间：2008-10-02T11:58:12.357
> 
> 标签：asp.net, web-applications, asp-classic

在将 Web 应用程序从 ASP 更新到 ASP.NET 的过程中，我想将其中一个新文件插入到旧应用程序中以进行测试——这是违反理性的吗？

* * *

## 回答 #1

> 赞同：1
> 
> 时间：2008-10-02T12:00:28.107

是的，但他们不会共享会话内存。我有一个旧的 ASP 网站，并已将主页替换为带有母版页/内容页面设置的 asp.net 页面。我使用 asp.net 来发送电子邮件，而不是使用旧的 asp/com 组件。

一个解决会话共享问题的方法是创建一个桥页面，该页面使用表单发布或查询字符串交换会话数据。[http://msdn.microsoft.com/en-us/library/aa479313.aspx](http://msdn.microsoft.com/en-us/library/aa479313.aspx)

此外，如果您只是在现有的 asp.net 应用程序中添加一个 asp 页面，它将不会运行。您需要在 IIS 中设置整个应用程序，以便 ASP 和 ASP.NET 页面能够像在服务器上一样运行。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-02T14:36:38.933

ASP 和 ASP.NET 可以很好地并行工作。我对人们对会话状态的重要性感到惊讶。我移植到现有 ASP 站点的大多数新 ASP.NET 都不需要 ASP 应用程序存储的任何会话状态。话虽如此，我还是避免在 ASP 或 ASP.NET 中使用会话状态。

唯一棘手的事情是找到一个通用的登录机制，我使用自定义会话 cookie 和数据库条目来做到这一点。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T11:59:48.297

是的。

这不是一个很好的做事方式。但它会很好地工作，直到您尝试共享会话状态等。然后你将不得不做一些额外的工作。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T12:03:36.947

不，您不能将 ASP.NET 文件放入经典的 ASP 应用程序中 - 它不会运行。

您*可以*采用另一种方式，将经典的 ASP 文件放入 ASP.NET 应用程序中。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T12:20:42.223

您可以将 ASP 应用程序发布到 ASP.NET 页面。

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2008-10-02T13:55:57.173

简短的回答是“是”，但这是一次非常痛苦的经历。ASP 页面和 ASP.Net 页面*不会*共享一个公共会话，将两者连接起来并不容易。

# javascript - 确定动态填充的 HTML 表格的高度

> ID：161913
> 
> 赞同：4
> 
> 时间：2008-10-02T12:01:18.230
> 
> 标签：javascript, html, html-table

我想用 HTML 绘制图表。定位结构如下所示：

```
<div id='hostDiv'>
  <div id='backgroundDiv'>
    ... drawing the background ...
  </div>
  <div id='foregroundDiv' style='position: absolute;'>
    ... drawing the foreground ...
  </div>
</div> 
```

前景包含一个动态填充文本的 Table 元素，因此行高可能会根据进入单元格的文本量而改变。如何预测前景中 Table 元素的最终高度？我需要这些信息来设置正确的背景高度。有没有办法从 Javascript 预渲染表格并读出它的高度？还是其他什么技巧？

PS。hostDiv 的大小可能会随着浏览器调整大小而变化。

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-02T12:03:41.017

如果没有在目标浏览器中实际渲染它，就没有任何方法可以预测高度。

一旦你这样做了，你可以使用（例如）[**jQuery**](http://docs.jquery.com/)来获取元素的高度：

```
var height = $('#myTable').height(); 
```

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-02T12:06:26.143

使用 jquery 时，您实际上可以在表格呈现给用户*之前*找出表格的高度。使用这样的结构（从我上面的人那里借用代码）：

```
$(document).ready(function () { var height = $('#myTable').height(); }); 
```

* * *

## 回答 #3

> 赞同：1
> 
> 时间：2008-10-02T12:10:15.993

在加载之前，您无法预测元素的整体高度，因为浏览器将根据相邻元素和查看窗口的大小来渲染和定位元素。

也就是说，您可以使用大多数 js 库来查找您要查找的内容。在原型中，它是：

```
$('navlist-main').offsetHeight 
```

这将递归地累加每个子元素的渲染高度（不仅仅是样式化高度）以及任何相关的边距和填充，并返回元素高度的准确数字。

* * *

## 回答 #4

> 赞同：1
> 
> 时间：2008-10-02T12:11:40.700

如果您只是不想在调整前 div 大小之前显示表格：
表格上设置 style.visibility="hidden"。与 display:none 不同，这不会从文档流中删除 div，因此前景 div 的大小仍将正确（表格将根本不可见）。

当然，如果可以接受，您可以将 foregroundDiv 移动到 backgroundDiv 并移除绝对定位。然后 backgroundDiv 将自动调整大小以包含foregroundDiv（和表格）。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2011-02-24T03:32:49.433

我认为您可以使用其中一个 DOM 属性：clientHeight、offsetHeight 和 scrollHeight，如 w3 中定义的[那样](http://www.w3.org/TR/cssom-view/#extensions-to-the-element-interface)

这是clientHeight的用法：

```
document.getElementById("#Table").clientHeight;
document.getElementById("#Table").clientWidth; 
```

# html - 使用 XHTML 1.0 严格的不等 Html 文本框和下拉列表宽度

> ID：161915
> 
> 赞同：9
> 
> 时间：2008-10-02T12:01:55.967
> 
> 标签：html, css

我试图让两个输入（一个文本框，一个下拉菜单）具有相同的宽度。可以通过css设置宽度，但是由于某种原因，选择框总是小几个像素。似乎这只发生在 xhtml 1.0 strict doctype 关于原因/解决方法的任何建议/想法？

具有以下 HTML

```
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <style>
        .searchInput{
            width: 1000px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <form action="theAction" method="post" class="searchForm" >
        <fieldset>
            <legend>Search</legend>            
            <p>
                <!--<label for="name">Product name</label>-->
                <input class="searchInput" type="text" name="name" id="name" value="" />
            </p>
            <p>
                <!--<label for="ml2">Product Group</label>-->
                <select class="searchInput" name="ml2" id="ml2">
                    <option value="158">INDUSTRIAL PRIMERS/FILLERS</option>
                    <option value="168">CV CLEAR COATS</option>
                    <option value="171">CV PRIMERS/FILLERS</option>
                    <option value="" selected="selected">All</option>
                </select>
            </p>
            <input type="submit"  class="search"  value="Show"  name="Show"  id="Show"  />
            <input type="reset" value="Reset" name="reset" id="reset" class="reset"/>
        </fieldset>
    </form>
</body
</html> 
```

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-03T14:58:33.053

您可以尝试重置边距、填充和边框，看看是否有帮助：

```
.searchInput {
    margin:0;
    padding:0;
    border-width:1px;
    width:1000px;
} 
```

* * *

## 回答 #2

> 赞同：3
> 
> 时间：2008-10-03T21:41:02.727

这似乎与盒子模型有关。更具体地说，它似乎与边界有关。如果您使用的是萤火虫，请查看布局选项卡...

选择显示 2 像素的边框、0 填充和 996 像素的宽度和 18 像素的高度。
输入显示 2px 边框、1px 0 填充和 1000px 宽度和 16px 高度。

如果您将边框设置为零（并给它们一个背景颜色），您可以看到它们的大小相同，这在布局选项卡中显示它们的宽度均为 1000 像素。

```
 .searchInput{
        width: 1000px;
        border: 0;
        background-color: #CCC;
        overflow: hidden;
    } 
```

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T12:08:37.900

你是对的，有4px的差异。这`input`在 103 像素宽，而出现在 99`select`像素宽。我不知道为什么会发生这种情况，但你可以像这样解决它：

```
<style type="text/css">
    .searchInput {
        overflow: hidden;
    }
    select.searchInput {
        width: 101px;
    }
    input.searchInput {
        width: 97px;
    }
</style> 
```

这真的很愚蠢，如果有人知道为什么会发生这种情况以及防止它的方法，我会非常感兴趣。

该变通方法适用于 Webkit 和 Firefox。IE中的像素差异是不同的。

有趣的是，它们通常使用 HTML doctype 的大小相同。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T12:09:59.973

我在 Firefox 2 中遇到过这个问题，但似乎在 Firefox 3 和 IE7 中得到了解决。

我的解决方法是将丢失的像素添加到`select`.

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T16:21:49.087

@Paul D. Waite - Got to agree with you there

This isn't what CSS is meant for. Look at input boxes in Safari, for example. They're elliptical. CSS properties just don't apply in some cases.

Pad around your elements to line them up.

* * *

## 回答 #6

> 赞同：0
> 
> 时间：2009-02-21T13:48:49.977

这确实是由于#IE 在文档类型中找到“严格”时支持的盒模型。如果您将其更改为“传统”文档类型，一切都会正常运行……但通常不符合 CSS 标准。

CSS 盒子模型指出，在元素的宽度/高度中，不包括填充和边框。因此，它们是在提到的元素宽度之上的附加值，因此实际上比预期的要大。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T13:31:54.283

浏览器倾向于在表单元素和样式方面做自己的事情。CSS 标准没有指定浏览器应该如何显示表单小部件，也没有指定它应该让用户更改哪些 CSS 属性。它在浏览器之间以及同一浏览器中的不同表单小部件之间有所不同。

您可以尝试调整填充和边框以帮助不同的表单小部件匹配。

* * *

## 回答 #8

> 赞同：-1
> 
> 时间：2008-10-02T12:27:16.000

似乎只有添加了 doctype 才会发生这种情况。更正了示例。

# environment - 转角桌与直桌

> ID：161925
> 
> 赞同：6
> 
> 时间：2008-10-02T12:03:59.613
> 
> 标签：environment, ergonomics

我工作的公司目前正在进行全厂改造，我正在参与关于研发工作空间的“咨询”。

没有单独的私人办公室的范围 - 所以让我们不要从这个话题开始。

一大要求是办公室布局可以灵活（即可以根据需要创建和更改团队区域）。

为了实现这一点，最重要的变化之一是我们将失去面向角落的办公桌。理由是，既然没有人再有大的 CRT 显示器，我们就不需要浪费角落里的空间了。

人们不愿接受这种改变，但我不确定这是否只是因为人们不喜欢改变，或者背后是否有真正的原因。我已经将我的设置从角落移到直边上，看看它对我自己有多大的影响。

我们还被告知，这种情况现在正在整个行业中发生……人们正在从他们的角落转移到更像长凳的安排中。

所以我的问题是双重的：

1.  有一个角落真的很重要吗？
2.  真的有全行业的“走出困境”吗？

我知道这里已经有很多关于开发人员条件的问题，但我不认为这个具体问题没有。

* * *

## 回答 #1

> 赞同：7
> 
> 时间：2008-10-02T13:00:42.830

用于结对编程的直桌非常适合这种类型的椅子：
[http://www.cenqua.com/pairon/](http://www.cenqua.com/pairon/)

* * *

## 回答 #2

> 赞同：6
> 
> 时间：2008-10-02T12:07:10.277

如果您要进行任何结对编程，那么我建议您避免使用角落办公桌，因为它们会妨碍两个人并排工作的能力。

那么弧形办公桌呢？一个四人团队，带有弯曲的办公桌（远离您，而不是您周围）将形成一个圆形阵型，非常适合小组讨论和结对编程。

* * *

## 回答 #3

> 赞同：6
> 
> 时间：2008-10-02T12:17:00.110

我个人的偏好是转角办公桌，它们在打字或移动鼠标时可以更好地支撑您的手臂。您可以在不移动椅子的情况下在桌子上做笔记，也可以在桌子上与人交谈，而无需站起来或靠在显示器的一侧。

关于结对编程，您始终可以将显示器稍微移到您身边（就像您在直桌中所做的那样），并拥有与任何其他桌子相同的设施。

你也可以增大你的肚子，它会完美地适合桌子的内圆部分，而不会让你远离电脑；）

* * *

## 回答 #4

> 赞同：4
> 
> 时间：2008-10-02T12:11:09.347

我认为一个更大的问题是你的同事会如何看待它。如果他们觉得自己失去了声望或因为失去角落办公桌而被视为机器人，那可能比生产力的任何实际差异更重要。（我觉得即使有一个也会很小，在两者都工作过。）

* * *

## 回答 #5

> 赞同：3
> 
> 时间：2008-10-02T12:06:03.990

我有一张转角办公桌，虽然我的整体工作区很小，但它很有用。我可以想象一个带有“翅膀”的角落办公桌会更好，因为这会给你一个更大的工作区域。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2008-10-02T12:08:25.577

我目前在一张 L 形办公桌上工作，角落是我电脑的主要工作区。短的部分是我的手机和记事本所在的地方。较长的部分是我的书和我必须阅读或回顾的东西。我发现拥有 L 型办公桌很有用，但我们不使用立方体（甚至办公室）进行激烈的团队会议——对于那些，我们带着笔记本电脑去会议室（我们这里不使用台式机）。

* * *

## 回答 #7

> 赞同：3
> 
> 时间：2008-10-08T02:27:44.907

我看到很多人已经提到它，但正如[Joel Spolsky 在他关于新 Fog Creek 办公室的博客文章中所说](http://www.joelonsoftware.com/articles/BionicOffice.html)，**L 形办公桌不适合结对编程**：

> *结对编程*。当您制作典型的 L 形办公桌时，许多开发人员都会把自己安置在角落里。当他们需要临时协作、结对编程，甚至只是在他们的屏幕上向某人展示某些东西时，第二个人必须一直靠在桌子对面，或者从第一个人的肩膀上看过去。为了避免这种情况，我们将所有的桌子都设计成又长又直，这样无论软件开发人员坐在哪里，总有空间让另一个人拉起椅子坐在他们旁边。

* * *

## 回答 #8

> 赞同：3
> 
> 时间：2008-10-02T12:53:06.030

我可能有点奇怪，但实际上我更喜欢使用直的、矩形的桌子。这样做的简单原因是我喜欢在我的键盘（或笔记本电脑）边缘和桌子边缘之间留出尽可能小的空间。我不时地移动一些东西——为了变化——但我的键盘离桌子边缘很少超过 5-10 厘米。正因为如此，角落的桌子或没有直边的桌子只会让我烦恼。

我理想的办公桌是一张 160x80 厘米的木制“床单”，上面有四个简单、可调节的腿，而且没有“幻想”——因为它们往往会妨碍我（如果你曾经把腿撞到穿过你下面的金属条之一） “稳定”的办公桌，你知道我在说什么）。

如果您需要更多空间，您可以随时将两张桌子组合成一个漂亮的大表面，您可以轻松“滑动”而不用担心撞到任何角落或边缘“突出”。此外，正如其他人所提到的，直立的办公桌更适合结对编程或任何其他形式的团体活动，其中涉及多人坐在办公桌/显示器前。

* * *

## 回答 #9

> 赞同：3
> 
> 时间：2008-10-02T12:25:42.507

我喜欢我的角落。它给了我一种熟悉的安全感。到目前为止，我已经从站在学校的角落发展到坐在工作的角落。我正在焦急地等待下一阶段，躺在家里的一个角落里:)

更严肃一点：我喜欢L型的桌子，不管是不是在角落里，因为桌子的两边“更近”，我可以通过转动椅子轻松改变焦点。在角落里蜂拥而至在开放式办公室中具有优势，并且视线中的代码猴分散注意力较少......

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2008-10-02T12:11:40.187

我更喜欢四张桌子组合在一起的岛屿 - 非常适合四人团队。它们是角落书桌，但不用于角落。它们也是长方形的，可以进行配对编程。

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-10-02T13:50:41.400

我目前在直桌工作。不过我更喜欢角​​落的桌子。有了直桌，我的办公桌空间似乎少了很多，可以放容易拿到的文件。使用 L 型办公桌，我有更多可触及的区域来放置东西。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2008-10-02T12:35:55.540

我有一张 L 形的角桌。正如其他人所提到的，结对编程会让事情变得有些棘手，但即使我一个人，我也会下意识地觉得它有点费力。

屏幕围绕其中一个直位，一个肘部坐在“L”部分，另一个漂浮在自由空间中，感觉“不平衡”；角落里有屏幕，没有任何配对的希望，我觉得自己被困在了我的藏身处。

考虑到所有因素，我宁愿有一张直桌。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-10-02T12:08:19.837

我们所有的立方体/办公室都在 2 个相邻的墙壁上衬有办公桌，因此如果有人愿意，总有一个角落可以使用。尽管如此，我不能说我在这里见过有人把他们的装置放在角落里。我个人认为不是在角落里更舒服。

* * *

## 回答 #14

> 赞同：0
> 
> 时间：2008-10-08T02:32:44.383

角桌能够在打字和使用鼠标时支撑您的手臂，对您的健康非常有益（我猜）

* * *

## 回答 #15

> 赞同：0
> 
> 时间：2008-10-02T13:49:14.883

我以前有一张角落办公桌，但最近，我搬到了一张直桌（这是我的决定）。错误的决定。我有 2 24 英寸。连接到我的桌面的宽屏显示器，加上我的笔记本电脑，这是一个 19 英寸的宽屏。[我通过Synergy](http://synergy2.sourceforge.net/)使用单个鼠标和键盘。没有很好的方法来放置显示器和笔记本电脑，让您可以直面所有屏幕。面对一个角落和一个**键盘托盘**，您可以将自己放在周围，这样您就可以直视每个屏幕，或者尽量不转动头部。

我真的在考虑转行。

* * *

## 回答 #16

> 赞同：0
> 
> 时间：2008-10-02T12:12:01.013

我有一张转角办公桌，但它的实际正面是弯曲的，所以它就像是直角和角的混合体。

* * *

## 回答 #17

> 赞同：0
> 
> 时间：2008-10-02T12:12:25.957

我们的商店本身不使用桌子。我们有这些工业工作台，头顶上有重型机架，盒子可以放在上面，提供了大量的桌面空间——我桌子上唯一的东西是四个纯平显示器、几个键盘和鼠标。如果我有自己的办公室（我确实有），我喜欢直立的办公桌，但当我在一个有多人的大房间里工作时，我实际上更喜欢角落风格或立方体，这样可以减少一些干扰。

* * *

## 回答 #18

> 赞同：0
> 
> 时间：2008-10-02T12:21:08.853

我会在任何一天直接使用角落办公桌。我在办公桌上处理很多有形物品（文件夹、时间日志、计算器、咖啡等），如果没有角落办公桌，我不知道我会把它们放在什么地方，触手可及。

* * *

## 回答 #19

> 赞同：0
> 
> 时间：2008-10-02T12:21:48.133

整体平面图决定了最适合人们的方式。

我以前的雇主使用带有环绕式办公桌的立方体，可以使用面向角的或直的。大多数用作角落饰面以增加腿部空间。

我同意 Sam Wessel 的观点，结对编程概念最适合直接使用办公桌，以快速共享工作空间并查看彼此的显示器。

我也曾在前雇主的德国分公司工作过一段时间，他们的模式是将地板分隔成带有高隔墙的房间，并在中间贴 4 张桌子，这样每个人都面对面，而不是远离。高高的隔墙阻挡了闲聊，但如果需要，您仍然可以向邻居喊叫。这使您可以建立一种紧密的工作组关系，否则您将无法建立这种关系。我喜欢这种布局。

我现在的雇主只使用靠墙或半高隔板排列的桌子。他们相信干净的办公桌政策和最小的存储空间。忘记你的编码书籍收藏或办公室装饰、隐私等。我最终在电话里和我妻子耳语，因为每个人都听到了你的声音。我不是粉丝。他们可以像沙丁鱼一样把我们挤在一起，以减少办公空间的占用。由于增长，他们现在将人们的办公桌推向会议室和储藏室。很快，我预计会搬到没有订书机的地下室。

# git - .git/info/grafts 有什么用？

> ID：161928
> 
> 赞同：51
> 
> 时间：2008-10-02T12:05:16.707
> 
> 标签：git, version-control

我试图弄清楚 Git 中的“移植物”是什么。

例如，在[这里](http://web.archive.org/web/20080930112610/http://log.emmanuelebassi.net/archives/2007/09/when-the-levee-breaks/)的最新评论之一中，Tobu 假设使用**git-filter-branch**和**.git/info/grafts**来加入两个存储库。

但我不明白为什么我需要这些*移植物*？看来，所有工作都没有最后两个命令。

* * *

## 回答 #1

> 赞同：38
> 
> 时间：2008-10-02T12:11:07.160

来自[Git 维基](https://git.wiki.kernel.org/index.php/GraftPoint)：

> 移植点或移植物使两条不同的发展线能够连接在一起。它的工作原理是让用户记录提交的虚假祖先信息。这样，您可以让 git 假装提交所具有的父集与创建提交时记录的不同。
> 
> **使用移植物的原因**
> 
> 在将开发转移到 git 时，Grafts 很有用，因为它允许您克隆从另一个 SCM 导入的旧历史记录，这是可选的。这为只想遵循最新版本的用户保留了初始克隆，而开发人员可以获得完整的开发历史记录。
> 
> 当 Linus 开始使用 git 来维护他的内核树时，并没有任何工具可以转换旧的内核历史。后来，当旧的内核历史从 bkcvs 网关导入到 git 时，grafts 被创建为一种可以将两个不同的存储库绑定在一起的方法。

* * *

## 回答 #2

> 赞同：12
> 
> 时间：2018-05-24T20:37:34.430

[Chris Johnsen](https://stackoverflow.com/users/193688/chris-johnsen)[提到](https://stackoverflow.com/a/3148117/6309)的加入两个存储库的移植方法不再*完全*有效（仅使用移植）。 在 Git 2.18（2018 年第二季度）中，“ ”的功能已被“ ”机制所取代（一段时间以来）。**内部代码在很多地方都支持它，为了放弃对“嫁接”机制的支持，** 已经对其进行了清理 。 *`$GIT_DIR/info/grafts``refs/replace/`* 

 ***请参阅[提交 a3694d9](https://github.com/git/git/commit/a3694d949fcd39f9a909cf762f698df8ce83215c)、[提交 f42fa47](https://github.com/git/git/commit/f42fa470b0d87fcb36475f78f2366bba6864895a)、[提交 8d0d81a](https://github.com/git/git/commit/8d0d81a9caf612b479b96bc474815e2f38c4746b)、[提交 e2d65c1](https://github.com/git/git/commit/e2d65c1ea810f34681c3f3aba03c58b6e8484b3f)、[提交 f9f99b3](https://github.com/git/git/commit/f9f99b3f7d06716336b239bcf122eb5a7348bfd5)、[提交 0115e03](https://github.com/git/git/commit/0115e030db499853a77c2b92dc8c6a51552009ef)、[提交 fb40429](https://github.com/git/git/commit/fb40429109723c0d8ec77ba81421f508ac2532a0)、[提交 041c98e](https://github.com/git/git/commit/041c98e22d88d963a92f1bac6ab348a0d4c6d228)、[提交 e24e871](https://github.com/git/git/commit/e24e871920ac04473a470645e4c4dc53b422dd75)（2018 年 4 月 28 日）和[提交 d398f2e](https://github.com/git/git/commit/d398f2ea001ab4e639896c81fb616810cf14eb12) [、](https://github.com/dscho)提交[Jodb25461e](https://github.com/git/git/commit/fef461ea5d53dd84c6d946f57a018ffc9f391a05) 2018年[aa](https://github.com/git/git/commit/c5aa6db64f6f43621568bb1fec9360c25dbd2749) [( `dscho`)](https://github.com/dscho)。
^(（由[Junio C Hamano 合并 -- `gitster`--](https://github.com/gitster)在[提交 352cf6c](https://github.com/git/git/commit/352cf6cfe138b1dbcf9c105c91ca793b67511d7b)中，2018 年 5 月 23 日）)

所以而不是

```
echo "$commit-id $graft-id" >> .git/info/grafts 
```

你现在做：

```
git replace --graft $commit-id $graft-id
git filter-branch $graft-id..HEAD 
```

> ## 弃用支持`.git/info/grafts`
> 
> 移植功能是将古代历史“缝合”到新的开始的便捷方式`linux.git`。
> 
> 然而，它的实现并没有达到 Git 的标准，因为有太多的方式会导致令人惊讶和不受欢迎的行为。
> 
> 例如，当从具有活动移植的存储库推送时，可能会错过已“移植”的提交，从而导致另一侧处于损坏状态。
> 
> 此外，grafts 功能仅限于“重写”提交的父级列表，它不能替代任何其他内容。
> 
> 实施的更年轻的功能`git replace`旨在纠正这些限制和危险的错误。
> 
> 看到`git replace`现在已经相当成熟了（因为[4228e8b](https://github.com/git/git/commit/4228e8bc989c6cac1c47faece720faa06531281f) （替换：添加`--graft`选项，2014-07-19，Git 2.1.0）它可以执行嫁接文件的职责），是时候弃用对嫁接文件的支持并退休了它最终。

现在（再次，Git 2.18，2018 年第二季度），你有：

> ## `replace`: 添加`--graft`选项
> 
> 此选项的使用字符串是：
> 
> ```
> git replace [-f] --graft <commit> [<parent>...] 
> ```
> 
> 首先，我们创建一个新的提交，`<commit>` 除了它的父母是`[<parents>...]`
> 
> 然后我们创建一个替换引用，用我们刚刚创建的提交替换。
> 
> 使用这个新选项，将移植物转换为替换参考应该很简单。

* * *

而在 Git 2.20（2018 年第四季度）之前，最近引入的提交图辅助数据与“破坏”对象引用关系的不可变性质的替换和移植等机制不兼容。
**当存储库中使用这些不兼容的功能时，根据其使用（并更新现有的提交图）禁用优化。**

请参阅[Derrick Stolee ( ) 的](https://github.com/derrickstolee)[提交 829a321](https://github.com/git/git/commit/829a321569d8e8f2c582aef9f0c990df976ab842)、[提交 5cef295](https://github.com/git/git/commit/5cef295f283e84351a104c66f949a53a56297aa7)、[提交 20fd6d5](https://github.com/git/git/commit/20fd6d57996e33c30b6bb030329523d0116f15ec)、[提交 d653824](https://github.com/git/git/commit/d6538246d3d4edbfbc9b0af6a2aa38552d35f7f1)、[提交 b775896](https://github.com/git/git/commit/b7758963424e238b9152f0c9991325ff7fdffff1)、[提交 950c62b](https://github.com/git/git/commit/950c62bda208790e223230a73ce6c19ae8f9177b)（2018 年 8 月 20 日[）](https://github.com/derrickstolee)。 请参阅[Stefan Beller ( ) 的](https://github.com/stefanbeller)[提交 212e0f7](https://github.com/git/git/commit/212e0f7efe163d062dcd393a0788cf3f93544a6e)和[提交 4a6067c](https://github.com/git/git/commit/4a6067cda51b592871144eb050d4673db9ad5103)（2018 年 8 月 20 日[）](https://github.com/stefanbeller)。^(（由)^([Junio C Hamano 合并 --](https://github.com/gitster)) ^([--](https://github.com/gitster))^在^([6d8f8eb 提交中](https://github.com/git/git/commit/6d8f8ebb74d21b51cfbf427a436094134af36ee2))^(，2018 年 10 月 16 日）)[`derrickstolee`](https://github.com/derrickstolee)
[`stefanbeller`](https://github.com/stefanbeller)
^([`gitster`](https://github.com/gitster))

* * *

使用 Git 2.24（2019 年第四季度），在响应浅层克隆/获取请求时需要禁用提交图的“ `upload-pack`”（“”的对应物`git fetch`）不再恐慌。

请参阅[Jeff King ( ) 的](https://github.com/peff)[提交 6abada1](https://github.com/git/git/commit/6abada1880156df9c6a0de91fb23716e378e13d7)和[提交 fbab552](https://github.com/git/git/commit/fbab552a53a2558ec84a06034e6657fb95227266)（2019 年 9 月 12 日[）](https://github.com/peff)。^(（由)^([Junio C Hamano 合并 --](https://github.com/gitster)) ^([--](https://github.com/gitster))^在^([提交 098e8c6](https://github.com/git/git/commit/098e8c6716b8c6abc29b6788acdb3ac8725f835d))^(中，2019 年 10 月 7 日）)[`peff`](https://github.com/peff)
^([`gitster`](https://github.com/gitster))

> ## `upload-pack`: 更温和地禁用提交图以进行浅层遍历
> 
> 当客户要求某些浅层选项（例如“deepen-since”）时，我们会进行自定义的 rev-list walk 假装是浅层的。
> 在这样做之前，我们必须禁用提交图，因为它与存储库的浅视图不兼容。这是由[829a321](https://github.com/git/git/commit/829a321569d8e8f2c582aef9f0c990df976ab842)处理的（`commit-graph`：close_commit_graph before shallow walk，2018-08-20，Git v2.19.2）。
> 该提交实际上关闭并释放了我们的`repo->objects->commit_graph struct`.
> 
> *对于已经*使用提交图解析的提交，这会产生一个有趣的问题。
> 他们的`commit->object.parsed`标志已经设置，他们`commit->graph_pos`的设置，但他们`commit->maybe_tree`可能仍然是`NULL`。
> 当有人稍后调用`repo_get_commit_tree()`时，我们看到我们还没有加载树 oid，并尝试从提交图中获取它。
> 但是既然它已经被释放了，我们就会出现段错误！
> 
> 所以问题的根源是提交的延迟加载树 oid 和提交图可以在进程中消失的事实之间的数据依赖关系。

* * *

## 回答 #3

> 赞同：8
> 
> 时间：2011-04-14T15:25:19.513

使用 git-svn 时：

git 移植对于将 Git 树导入 Subversion 存储库非常有用。

例如，我创建了一个本地 Git 存储库作为开始。经过几天的工作，创建了大量的提交，我不得不将它发布到中央 Subversion 存储库中，我不想丢失历史记录。

我找到了以下操作方法文章： [http ://eikke.com/importing-a-git-tree-into-a-subversion-repository/](http://eikke.com/importing-a-git-tree-into-a-subversion-repository/)

# http - 如何在jsp页面中停用缓存

> ID：161937
> 
> 赞同：4
> 
> 时间：2008-10-02T12:07:28.653
> 
> 标签：http, jsp, jstl, cache-control, no-cache

我知道有一个 HTTP 响应标头指令可以禁用页面缓存：

```
Cache-Control:no-cache 
```

我可以通过“手”修改标题：

```
 <%response.addHeader("Cache-Control","no-cache");%> 
```

但是有没有一种“好”的方法可以让 JSP 解释器在服务器响应中返回这个标题行？

（我检查了 <%@page ...%> 指令。似乎没有这样的东西。）

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-04T05:54:20.123

还添加

```
response.addHeader("过期","-1");
response.addHeader("Pragma","no-cache");

```

到你的头球并试一试。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2008-10-02T12:11:41.573

如果您使用的是 servlet，那么我相信您在问题中发布的内容将是正确的方法。我不知道在 JSP 中有任何方法可以做到这一点。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T12:51:36.563

```
<?xml version="1.0"?>
<jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" version="2.0"> 
 <jsp:scriptlet><![CDATA[
   response.setHeader("Cache-Control", "no-cache");
 ]]></jsp:scriptlet>
</jsp:root> 
```

您必须将响应标头放入`<jsp:root />`. 另外，我建议它从您的 servlet 而不是 JSP 页面发送它。

* * *

## 回答 #4

> 赞同：0
> 
> 时间：2008-10-02T12:58:58.560

IIRC 某些浏览器可能会在某些情况下忽略缓存控制设置。解决此问题的“安全”解决方法是始终获取带有新查询字符串变量（例如时间）的页面（甚至是 AJAX 块）。

# c# - .NET 异常有多慢？

> ID：161942
> 
> 赞同：146
> 
> 时间：2008-10-02T12:09:10.147
> 
> 标签：c#, .net, performance, exception

我不想讨论什么时候抛出异常，什么时候不抛出异常。我想解决一个简单的问题。99% 的时间，不抛出异常的论点围绕着它们很慢，而另一方声称（通过基准测试）速度不是问题。我已经阅读了许多与一方或另一方相关的博客、文章和帖子。那么它是哪一个？

答案中的一些链接：[Skeet](http://yoda.arachsys.com/csharp/exceptions2.html)、[Mariani](http://blogs.msdn.com/ricom/archive/2006/09/25/771142.aspx)、[Brumme](http://blogs.msdn.com/cbrumme/archive/2003/10/01/51524.aspx)。

* * *

## 回答 #1

> 赞同：212
> 
> 时间：2008-10-02T12:15:25.187

我在“不慢”方面 - 或者更准确地说“不够慢以至于值得在正常使用中避免它们”。我已经写了[两篇](http://pobox.com/%7Eskeet/csharp/exceptions2.html)关于这个的[短文。](http://pobox.com/%7Eskeet/csharp/exceptions.html) 有对基准方面的批评，主要归结为“在现实生活中会有更多的堆栈要通过，所以你会破坏缓存等” - 但是使用错误代码来提升堆栈*也会*吹缓存，所以我不认为这是一个特别好的论点。

 *只是说清楚 - 我不支持使用不合逻辑的异常。例如，`int.TryParse`完全适合转换来自用户的数据。读取机器生成的文件时这是不合适的，其中失败意味着“文件不是应有的格式，我真的不想尝试处理这个问题，因为我不知道还有什么问题。 "

在“仅在合理的情况下”使用异常时，我从未见过一个应用程序的性能受到异常的严重影响。基本上，除非您遇到严重的正确性问题，否则不应经常发生异常，并且如果您遇到严重的正确性问题，那么性能并不是您面临的最大问题。

* * *

## 回答 #2

> 赞同：35
> 
> 时间：2008-10-02T12:33:48.790

实施它们的人克里斯·布鲁姆（Chris Brumme）对此给出了明确的答案。他写了一篇关于这个主题的[优秀博客文章](https://devblogs.microsoft.com/cbrumme/the-exception-model/)（警告 - 很长）（警告2 - 写得很好，如果你是技术人员，你会读到最后，然后必须在下班后弥补你的时间:) )

执行摘要：他们很慢。它们被实现为 Win32 SEH 异常，因此有些甚至会通过 ring 0 CPU 边界！显然，在现实世界中，您将做很多其他工作，因此根本不会注意到奇怪的异常，但是如果您将它们用于程序流程，则希望您的应用程序会受到重创。这是 MS 营销机器对我们造成伤害的另一个例子。我记得一位微软告诉我们他们是如何产生绝对零开销的，这完全是胡说八道。

克里斯给出了一个相关的引用：

> 事实上，即使在引擎的非托管部分，CLR 在内部也使用异常。但是，有一个严重的长期性能问题，例外情况必须考虑到您的决定。

* * *

## 回答 #3

> 赞同：9
> 
> 时间：2008-10-02T12:44:34.383

我不知道人们在说他们只有被抛出时才慢时在说什么。

*编辑：如果没有抛出异常，那么这意味着你正在做 new Exception() 或类似的事情。否则异常会导致线程被挂起，栈被遍历。这在较小的情况下可能没问题，但是在高流量的网站中，依赖异常作为工作流或执行路径机制肯定会导致性能问题。异常本身并不坏，并且对于表达异常情况很有用*

.NET 应用程序中的异常工作流使用第一次和第二次机会异常。对于所有异常，即使您正在捕获和处理它们，仍然会创建异常对象，并且框架仍然必须遍历堆栈以查找处理程序。如果您捕获并重新抛出当然会花费更长的时间 - 您将获得第一次机会异常，捕获它，重新抛出它，导致另一个第一次机会异常，然后找不到处理程序，然后导致第二次机会例外。

异常也是堆上的对象 - 因此，如果您抛出大量异常，那么您将导致性能和内存问题。

此外，根据我的 ACE 团队编写的“性能测试 Microsoft .NET Web 应用程序”副本：

“异常处理代价高昂。当 CLR 通过调用堆栈递归搜索正确的异常处理程序时，相关线程的执行被挂起，当找到正确的异常处理程序时，异常处理程序和一些 finally 块必须都有机会执行在进行常规处理之前。”

我自己在该领域的经验表明，减少异常可以显着提高性能。当然，在进行性能测试时，您还需要考虑其他一些事情——例如，如果您的磁盘 I/O 被触发，或者您的查询是在几秒钟内完成的，那么这应该是您的重点。但是发现和消除异常应该是该策略的重要组成部分。

* * *

## 回答 #4

> 赞同：7
> 
> 时间：2008-10-02T12:19:55.393

我理解的论点并不是抛出异常是不好的，它们本身很慢。相反，它是关于使用 throw/catch 构造作为控制正常应用程序逻辑的一流方式，而不是更传统的条件构造。

通常在正常的应用程序逻辑中，您执行循环，其中相同的操作重复数千/数百万次。在这种情况下，通过一些非常简单的分析（参见 Stopwatch 类），您可以亲眼看到抛出异常而不是简单的 if 语句会变得非常慢。

事实上，我曾经读到 Microsoft 的 .NET 团队将 .NET 2.0 中的 TryXXXXX 方法引入了许多基本 FCL 类型，特别是因为客户抱怨他们的应用程序性能太慢。

事实证明，在许多情况下，这是因为客户在循环中尝试对值进行类型转换，并且每次尝试都失败了。一个转换异常被抛出，然后被异常处理程序捕获，然后吞下异常并继续循环。

Microsoft 现在建议在这种情况下尤其应使用 TryXXX 方法，以避免此类可能的性能问题。

我可能是错的，但听起来你不确定你读到的“基准”的真实性。简单的解决方案：自己尝试一下。

* * *

## 回答 #5

> 赞同：4
> 
> 时间：2008-10-02T12:51:06.037

在我一直试图阻止它们发生（例如在尝试读取更多数据之前检查套接字是否已连接）并为自己提供避免它们的方法之后，我的 XMPP 服务器获得了显着的速度提升（抱歉，没有实际数字，纯粹是观察性的） （提到的 TryX 方法）。那是只有大约 50 个活跃（聊天）的虚拟用户。

* * *

## 回答 #6

> 赞同：3
> 
> 时间：2011-03-25T12:17:21.060

只是为了在这个讨论中添加我自己最近的经验：与上面写的大部分内容一致，我发现在重复执行时抛出异常非常慢，即使没有调试器运行。我刚刚通过更改大约五行代码将我正在编写的大型程序的性能提高了 60%：切换到返回代码模型而不是抛出异常。诚然，有问题的代码在我更改之前运行了数千次，并可能引发数千个异常。所以我同意上面的说法：当重要的事情真的出错时抛出异常，而不是作为在任何“预期”情况下控制应用程序流的一种方式。

* * *

## 回答 #7

> 赞同：2
> 
> 时间：2008-10-02T12:26:15.860

我从来没有遇到过任何异常的性能问题。我经常使用异常——如果可以的话，我从不使用返回码。它们是一种不好的做法，在我看来，闻起来像意大利面条代码。

我认为这一切都归结为你如何使用异常：如果你像返回码一样使用它们（堆栈中的每个方法调用都会捕获并重新抛出），那么，是的，它们会很慢，因为每次捕获/抛出都有开销。

但是，如果您在堆栈底部抛出并在顶部捕获（您将整个返回码链替换为一次抛出/捕获），则所有昂贵的操作都将完成一次。

归根结底，它们是有效的语言功能。

**只是为了证明我的观点**

请[在此链接上运行代码](http://pastebin.com/f11f9e966)（太大而无法回答）。

我的电脑上的结果：

`marco@sklivvz:~/develop/test$ mono Exceptions.exe | grep PM
10/2/2008 2:53:32 PM
10/2/2008 2:53:42 PM
10/2/2008 2:53:52 PM`

时间戳在开头输出，在返回码和异常之间，最后输出。在这两种情况下都需要相同的时间。请注意，您必须使用优化进行编译。

* * *

## 回答 #8

> 赞同：2
> 
> 时间：2008-10-02T12:27:06.747

如果将它们与返回代码进行比较，它们会非常慢。但是，正如之前的海报所说，您不想投入正常的程序操作，因此只有在出现问题时才会受到性能影响，并且在绝大多数情况下，性能不再重要（因为异常意味着无论如何都会遇到障碍）。

它们绝对值得使用而不是错误代码，其优点是巨大的 IMO。

* * *

## 回答 #9

> 赞同：2
> 
> 时间：2012-02-24T05:38:57.280

但是 mono 抛出异常的速度比 .net 独立模式快 10 倍，而 .net 独立模式抛出异常的速度比 .net 调试器模式快 60 倍。（测试机具有相同的CPU型号）

```
int c = 1000000;
int s = Environment.TickCount;
for (int i = 0; i < c; i++)
{
    try { throw new Exception(); }
    catch { }
}
int d = Environment.TickCount - s;

Console.WriteLine(d + "ms / " + c + " exceptions"); 
```

* * *

## 回答 #10

> 赞同：2
> 
> 时间：2012-03-21T04:40:05.330

在 Windows CLR 上，对于深度为 8 的调用链，抛出异常比检查和传播返回值慢 750 倍。（请参阅下面的基准）

异常的高成本是因为 Windows CLR 与称为[Windows 结构化异常处理](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680657(v=vs.85).aspx)的东西集成在一起。这使得异常能够在不同的运行时和语言中被正确地捕获和抛出。但是，它非常非常缓慢。

Mono 运行时（在任何平台上）中的异常要快得多，因为它不与 SEH 集成。但是，跨多个运行时传递异常时会丢失功能，因为它不使用 SEH 之类的东西。

以下是我的 Windows CLR 异常与返回值基准测试的简短结果。

```
baseline: recurse_depth 8, error_freqeuncy 0 (0), time elapsed 13.0007 ms
baseline: recurse_depth 8, error_freqeuncy 0.25 (0), time elapsed 13.0007 ms
baseline: recurse_depth 8, error_freqeuncy 0.5 (0), time elapsed 13.0008 ms
baseline: recurse_depth 8, error_freqeuncy 0.75 (0), time elapsed 13.0008 ms
baseline: recurse_depth 8, error_freqeuncy 1 (0), time elapsed 14.0008 ms
retval_error: recurse_depth 5, error_freqeuncy 0 (0), time elapsed 13.0008 ms
retval_error: recurse_depth 5, error_freqeuncy 0.25 (249999), time elapsed 14.0008 ms
retval_error: recurse_depth 5, error_freqeuncy 0.5 (499999), time elapsed 16.0009 ms
retval_error: recurse_depth 5, error_freqeuncy 0.75 (999999), time elapsed 16.001 ms
retval_error: recurse_depth 5, error_freqeuncy 1 (999999), time elapsed 16.0009 ms
retval_error: recurse_depth 8, error_freqeuncy 0 (0), time elapsed 20.0011 ms
retval_error: recurse_depth 8, error_freqeuncy 0.25 (249999), time elapsed 21.0012 ms
retval_error: recurse_depth 8, error_freqeuncy 0.5 (499999), time elapsed 24.0014 ms
retval_error: recurse_depth 8, error_freqeuncy 0.75 (999999), time elapsed 24.0014 ms
retval_error: recurse_depth 8, error_freqeuncy 1 (999999), time elapsed 24.0013 ms
exception_error: recurse_depth 8, error_freqeuncy 0 (0), time elapsed 31.0017 ms
exception_error: recurse_depth 8, error_freqeuncy 0.25 (249999), time elapsed 5607.3208     ms
exception_error: recurse_depth 8, error_freqeuncy 0.5 (499999), time elapsed 11172.639  ms
exception_error: recurse_depth 8, error_freqeuncy 0.75 (999999), time elapsed 22297.2753 ms
exception_error: recurse_depth 8, error_freqeuncy 1 (999999), time elapsed 22102.2641 ms 
```

这是代码..

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1 {

public class TestIt {
    int value;

    public class TestException : Exception { } 

    public int getValue() {
        return value;
    }

    public void reset() {
        value = 0;
    }

    public bool baseline_null(bool shouldfail, int recurse_depth) {
        if (recurse_depth <= 0) {
            return shouldfail;
        } else {
            return baseline_null(shouldfail,recurse_depth-1);
        }
    }

    public bool retval_error(bool shouldfail, int recurse_depth) {
        if (recurse_depth <= 0) {
            if (shouldfail) {
                return false;
            } else {
                return true;
            }
        } else {
            bool nested_error = retval_error(shouldfail,recurse_depth-1);
            if (nested_error) {
                return true;
            } else {
                return false;
            }
        }
    }

    public void exception_error(bool shouldfail, int recurse_depth) {
        if (recurse_depth <= 0) {
            if (shouldfail) {
                throw new TestException();
            }
        } else {
            exception_error(shouldfail,recurse_depth-1);
        }

    }

    public static void Main(String[] args) {
        int i;
        long l;
        TestIt t = new TestIt();
        int failures;

        int ITERATION_COUNT = 1000000;

        // (0) baseline null workload
        for (int recurse_depth = 2; recurse_depth <= 10; recurse_depth+=3) {
            for (float exception_freq = 0.0f; exception_freq <= 1.0f; exception_freq += 0.25f) {            
                int EXCEPTION_MOD = (exception_freq == 0.0f) ? ITERATION_COUNT+1 : (int)(1.0f / exception_freq);            

                failures = 0;
                DateTime start_time = DateTime.Now;
                t.reset();              
                for (i = 1; i < ITERATION_COUNT; i++) {
                    bool shoulderror = (i % EXCEPTION_MOD) == 0;
                    t.baseline_null(shoulderror,recurse_depth);
                }
                double elapsed_time = (DateTime.Now - start_time).TotalMilliseconds;
                Console.WriteLine(
                    String.Format(
                      "baseline: recurse_depth {0}, error_freqeuncy {1} ({2}), time elapsed {3} ms",
                        recurse_depth, exception_freq, failures,elapsed_time));
            }
        }

        // (1) retval_error
        for (int recurse_depth = 2; recurse_depth <= 10; recurse_depth+=3) {
            for (float exception_freq = 0.0f; exception_freq <= 1.0f; exception_freq += 0.25f) {            
                int EXCEPTION_MOD = (exception_freq == 0.0f) ? ITERATION_COUNT+1 : (int)(1.0f / exception_freq);            

                failures = 0;
                DateTime start_time = DateTime.Now;
                t.reset();              
                for (i = 1; i < ITERATION_COUNT; i++) {
                    bool shoulderror = (i % EXCEPTION_MOD) == 0;
                    if (!t.retval_error(shoulderror,recurse_depth)) {
                        failures++;
                    }
                }
                double elapsed_time = (DateTime.Now - start_time).TotalMilliseconds;
                Console.WriteLine(
                    String.Format(
                      "retval_error: recurse_depth {0}, error_freqeuncy {1} ({2}), time elapsed {3} ms",
                        recurse_depth, exception_freq, failures,elapsed_time));
            }
        }

        // (2) exception_error
        for (int recurse_depth = 2; recurse_depth <= 10; recurse_depth+=3) {
            for (float exception_freq = 0.0f; exception_freq <= 1.0f; exception_freq += 0.25f) {            
                int EXCEPTION_MOD = (exception_freq == 0.0f) ? ITERATION_COUNT+1 : (int)(1.0f / exception_freq);            

                failures = 0;
                DateTime start_time = DateTime.Now;
                t.reset();              
                for (i = 1; i < ITERATION_COUNT; i++) {
                    bool shoulderror = (i % EXCEPTION_MOD) == 0;
                    try {
                        t.exception_error(shoulderror,recurse_depth);
                    } catch (TestException e) {
                        failures++;
                    }
                }
                double elapsed_time = (DateTime.Now - start_time).TotalMilliseconds;
                Console.WriteLine(
                    String.Format(
                      "exception_error: recurse_depth {0}, error_freqeuncy {1} ({2}), time elapsed {3} ms",
                        recurse_depth, exception_freq, failures,elapsed_time));         }
        }
    }
}

} 
```

* * *

## 回答 #11

> 赞同：1
> 
> 时间：2008-10-02T12:13:36.343

在发布模式下，开销是最小的。

除非您打算以递归方式使用流控制异常（例如，非本地退出），否则我怀疑您是否能够注意到差异。

* * *

## 回答 #12

> 赞同：1
> 
> 时间：2020-10-01T07:10:31.150

我想你几乎回答了你自己的问题。你和几乎所有了解它们的人都知道它们很慢。这是 100% 的事实，但正如许多其他人所指出的那样，关于何时使用它们，上下文是 100% 重要的。编写非服务器应用程序？你永远不会注意到差异。编写一个格式错误的客户端请求会在后端触发异常的网站公共 API？这是一个数量级的灾难配方，乘以请求/秒。与杂货店的便士小马相比，后端的固定次数更多。但是，问题在于 BCL/其他库会抛出您无法控制的异常，因此您必须在它们到达 BCL 之前触发这些异常的中间人/交叉守卫。在某些情况下，您完全没有任何防御能力。例如使用 MongoClient 访问 MongoDB 数据库。如果所有的 MongoCollection.*Async 函数在某些情况下没有成功，它们都会抛出异常，但它根本不会抛出很多异常，而且我很确定这些情况属于罕见的情况（这会将其转移到上下文中部分情况）。不过，我也可能是错的。我只是假设他们只在极少数情况下投掷。正如您所指出的，您知道它们很慢，因此在要求事情不慢的情况下使用它们只是常识。干净利落。但它根本不会抛出很多，而且我很确定这些场景在光谱的罕见端（这将其转移到情况的上下文部分）。不过，我也可能是错的。我只是假设他们只在极少数情况下投掷。正如您所指出的，您知道它们很慢，因此在要求事情不慢的情况下使用它们只是常识。干净利落。但它根本不会抛出很多，而且我很确定这些场景在光谱的罕见端（这将其转移到情况的上下文部分）。不过，我也可能是错的。我只是假设他们只在极少数情况下投掷。正如您所指出的，您知道它们很慢，因此在要求事情不慢的情况下使用它们只是常识。干净利落。

* * *

## 回答 #13

> 赞同：0
> 
> 时间：2008-10-23T08:55:39.037

这里有一个关于与捕获异常相关的性能的快速说明。

当执行路径进入“try”块时，不会发生任何神奇的事情。没有“try”指令，也没有与进入或退出 try 块相关的成本。有关 try 块的信息存储在方法的元数据中，并且只要引发异常，就会在运行时使用此元数据。执行引擎沿着堆栈向下走，寻找包含在 try 块中的第一个调用。只有在抛出异常时才会发生与异常处理相关的任何开销。

* * *

## 回答 #14

> 赞同：-1
> 
> 时间：2014-03-23T02:12:18.220

在编写类/函数供其他人使用时，似乎很难说什么时候例外是合适的。BCL 有一些有用的部分我不得不放弃并转而使用 pinvoke，因为它们会抛出异常而不是返回错误。在某些情况下，您可以解决它，但对于 System.Management 和 Performance Counters 等其他情况，您需要执行循环，其中 BCL 经常抛出异常。

如果您正在编写一个库，并且您的函数极有可能在循环中使用并且有可能进行大量迭代，请使用 Try.. 模式或其他方式来暴露除异常之外的错误。即使那样，如果共享环境中的许多进程都在使用您的函数，也很难说它会被调用多少。

在我自己的代码中，只有当事情非常异常以至于有必要查看堆栈跟踪并查看出了什么问题然后修复它时才会引发异常。因此，我几乎重写了 BCL 的部分内容，以使用基于 Try.. 模式而不是异常的错误处理。

# sql - 如果我停止长时间运行的查询，它会回滚吗？

> ID：161960
> 
> 赞同：27
> 
> 时间：2008-10-02T12:13:49.587
> 
> 标签：sql, sql-server, duplicate-data

一个用于循环遍历**1700 万条记录以删除重复项**的查询 现在已经运行了大约**16 个小时**，我想知道查询是否现在停止，它是否会完成删除语句，或者它是否在运行时被删除询问？事实上，如果我停止它，它会完成删除还是回滚？

我发现当我做一个

```
 select count(*) from myTable 
```

它返回的行（在执行此查询时）大约比起始行数少 5。显然服务器资源极差，这是否意味着这个过程需要 16 个小时才能找到 5 个重复项（实际上有数千个），而且这可能会运行数天？

这个查询在 2000 行测试数据上花费了 6 秒，并且在该组数据上效果很好，所以我认为完整的数据集需要 15 个小时。

有任何想法吗？

以下是查询：

```
--Declare the looping variable
DECLARE @LoopVar char(10)

    DECLARE
     --Set private variables that will be used throughout
      @long DECIMAL,
      @lat DECIMAL,
      @phoneNumber char(10),
      @businessname varchar(64),
      @winner char(10)

    SET @LoopVar = (SELECT MIN(RecordID) FROM MyTable)

    WHILE @LoopVar is not null
    BEGIN

      --initialize the private variables (essentially this is a .ctor)
      SELECT 
        @long = null,
        @lat = null,
        @businessname = null,
        @phoneNumber = null,
        @winner = null

      -- load data from the row declared when setting @LoopVar  
      SELECT
        @long = longitude,
        @lat = latitude,
        @businessname = BusinessName,
        @phoneNumber = Phone
      FROM MyTable
      WHERE RecordID = @LoopVar

      --find the winning row with that data. The winning row means 
      SELECT top 1 @Winner = RecordID
      FROM MyTable
      WHERE @long = longitude
        AND @lat = latitude
        AND @businessname = BusinessName
        AND @phoneNumber = Phone
      ORDER BY
        CASE WHEN webAddress is not null THEN 1 ELSE 2 END,
        CASE WHEN caption1 is not null THEN 1 ELSE 2 END,
        CASE WHEN caption2 is not null THEN 1 ELSE 2 END,
        RecordID

      --delete any losers.
      DELETE FROM MyTable
      WHERE @long = longitude
        AND @lat = latitude
        AND @businessname = BusinessName
        AND @phoneNumber = Phone
        AND @winner != RecordID

      -- prep the next loop value to go ahead and perform the next duplicate query.
      SET @LoopVar = (SELECT MIN(RecordID) 
    FROM MyTable
    WHERE @LoopVar < RecordID)
    END 
```

* * *

## 回答 #1

> 赞同：30
> 
> 时间：2008-10-02T12:36:19.457

不，如果您停止查询执行，sql server 将不会回滚它已经执行的删除操作。oracle 需要明确提交操作查询，否则数据会回滚，但 mssql 不需要。

使用 sql server 它不会回滚，除非您专门在事务的上下文中运行并且您回滚该事务，或者连接在未提交事务的情况下关闭。但我在您的上述查询中没有看到事务上下文。

您也可以尝试重新构建查询以使删除更有效率，但基本上如果您的盒子的规格不符合标准，那么您可能会被卡住等待它。

展望未来，您应该在表上创建一个唯一索引，以使自己不必再经历一次。

* * *

## 回答 #2

> 赞同：9
> 
> 时间：2008-10-02T12:32:08.670

您的查询未包含在事务中，因此它不会回滚各个删除语句已经进行的更改。

我使用以下查询在我自己的 SQL Server 上专门对此进行了测试，即使我取消了查询，ApplicationLog 表也是空的：

```
declare @count int
select @count = 5
WHILE @count > 0
BEGIN
  print @count
  delete from applicationlog;
  waitfor time '20:00';
  select @count = @count -1
END 
```

但是，您的查询可能需要数天或数周，甚至比 15 小时长得多。您估计每 6 秒可以处理 2000 条记录是错误的，因为您的 while 循环中的每次迭代将花费 1700 万行比 2000 行更长的时间。因此，除非查询 2000 行所需的时间明显少于一秒，否则所有 1700 万行都需要几天时间。

您应该提出一个关于如何有效删除重复行的新问题。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-02T12:40:10.587

如果您没有对事务做任何明确的操作，那么连接将处于[自动提交事务](http://msdn.microsoft.com/en-us/library/ms187878.aspx)模式。在这种模式下，每个 SQL 语句都被视为一个事务。

问题是这是否意味着各个 SQL 语句是事务，因此在执行过程中会被提交，或者外部 WHILE 循环是否算作事务。

[在MSDN](http://msdn.microsoft.com/en-us/library/ms178642.aspx)上的 WHILE 构造的描述中似乎没有对此进行任何讨论。但是，由于 WHILE 语句不能直接修改数据库，因此它**不**启动自动提交事务似乎是合乎逻辑的。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-03T04:10:17.543

## 隐式事务

**如果没有设置“隐式事务”，则循环中的每次迭代都会提交更改。**

任何 SQL Server 都可以设置为“隐式事务”。这是一个数据库设置（默认为关闭）。您还可以在 Management Studio 内的特定查询的属性中包含隐式事务（在查询窗格中单击鼠标右键>选项）、客户端中的默认设置或 SET 语句。

```
SET IMPLICIT_TRANSACTIONS ON; 
```

无论哪种方式，如果是这种情况，您仍然需要执行显式 COMMIT/ROLLBACK，而不管查询执行是否中断。

* * *

**隐式交易参考：**

[http://msdn.microsoft.com/en-us/library/ms188317.aspx](http://msdn.microsoft.com/en-us/library/ms188317.aspx)

[http://msdn.microsoft.com/en-us/library/ms190230.aspx](http://msdn.microsoft.com/en-us/library/ms190230.aspx)

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T12:44:36.270

我继承了一个系统，该系统的逻辑类似于您在 SQL 中实现的逻辑。在我们的例子中，我们试图使用具有相似名称/地址等的模糊匹配将行链接在一起，并且该逻辑纯粹在 SQL 中完成。在我继承它的时候，我们的表中有大约 300,000 行，根据时间，我们计算出匹配所有行需要 A YEAR。

作为一个实验，看看我可以在 SQL 之外执行多快，我编写了一个程序将 db 表转储到平面文件中，将平面文件读入 C++ 程序，构建我自己的索引，并在那里执行模糊逻辑，然后将平面文件重新导入数据库。在 SQL 中花费一年的时间在 C++ 应用程序中花费了大约 30 秒。

所以，我的建议是，甚至不要尝试你在 SQL 中所做的事情。导出、处理、重新导入。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T13:31:44.223

到目前为止已执行的 DELETES 将不会回滚。

* * *

[作为相关代码的](https://stackoverflow.com/questions/150891/sql-query-remove-duplicates-with-caveats#150967)原作者，并且已经发出警告，性能将取决于索引，我将提出以下项目来加快速度。

RecordId 最好是 PRIMARY KEY。我不是说身份，我是说主键。使用 sp_help 确认这一点

在评估这个查询时应该使用一些索引。找出这四列中哪一列的重复次数和索引最少...

```
SELECT *
FROM MyTable
WHERE @long = longitude
  AND @lat = latitude
  AND @businessname = BusinessName
  AND @phoneNumber = Phone 
```

添加此索引之前和之后，检查查询计划以查看是否添加了索引扫描。

* * *

## 回答 #7

> 赞同：0
> 
> 时间：2008-10-02T12:37:36.723

作为一个循环，即使使用适当的索引，您的查询也很难很好地扩展。[根据您之前](https://stackoverflow.com/questions/150891/sql-query-remove-duplicates-with-caveats)关于此问题的建议，应将查询重写为单个语句。

如果您没有在事务中显式运行它，它只会回滚正在执行的语句。

* * *

## 回答 #8

> 赞同：0
> 
> 时间：2008-10-02T13:12:05.283

我认为如果使用游标使用单遍算法重写此查询，效率会更高。您可以按经度、纬度、BusinessName 和@phoneNumber 对光标表进行排序。您将逐行逐行浏览。如果一行与前一行具有相同的经度、纬度、商家名称和电话号码，则将其删除。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2009-07-24T13:48:19.327

我认为你需要认真考虑你的方法论。您需要开始思考集合（尽管为了性能，您可能需要批处理，但不是针对 1700 万条记录表逐行处理。）

首先，您的所有记录都有重复项吗？我怀疑不是，所以你要做的第一件事就是将你的处理限制在那些有重复的记录上。由于这是一个大表，您可能需要随着时间的推移分批删除，具体取决于正在进行的其他处理，您首先将要处理的记录拉入自己的表中，然后编制索引。如果您能够同时执行所有操作而无需停止它，您也可以使用临时表，否则在数据库中创建一个表并在最后删除。

类似的东西（注意我没有写创建索引语句，我想你可以自己查一下）：

```
SELECT min(m.RecordID), m.longitude, m.latitude, m.businessname, m.phone  
     into  #RecordsToKeep    
FROM MyTable   m
join 
(select longitude, latitude, businessname, phone
from MyTable
group by longitude, latitude, businessname, phone
having count(*) >1) a 
on a.longitude = m.longitude and a.latitude = m.latitude and
a.businessname = b.businessname and a.phone = b.phone 
group by  m.longitude, m.latitude, m.businessname, m.phone   
ORDER BY CASE WHEN m.webAddress is not null THEN 1 ELSE 2 END,        
    CASE WHEN m.caption1 is not null THEN 1 ELSE 2 END,        
    CASE WHEN m.caption2 is not null THEN 1 ELSE 2 END

while (select count(*) from #RecordsToKeep) > 0
begin
select top 1000 * 
into #Batch
from #RecordsToKeep

Delete m
from mytable m
join #Batch b 
        on b.longitude = m.longitude and b.latitude = m.latitude and
        b.businessname = b.businessname and b.phone = b.phone 
where r.recordid <> b.recordID

Delete r
from  #RecordsToKeep r
join #Batch b on r.recordid = b.recordid

end

Delete m
from mytable m
join #RecordsToKeep r 
        on r.longitude = m.longitude and r.latitude = m.latitude and
        r.businessname = b.businessname and r.phone = b.phone 
where r.recordid <> m.recordID 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2011-01-10T11:46:22.833

还可以尝试考虑另一种删除重复行的方法：

```
delete t1 from table1 as t1 where exists (
    select * from table1 as t2 where
        t1.column1=t2.column1 and
        t1.column2=t2.column2 and
        t1.column3=t2.column3 and
        --add other colums if any
        t1.id>t2.id
) 
```

我想你的表中有一个整数 id 列。

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2013-10-24T21:04:10.180

如果您的机器没有非常先进的硬件，那么 sql server 可能需要很长时间才能完成该命令。我不确定这个操作是如何在后台执行的，但根据我的经验，这可以通过将记录从数据库中取出并放入内存中以用于使用具有删除重复规则的树结构的程序来更有效地完成用于插入。尝试使用 ODBC 将整个表以块的形式（例如一次 10000 行）读入 C++ 程序。一旦在 C++ 程序中使用和 std::map ，其中 key 是唯一键，而 struct 是一个将其余数据保存在变量中的结构。循环所有记录并插入到地图中。地图插入功能将处理删除重复项。由于在地图内搜索是 lg(n) 时间，因此查找重复项的时间远少于使用 while 循环的时间。然后，您可以删除整个表并将元组从映射中添加回数据库，方法是形成插入查询并通过 odbc 执行它们或构建文本文件脚本并在管理工作室中运行它。

* * *

## 回答 #12

> 赞同：-1
> 
> 时间：2008-10-02T12:23:29.643

我很确定这是否定的。否则交易的意义何在？

# visual-studio - Visual Studio 2005：解决方案资源管理器中的所有项目在首次打开解决方案时扩展

> ID：161962
> 
> 赞同：4
> 
> 时间：2008-10-02T12:14:12.973
> 
> 标签：visual-studio

有什么方法可以告诉 Visual Studio 2005 的解决方案资源管理器不要在 svn-checkout 后第一次打开解决方案时扩展所有项目？

编辑：感谢您指出 PowerCommands。当我使用带有 .Net 2.0 的 Visual Studio 2005 时，它对我不起作用。VS2005有类似的工具吗？

* * *

## 回答 #1

> 赞同：2
> 
> 时间：2008-10-02T12:28:57.430

我也觉得这很烦人，所以我的解决方案是为 Visual Studio 安装[PowerCommands](http://code.msdn.microsoft.com/PowerCommands)，这是一个不错的插件，它具有“折叠项目”功能，可以做到这一点。它还有十几个其他很酷的功能。

强烈推荐。

* * *

## 回答 #2

> 赞同：1
> 
> 时间：2008-10-07T08:44:30.247

回复：PowerPack 之类的东西：[DPack](http://www.usysware.com/dpack/)也有一个解决方案折叠选项，它适用于 2005。

我将其配置为折叠“仅热门项目”，因为“所有项目和文件”对我来说工作太慢且闪烁。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2008-10-02T13:12:12.863

我的默认设置（据我所知，无论如何都没有更改）VS 将在第一次打开解决方案和创建解决方案用户选项文件时扩展所有项目。正如**ljubomir 所**提到的，最好的办法是创造一些东西来瓦解所有的项目。

# c# - 重构代码：什么时候做什么？

> ID：161975
> 
> 赞同：22
> 
> 时间：2008-10-02T12:19:00.653
> 
> 标签：c#, vb.net, refactoring, coding-style

自从我开始使用 .NET 以来，我一直在创建 Helper 类或 Partial 类来将代码定位并包含在它们自己的小容器等中。

我想知道的是使代码尽可能干净和优美的最佳实践。

显然干净的代码是主观的，但我说的是何时使用事物（而不是如何使用它们），例如多态性、继承、接口、类以及如何更恰当地设计类（使它们更有用，而不仅仅是说' DatabaseHelper'，因为有些人认为代码中的这种不良做法有[wiki 的味道](https://stackoverflow.com/questions/114342/what-are-code-smells-what-is-the-best-way-to-correct-them)）。

是否有任何资源可以帮助做出这种决策？

请记住，我什至没有开始学习计算机科学或软件工程课程，而且现实生活中的教学资源相当有限。

* * *

## 回答 #1

> 赞同：23
> 
> 时间：2008-10-02T12:26:25.080

让我大开眼界的是[重构：改进现有代码的设计](https://rads.stackoverflow.com/amzn/click/com/0201485672)：

> 通过适当的培训，熟练的系统设计人员可以采用糟糕的设计并将其改造成设计良好、健壮的代码。在本书中，Martin Fowler 向您展示了通常可以在哪里找到重构的机会，以及如何将糟糕的设计改造成好的设计。

[重构 http://ecx.images-amazon.com/images/I/519XT0DER6L._SL160_PIlitb-dp-arrow,TopRight,21,-23_SH30_OU01_AA115_.jpg](http://ecx.images-amazon.com/images/I/519XT0DER6L._SL160_PIlitb-dp-arrow,TopRight,21,-23_SH30_OU01_AA115_.jpg)

它帮助我高效、系统地重构代码。在与其他开发人员讨论时，它也对我有很大帮助，当他们`holy code`必须改变时......

* * *

## 回答 #2

> 赞同：11
> 
> 时间：2008-10-02T12:39:39.823

Jeff Atwood 发表了[一篇关于重构和代码异味的精彩博客文章](http://blog.codinghorror.com/code-smells/)，您可能想查看一下。

在 .NET 中重构代码需要一些时间来理解。你需要了解一些面向对象的[设计原则](http://books.google.se/books?id=LjJcCnNf92kC)（或[设计技巧](http://en.wikipedia.org/wiki/Gang_of_Four_(software))）才能有效地、[无情地进行](http://www.extremeprogramming.org/rules/refactor.html)[重构](http://www.industriallogic.com/xp/refactoring/catalog.html)。

简而言之，您重构代码是为了消除代码异味并使更改更容易进行。另外，不要过度。

* * *

## 回答 #3

> 赞同：5
> 
> 时间：2008-10-02T12:25:29.263

这是对名为[Clean Code](http://books.slashdot.org/article.pl?sid=08/09/23/2243216)的书的斜线点的评论。

这本书显然有点干，但非常好。

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-02T12:23:24.637

查看[Martin Fowler 的](http://martinfowler.com/)评论和关于[重构的书](https://rads.stackoverflow.com/amzn/click/com/0201485672)

* * *

## 回答 #5

> 赞同：1
> 
> 时间：2008-10-02T12:40:39.977

*   当它导致问题时重构你的代码。任何问题都可以解决：性能、可扩展性、集成、维护——任何让你在应该花更多时间在它上面的东西。它没有损坏，即使您不相信它是干净的或不符合现代标准，也不要修复它。
*   不要花太多时间使代码完美。你永远不会达到完美，但你可以花很多时间来尝试做到这一点。记住收益递减规律。
*   只有在您实际处理依赖于它的功能时，才在项目内部重构代码。即，如果您有迭代的用户故事要求“更改上传机制”或“修复文件上传中的错误”，您可以重构文件上传代码。但是，如果您的用户故事是关于“改头换面的文件上传 UI 设计”，请不要进入业务逻辑。

* * *

## 回答 #6

> 赞同：1
> 
> 时间：2008-10-02T12:48:28.210

我推荐[领域驱动设计](https://rads.stackoverflow.com/amzn/click/com/0321125215)。我认为 YAGNI 和 AlwaysRefactor 原则都是两个简单化的原则。关于这个问题的古老问题是我是否将“if（someArgument == someValue）”重构为一个函数或将其保留为内联？

没有是或否的答案。如果测试代表业务规则，DDD 建议对其进行重构。重构不仅仅是（仅）关于重用，而是关于明确意图。

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2008-10-02T16:12:34.257

[Working Effectively with Legacy Code](https://rads.stackoverflow.com/amzn/click/com/0131177052)是我看过的关于这个主题的最好的书之一。

不要拖延书名——这本书没有将重构视为一个正式的概念（它有它的位置），而是有很多很多简单的“我为什么没想到”的技巧。诸如“通过一个类并删除任何不直接与该类相关的方法并将它们放在不同的类中”之类的事情。

例如，您有一个网格和一些代码来将该网格的布局保存到文件中。您可能可以安全地将布局持久化代码移到不同的类。

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2009-07-22T12:43:14.250

我的经验法则是**让代码的形状不会比你发现的更糟**。

我们的想法是*朝着更好的方向*努力，而不是试图达到完美的结果，或者一路走下去。

个别重构有时有一个值得怀疑的好处，并且 - 作为一个极端的例子 - 确实可能会争论是否`m_Pi`是一个比`m_PI`. 然而，大多数情况下，一个选择更一致，即使不是明显“更好”，也不那么令人惊讶。

我经常发现自己自动重构的一种情况是在一段代码上实现功能*之前。*

经常有一些 TODO 等待提供，一些不一致或有时自定义功能最近获得了更好的库支持。在实现实际功能请求之前进行这些更改可以让我对代码有所了解，并验证“之前”功能。

另一点是*在*修复错误之后。之后，因此之前的重现不受影响，并且错误修复和重构是两个单独的提交。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2008-10-03T10:38:51.340

我刚刚得到了一份 Code Complete 的副本，发现有一个关于这个的部分。

尽管我仍将阅读公认答案的书，但 Code Complete 教给我的内容极大地改善了我对设计课程的看法。

在今天之前，我不知道 ADT 是什么（抽象数据类型），现在我知道了如何开发遵循封装的类。

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2009-07-22T12:28:40.130

[在http://www.refactoring.com/](http://www.refactoring.com/)上有一个专门用于重构的网页。它提供了许多关于重构代码主题的更多资源的参考，以及一个讨论重构相关问题的邮件列表。

最后但并非最不重要的一点是，有一个很大的（并且还在增长的）可用的重构目录，它远远超出了 Martin Fowler 的（非常推荐的）重构书中所写的内容。

# testing - 使用带有随机值的 Selenium IDE

> ID：161984
> 
> 赞同：48
> 
> 时间：2008-10-02T12:21:33.923
> 
> 标签：testing, user-interface, selenium

是否可以使用 Firefox 插件创建 Selenium 测试，该插件使用随机生成的值来帮助进行回归测试？

**完整的故事：** 我想帮助我的客户进行验收测试，为他们提供一套测试，这些测试使用一些智能来为数据库创建随机（或至少是伪随机）值。目前我的 Selenium IDE 测试的问题之一是它们具有预定义的值——这使得某些类型的测试出现问题。

* * *

## 回答 #1

> 赞同：48
> 
> 时间：2008-10-02T12:54:38.710

首先，Selenium IDE 相当有限，您应该考虑切换到 Selenium RC，它可以由 Java 或 Perl 或 Ruby 或其他一些语言驱动。

仅使用 Selenium IDE，您可以嵌入 JavaScript 表达式来派生命令参数。您应该能够在文本字段中输入随机数，例如：

```
type fieldName javascript{Math.floor(Math.random()*11)} 
```

**更新：**您可以在名为“user-extensions.js”的文件中定义帮助函数。请参阅[硒参考](http://seleniumhq.org/docs/08_user_extensions.html#using-user-extensions-with-selenium-ide)。

* * *

## 回答 #2

> 赞同：31
> 
> 时间：2010-09-01T08:19:31.010

*（基于 Thilo 的回答）* 您可以像这样混合文字和随机数：

```
javascript{"joe+" + Math.floor(Math.random()*11111) + "@gmail.com";} 
```

例如，Gmail 可以自动将使用别名的所有内容`joe+testing@gmail.com`发送到您的地址`joe@gmail.com`

乘以 *11111 为您提供比 1 到 9 更多的随机值（在 Thilo 示例中）

* * *

## 回答 #3

> 赞同：22
> 
> 时间：2010-04-25T18:59:35.583

您可以添加用户 exentions.js 来获取随机值。

复制以下代码并将其保存为 .js 扩展名（randomgenerator.js）并将其添加到 Selenium 核心扩展名（SeleniumIDE-->Options--->general 选项卡）

```
Selenium.prototype.doRandomString = function( options, varName ) {

    var length = 8;
    var type   = 'alphanumeric';
    var o = options.split( '|' );
    for ( var i = 0 ; i < 2 ; i ++ ) {
        if ( o[i] && o[i].match( /^\d+$/ ) )
            length = o[i];

        if ( o[i] && o[i].match( /^(?:alpha)?(?:numeric)?$/ ) )
            type = o[i];
    }

    switch( type ) {
        case 'alpha'        : storedVars[ varName ] = randomAlpha( length ); break;
        case 'numeric'      : storedVars[ varName ] = randomNumeric( length ); break;
        case 'alphanumeric' : storedVars[ varName ] = randomAlphaNumeric( length ); break;
        default             : storedVars[ varName ] = randomAlphaNumeric( length );
    };
};

function randomNumeric ( length ) {
    return generateRandomString( length, '0123456789'.split( '' ) );
}

function randomAlpha ( length ) {
    var alpha = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split( '' );
    return generateRandomString( length, alpha );
}

function randomAlphaNumeric ( length ) {
    var alphanumeric = '01234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split( '' );
    return generateRandomString( length, alphanumeric );
}

function generateRandomString( length, chars ) {
    var string = '';
    for ( var i = 0 ; i < length ; i++ )
        string += chars[ Math.floor( Math.random() * chars.length ) ];
    return string;
} 
```

使用方式

```
Command                Target     Value
-----------           ---------   ----------
randomString           6           x
type                username       ${x} 
```

上面的代码生成 6 个字符的字符串，并将其分配给变量 x

HTML 格式的代码如下所示：

```
<tr>
    <td>randomString</td>
    <td>6</td>
    <td>x</td>
</tr>
<tr>
    <td>type</td>
    <td>username</td>
    <td>${x}</td>
</tr> 
```

* * *

## 回答 #4

> 赞同：5
> 
> 时间：2011-02-10T15:40:36.920

这是在 JS 中生成随机字母字符串的单行解决方案：

```
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").filter(function(e, i, a) { return Math.random() > 0.8 }).join("") 
```

用于粘贴到 Selenium IDE 中。

* * *

## 回答 #5

> 赞同：2
> 
> 时间：2011-03-31T13:49:33.880

用于从一小组备选方案中随机选择的单线：

```
javascript{['brie','cheddar','swiss'][Math.floor(Math.random()*3)]} 
```

* * *

## 回答 #6

> 赞同：2
> 
> 时间：2015-04-22T19:45:48.083

```
<tr>
<td>store</td>
 <td>javascript{Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 8)}</td>
<td>myRandomString</td>
</tr> 
```

* * *

## 回答 #7

> 赞同：1
> 
> 时间：2011-04-11T09:26:29.250

我对函数 generateRandomString 做了一点改进。当FF崩溃时，能够再次使用相同的随机数是很好的。

基本上，它会要求您自己输入一个字符串。如果您不输入任何内容，它将生成它。

`function generateRandomString( length, chars ) { var string=prompt("Please today's random string",''); if (string == '') {for ( var i = 0 ; i < length ; i++ ) string += chars[ Math.floor( Math.random() * chars.length ) ]; return string;} else { return string;} }`

* * *

## 回答 #8

> 赞同：1
> 
> 时间：2012-06-02T15:13:36.440

在理解上面 RajendraChary 的帖子时，我花了一些时间编写了一个新的 Selenium IDE 扩展。

我的扩展将让用户使用 lorem ipsum 文本填充变量。有许多可配置的选项，它变成了一个不错的小命令。您可以执行“5 words|wordcaps|nomarks”之类的操作来生成 5 个 lorem ipsum 单词，全部大写，没有标点符号。

我已经彻底解释了安装和使用，并在此处提供了[完整的代码库](https://github.com/agileadam/selenium-lipsumtext)

如果您查看代码，您将了解如何构建类似的功能。

* * *

## 回答 #9

> 赞同：0
> 
> 时间：2012-03-14T19:09:00.067

这是 gmail 示例的另一个变体：

```
<tr>
  <td>runScript</td>
  <td>emailRandom=document.getElementById('email');console.log(emailRandom.value);emailRandom.value=&quot;myEmail+&quot; + Math.floor(Math.random()*11111)+ &quot;@gmail.com&quot;;</td>
 <td></td>
</tr> 
```

* * *

## 回答 #10

> 赞同：0
> 
> 时间：2012-05-18T11:16:07.263

Selenium RC 为您提供比 Selenium IDE 更多的自由，因为您可以：

*   (1) 在某个字段中输入任意值
*   （2）在某个HTML表单中选择任意字段进行测试
*   (3) 选择任何执行顺序/步骤来测试某一组字段。

您问如何使用 Selenium IDE 在字段中输入一些随机值，其他人已经回答您如何使用 Selenium RC 在字段中生成和输入随机值。这属于测试阶段（1）：“在某个字段中输入任何值”。

使用 Selenium RC，您可以轻松完成阶段 (2) 和 (3)：通过使用 Java、PHP、CSharp、Ruby、Perl、Python 等受支持的语言进行一些编程，在任何执行步骤下测试任何字段。

以下是执行阶段（2）和（3）的步骤：

*   创建您的 HTML 字段列表，以便您可以轻松地遍历它们
*   创建一个随机变量来控制步骤，比如 RAND_STEP
*   创建一个随机变量来控制字段，比如 RAND_FIELD
*   [最终，创建一个随机变量来控制输入某个字段的值，比如 RAND_VALUE，如果你想做阶段 (1)]
*   现在，在你的模糊算法中，首先遍历 RAND_STEP 的值，然后在每次这样的迭代中，遍历 RAND_FIELD，最后遍历 RAND_VALUE。

请参阅我关于模糊测试、Selenium 和白/黑盒测试[的其他答案](https://stackoverflow.com/questions/10650990/how-to-do-fuzzing-testing-with-selenium)

* * *

## 回答 #11

> 赞同：0
> 
> 时间：2013-05-20T20:46:51.813

Math.random 可能“足够好”，但在实践中，**Random 类**通常比 Math.random() 更可取。使用 Math.random ，你得到的数字实际上可能不是完全随机的。“Effective Java Second Edition”一书在 Item #47 中对此进行了介绍。

* * *

## 回答 #12

> 赞同：0
> 
> 时间：2016-12-07T05:34:05.827

另一种解决方案，我已将其复制并粘贴到数百个测试中：

```
<tr>
    <td>store</td>
    <td>javascript{var myDate = new Date(); myDate.getFullYear()+&quot;-&quot;+(myDate.getMonth()+1)+&quot;-&quot;+myDate.getDate()+&quot;-&quot;+myDate.getHours()+myDate.getMinutes()+myDate.getSeconds()+myDate.getMilliseconds();}</td>
    <td>S_Unique</td>
</tr>
<tr>
    <td>store</td>
    <td>Selenium Test InternalRefID-${S_Unique}</td>
    <td>UniqueInternalRefID</td>
</tr>
<tr>
    <td>store</td>
    <td>Selenium Test Title-${S_Unique}</td>
    <td>UniqueTitle</td>
</tr>
<tr>
    <td>store</td>
    <td>SeleniumEmail-${G_Unique}@myURL.com</td>
    <td>UniqueEmailAddress</td>
</tr> 
```

每个测试套件都从设置一系列变量开始（如果它是一个大套件，请使用单独的文件，如 Set_Variables.html）。然后可以在整个套件中使用这些变量来设置、测试和删除测试数据。由于变量使用日期而不是随机数，您可以通过查找共享日期的对象来调试您的测试套件。

# java - 无法从结果集中读取列值；字符串索引超出范围：0

> ID：161988
> 
> 赞同：1
> 
> 时间：2008-10-02T12:22:21.940
> 
> 标签：java, hibernate

我正在使用 Hibernate SQL Query 从表（来自 MySQL 数据库）中读取数据。问题是，该表包含一个映射到 Hibernate 模型中的字符的列，有时该列是空的。我想这就是我的例外的来源。如何在不出现此错误的情况下将一列 char 映射到我的休眠模型？感谢您的回答！

* * *

谢谢您的回答 ！我的列不可为空（我正在使用 MySQL，并且此列不是 NULL）然后，我不认为

```
if (str == null) { 
```

是合适的。

错误是：

```
15:30:35,289  INFO CharacterType:178 - could not read column value from result set: LSFUS11_20_; String index out of range: 0 
```

这导致以下异常：

```
java.lang.StringIndexOutOfBoundsException: String index out of range: 0
    at java.lang.String.charAt(String.java:558) 
```

我想我可以试试你的解决方案，但是：

```
if (str == "") { 
```

因为它不能为空，它只是一个空字符串。

谢谢你的代码，我去试试！

* * *

## 回答 #1

> 赞同：3
> 
> 时间：2008-10-02T13:05:45.640

我从您的问题中假设您将其映射到原始字符。下次，请发布您收到的堆栈跟踪（您可能会忽略调用它的位置，如果您的项目过于敏感，则只能包含休眠内容）。

如果您确实映射到原始字符，并且它为 null，您将得到一个异常，因为原始字符不能为它们分配 null。

此类将缓解这种情况，“null”字符作为表示“0”的字符返回。您可以根据自己的喜好自定义：

```
import java.sql.ResultSet;
import java.sql.SQLException;

import org.hibernate.type.CharacterType;

public class NullCharacterType extends CharacterType {

    /**
     * Serializable ID generated by Eclipse
     */
    private static final long serialVersionUID = 1L;

    public NullCharacterType() {
        super();
    }

    public Object get(final ResultSet rs, final String name)
            throws SQLException {
        final String str = rs.getString(name);
        if (str == null || str.length() == 0) {
            return new Character((char) 0);
        } else {
            return new Character(str.charAt(0));
        }
    }
} 
```

要使用这种新类型，在你的休眠映射中，在你有类似的东西之前：

```
<property name="theChar" type="character"> 
```

现在，您只需将类名指定为您的类型：

```
<property name="theChar" type="yourpackage.NullCharacterType"> 
```

但是，最佳实践是不使用原始类型进行数据库映射。如果可能，请使用 Character 而不是 char，因为这样您就不会遇到 null 问题（可以将 null 分配给包装器类型）。

* * *

## 回答 #2

> 赞同：0
> 
> 时间：2010-07-19T12:06:45.803

搜索您的 JBoss（服务器）是否`mysql.jar`(mysql-connector-java-5.1.7-bin) 存在于 lib 文件中。即使我遇到了同样的问题，添加`mysql.jar`文件后它工作正常。

* * *

## 回答 #3

> 赞同：0
> 
> 时间：2011-03-23T16:31:45.833

使用本机函数 LEFT 或 RIGHT 更改源中的列数据类型

假设这是 SQL 查询，给出错误 select username from Users

更改它：从用户中选择**LEFT** (username, **100** )

数字应该等于字段的大小

# visual-studio-2008 - Visual Studio 2008：使 Ctrl + K、Ctrl + N（下一个书签）留在同一个文件中

> ID：161993
> 
> 赞同：18
> 
> 时间：2008-10-02T12:24:07.520
> 
> 标签：visual-studio-2008, keyboard-shortcuts

`Ctrl`在 Visual Studio 2003 中，您可以使用+ `K`、`Ctrl`+跳转到下一个书签`N`；当文件中没有更多书签时，它保留在同一个文件中并环绕到文件顶部。现在在 VS 2008 中，这似乎发生了变化，并且`Ctrl`+ `K`, `Ctrl`+`N`跳转到带有书签的其他文件。如何将其更改回旧行为？

* * *

## 回答 #1

> 赞同：29
> 
> 时间：2008-10-02T12:37:33.557

实际上，您还有另外两个默认未分配快捷方式的命令：

*   文档中的上一个书签
*   文档中的下一个书签

如果您转到“编辑”->“书签”菜单，您会看到它们。如果您转到**Options->Preferences->Environment->Keyboard**并将它们查找为`Edit.PreviousBookmarkInDocument`and ，则可以将它们绑定到快捷方式`Edit.NextBookmarkInDocument`。

干杯!

# apache - 有什么方法可以确定客户在网页上花费的时间

> ID：161994
> 
> 赞同：6
> 
> 时间：2008-10-02T12:24:31.060
> 
> 标签：apache, proxy, apache2, squid

假设我有一个可以增强的开源 Web 服务器或代理，比如说 apache 或 squid。

有没有办法确定每个客户在网页上花费的时间？

HTTP当然是无状态的，所以它不是微不足道的，但也许有人对如何解决这个问题有想法？

* * *

## 回答 #1

> 赞同：5
> 
> 时间：2008-10-02T12:28:20.007

使用 Apache 或 Squid，您几乎无法检测到用户在您的页面上花费的时间。

但是在您的网页上添加一些额外的糖，您可以：

*   试试[谷歌分析](http://www.google.com/analytics/)。

它是*免费*的，并且有*很多*功能。

但是您还会邀请 Google 观看您网站的统计信息……（但这可能有助于他们决定您是否想购买 :-)）

* * *

## 回答 #2

> 赞同：4
> 
> 时间：2008-10-02T12:27:59.617

并非没有一些 javascript 不断地在客户端访问您的服务器，然后检查它何时停止（但当然假设用户启用了 javascript）。还有各种（丑陋的）方法可以检测用 javascript 关闭的窗口，但当然这些不会总是触发。例如。浏览器崩溃。

我有点想知道你为什么想要这个。如果一个人看网页 3 秒钟，被另一个选项卡/窗口分心但让您的页面打开 2 小时怎么办？你得到的答案是 2 小时，你（可能）想要的答案是 3 秒。

* * *

## 回答 #3

> 赞同：2
> 
> 时间：2008-10-02T12:29:21.453

您可以计算从请求页面到请求下一页之间的时间，但是只有当用户一直停留在该页面上直到他请求下一页时，这才是正确的。即使那样，他可能仍然在原始页面上（例如，他在选项卡中打开了新页面），并且只有在他们确实浏览到另一个页面时才会起作用。

唯一确定的方法是每隔十秒左右使用 Javascript 从打开的页面 ping 服务器，只是说“我还在被阅读！”

* * *

## 回答 #4

> 赞同：2
> 
> 时间：2008-10-02T12:36:18.520

我实际上已经看到了 javascript 分析包，它们不仅通过不时地 ping 服务器来跟踪您在页面上停留的时间，而且还准确地跟踪屏幕上的内容。通过测量浏览器窗口的大小以及文档的滚动位置，他们能够准确地确定每个元素在屏幕上的确切长度。通过跟踪鼠标的位置，可能也可以很好地猜测它们在看什么。我现在找不到链接，但这是一个简短的故事。如果您真的对人们在看什么以及持续多长时间感兴趣，您就可以做到。您可以跟踪的数量没有太大限制。

另外，只是一个想法，如果您不想过多地ping服务器，您可以将内容缓存在内存中，并且仅在您获得足够数量的数据时或在页面关闭之前发送到服务器。

* * *

## 回答 #5

> 赞同：0
> 
> 时间：2008-10-02T13:02:49.830

这种指标实际上在几年前非常流行，在 PC 变得更强大和标签式浏览器变得流行之前，它变得更难以准确测量。过去这样做的标准方法是假设人们通常一次只加载一页，并且只使用服务器日志数据来确定页面浏览之间的时间。您的标准分析供应商，如 Omniture 和 Urchin（现在的 Google Analytics）会计算这一点。

通常，您设置跟踪 cookie 以便能够随着时间的推移识别特定的人/浏览器，但在短期内，您可以只使用 IP 地址/用户代理组合。

因此，基本上您只需处理日志数据并将页面浏览量之间的增量计算为该人在页面上的时间。您设置了一些规则（或您的分析供应商在幕后执行此操作），例如丢弃/截断超出某个截止时间（例如 10 分钟）的时间，您假设该人实际上并未阅读，而是在窗口/选项卡中打开页面。

这些数据完美吗？显然不是。但是你只需要足够“足够好”的数据来进行统计分析并得出一些结论。

它对于纵向分析（读者随时间的习惯）和网站上不同页面之间的定性比较仍然有用。（即在两篇 700 字的文章之间，如果一篇文章的平均阅读时间是另一篇文章的两倍，那么实际上阅读第一篇文章的人会更多。）当然，您的网站必须足够繁忙才能有足够的数据点丢弃所有“坏”异常数据点后，进行统计上的合理分析。

是的，您可以使用 Javascript 发送保持活动以改进数据。您可以在 document.onload 之后以给定的时间间隔进行轮询，或者在页面的某些部分上设置鼠标悬停事件。

另一种技术是使用 Javascript 将 onclick 事件添加到每个`<a href>`点击您的服务器的事件。然后，您不仅知道何时有人单击链接以将其从您的站点中删除，而且真正复杂的“热点”分析着眼于这样一个事实，即如果有人单击页面下方 6 段的链接，那么他们一定已经阅读了那么远。*******************